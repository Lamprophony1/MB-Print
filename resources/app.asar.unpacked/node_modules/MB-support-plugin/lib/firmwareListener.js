'use strict';

const EventEmitter = require('eventemitter3');

const fs = require('fs-extra');

const request = require('request');

const q = require('q');

const tmp = require('tmp');

const _ = require('lodash');

const crypto = require('crypto');

const path = require('path');

const yauzl = require('yauzl');

const {
  progress
} = require('./util');

const {
  BotTypeEnum
} = require('./constants');

const fwEndpointTargets = {
  fifthGen: 'https://s3.amazonaws.com/firmware-makerbot-com/bwfw',
  sixthGen: 'https://s3.amazonaws.com/firmware-makerbot-com/sbfw' // sketch: 'https://s3.amazonaws.com/firmware-makerbot-com/wsfw',

};
const notification = 'firmware_updates_info_change';
const vendorID = 9153;

class VerificationFailedErr extends Error {
  constructor(filename) {
    super(`${filename} didn't pass verification`);
    this.code = 'VerificationFailedErr';
  }

}

class NotZipErr extends Error {
  constructor(msg) {
    super(`Error opening firmware file. It should be a .zip: ${msg}`);
    this.code = 'NotZipErr';
  }

}

class NotMBFirmwareErr extends Error {
  constructor() {
    super('This does not appear to be a Makerbot firmware file');
    this.code = 'NotMBFirmwareErr';
  }

}

class BotNotSupportedErr extends Error {
  constructor() {
    super('This firmware does not support the current printer');
    this.code = 'BotNotSupportedErr';
  }

}
/**
 * @classdesc
 * FirmwareListener listens for firmware updates from the printer. It will also check the server
 * for new updates that the printer doesn't know about it. You need to subscribe to a listener to
 * get updates from the printer. If an update is available, you can trigger an update from here too.
 */


class FirmwareListener {
  /**
   * @constructor
   * @param {MakerBotPrinter} mbPrinter
   */
  constructor(mbPrinter) {
    this._printer = mbPrinter;
    this._availableFirmware = null;
    this._customFirmware = null;
    this._updateNotifications = new EventEmitter();
    this._updateInitiated = false;
    this._putFileJob = null;

    this._progressCallback = () => {};

    this._printer.updateNotifications.addListener(notification, (version, updateAvailable, releaseNotes) => {
      let fw = null;

      if (updateAvailable === true) {
        this._updateInitiated = false;
        fw = {
          manifest: {
            version: version.split('.'),
            description: releaseNotes
          }
        };
      }

      this._parse(fw).then(version => {
        this._updateNotifications.emit(notification, version);
      }).catch(() => {
        // if something goes wrong here, it's probably that the server didn't find
        // any relevant updates, so we'll just emit the notification with `null`
        // which should let the components know that there wasn't an update
        this._updateNotifications.emit(notification, null);
      });
    });

    this._updateNotifications.addListener(notification, fw => this._availableFirmware = fw);
  }
  /**
   * This callback is called whenever the printer sends a "firmware_updates_info_change" notification
   * @callback fwCallback
   * @param {Object} firmware - The latest firmware. It is `null` if there's no new firmware
   */

  /**
   * Adds a notification listener for any available firmware updates
   * @param {fwCallback} callback
   */


  listen(callback) {
    this._updateNotifications.addListener(notification, callback);
  }
  /**
   * Removes a notification listener
   * @param {fwCallback} callback
   */


  remove(callback) {
    this._updateNotifications.removeListener(notification, callback);
  }
  /**
   * Asks the printer if it knows about any available firmware.
   * The printer will send back a notification, which will either have info
   * about an available update, or we'll check the web endpoint.
   * IMPORTANT: The returned Promise won't have any information about available updates.
   * To get that information, you must add a listener. See `listen()`
   * @returns {q.Promise}
   */


  check() {
    if (this._printer._printer.UpdateAvailableFirmwareIsSupported()) {
      return this._printer.invoke('UpdateAvailableFirmware');
    } else {
      this._parse(null).then(version => {
        this._updateNotifications.emit(notification, version);
      }).catch(() => {
        // if something goes wrong here, it's probably that the server didn't find
        // any relevant updates, so we'll just emit the notification with `null`
        // which should let the components know that there wasn't an update
        this._updateNotifications.emit(notification, null);
      });
    }
  }
  /**
   * Tells the printer to update its firmware
   * @returns {q.Promise}
   */


  update() {
    this._updateInitiated = true;

    if (this._availableFirmware && this._availableFirmware.remote) {
      const checksum = this._availableFirmware.md5sum || ''; // prevent bypassing checksum for downloads

      return this._download(this._availableFirmware.path, checksum).then(tmp => this.upload(tmp)).then(tmp => fs.unlinkSync(tmp)).catch(err => console.log('err:', err));
    } // despite the name `DownloadAndInstallFirmware` doesn't download anything,
    // it only installs. Thus, this will throw an error when it tries to update
    // from remote


    return this._printer.invoke('DownloadAndInstallFirmware');
  }
  /**
   * Uploads firmware file (.zip) to the printer to be installed
   * @param {string} localPath - Local path to file
   * @param {bool} [verify] - whether to perform a verification on the file. This is not necessary if the firmware was downloaded via FirmwareListener#download.
   * @returns {q.Promise}
   */


  upload(localPath, verify) {
    if (this._putFileJob && this._putFileJob.isPending()) throw 'Already transferring a firmware file';
    this._updateInitiated = true;
    const remotePath = `/firmware/firmware.zip`;
    this._putFileJob = this._printer.fileTransferHelper.putFileJob(localPath, remotePath);

    if (verify) {
      return this.verify(localPath).then(() => {
        this._printer.invoke('BrooklynUpload', [remotePath, true]);

        return this._putFileJob.start();
      });
    } // hehe, surprise!! BrooklynUpload doesn't actually upload!
    // We call this now with `transfer_wait` (the second parameter) set to
    // true, which will make the printer wait until we've actually finished
    // uploading the localPath (which is done with `PutInit`), before uploading the
    // localPath to the Brooklyn hardware


    this._printer.invoke('BrooklynUpload', [remotePath, true]);

    return this._putFileJob.start().then(() => localPath);
  }

  managingFwUpdate() {
    return this._putFileJob && this._putFileJob.isPending();
  }

  cancelUpdate() {
    let transferCancelPromise = q();
    let processCancelPromise = q();
    if (this._putFileJob && this._putFileJob.isPending()) transferCancelPromise = this._putFileJob.cancel();
    if (_.get(this._printer, 'currentProcess.name') === 'FirmwareBurningProcess') processCancelPromise = this._printer.invoke('Cancel');
    return q.allSettled([transferCancelPromise, processCancelPromise]).then(res => {
      const errs = [];

      for (const r of res) {
        if (r.reason) errs.push(r.reason);
      }

      if (errs.length) throw errs;
    });
  }
  /**
   * Checks to see if there's a cached update before asking the
   * printer again. Its intended use is to reduce lag time in
   * communication between the client and the printer
   * @returns {Boolean}
   */


  hasUpdate() {
    const current = this.currentVersion;
    return this._availableFirmware != null && current !== _latestVersion(current, this._availableFirmware) && !this._updateInitiated;
  }
  /**
   * Checks the hash of the firmware and compares it to the checksum
   * @param {string} filename - path to the file on disk you want to veryify
   * @param {string} [checksum] - md5 checksum for relevant firmware
   * @returns {q.Promise}
   */


  verify(filename, checksum) {
    const hash = crypto.createHash('md5');
    return new q.Promise((resolve, reject) => {
      const file = fs.readFileSync(filename); // need to do this synchronously for this._isSupported

      if (checksum != null) {
        hash.update(file);
        const digest = hash.digest('hex'); // get checksum for input file

        if (digest !== checksum) {
          return reject(new VerificationFailedErr(filename));
        }
      } // check if this machine is supported by this firmware


      return this._isSupported(file).then(resolve).catch(reject);
    });
  }
  /**
   * Formats the current firware version from the printer in the same schema
   * as the JSON response from the server. This just makes comparison easier.
   * @returns {Object} The current firmware version formatted
   */


  get currentVersion() {
    const fw = this._printer.currentState.firmware_version;
    return {
      manifest: {
        version: [fw.major, fw.minor, fw.bugfix, fw.build]
      }
    };
  }
  /**
   * Returns the cached firmware update
   * @returns {Object}
   */


  get availableUpdate() {
    return this._availableFirmware;
  }
  /**
   * Indicates whether an update has begun
   * @returns {Boolean}
   */


  get updateInitiated() {
    return this._updateInitiated;
  }
  /**
   * @private
   * Checks the response from the printer looking for new firmware. If not, we'll ping the website, just to
   * make sure.
   * @param {Object} [newFirmware] - information about known firmware from the printer. If the printer
   * doesn't know about new firmware, it is `null`. In that case we ping the website for
   * new firmware.
   * @returns {q.Promise}
   */


  _parse(newFirmware) {
    // If nothing comes back from the printer, let's check the web endpoint
    if (newFirmware == null) {
      return this._checkFirmwareRemote();
    }

    return new q.Promise(resolve => {
      // otherwise, set the version from what the printer already has
      resolve(_latestVersion(this.currentVersion, newFirmware));
    });
  }
  /**
   * @private
   * Hits a JSON endpoint to see what firmware is available remotely. The JSON response will
   * have every available firmware, which may or may not support the current machine, so we
   * have to filter it down, and then find the most recent of the applicable firmware.
   * @returns {q.Promise}
   */


  _checkFirmwareRemote() {
    let fwEndpoint; // skipping sketch until it's ready & explicitly ignoring it in the constants map to be extra safe
    // if (this._printer.isFifthGen() && this._printer._printerInfo.info.bot_type === BotTypeEnum.sketch) {
    //     fwEndpoint = fwEndpointTargets.sketch;
    // }

    if (this._printer.isFifthGen() && !this._printer._printerInfo.info.bot_type === BotTypeEnum.sketch) {
      fwEndpoint = fwEndpointTargets.fifthGen;
    } else {
      fwEndpoint = fwEndpointTargets.sixthGen;
    }

    return new q.Promise((resolve, reject) => {
      request(`${fwEndpoint}/list.json`, (err, res, body) => {
        if (err) {
          reject(err);
          return;
        }

        const updates = JSON.parse(body);

        const pid = this._printer.getGender().pid;

        const available = this._filterAvailableFirmware(pid, updates);

        if (available.length > 0) {
          const latest = this._filterLatestFirmware(available);

          latest.remote = true;
          this._updateInitiated = false;
          resolve(latest);
        } else {
          reject();
        }
      });
    });
  }
  /**
   * @private
   * In the event that there isn't an availble update on the printer, but there is one on the server, we
   * have to download it to a temporary location, and upload it to the printer ourselves. This method downloads
   * the file and puts it in a tmp location
   * @param {string} filepath - the file name for the firmware update on the server
   * @returns {q.Promise}
   */


  _download(filepath, checksum) {
    const out = tmp.tmpNameSync({
      postfix: '.zip'
    });
    let fwEndpoint; // skipping sketch until it's ready & explicitly ignoring it in the constants map to be extra safe
    // if (this._printer.isFifthGen() && this._printer._printerInfo.info.bot_type === BotTypeEnum.sketch) {
    //     fwEndpoint = fwEndpointTargets.sketch;
    // }

    if (this._printer.isFifthGen() && !this._printer._printerInfo.info.bot_type === BotTypeEnum.sketch) {
      fwEndpoint = fwEndpointTargets.fifthGen;
    } else {
      fwEndpoint = fwEndpointTargets.sixthGen;
    }

    return new q.Promise((resolve, reject, notify) => {
      progress(request(`${fwEndpoint}/${filepath}`)).on('progress', state => notify(state)).pipe(fs.createWriteStream(out)).on('finish', () => {
        this.verify(out, checksum).then(() => resolve(out)).catch(reject);
      }).on('error', err => {
        reject(err);
      });
    });
  }
  /**
   * @private
   * When we get a list of firmware back from the JSON endpoint, not every version will be compatible
   * with the current printer, thus we need to filter it down based on the `pid` of the printer.
   * @param {Number} pid - The Product ID of the current printer
   * @param {Object[]} allUpdates - All of the unfiltered firmware updates parsed from the JSON endpoint
   * @returns {Object[]} Filtered results
   */


  _filterAvailableFirmware(pid, allUpdates) {
    return allUpdates.filter(u => {
      return u.manifest.supported_machines.filter(m => m.pid === pid).length > 0;
    });
  }
  /**
   * @private
   * Cycles through the filtered firmware updates from the JSON endpoint and returns the
   * latest firmware update.
   * @param {Object[]} updates - filtered firmware updates fro the JSON endpoint
   * @returns {Object} The most recent update
   */


  _filterLatestFirmware(updates) {
    let latest = updates[0];
    updates.map(u => {
      latest = _latestVersion(latest, u);
    });
    return latest;
  }
  /**
   * @private
   * Checks to see if a particular firmware supports this machine
   * @param {Buffer} file - the zip file containing the firmware
   * @returns {q.Promise}
   */


  _isSupported(file) {
    return this._extractManifest(file).then(manifest => {
      // loop through supported machines
      for (let i = 0; i < manifest.supported_machines.length; i++) {
        const supported = manifest.supported_machines[i]; // if we find that this machine is supported, resolve and return

        if (supported.pid === this._printer.getGender().pid && supported.vid === vendorID) {
          return manifest;
        }
      }

      throw new BotNotSupportedErr();
    });
  }

  _extractManifest(file) {
    const deferred = q.defer();
    let foundManifest = false; // unzip the firmware file

    yauzl.fromBuffer(file, (err, zipFile) => {
      if (err) {
        deferred.reject(new NotZipErr(err.message));
        return;
      }

      zipFile.on('entry', entry => {
        // find the manifest file
        if (path.basename(entry.fileName) === 'manifest.json') {
          foundManifest = true; // stream it

          zipFile.openReadStream(entry, (err, stream) => {
            if (err) {
              deferred.reject(err);
              return;
            }

            let json = '';
            stream.on('readable', () => {
              const data = stream.read();

              if (data) {
                json += data;
              } else {
                // parse and return the manifest
                deferred.resolve(JSON.parse(json));
              }
            }).on('error', deferred.reject);
          });
        }
      });
      zipFile.on('end', () => {
        if (!foundManifest) {
          deferred.reject(new NotMBFirmwareErr());
        }
      });
    });
    return deferred.promise;
  }

}
/**
 * Takes two versions and recursively determines which is the
 * latest of the two.
 * @param {Object} v1 - A version of firmware
 * @param {Object} v2 - Another version of firmware
 * @param {Number} [n=0] - Depth of the iteration. Used for recursion
 * @returns {Object} The latest of the two provided versions
 */


function _latestVersion(v1, v2, n) {
  if (!n) n = 0; // apparently default parameters don't work?
  // Will throw an error if n is out of bounds. If that happens,
  // it most likely means that the two versions are equal, so
  // return either one.

  try {
    if (v1.manifest.version[n] > v2.manifest.version[n]) {
      return v1;
    }

    if (v2.manifest.version[n] > v1.manifest.version[n]) {
      return v2;
    }

    return _latestVersion(v1, v2, n + 1);
  } catch (e) {
    return v1; // both equal, doesn't matter
  }
}

module.exports = FirmwareListener;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpcm13YXJlTGlzdGVuZXIuanMiXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsImZzIiwicmVxdWVzdCIsInEiLCJ0bXAiLCJfIiwiY3J5cHRvIiwicGF0aCIsInlhdXpsIiwicHJvZ3Jlc3MiLCJCb3RUeXBlRW51bSIsImZ3RW5kcG9pbnRUYXJnZXRzIiwiZmlmdGhHZW4iLCJzaXh0aEdlbiIsIm5vdGlmaWNhdGlvbiIsInZlbmRvcklEIiwiVmVyaWZpY2F0aW9uRmFpbGVkRXJyIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImZpbGVuYW1lIiwiY29kZSIsIk5vdFppcEVyciIsIm1zZyIsIk5vdE1CRmlybXdhcmVFcnIiLCJCb3ROb3RTdXBwb3J0ZWRFcnIiLCJGaXJtd2FyZUxpc3RlbmVyIiwibWJQcmludGVyIiwiX3ByaW50ZXIiLCJfYXZhaWxhYmxlRmlybXdhcmUiLCJfY3VzdG9tRmlybXdhcmUiLCJfdXBkYXRlTm90aWZpY2F0aW9ucyIsIl91cGRhdGVJbml0aWF0ZWQiLCJfcHV0RmlsZUpvYiIsIl9wcm9ncmVzc0NhbGxiYWNrIiwidXBkYXRlTm90aWZpY2F0aW9ucyIsImFkZExpc3RlbmVyIiwidmVyc2lvbiIsInVwZGF0ZUF2YWlsYWJsZSIsInJlbGVhc2VOb3RlcyIsImZ3IiwibWFuaWZlc3QiLCJzcGxpdCIsImRlc2NyaXB0aW9uIiwiX3BhcnNlIiwidGhlbiIsImVtaXQiLCJjYXRjaCIsImxpc3RlbiIsImNhbGxiYWNrIiwicmVtb3ZlIiwicmVtb3ZlTGlzdGVuZXIiLCJjaGVjayIsIlVwZGF0ZUF2YWlsYWJsZUZpcm13YXJlSXNTdXBwb3J0ZWQiLCJpbnZva2UiLCJ1cGRhdGUiLCJyZW1vdGUiLCJjaGVja3N1bSIsIm1kNXN1bSIsIl9kb3dubG9hZCIsInVwbG9hZCIsInVubGlua1N5bmMiLCJlcnIiLCJjb25zb2xlIiwibG9nIiwibG9jYWxQYXRoIiwidmVyaWZ5IiwiaXNQZW5kaW5nIiwicmVtb3RlUGF0aCIsImZpbGVUcmFuc2ZlckhlbHBlciIsInB1dEZpbGVKb2IiLCJzdGFydCIsIm1hbmFnaW5nRndVcGRhdGUiLCJjYW5jZWxVcGRhdGUiLCJ0cmFuc2ZlckNhbmNlbFByb21pc2UiLCJwcm9jZXNzQ2FuY2VsUHJvbWlzZSIsImNhbmNlbCIsImdldCIsImFsbFNldHRsZWQiLCJyZXMiLCJlcnJzIiwiciIsInJlYXNvbiIsInB1c2giLCJsZW5ndGgiLCJoYXNVcGRhdGUiLCJjdXJyZW50IiwiY3VycmVudFZlcnNpb24iLCJfbGF0ZXN0VmVyc2lvbiIsImhhc2giLCJjcmVhdGVIYXNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmaWxlIiwicmVhZEZpbGVTeW5jIiwiZGlnZXN0IiwiX2lzU3VwcG9ydGVkIiwiY3VycmVudFN0YXRlIiwiZmlybXdhcmVfdmVyc2lvbiIsIm1ham9yIiwibWlub3IiLCJidWdmaXgiLCJidWlsZCIsImF2YWlsYWJsZVVwZGF0ZSIsInVwZGF0ZUluaXRpYXRlZCIsIm5ld0Zpcm13YXJlIiwiX2NoZWNrRmlybXdhcmVSZW1vdGUiLCJmd0VuZHBvaW50IiwiaXNGaWZ0aEdlbiIsIl9wcmludGVySW5mbyIsImluZm8iLCJib3RfdHlwZSIsInNrZXRjaCIsImJvZHkiLCJ1cGRhdGVzIiwiSlNPTiIsInBhcnNlIiwicGlkIiwiZ2V0R2VuZGVyIiwiYXZhaWxhYmxlIiwiX2ZpbHRlckF2YWlsYWJsZUZpcm13YXJlIiwibGF0ZXN0IiwiX2ZpbHRlckxhdGVzdEZpcm13YXJlIiwiZmlsZXBhdGgiLCJvdXQiLCJ0bXBOYW1lU3luYyIsInBvc3RmaXgiLCJub3RpZnkiLCJvbiIsInN0YXRlIiwicGlwZSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiYWxsVXBkYXRlcyIsImZpbHRlciIsInUiLCJzdXBwb3J0ZWRfbWFjaGluZXMiLCJtIiwibWFwIiwiX2V4dHJhY3RNYW5pZmVzdCIsImkiLCJzdXBwb3J0ZWQiLCJ2aWQiLCJkZWZlcnJlZCIsImRlZmVyIiwiZm91bmRNYW5pZmVzdCIsImZyb21CdWZmZXIiLCJ6aXBGaWxlIiwibWVzc2FnZSIsImVudHJ5IiwiYmFzZW5hbWUiLCJmaWxlTmFtZSIsIm9wZW5SZWFkU3RyZWFtIiwic3RyZWFtIiwianNvbiIsImRhdGEiLCJyZWFkIiwicHJvbWlzZSIsInYxIiwidjIiLCJuIiwiZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLE1BQU1BLFlBQVksR0FBR0MsT0FBTyxDQUFDLGVBQUQsQ0FBNUI7O0FBQ0EsTUFBTUMsRUFBRSxHQUFHRCxPQUFPLENBQUMsVUFBRCxDQUFsQjs7QUFDQSxNQUFNRSxPQUFPLEdBQUdGLE9BQU8sQ0FBQyxTQUFELENBQXZCOztBQUNBLE1BQU1HLENBQUMsR0FBR0gsT0FBTyxDQUFDLEdBQUQsQ0FBakI7O0FBQ0EsTUFBTUksR0FBRyxHQUFHSixPQUFPLENBQUMsS0FBRCxDQUFuQjs7QUFDQSxNQUFNSyxDQUFDLEdBQUdMLE9BQU8sQ0FBQyxRQUFELENBQWpCOztBQUNBLE1BQU1NLE1BQU0sR0FBR04sT0FBTyxDQUFDLFFBQUQsQ0FBdEI7O0FBQ0EsTUFBTU8sSUFBSSxHQUFHUCxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFDQSxNQUFNUSxLQUFLLEdBQUdSLE9BQU8sQ0FBQyxPQUFELENBQXJCOztBQUVBLE1BQU07QUFBRVMsRUFBQUE7QUFBRixJQUFlVCxPQUFPLENBQUMsUUFBRCxDQUE1Qjs7QUFDQSxNQUFNO0FBQUVVLEVBQUFBO0FBQUYsSUFBa0JWLE9BQU8sQ0FBQyxhQUFELENBQS9COztBQUVBLE1BQU1XLGlCQUFpQixHQUFHO0FBQ3RCQyxFQUFBQSxRQUFRLEVBQUUscURBRFk7QUFFdEJDLEVBQUFBLFFBQVEsRUFBRSxxREFGWSxDQUd0Qjs7QUFIc0IsQ0FBMUI7QUFLQSxNQUFNQyxZQUFZLEdBQUcsOEJBQXJCO0FBQ0EsTUFBTUMsUUFBUSxHQUFHLElBQWpCOztBQUVBLE1BQU1DLHFCQUFOLFNBQW9DQyxLQUFwQyxDQUEwQztBQUN0Q0MsRUFBQUEsV0FBVyxDQUFDQyxRQUFELEVBQVc7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UUFBUSxDQUFDbEQsTUFBVCxDQUFnQixJQUFJckUsZ0JBQUosRUFBaEI7QUFDSDtBQUNKLE9BSkQ7QUFLSCxLQXhDRDtBQTBDQSxXQUFPdUgsUUFBUSxDQUFDYyxPQUFoQjtBQUNIOztBQWxia0I7QUFxYnZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNyRSxjQUFULENBQXdCc0UsRUFBeEIsRUFBNEJDLEVBQTVCLEVBQWdDQyxDQUFoQyxFQUFtQztBQUMvQixNQUFJLENBQUNBLENBQUwsRUFBUUEsQ0FBQyxHQUFHLENBQUosQ0FEdUIsQ0FDaEI7QUFFZjtBQUNBO0FBQ0E7O0FBQ0EsTUFBSTtBQUNBLFFBQUlGLEVBQUUsQ0FBQ3JILFFBQUgsQ0FBWUosT0FBWixDQUFvQjJILENBQXBCLElBQXlCRCxFQUFFLENBQUN0SCxRQUFILENBQVlKLE9BQVosQ0FBb0IySCxDQUFwQixDQUE3QixFQUFxRDtBQUNqRCxhQUFPRixFQUFQO0FBQ0g7O0FBRUQsUUFBSUMsRUFBRSxDQUFDdEgsUUFBSCxDQUFZSixPQUFaLENBQW9CMkgsQ0FBcEIsSUFBeUJGLEVBQUUsQ0FBQ3JILFFBQUgsQ0FBWUosT0FBWixDQUFvQjJILENBQXBCLENBQTdCLEVBQXFEO0FBQ2pELGFBQU9ELEVBQVA7QUFDSDs7QUFFRCxXQUFPdkUsY0FBYyxDQUFDc0UsRUFBRCxFQUFLQyxFQUFMLEVBQVNDLENBQUMsR0FBRyxDQUFiLENBQXJCO0FBQ0gsR0FWRCxDQVVFLE9BQU9DLENBQVAsRUFBVTtBQUNSLFdBQU9ILEVBQVAsQ0FEUSxDQUNHO0FBQ2Q7QUFDSjs7QUFFREksTUFBTSxDQUFDQyxPQUFQLEdBQWlCekksZ0JBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xyXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XHJcbmNvbnN0IHJlcXVlc3QgPSByZXF1aXJlKCdyZXF1ZXN0Jyk7XHJcbmNvbnN0IHEgPSByZXF1aXJlKCdxJyk7XHJcbmNvbnN0IHRtcCA9IHJlcXVpcmUoJ3RtcCcpO1xyXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCB5YXV6bCA9IHJlcXVpcmUoJ3lhdXpsJyk7XHJcblxyXG5jb25zdCB7IHByb2dyZXNzIH0gPSByZXF1aXJlKCcuL3V0aWwnKTtcclxuY29uc3QgeyBCb3RUeXBlRW51bSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxuXHJcbmNvbnN0IGZ3RW5kcG9pbnRUYXJnZXRzID0ge1xyXG4gICAgZmlmdGhHZW46ICdodHRwczovL3MzLmFtYXpvbmF3cy5jb20vZmlybXdhcmUtbWFrZXJib3QtY29tL2J3ZncnLFxyXG4gICAgc2l4dGhHZW46ICdodHRwczovL3MzLmFtYXpvbmF3cy5jb20vZmlybXdhcmUtbWFrZXJib3QtY29tL3NiZncnLFxyXG4gICAgLy8gc2tldGNoOiAnaHR0cHM6Ly9zMy5hbWF6b25hd3MuY29tL2Zpcm13YXJlLW1ha2VyYm90LWNvbS93c2Z3JyxcclxufTtcclxuY29uc3Qgbm90aWZpY2F0aW9uID0gJ2Zpcm13YXJlX3VwZGF0ZXNfaW5mb19jaGFuZ2UnO1xyXG5jb25zdCB2ZW5kb3JJRCA9IDkxNTM7XHJcblxyXG5jbGFzcyBWZXJpZmljYXRpb25GYWlsZWRFcnIgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWxlbmFtZSkge1xyXG4gICAgICAgIHN1cGVyKGAke2ZpbGVuYW1lfSBkaWRuJ3QgcGFzcyB2ZXJpZmljYXRpb25gKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSAnVmVyaWZpY2F0aW9uRmFpbGVkRXJyJztcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgTm90WmlwRXJyIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IobXNnKSB7XHJcbiAgICAgICAgc3VwZXIoYEVycm9yIG9wZW5pbmcgZmlybXdhcmUgZmlsZS4gSXQgc2hvdWxkIGJlIGEgLnppcDogJHttc2d9YCk7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gJ05vdFppcEVycic7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIE5vdE1CRmlybXdhcmVFcnIgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcignVGhpcyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSBNYWtlcmJvdCBmaXJtd2FyZSBmaWxlJyk7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gJ05vdE1CRmlybXdhcmVFcnInO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBCb3ROb3RTdXBwb3J0ZWRFcnIgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcignVGhpcyBmaXJtd2FyZSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjdXJyZW50IHByaW50ZXInKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSAnQm90Tm90U3VwcG9ydGVkRXJyJztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBjbGFzc2Rlc2NcclxuICogRmlybXdhcmVMaXN0ZW5lciBsaXN0ZW5zIGZvciBmaXJtd2FyZSB1cGRhdGVzIGZyb20gdGhlIHByaW50ZXIuIEl0IHdpbGwgYWxzbyBjaGVjayB0aGUgc2VydmVyXHJcbiAqIGZvciBuZXcgdXBkYXRlcyB0aGF0IHRoZSBwcmludGVyIGRvZXNuJ3Qga25vdyBhYm91dCBpdC4gWW91IG5lZWQgdG8gc3Vic2NyaWJlIHRvIGEgbGlzdGVuZXIgdG9cclxuICogZ2V0IHVwZGF0ZXMgZnJvbSB0aGUgcHJpbnRlci4gSWYgYW4gdXBkYXRlIGlzIGF2YWlsYWJsZSwgeW91IGNhbiB0cmlnZ2VyIGFuIHVwZGF0ZSBmcm9tIGhlcmUgdG9vLlxyXG4gKi9cclxuY2xhc3MgRmlybXdhcmVMaXN0ZW5lciB7XHJcbiAgICAvKipcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtNYWtlckJvdFByaW50ZXJ9IG1iUHJpbnRlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYlByaW50ZXIpIHtcclxuICAgICAgICB0aGlzLl9wcmludGVyID0gbWJQcmludGVyO1xyXG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZUZpcm13YXJlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9jdXN0b21GaXJtd2FyZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTm90aWZpY2F0aW9ucyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVJbml0aWF0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wdXRGaWxlSm9iID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9wcm9ncmVzc0NhbGxiYWNrID0gKCkgPT4ge307XHJcblxyXG4gICAgICAgIHRoaXMuX3ByaW50ZXIudXBkYXRlTm90aWZpY2F0aW9ucy5hZGRMaXN0ZW5lcihub3RpZmljYXRpb24sICh2ZXJzaW9uLCB1cGRhdGVBdmFpbGFibGUsIHJlbGVhc2VOb3RlcykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZncgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgaWYgKHVwZGF0ZUF2YWlsYWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlSW5pdGlhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmdyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiByZWxlYXNlTm90ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlKGZ3KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4odmVyc2lvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTm90aWZpY2F0aW9ucy5lbWl0KG5vdGlmaWNhdGlvbiwgdmVyc2lvbik7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZyBoZXJlLCBpdCdzIHByb2JhYmx5IHRoYXQgdGhlIHNlcnZlciBkaWRuJ3QgZmluZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFueSByZWxldmFudCB1cGRhdGVzLCBzbyB3ZSdsbCBqdXN0IGVtaXQgdGhlIG5vdGlmaWNhdGlvbiB3aXRoIGBudWxsYFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHNob3VsZCBsZXQgdGhlIGNvbXBvbmVudHMga25vdyB0aGF0IHRoZXJlIHdhc24ndCBhbiB1cGRhdGVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVOb3RpZmljYXRpb25zLmVtaXQobm90aWZpY2F0aW9uLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU5vdGlmaWNhdGlvbnMuYWRkTGlzdGVuZXIobm90aWZpY2F0aW9uLCBmdyA9PiAodGhpcy5fYXZhaWxhYmxlRmlybXdhcmUgPSBmdykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHByaW50ZXIgc2VuZHMgYSBcImZpcm13YXJlX3VwZGF0ZXNfaW5mb19jaGFuZ2VcIiBub3RpZmljYXRpb25cclxuICAgICAqIEBjYWxsYmFjayBmd0NhbGxiYWNrXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlybXdhcmUgLSBUaGUgbGF0ZXN0IGZpcm13YXJlLiBJdCBpcyBgbnVsbGAgaWYgdGhlcmUncyBubyBuZXcgZmlybXdhcmVcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5vdGlmaWNhdGlvbiBsaXN0ZW5lciBmb3IgYW55IGF2YWlsYWJsZSBmaXJtd2FyZSB1cGRhdGVzXHJcbiAgICAgKiBAcGFyYW0ge2Z3Q2FsbGJhY2t9IGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIGxpc3RlbihjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU5vdGlmaWNhdGlvbnMuYWRkTGlzdGVuZXIobm90aWZpY2F0aW9uLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgbm90aWZpY2F0aW9uIGxpc3RlbmVyXHJcbiAgICAgKiBAcGFyYW0ge2Z3Q2FsbGJhY2t9IGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU5vdGlmaWNhdGlvbnMucmVtb3ZlTGlzdGVuZXIobm90aWZpY2F0aW9uLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBc2tzIHRoZSBwcmludGVyIGlmIGl0IGtub3dzIGFib3V0IGFueSBhdmFpbGFibGUgZmlybXdhcmUuXHJcbiAgICAgKiBUaGUgcHJpbnRlciB3aWxsIHNlbmQgYmFjayBhIG5vdGlmaWNhdGlvbiwgd2hpY2ggd2lsbCBlaXRoZXIgaGF2ZSBpbmZvXHJcbiAgICAgKiBhYm91dCBhbiBhdmFpbGFibGUgdXBkYXRlLCBvciB3ZSdsbCBjaGVjayB0aGUgd2ViIGVuZHBvaW50LlxyXG4gICAgICogSU1QT1JUQU5UOiBUaGUgcmV0dXJuZWQgUHJvbWlzZSB3b24ndCBoYXZlIGFueSBpbmZvcm1hdGlvbiBhYm91dCBhdmFpbGFibGUgdXBkYXRlcy5cclxuICAgICAqIFRvIGdldCB0aGF0IGluZm9ybWF0aW9uLCB5b3UgbXVzdCBhZGQgYSBsaXN0ZW5lci4gU2VlIGBsaXN0ZW4oKWBcclxuICAgICAqIEByZXR1cm5zIHtxLlByb21pc2V9XHJcbiAgICAgKi9cclxuICAgIGNoZWNrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcmludGVyLl9wcmludGVyLlVwZGF0ZUF2YWlsYWJsZUZpcm13YXJlSXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpbnRlci5pbnZva2UoJ1VwZGF0ZUF2YWlsYWJsZUZpcm13YXJlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFyc2UobnVsbClcclxuICAgICAgICAgICAgICAgIC50aGVuKHZlcnNpb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU5vdGlmaWNhdGlvbnMuZW1pdChub3RpZmljYXRpb24sIHZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc29tZXRoaW5nIGdvZXMgd3JvbmcgaGVyZSwgaXQncyBwcm9iYWJseSB0aGF0IHRoZSBzZXJ2ZXIgZGlkbid0IGZpbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbnkgcmVsZXZhbnQgdXBkYXRlcywgc28gd2UnbGwganVzdCBlbWl0IHRoZSBub3RpZmljYXRpb24gd2l0aCBgbnVsbGBcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBzaG91bGQgbGV0IHRoZSBjb21wb25lbnRzIGtub3cgdGhhdCB0aGVyZSB3YXNuJ3QgYW4gdXBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTm90aWZpY2F0aW9ucy5lbWl0KG5vdGlmaWNhdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoZSBwcmludGVyIHRvIHVwZGF0ZSBpdHMgZmlybXdhcmVcclxuICAgICAqIEByZXR1cm5zIHtxLlByb21pc2V9XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVJbml0aWF0ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fYXZhaWxhYmxlRmlybXdhcmUgJiYgdGhpcy5fYXZhaWxhYmxlRmlybXdhcmUucmVtb3RlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gdGhpcy5fYXZhaWxhYmxlRmlybXdhcmUubWQ1c3VtIHx8ICcnOyAvLyBwcmV2ZW50IGJ5cGFzc2luZyBjaGVja3N1bSBmb3IgZG93bmxvYWRzXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb3dubG9hZCh0aGlzLl9hdmFpbGFibGVGaXJtd2FyZS5wYXRoLCBjaGVja3N1bSlcclxuICAgICAgICAgICAgICAgIC50aGVuKHRtcCA9PiB0aGlzLnVwbG9hZCh0bXApKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4odG1wID0+IGZzLnVubGlua1N5bmModG1wKSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coJ2VycjonLCBlcnIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRlc3BpdGUgdGhlIG5hbWUgYERvd25sb2FkQW5kSW5zdGFsbEZpcm13YXJlYCBkb2Vzbid0IGRvd25sb2FkIGFueXRoaW5nLFxyXG4gICAgICAgIC8vIGl0IG9ubHkgaW5zdGFsbHMuIFRodXMsIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciB3aGVuIGl0IHRyaWVzIHRvIHVwZGF0ZVxyXG4gICAgICAgIC8vIGZyb20gcmVtb3RlXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW50ZXIuaW52b2tlKCdEb3dubG9hZEFuZEluc3RhbGxGaXJtd2FyZScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkcyBmaXJtd2FyZSBmaWxlICguemlwKSB0byB0aGUgcHJpbnRlciB0byBiZSBpbnN0YWxsZWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbFBhdGggLSBMb2NhbCBwYXRoIHRvIGZpbGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW3ZlcmlmeV0gLSB3aGV0aGVyIHRvIHBlcmZvcm0gYSB2ZXJpZmljYXRpb24gb24gdGhlIGZpbGUuIFRoaXMgaXMgbm90IG5lY2Vzc2FyeSBpZiB0aGUgZmlybXdhcmUgd2FzIGRvd25sb2FkZWQgdmlhIEZpcm13YXJlTGlzdGVuZXIjZG93bmxvYWQuXHJcbiAgICAgKiBAcmV0dXJucyB7cS5Qcm9taXNlfVxyXG4gICAgICovXHJcbiAgICB1cGxvYWQobG9jYWxQYXRoLCB2ZXJpZnkpIHtcclxuICAgICAgICBpZiAodGhpcy5fcHV0RmlsZUpvYiAmJiB0aGlzLl9wdXRGaWxlSm9iLmlzUGVuZGluZygpKSB0aHJvdyAnQWxyZWFkeSB0cmFuc2ZlcnJpbmcgYSBmaXJtd2FyZSBmaWxlJztcclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSW5pdGlhdGVkID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCByZW1vdGVQYXRoID0gYC9maXJtd2FyZS9maXJtd2FyZS56aXBgO1xyXG5cclxuICAgICAgICB0aGlzLl9wdXRGaWxlSm9iID0gdGhpcy5fcHJpbnRlci5maWxlVHJhbnNmZXJIZWxwZXIucHV0RmlsZUpvYihsb2NhbFBhdGgsIHJlbW90ZVBhdGgpO1xyXG5cclxuICAgICAgICBpZiAodmVyaWZ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeShsb2NhbFBhdGgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJpbnRlci5pbnZva2UoJ0Jyb29rbHluVXBsb2FkJywgW3JlbW90ZVBhdGgsIHRydWVdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXRGaWxlSm9iLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaGVoZSwgc3VycHJpc2UhISBCcm9va2x5blVwbG9hZCBkb2Vzbid0IGFjdHVhbGx5IHVwbG9hZCFcclxuICAgICAgICAvLyBXZSBjYWxsIHRoaXMgbm93IHdpdGggYHRyYW5zZmVyX3dhaXRgICh0aGUgc2Vjb25kIHBhcmFtZXRlcikgc2V0IHRvXHJcbiAgICAgICAgLy8gdHJ1ZSwgd2hpY2ggd2lsbCBtYWtlIHRoZSBwcmludGVyIHdhaXQgdW50aWwgd2UndmUgYWN0dWFsbHkgZmluaXNoZWRcclxuICAgICAgICAvLyB1cGxvYWRpbmcgdGhlIGxvY2FsUGF0aCAod2hpY2ggaXMgZG9uZSB3aXRoIGBQdXRJbml0YCksIGJlZm9yZSB1cGxvYWRpbmcgdGhlXHJcbiAgICAgICAgLy8gbG9jYWxQYXRoIHRvIHRoZSBCcm9va2x5biBoYXJkd2FyZVxyXG4gICAgICAgIHRoaXMuX3ByaW50ZXIuaW52b2tlKCdCcm9va2x5blVwbG9hZCcsIFtyZW1vdGVQYXRoLCB0cnVlXSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1dEZpbGVKb2Iuc3RhcnQoKS50aGVuKCgpID0+IGxvY2FsUGF0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgbWFuYWdpbmdGd1VwZGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHV0RmlsZUpvYiAmJiB0aGlzLl9wdXRGaWxlSm9iLmlzUGVuZGluZygpO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbmNlbFVwZGF0ZSgpIHtcclxuICAgICAgICBsZXQgdHJhbnNmZXJDYW5jZWxQcm9taXNlID0gcSgpO1xyXG4gICAgICAgIGxldCBwcm9jZXNzQ2FuY2VsUHJvbWlzZSA9IHEoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3B1dEZpbGVKb2IgJiYgdGhpcy5fcHV0RmlsZUpvYi5pc1BlbmRpbmcoKSkgdHJhbnNmZXJDYW5jZWxQcm9taXNlID0gdGhpcy5fcHV0RmlsZUpvYi5jYW5jZWwoKTtcclxuXHJcbiAgICAgICAgaWYgKF8uZ2V0KHRoaXMuX3ByaW50ZXIsICdjdXJyZW50UHJvY2Vzcy5uYW1lJykgPT09ICdGaXJtd2FyZUJ1cm5pbmdQcm9jZXNzJylcclxuICAgICAgICAgICAgcHJvY2Vzc0NhbmNlbFByb21pc2UgPSB0aGlzLl9wcmludGVyLmludm9rZSgnQ2FuY2VsJyk7XHJcblxyXG4gICAgICAgIHJldHVybiBxLmFsbFNldHRsZWQoW3RyYW5zZmVyQ2FuY2VsUHJvbWlzZSwgcHJvY2Vzc0NhbmNlbFByb21pc2VdKS50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCByIG9mIHJlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIucmVhc29uKSBlcnJzLnB1c2goci5yZWFzb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZXJycy5sZW5ndGgpIHRocm93IGVycnM7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZXJlJ3MgYSBjYWNoZWQgdXBkYXRlIGJlZm9yZSBhc2tpbmcgdGhlXHJcbiAgICAgKiBwcmludGVyIGFnYWluLiBJdHMgaW50ZW5kZWQgdXNlIGlzIHRvIHJlZHVjZSBsYWcgdGltZSBpblxyXG4gICAgICogY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHRoZSBjbGllbnQgYW5kIHRoZSBwcmludGVyXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgaGFzVXBkYXRlKCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnRWZXJzaW9uO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLl9hdmFpbGFibGVGaXJtd2FyZSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgIGN1cnJlbnQgIT09IF9sYXRlc3RWZXJzaW9uKGN1cnJlbnQsIHRoaXMuX2F2YWlsYWJsZUZpcm13YXJlKSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5fdXBkYXRlSW5pdGlhdGVkXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aGUgaGFzaCBvZiB0aGUgZmlybXdhcmUgYW5kIGNvbXBhcmVzIGl0IHRvIHRoZSBjaGVja3N1bVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIC0gcGF0aCB0byB0aGUgZmlsZSBvbiBkaXNrIHlvdSB3YW50IHRvIHZlcnlpZnlcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hlY2tzdW1dIC0gbWQ1IGNoZWNrc3VtIGZvciByZWxldmFudCBmaXJtd2FyZVxyXG4gICAgICogQHJldHVybnMge3EuUHJvbWlzZX1cclxuICAgICAqL1xyXG4gICAgdmVyaWZ5KGZpbGVuYW1lLCBjaGVja3N1bSkge1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1Jyk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgcS5Qcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSk7IC8vIG5lZWQgdG8gZG8gdGhpcyBzeW5jaHJvbm91c2x5IGZvciB0aGlzLl9pc1N1cHBvcnRlZFxyXG5cclxuICAgICAgICAgICAgaWYgKGNoZWNrc3VtICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGhhc2gudXBkYXRlKGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlnZXN0ID0gaGFzaC5kaWdlc3QoJ2hleCcpOyAvLyBnZXQgY2hlY2tzdW0gZm9yIGlucHV0IGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlnZXN0ICE9PSBjaGVja3N1bSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFZlcmlmaWNhdGlvbkZhaWxlZEVycihmaWxlbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIG1hY2hpbmUgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgZmlybXdhcmVcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzU3VwcG9ydGVkKGZpbGUpXHJcbiAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXRzIHRoZSBjdXJyZW50IGZpcndhcmUgdmVyc2lvbiBmcm9tIHRoZSBwcmludGVyIGluIHRoZSBzYW1lIHNjaGVtYVxyXG4gICAgICogYXMgdGhlIEpTT04gcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLiBUaGlzIGp1c3QgbWFrZXMgY29tcGFyaXNvbiBlYXNpZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCBmaXJtd2FyZSB2ZXJzaW9uIGZvcm1hdHRlZFxyXG4gICAgICovXHJcbiAgICBnZXQgY3VycmVudFZlcnNpb24oKSB7XHJcbiAgICAgICAgY29uc3QgZncgPSB0aGlzLl9wcmludGVyLmN1cnJlbnRTdGF0ZS5maXJtd2FyZV92ZXJzaW9uO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1hbmlmZXN0OiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBbZncubWFqb3IsIGZ3Lm1pbm9yLCBmdy5idWdmaXgsIGZ3LmJ1aWxkXSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGVkIGZpcm13YXJlIHVwZGF0ZVxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgZ2V0IGF2YWlsYWJsZVVwZGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXZhaWxhYmxlRmlybXdhcmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhbiB1cGRhdGUgaGFzIGJlZ3VuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHVwZGF0ZUluaXRpYXRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlSW5pdGlhdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIENoZWNrcyB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgcHJpbnRlciBsb29raW5nIGZvciBuZXcgZmlybXdhcmUuIElmIG5vdCwgd2UnbGwgcGluZyB0aGUgd2Vic2l0ZSwganVzdCB0b1xyXG4gICAgICogbWFrZSBzdXJlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtuZXdGaXJtd2FyZV0gLSBpbmZvcm1hdGlvbiBhYm91dCBrbm93biBmaXJtd2FyZSBmcm9tIHRoZSBwcmludGVyLiBJZiB0aGUgcHJpbnRlclxyXG4gICAgICogZG9lc24ndCBrbm93IGFib3V0IG5ldyBmaXJtd2FyZSwgaXQgaXMgYG51bGxgLiBJbiB0aGF0IGNhc2Ugd2UgcGluZyB0aGUgd2Vic2l0ZSBmb3JcclxuICAgICAqIG5ldyBmaXJtd2FyZS5cclxuICAgICAqIEByZXR1cm5zIHtxLlByb21pc2V9XHJcbiAgICAgKi9cclxuICAgIF9wYXJzZShuZXdGaXJtd2FyZSkge1xyXG4gICAgICAgIC8vIElmIG5vdGhpbmcgY29tZXMgYmFjayBmcm9tIHRoZSBwcmludGVyLCBsZXQncyBjaGVjayB0aGUgd2ViIGVuZHBvaW50XHJcbiAgICAgICAgaWYgKG5ld0Zpcm13YXJlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrRmlybXdhcmVSZW1vdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgcS5Qcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHNldCB0aGUgdmVyc2lvbiBmcm9tIHdoYXQgdGhlIHByaW50ZXIgYWxyZWFkeSBoYXNcclxuICAgICAgICAgICAgcmVzb2x2ZShfbGF0ZXN0VmVyc2lvbih0aGlzLmN1cnJlbnRWZXJzaW9uLCBuZXdGaXJtd2FyZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEhpdHMgYSBKU09OIGVuZHBvaW50IHRvIHNlZSB3aGF0IGZpcm13YXJlIGlzIGF2YWlsYWJsZSByZW1vdGVseS4gVGhlIEpTT04gcmVzcG9uc2Ugd2lsbFxyXG4gICAgICogaGF2ZSBldmVyeSBhdmFpbGFibGUgZmlybXdhcmUsIHdoaWNoIG1heSBvciBtYXkgbm90IHN1cHBvcnQgdGhlIGN1cnJlbnQgbWFjaGluZSwgc28gd2VcclxuICAgICAqIGhhdmUgdG8gZmlsdGVyIGl0IGRvd24sIGFuZCB0aGVuIGZpbmQgdGhlIG1vc3QgcmVjZW50IG9mIHRoZSBhcHBsaWNhYmxlIGZpcm13YXJlLlxyXG4gICAgICogQHJldHVybnMge3EuUHJvbWlzZX1cclxuICAgICAqL1xyXG4gICAgX2NoZWNrRmlybXdhcmVSZW1vdGUoKSB7XHJcbiAgICAgICAgbGV0IGZ3RW5kcG9pbnQ7XHJcbiAgICAgICAgLy8gc2tpcHBpbmcgc2tldGNoIHVudGlsIGl0J3MgcmVhZHkgJiBleHBsaWNpdGx5IGlnbm9yaW5nIGl0IGluIHRoZSBjb25zdGFudHMgbWFwIHRvIGJlIGV4dHJhIHNhZmVcclxuICAgICAgICAvLyBpZiAodGhpcy5fcHJpbnRlci5pc0ZpZnRoR2VuKCkgJiYgdGhpcy5fcHJpbnRlci5fcHJpbnRlckluZm8uaW5mby5ib3RfdHlwZSA9PT0gQm90VHlwZUVudW0uc2tldGNoKSB7XHJcbiAgICAgICAgLy8gICAgIGZ3RW5kcG9pbnQgPSBmd0VuZHBvaW50VGFyZ2V0cy5za2V0Y2g7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGlmICh0aGlzLl9wcmludGVyLmlzRmlmdGhHZW4oKSAmJiAhdGhpcy5fcHJpbnRlci5fcHJpbnRlckluZm8uaW5mby5ib3RfdHlwZSA9PT0gQm90VHlwZUVudW0uc2tldGNoKSB7XHJcbiAgICAgICAgICAgIGZ3RW5kcG9pbnQgPSBmd0VuZHBvaW50VGFyZ2V0cy5maWZ0aEdlbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmd0VuZHBvaW50ID0gZndFbmRwb2ludFRhcmdldHMuc2l4dGhHZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHEuUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QoYCR7ZndFbmRwb2ludH0vbGlzdC5qc29uYCwgKGVyciwgcmVzLCBib2R5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBKU09OLnBhcnNlKGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGlkID0gdGhpcy5fcHJpbnRlci5nZXRHZW5kZXIoKS5waWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlID0gdGhpcy5fZmlsdGVyQXZhaWxhYmxlRmlybXdhcmUocGlkLCB1cGRhdGVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3QgPSB0aGlzLl9maWx0ZXJMYXRlc3RGaXJtd2FyZShhdmFpbGFibGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdC5yZW1vdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUluaXRpYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobGF0ZXN0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEluIHRoZSBldmVudCB0aGF0IHRoZXJlIGlzbid0IGFuIGF2YWlsYmxlIHVwZGF0ZSBvbiB0aGUgcHJpbnRlciwgYnV0IHRoZXJlIGlzIG9uZSBvbiB0aGUgc2VydmVyLCB3ZVxyXG4gICAgICogaGF2ZSB0byBkb3dubG9hZCBpdCB0byBhIHRlbXBvcmFyeSBsb2NhdGlvbiwgYW5kIHVwbG9hZCBpdCB0byB0aGUgcHJpbnRlciBvdXJzZWx2ZXMuIFRoaXMgbWV0aG9kIGRvd25sb2Fkc1xyXG4gICAgICogdGhlIGZpbGUgYW5kIHB1dHMgaXQgaW4gYSB0bXAgbG9jYXRpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCAtIHRoZSBmaWxlIG5hbWUgZm9yIHRoZSBmaXJtd2FyZSB1cGRhdGUgb24gdGhlIHNlcnZlclxyXG4gICAgICogQHJldHVybnMge3EuUHJvbWlzZX1cclxuICAgICAqL1xyXG4gICAgX2Rvd25sb2FkKGZpbGVwYXRoLCBjaGVja3N1bSkge1xyXG4gICAgICAgIGNvbnN0IG91dCA9IHRtcC50bXBOYW1lU3luYyh7IHBvc3RmaXg6ICcuemlwJyB9KTtcclxuXHJcbiAgICAgICAgbGV0IGZ3RW5kcG9pbnQ7XHJcbiAgICAgICAgLy8gc2tpcHBpbmcgc2tldGNoIHVudGlsIGl0J3MgcmVhZHkgJiBleHBsaWNpdGx5IGlnbm9yaW5nIGl0IGluIHRoZSBjb25zdGFudHMgbWFwIHRvIGJlIGV4dHJhIHNhZmVcclxuICAgICAgICAvLyBpZiAodGhpcy5fcHJpbnRlci5pc0ZpZnRoR2VuKCkgJiYgdGhpcy5fcHJpbnRlci5fcHJpbnRlckluZm8uaW5mby5ib3RfdHlwZSA9PT0gQm90VHlwZUVudW0uc2tldGNoKSB7XHJcbiAgICAgICAgLy8gICAgIGZ3RW5kcG9pbnQgPSBmd0VuZHBvaW50VGFyZ2V0cy5za2V0Y2g7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGlmICh0aGlzLl9wcmludGVyLmlzRmlmdGhHZW4oKSAmJiAhdGhpcy5fcHJpbnRlci5fcHJpbnRlckluZm8uaW5mby5ib3RfdHlwZSA9PT0gQm90VHlwZUVudW0uc2tldGNoKSB7XHJcbiAgICAgICAgICAgIGZ3RW5kcG9pbnQgPSBmd0VuZHBvaW50VGFyZ2V0cy5maWZ0aEdlbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmd0VuZHBvaW50ID0gZndFbmRwb2ludFRhcmdldHMuc2l4dGhHZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IHEuUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpID0+IHtcclxuICAgICAgICAgICAgcHJvZ3Jlc3MocmVxdWVzdChgJHtmd0VuZHBvaW50fS8ke2ZpbGVwYXRofWApKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdwcm9ncmVzcycsIHN0YXRlID0+IG5vdGlmeShzdGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAucGlwZShmcy5jcmVhdGVXcml0ZVN0cmVhbShvdXQpKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdmaW5pc2gnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJpZnkob3V0LCBjaGVja3N1bSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVzb2x2ZShvdXQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgZXJyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIFdoZW4gd2UgZ2V0IGEgbGlzdCBvZiBmaXJtd2FyZSBiYWNrIGZyb20gdGhlIEpTT04gZW5kcG9pbnQsIG5vdCBldmVyeSB2ZXJzaW9uIHdpbGwgYmUgY29tcGF0aWJsZVxyXG4gICAgICogd2l0aCB0aGUgY3VycmVudCBwcmludGVyLCB0aHVzIHdlIG5lZWQgdG8gZmlsdGVyIGl0IGRvd24gYmFzZWQgb24gdGhlIGBwaWRgIG9mIHRoZSBwcmludGVyLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBpZCAtIFRoZSBQcm9kdWN0IElEIG9mIHRoZSBjdXJyZW50IHByaW50ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGFsbFVwZGF0ZXMgLSBBbGwgb2YgdGhlIHVuZmlsdGVyZWQgZmlybXdhcmUgdXBkYXRlcyBwYXJzZWQgZnJvbSB0aGUgSlNPTiBlbmRwb2ludFxyXG4gICAgICogQHJldHVybnMge09iamVjdFtdfSBGaWx0ZXJlZCByZXN1bHRzXHJcbiAgICAgKi9cclxuICAgIF9maWx0ZXJBdmFpbGFibGVGaXJtd2FyZShwaWQsIGFsbFVwZGF0ZXMpIHtcclxuICAgICAgICByZXR1cm4gYWxsVXBkYXRlcy5maWx0ZXIodSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB1Lm1hbmlmZXN0LnN1cHBvcnRlZF9tYWNoaW5lcy5maWx0ZXIobSA9PiBtLnBpZCA9PT0gcGlkKS5sZW5ndGggPiAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEN5Y2xlcyB0aHJvdWdoIHRoZSBmaWx0ZXJlZCBmaXJtd2FyZSB1cGRhdGVzIGZyb20gdGhlIEpTT04gZW5kcG9pbnQgYW5kIHJldHVybnMgdGhlXHJcbiAgICAgKiBsYXRlc3QgZmlybXdhcmUgdXBkYXRlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdXBkYXRlcyAtIGZpbHRlcmVkIGZpcm13YXJlIHVwZGF0ZXMgZnJvIHRoZSBKU09OIGVuZHBvaW50XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbW9zdCByZWNlbnQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIF9maWx0ZXJMYXRlc3RGaXJtd2FyZSh1cGRhdGVzKSB7XHJcbiAgICAgICAgbGV0IGxhdGVzdCA9IHVwZGF0ZXNbMF07XHJcbiAgICAgICAgdXBkYXRlcy5tYXAodSA9PiB7XHJcbiAgICAgICAgICAgIGxhdGVzdCA9IF9sYXRlc3RWZXJzaW9uKGxhdGVzdCwgdSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGxhdGVzdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgcGFydGljdWxhciBmaXJtd2FyZSBzdXBwb3J0cyB0aGlzIG1hY2hpbmVcclxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBmaWxlIC0gdGhlIHppcCBmaWxlIGNvbnRhaW5pbmcgdGhlIGZpcm13YXJlXHJcbiAgICAgKiBAcmV0dXJucyB7cS5Qcm9taXNlfVxyXG4gICAgICovXHJcbiAgICBfaXNTdXBwb3J0ZWQoZmlsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9leHRyYWN0TWFuaWZlc3QoZmlsZSkudGhlbihtYW5pZmVzdCA9PiB7XHJcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBzdXBwb3J0ZWQgbWFjaGluZXNcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYW5pZmVzdC5zdXBwb3J0ZWRfbWFjaGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRlZCA9IG1hbmlmZXN0LnN1cHBvcnRlZF9tYWNoaW5lc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIHRoYXQgdGhpcyBtYWNoaW5lIGlzIHN1cHBvcnRlZCwgcmVzb2x2ZSBhbmQgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydGVkLnBpZCA9PT0gdGhpcy5fcHJpbnRlci5nZXRHZW5kZXIoKS5waWQgJiYgc3VwcG9ydGVkLnZpZCA9PT0gdmVuZG9ySUQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFuaWZlc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEJvdE5vdFN1cHBvcnRlZEVycigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF9leHRyYWN0TWFuaWZlc3QoZmlsZSkge1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gcS5kZWZlcigpO1xyXG4gICAgICAgIGxldCBmb3VuZE1hbmlmZXN0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIHVuemlwIHRoZSBmaXJtd2FyZSBmaWxlXHJcbiAgICAgICAgeWF1emwuZnJvbUJ1ZmZlcihmaWxlLCAoZXJyLCB6aXBGaWxlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgTm90WmlwRXJyKGVyci5tZXNzYWdlKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHppcEZpbGUub24oJ2VudHJ5JywgZW50cnkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgbWFuaWZlc3QgZmlsZVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGguYmFzZW5hbWUoZW50cnkuZmlsZU5hbWUpID09PSAnbWFuaWZlc3QuanNvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZE1hbmlmZXN0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyZWFtIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgemlwRmlsZS5vcGVuUmVhZFN0cmVhbShlbnRyeSwgKGVyciwgc3RyZWFtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQganNvbiA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbigncmVhZGFibGUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHN0cmVhbS5yZWFkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gKz0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZSBhbmQgcmV0dXJuIHRoZSBtYW5pZmVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKEpTT04ucGFyc2UoanNvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgZGVmZXJyZWQucmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB6aXBGaWxlLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kTWFuaWZlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3IE5vdE1CRmlybXdhcmVFcnIoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRha2VzIHR3byB2ZXJzaW9ucyBhbmQgcmVjdXJzaXZlbHkgZGV0ZXJtaW5lcyB3aGljaCBpcyB0aGVcclxuICogbGF0ZXN0IG9mIHRoZSB0d28uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2MSAtIEEgdmVyc2lvbiBvZiBmaXJtd2FyZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gdjIgLSBBbm90aGVyIHZlcnNpb24gb2YgZmlybXdhcmVcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtuPTBdIC0gRGVwdGggb2YgdGhlIGl0ZXJhdGlvbi4gVXNlZCBmb3IgcmVjdXJzaW9uXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBsYXRlc3Qgb2YgdGhlIHR3byBwcm92aWRlZCB2ZXJzaW9uc1xyXG4gKi9cclxuZnVuY3Rpb24gX2xhdGVzdFZlcnNpb24odjEsIHYyLCBuKSB7XHJcbiAgICBpZiAoIW4pIG4gPSAwOyAvLyBhcHBhcmVudGx5IGRlZmF1bHQgcGFyYW1ldGVycyBkb24ndCB3b3JrP1xyXG5cclxuICAgIC8vIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgbiBpcyBvdXQgb2YgYm91bmRzLiBJZiB0aGF0IGhhcHBlbnMsXHJcbiAgICAvLyBpdCBtb3N0IGxpa2VseSBtZWFucyB0aGF0IHRoZSB0d28gdmVyc2lvbnMgYXJlIGVxdWFsLCBzb1xyXG4gICAgLy8gcmV0dXJuIGVpdGhlciBvbmUuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh2MS5tYW5pZmVzdC52ZXJzaW9uW25dID4gdjIubWFuaWZlc3QudmVyc2lvbltuXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdjE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodjIubWFuaWZlc3QudmVyc2lvbltuXSA+IHYxLm1hbmlmZXN0LnZlcnNpb25bbl0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHYyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9sYXRlc3RWZXJzaW9uKHYxLCB2MiwgbiArIDEpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiB2MTsgLy8gYm90aCBlcXVhbCwgZG9lc24ndCBtYXR0ZXJcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGaXJtd2FyZUxpc3RlbmVyO1xyXG4iXX0=
