"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GcodeParserStream = void 0;

const {
  Transform
} = require('stream');
/**
 * GCode ToolPath Parser
 *
 * ### How It Works:
 * It takes a gcode readable file nodejs stream and converts the readable
 * chunks into layer chunks. This task is executed in LayerChunksTransform
 *
 * Each layer chunks contains comments on the top portion follow by linear
 * move commands.
 *
 * ie. Layer Chunk:
 * """
 * ; Layer Section 0 (1)
 * ; Material 0
 * ; Lower Position  0
 * ; Upper Position  0.4
 * ; Thickness       0.4
 * ; Width           1.4
 * G1 X-3.55 Y-3.55 Z0.4 F15000; Travel Move
 * ..
 * G1 X-9.71 Y-9.71 Z0.4 E60.85656 F900; Inset
 * ..
 * G1 X0.16 Y-2.705 Z0.4 F1380; Travel Move
 * """
 *
 * Next, each layer chunk will get transformed by the GcodeCmdParserTransform
 * nodejs stream. It will parse each layer chunk for command moves,
 * lower/upper positions, and thickness/width values, then build out the
 * necessary object for the eagle 3D previewer.
 *
 * Each output GcodeCmdParser chunk will return:
 * {
 *    totalNrMoves: number, (all moves)
 *    totalNrHeadMoves: number, (moves that are just head moves)
 *    totalLength: number,
 *    movesModel: { type, [Move]}
 *    movesSupport: { type, [Move]}
 * }
 **/


class LayerChunksTranform extends Transform {
  constructor() {
    super({
      objectMode: true
    });
    /** regex expression to match the following:
     * case 1:
     * """
     * ; Layer Section 12 (13)
     * ...
     * G1 X12 Y12 Z123 F123; Infill
     * ...
     * G1 X42 Y42 Z123 F123; Infill
     * ; Layer Section 124 (14) <= *** Excludes this line ***
     *
     * -- OR --
     *
     * case 2:
     * """
     * ; Layer Section 123 (1234)
     * ...
     * G1 X12 Y12 Z123 F123; Travel Move
     * ...
     * G1 X42 Y42 Z123 F123; Travel Move
     * ; End of print  <= *** Excludes this line ***
     *
     * ### Explaination
     *
     * The regex will capture the top section comments [ie ; Layer Section 12 (13)] +
     * the linear move commands [ie. G1 X12 Y12 Z123; Infill] **UNTIL**
     * it hits another layer comment [; Layer Section 124 (14)] or
     * end of print comment [; End of print  ].
     *
     * With this regex we can split the buffer. The trailing end of the split will be
     * the new buffer that doesn't match the regex expression, meaning it didn't have
     * the end layer comment or end of print comment.
     **/

    this._delimiter = /(; Layer Section \d* \(\d*\) (\r\n?|\n)){1}(.|\n|\r\n)*?((?=; Layer Section \d* \(\d*\) (\r\n?|\n))|(?=; End of print (\r\n?|\n))){1}/g;
    this._encoding = 'utf8';
    this._buffer = '';
  }

  _transform(chunk, encoding, callback) {
    // convert input chunk encoding into output
    // encoding and append to internal buffer
    if (encoding === 'buffer') {
      this._buffer += chunk.toString(this._encoding);
    } else if (encoding === this._encoding) {
      this._buffer += chunk;
    } else {
      this._buffer += Buffer.from(chunk, encoding).toString(this._encoding);
    } // Check if chuck from file read stream contains matching pattern
    // based on the delimiter


    if (this._delimiter.test(chunk)) {
      // parse out the chunk for matching layer sections within
      const sections = this._buffer.match(this._delimiter); // any trailing end that doesn't match up, return to buffer
      // for the next file read stream chunk


      this._buffer = this._buffer.split(this._delimiter).pop(); // push out the layer sections

      sections.forEach(this.push, this);
    }

    callback();
  }

  _flush(callback) {
    callback(null, this._buffer);
  }

}

class GcodeCmdParserTransform extends Transform {
  constructor(buildVolume, totalRaftLayers) {
    super({
      objectMode: true
    });
    this._encoding = 'utf8';
    this._buffer = '';
    this._lowPosRegex = /; Lower Position.+\d+[.]?\d*.(\r\n?|\n)/gi;
    this._upPosRegex = /; Upper Position.+\d+[.\d+]?.+/gi;
    this._thicknessRegex = /; Thickness.+\d+[.]?\d*.(\r\n?|\n)/gi;
    this._widthRegex = /; Width.+\d+[.]?\d*.(\r\n?|\n)/gi;
    this._linearCmdRegex = /G1.+/gi;
    this._linearCmdTypeRegex = /(; )(.*)/gi;
    this._xPositionRegex = /X[-]?\d+[.]?\d+/;
    this._yPositionRegex = /Y[-]?\d+[.]?\d+/;
    this._zPositionRegex = /Z[-]?\d+[.]?\d+/;
    this._floatRegex = /[-]?\d+[.]?\d*/;
    this._xOffset = buildVolume.x / 2;
    this._yOffset = buildVolume.y / 2;
    this._totalRaftLayers = totalRaftLayers;
    this._inches_per_mm = 0.0393701;
    this._layerCount = 0;
    this._lowerPosition = 0;
    this._upperPosition = 0;
    this._thickness = 0;
    this._width = 0;
    this._totalMoves = 0;
    this._totalTravelMoves = 0;
    this._isTravel = true;
    this._isModel = true;
    this._movesModel = [];
    this._movesSupport = [];
  }

  _parseTag(tag, prevCmd, nextCmd) {
    switch (tag) {
      case 'Trailing Extrusion Move':
        this._isTravel = false;
        break;

      case 'Anchor':
      case 'Bridge':
      case 'Infill':
      case 'Inset':
      case 'Outline':
      case 'Spur':
        this._isTravel = false;
        this._isModel = true;
        break;

      case 'Support':
      case 'Purge':
      case 'Invalid Move':
        this._isTravel = false;
        this._isModel = false;
        break;

      case 'Backlash Compensation':
      case 'Connection':
      case 'Long Restart':
      case 'Long Retract':
      case 'Restart':
      case 'Retract':
      case 'Leaky Travel Move':
      case 'Travel Move':
        this._isTravel = true;
        break;

      default:
        if (this.logger) {
          this.logger.info(`tag not found: ${tag}`);
        }

    } // all raft layers are tagged as support


    if (this._layerCount <= this._totalRaftLayers) {
      this._isModel = false;
    } // Check previous and next command moves if either tags equals
    // "support". This should help with certain support features
    // not rendering because it lacks the prev cmd to generate preview.


    const prevTag = prevCmd && prevCmd.match(this._linearCmdTypeRegex)[0].replace(/; |\s/, '').trim();
    const nextTag = nextCmd && nextCmd.match(this._linearCmdTypeRegex)[0].replace(/; |\s/, '').trim();

    if (['Support', 'Purge', 'Invalid Move'].includes(prevTag) || ['Support', 'Purge', 'Invalid Move'].includes(nextTag)) {
      this._isModel = false;
    }
  }

  _parseCommentCommands() {
    // ; Lower Position  0
    //                   ^
    this._lowerPosition = parseFloat(this._buffer.match(this._lowPosRegex)[0].match(this._floatRegex)[0]) * this._inches_per_mm; // ; Upper Position  0
    //                   ^

    this._upperPosition = parseFloat(this._buffer.match(this._upPosRegex)[0].match(this._floatRegex)[0]) * this._inches_per_mm; // ; Thickness       0.4
    //                    ^

    this._thickness = parseFloat(this._buffer.match(this._thicknessRegex)[0].match(this._floatRegex)[0]) * this._inches_per_mm; // ; Width           1.4
    //                    ^

    this._width = parseFloat(this._buffer.match(this._widthRegex)[0].match(this._floatRegex)[0]) * this._inches_per_mm;
  }

  _parseTagsAndCoordinates(cmd) {
    // G1 X5.09 Y5.09 Z0.4 E11.59722 F900; Inset
    //     [x]   [y]   [z]                 [tag]
    const cmdTag = cmd.match(this._linearCmdTypeRegex)[0].replace(/; |\s/, '').trim();

    const x = (parseFloat(cmd.match(this._xPositionRegex)[0].match(this._floatRegex)[0]) + this._xOffset) * this._inches_per_mm;

    const y = (parseFloat(cmd.match(this._yPositionRegex)[0].match(this._floatRegex)[0]) + this._yOffset) * this._inches_per_mm;

    const z = parseFloat(cmd.match(this._zPositionRegex)[0].match(this._floatRegex)[0]) * this._inches_per_mm;

    return {
      x,
      y,
      z,
      cmdTag
    };
  }

  _parseMoveCommands() {
    // All 'G1 ...' are linear moves (https://marlinfw.org/docs/gcode/G000-G001.html)
    const linearMoves = this._buffer.match(this._linearCmdRegex);

    this._totalMoves = linearMoves.length;
    linearMoves.forEach((cmd, index) => {
      const {
        x,
        y,
        z,
        cmdTag
      } = this._parseTagsAndCoordinates(cmd); // Update this._isTravel & this._isModel based on tag


      this._parseTag(cmdTag, linearMoves[index - 1], linearMoves[index + 1]); // For all non-travel moves, area equals thickness * width;


      const area = this._isTravel ? 0 : this._thickness * this._width;

      if (this._isTravel) {
        this._totalTravelMoves += 1;
      } // All raft layers count as support layers


      if (this._isModel) {
        this._movesModel.push({
          x,
          y,
          z,
          area,
          index: index += 1
        });
      } else {
        this._movesSupport.push({
          x,
          y,
          z,
          area,
          index: index += 1
        });
      }
    });
  }

  _resetToDefault() {
    this._lowerPosition = 0;
    this._upperPosition = 0;
    this._thickness = 0;
    this._width = 0;
    this._totalMoves = 0;
    this._totalTravelMoves = 0;
    this._isTravel = true;
    this._isModel = true;
    this._movesModel = [];
    this._movesSupport = [];
  }

  _transform(chunk, encoding, callback) {
    // convert input encoding into output encoding
    // and update the buffer
    if (encoding === 'buffer') {
      this._buffer = chunk.toString(this._encoding);
    } else if (encoding === this._encoding) {
      this._buffer = chunk;
    } else {
      this._buffer = Buffer.from(chunk, encoding).toString(this._encoding);
    } // track layer count


    this._layerCount += 1; // parse the header portion of the buffer layer chunk

    this._parseCommentCommands(); // parse the linear commands of the buffer layer chunk


    this._parseMoveCommands(); // build out the payload


    this._layer = {
      totalNrMoves: this._totalMoves,
      totalNrHeadMoves: this._totalTravelMoves,
      movesMaterial: {
        '199': this._movesModel
      },
      movesSupport: {
        '201': this._movesSupport
      },
      upperPosition: this._upperPosition,
      lowerPosition: this._lowerPosition
    }; // push the payload

    this.push(this._layer); // reset certain values for the next incoming chunk

    this._resetToDefault();

    callback();
  }

  _flush(callback) {
    callback(null, this._buffer);
  }

}
/**
 * A function that pipes the two transform streams to a Gcode readable
 * file nodejs stream, then outputs the resulting stream out
 *
 * @param {stream} fileStream - A Gcode readable file nodejs stream
 * @param {obj} parsingParams - Obj that contains buildVolume & total
 *                              raft layers information
 **/


const GcodeParserStream = (fileStream, parsingParams) => {
  return fileStream.pipe(new LayerChunksTranform()).pipe(new GcodeCmdParserTransform(parsingParams.buildVolume, parsingParams.totalRaftLayers));
};

exports.GcodeParserStream = GcodeParserStream;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImdjb2RlX3Rvb2xwYXRoX3BhcnNlci5qcyJdLCJuYW1lcyI6WyJUcmFuc2Zvcm0iLCJyZXF1aXJlIiwiTGF5ZXJDaHVua3NUcmFuZm9ybSIsImNvbnN0cnVjdG9yIiwib2JqZWN0TW9kZSIsIl9kZWxpbWl0ZXIiLCJfZW5jb2RpbmciLCJfYnVmZmVyIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiZW5jb2RpbmciLCJjYWxsYmFjayIsInRvU3RyaW5nIiwiQnVmZmVyIiwiZnJvbSIsInRlc3QiLCJzZWN0aW9ucyIsIm1hdGNoIiwic3BsaXQiLCJwb3AiLCJmb3JFYWNoIiwicHVzaCIsIl9mbHVzaCIsIkdjb2RlQ21kUGFyc2VyVHJhbnNmb3JtIiwiYnVpbGRWb2x1bWUiLCJ0b3RhbFJhZnRMYXllcnMiLCJfbG93UG9zUmVnZXgiLCJfdXBQb3NSZWdleCIsIl90aGlja25lc3NSZWdleCIsIl93aWR0aFJlZ2V4IiwiX2xpbmVhckNtZFJlZ2V4IiwiX2xpbmVhckNtZFR5cGVSZWdleCIsIl94UG9zaXRpb25SZWdleCIsIl95UG9zaXRpb25SZWdleCIsIl96UG9zaXRpb25SZWdleCIsIl9mbG9hdFJlZ2V4IiwiX3hPZmZzZXQiLCJ4IiwiX3lPZmZzZXQiLCJ5IiwiX3RvdGFsUmFmdExheWVycyIsIl9pbmNoZXNfcGVyX21tIiwiX2xheWVyQ291bnQiLCJfbG93ZXJQb3NpdGlvbiIsIl91cHBlclBvc2l0aW9uIiwiX3RoaWNrbmVzcyIsIl93aWR0aCIsIl90b3RhbE1vdmVzIiwiX3RvdGFsVHJhdmVsTW92ZXMiLCJfaXNUcmF2ZWwiLCJfaXNNb2RlbCIsIl9tb3Zlc01vZGVsIiwiX21vdmVzU3VwcG9ydCIsIl9wYXJzZVRhZyIsInRhZyIsInByZXZDbWQiLCJuZXh0Q21kIiwibG9nZ2VyIiwiaW5mbyIsInByZXZUYWciLCJyZXBsYWNlIiwidHJpbSIsIm5leHRUYWciLCJpbmNsdWRlcyIsIl9wYXJzZUNvbW1lbnRDb21tYW5kcyIsInBhcnNlRmxvYXQiLCJfcGFyc2VUYWdzQW5kQ29vcmRpbmF0ZXMiLCJjbWQiLCJjbWRUYWciLCJ6IiwiX3BhcnNlTW92ZUNvbW1hbmRzIiwibGluZWFyTW92ZXMiLCJsZW5ndGgiLCJpbmRleCIsImFyZWEiLCJfcmVzZXRUb0RlZmF1bHQiLCJfbGF5ZXIiLCJ0b3RhbE5yTW92ZXMiLCJ0b3RhbE5ySGVhZE1vdmVzIiwibW92ZXNNYXRlcmlhbCIsIm1vdmVzU3VwcG9ydCIsInVwcGVyUG9zaXRpb24iLCJsb3dlclBvc2l0aW9uIiwiR2NvZGVQYXJzZXJTdHJlYW0iLCJmaWxlU3RyZWFtIiwicGFyc2luZ1BhcmFtcyIsInBpcGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxNQUFNO0FBQUVBLEVBQUFBO0FBQUYsSUFBZ0JDLE9BQU8sQ0FBQyxRQUFELENBQTdCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQSxNQUFNQyxtQkFBTixTQUFrQ0YsU0FBbEMsQ0FBNEM7QUFDeENHLEVBQUFBLFdBQVcsR0FBRztBQUNWLFVBQU07QUFBRUMsTUFBQUEsVUFBVSxFQUFFO0FBQWQsS0FBTjtBQUNBO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ1EsU0FBS0MsVUFBTCxHQUFrQix3SUFBbEI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLE1BQWpCO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLEVBQWY7QUFDSDs7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RSxLQUFLOUIsaUJBRmI7QUFHVitCLE1BQUFBLGFBQWEsRUFBRTtBQUFFLGVBQU8sS0FBSzVCO0FBQWQsT0FITDtBQUlWNkIsTUFBQUEsWUFBWSxFQUFFO0FBQUUsZUFBTyxLQUFLNUI7QUFBZCxPQUpKO0FBS1Y2QixNQUFBQSxhQUFhLEVBQUUsS0FBS3JDLGNBTFY7QUFNVnNDLE1BQUFBLGFBQWEsRUFBRSxLQUFLdkM7QUFOVixLQUFkLENBbEJrQyxDQTBCbEM7O0FBQ0EsU0FBS3RCLElBQUwsQ0FBVSxLQUFLdUQsTUFBZixFQTNCa0MsQ0E0QmxDOztBQUNBLFNBQUtELGVBQUw7O0FBRUFoRSxJQUFBQSxRQUFRO0FBQ1g7O0FBRURXLEVBQUFBLE1BQU0sQ0FBQ1gsUUFBRCxFQUFXO0FBQ2JBLElBQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU8sS0FBS0osT0FBWixDQUFSO0FBQ0g7O0FBOU4yQztBQWlPaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTTRFLGlCQUFpQixHQUFHLENBQUNDLFVBQUQsRUFBYUMsYUFBYixLQUErQjtBQUNyRCxTQUFPRCxVQUFVLENBQ1pFLElBREUsQ0FDRyxJQUFJcEYsbUJBQUosRUFESCxFQUVGb0YsSUFGRSxDQUVHLElBQUkvRCx1QkFBSixDQUE0QjhELGFBQWEsQ0FBQzdELFdBQTFDLEVBQXVENkQsYUFBYSxDQUFDNUQsZUFBckUsQ0FGSCxDQUFQO0FBR0gsQ0FKRCIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgVHJhbnNmb3JtIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcclxuXHJcbi8qKlxyXG4gKiBHQ29kZSBUb29sUGF0aCBQYXJzZXJcclxuICpcclxuICogIyMjIEhvdyBJdCBXb3JrczpcclxuICogSXQgdGFrZXMgYSBnY29kZSByZWFkYWJsZSBmaWxlIG5vZGVqcyBzdHJlYW0gYW5kIGNvbnZlcnRzIHRoZSByZWFkYWJsZVxyXG4gKiBjaHVua3MgaW50byBsYXllciBjaHVua3MuIFRoaXMgdGFzayBpcyBleGVjdXRlZCBpbiBMYXllckNodW5rc1RyYW5zZm9ybVxyXG4gKlxyXG4gKiBFYWNoIGxheWVyIGNodW5rcyBjb250YWlucyBjb21tZW50cyBvbiB0aGUgdG9wIHBvcnRpb24gZm9sbG93IGJ5IGxpbmVhclxyXG4gKiBtb3ZlIGNvbW1hbmRzLlxyXG4gKlxyXG4gKiBpZS4gTGF5ZXIgQ2h1bms6XHJcbiAqIFwiXCJcIlxyXG4gKiA7IExheWVyIFNlY3Rpb24gMCAoMSlcclxuICogOyBNYXRlcmlhbCAwXHJcbiAqIDsgTG93ZXIgUG9zaXRpb24gIDBcclxuICogOyBVcHBlciBQb3NpdGlvbiAgMC40XHJcbiAqIDsgVGhpY2tuZXNzICAgICAgIDAuNFxyXG4gKiA7IFdpZHRoICAgICAgICAgICAxLjRcclxuICogRzEgWC0zLjU1IFktMy41NSBaMC40IEYxNTAwMDsgVHJhdmVsIE1vdmVcclxuICogLi5cclxuICogRzEgWC05LjcxIFktOS43MSBaMC40IEU2MC44NTY1NiBGOTAwOyBJbnNldFxyXG4gKiAuLlxyXG4gKiBHMSBYMC4xNiBZLTIuNzA1IFowLjQgRjEzODA7IFRyYXZlbCBNb3ZlXHJcbiAqIFwiXCJcIlxyXG4gKlxyXG4gKiBOZXh0LCBlYWNoIGxheWVyIGNodW5rIHdpbGwgZ2V0IHRyYW5zZm9ybWVkIGJ5IHRoZSBHY29kZUNtZFBhcnNlclRyYW5zZm9ybVxyXG4gKiBub2RlanMgc3RyZWFtLiBJdCB3aWxsIHBhcnNlIGVhY2ggbGF5ZXIgY2h1bmsgZm9yIGNvbW1hbmQgbW92ZXMsXHJcbiAqIGxvd2VyL3VwcGVyIHBvc2l0aW9ucywgYW5kIHRoaWNrbmVzcy93aWR0aCB2YWx1ZXMsIHRoZW4gYnVpbGQgb3V0IHRoZVxyXG4gKiBuZWNlc3Nhcnkgb2JqZWN0IGZvciB0aGUgZWFnbGUgM0QgcHJldmlld2VyLlxyXG4gKlxyXG4gKiBFYWNoIG91dHB1dCBHY29kZUNtZFBhcnNlciBjaHVuayB3aWxsIHJldHVybjpcclxuICoge1xyXG4gKiAgICB0b3RhbE5yTW92ZXM6IG51bWJlciwgKGFsbCBtb3ZlcylcclxuICogICAgdG90YWxOckhlYWRNb3ZlczogbnVtYmVyLCAobW92ZXMgdGhhdCBhcmUganVzdCBoZWFkIG1vdmVzKVxyXG4gKiAgICB0b3RhbExlbmd0aDogbnVtYmVyLFxyXG4gKiAgICBtb3Zlc01vZGVsOiB7IHR5cGUsIFtNb3ZlXX1cclxuICogICAgbW92ZXNTdXBwb3J0OiB7IHR5cGUsIFtNb3ZlXX1cclxuICogfVxyXG4gKiovXHJcblxyXG5jbGFzcyBMYXllckNodW5rc1RyYW5mb3JtIGV4dGVuZHMgVHJhbnNmb3JtIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcclxuICAgICAgICAvKiogcmVnZXggZXhwcmVzc2lvbiB0byBtYXRjaCB0aGUgZm9sbG93aW5nOlxyXG4gICAgICAgICAqIGNhc2UgMTpcclxuICAgICAgICAgKiBcIlwiXCJcclxuICAgICAgICAgKiA7IExheWVyIFNlY3Rpb24gMTIgKDEzKVxyXG4gICAgICAgICAqIC4uLlxyXG4gICAgICAgICAqIEcxIFgxMiBZMTIgWjEyMyBGMTIzOyBJbmZpbGxcclxuICAgICAgICAgKiAuLi5cclxuICAgICAgICAgKiBHMSBYNDIgWTQyIFoxMjMgRjEyMzsgSW5maWxsXHJcbiAgICAgICAgICogOyBMYXllciBTZWN0aW9uIDEyNCAoMTQpIDw9ICoqKiBFeGNsdWRlcyB0aGlzIGxpbmUgKioqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAtLSBPUiAtLVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogY2FzZSAyOlxyXG4gICAgICAgICAqIFwiXCJcIlxyXG4gICAgICAgICAqIDsgTGF5ZXIgU2VjdGlvbiAxMjMgKDEyMzQpXHJcbiAgICAgICAgICogLi4uXHJcbiAgICAgICAgICogRzEgWDEyIFkxMiBaMTIzIEYxMjM7IFRyYXZlbCBNb3ZlXHJcbiAgICAgICAgICogLi4uXHJcbiAgICAgICAgICogRzEgWDQyIFk0MiBaMTIzIEYxMjM7IFRyYXZlbCBNb3ZlXHJcbiAgICAgICAgICogOyBFbmQgb2YgcHJpbnQgIDw9ICoqKiBFeGNsdWRlcyB0aGlzIGxpbmUgKioqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAjIyMgRXhwbGFpbmF0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgcmVnZXggd2lsbCBjYXB0dXJlIHRoZSB0b3Agc2VjdGlvbiBjb21tZW50cyBbaWUgOyBMYXllciBTZWN0aW9uIDEyICgxMyldICtcclxuICAgICAgICAgKiB0aGUgbGluZWFyIG1vdmUgY29tbWFuZHMgW2llLiBHMSBYMTIgWTEyIFoxMjM7IEluZmlsbF0gKipVTlRJTCoqXHJcbiAgICAgICAgICogaXQgaGl0cyBhbm90aGVyIGxheWVyIGNvbW1lbnQgWzsgTGF5ZXIgU2VjdGlvbiAxMjQgKDE0KV0gb3JcclxuICAgICAgICAgKiBlbmQgb2YgcHJpbnQgY29tbWVudCBbOyBFbmQgb2YgcHJpbnQgIF0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaXRoIHRoaXMgcmVnZXggd2UgY2FuIHNwbGl0IHRoZSBidWZmZXIuIFRoZSB0cmFpbGluZyBlbmQgb2YgdGhlIHNwbGl0IHdpbGwgYmVcclxuICAgICAgICAgKiB0aGUgbmV3IGJ1ZmZlciB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHJlZ2V4IGV4cHJlc3Npb24sIG1lYW5pbmcgaXQgZGlkbid0IGhhdmVcclxuICAgICAgICAgKiB0aGUgZW5kIGxheWVyIGNvbW1lbnQgb3IgZW5kIG9mIHByaW50IGNvbW1lbnQuXHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIHRoaXMuX2RlbGltaXRlciA9IC8oOyBMYXllciBTZWN0aW9uIFxcZCogXFwoXFxkKlxcKSAoXFxyXFxuP3xcXG4pKXsxfSgufFxcbnxcXHJcXG4pKj8oKD89OyBMYXllciBTZWN0aW9uIFxcZCogXFwoXFxkKlxcKSAoXFxyXFxuP3xcXG4pKXwoPz07IEVuZCBvZiBwcmludCAoXFxyXFxuP3xcXG4pKSl7MX0vZztcclxuICAgICAgICB0aGlzLl9lbmNvZGluZyA9ICd1dGY4JztcclxuICAgICAgICB0aGlzLl9idWZmZXIgPSAnJztcclxuICAgIH1cclxuXHJcbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBjb252ZXJ0IGlucHV0IGNodW5rIGVuY29kaW5nIGludG8gb3V0cHV0XHJcbiAgICAgICAgLy8gZW5jb2RpbmcgYW5kIGFwcGVuZCB0byBpbnRlcm5hbCBidWZmZXJcclxuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlciArPSBjaHVuay50b1N0cmluZyh0aGlzLl9lbmNvZGluZyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbmNvZGluZyA9PT0gdGhpcy5fZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyICs9IGNodW5rO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlciArPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpLnRvU3RyaW5nKHRoaXMuX2VuY29kaW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGNodWNrIGZyb20gZmlsZSByZWFkIHN0cmVhbSBjb250YWlucyBtYXRjaGluZyBwYXR0ZXJuXHJcbiAgICAgICAgLy8gYmFzZWQgb24gdGhlIGRlbGltaXRlclxyXG4gICAgICAgIGlmICh0aGlzLl9kZWxpbWl0ZXIudGVzdChjaHVuaykpIHtcclxuICAgICAgICAgICAgLy8gcGFyc2Ugb3V0IHRoZSBjaHVuayBmb3IgbWF0Y2hpbmcgbGF5ZXIgc2VjdGlvbnMgd2l0aGluXHJcbiAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25zID0gdGhpcy5fYnVmZmVyLm1hdGNoKHRoaXMuX2RlbGltaXRlcik7XHJcbiAgICAgICAgICAgIC8vIGFueSB0cmFpbGluZyBlbmQgdGhhdCBkb2Vzbid0IG1hdGNoIHVwLCByZXR1cm4gdG8gYnVmZmVyXHJcbiAgICAgICAgICAgIC8vIGZvciB0aGUgbmV4dCBmaWxlIHJlYWQgc3RyZWFtIGNodW5rXHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IHRoaXMuX2J1ZmZlci5zcGxpdCh0aGlzLl9kZWxpbWl0ZXIpLnBvcCgpO1xyXG4gICAgICAgICAgICAvLyBwdXNoIG91dCB0aGUgbGF5ZXIgc2VjdGlvbnNcclxuICAgICAgICAgICAgc2VjdGlvbnMuZm9yRWFjaCh0aGlzLnB1c2gsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfVxyXG5cclxuICAgIF9mbHVzaChjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMuX2J1ZmZlcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIEdjb2RlQ21kUGFyc2VyVHJhbnNmb3JtIGV4dGVuZHMgVHJhbnNmb3JtIHtcclxuICAgIGNvbnN0cnVjdG9yKGJ1aWxkVm9sdW1lLCB0b3RhbFJhZnRMYXllcnMpIHtcclxuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSAndXRmOCc7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gJyc7XHJcblxyXG4gICAgICAgIHRoaXMuX2xvd1Bvc1JlZ2V4ID0gLzsgTG93ZXIgUG9zaXRpb24uK1xcZCtbLl0/XFxkKi4oXFxyXFxuP3xcXG4pL2dpO1xyXG4gICAgICAgIHRoaXMuX3VwUG9zUmVnZXggPSAvOyBVcHBlciBQb3NpdGlvbi4rXFxkK1suXFxkK10/LisvZ2k7XHJcbiAgICAgICAgdGhpcy5fdGhpY2tuZXNzUmVnZXggPSAvOyBUaGlja25lc3MuK1xcZCtbLl0/XFxkKi4oXFxyXFxuP3xcXG4pL2dpO1xyXG4gICAgICAgIHRoaXMuX3dpZHRoUmVnZXggPSAvOyBXaWR0aC4rXFxkK1suXT9cXGQqLihcXHJcXG4/fFxcbikvZ2k7XHJcbiAgICAgICAgdGhpcy5fbGluZWFyQ21kUmVnZXggPSAvRzEuKy9naTtcclxuICAgICAgICB0aGlzLl9saW5lYXJDbWRUeXBlUmVnZXggPSAvKDsgKSguKikvZ2k7XHJcbiAgICAgICAgdGhpcy5feFBvc2l0aW9uUmVnZXggPSAvWFstXT9cXGQrWy5dP1xcZCsvO1xyXG4gICAgICAgIHRoaXMuX3lQb3NpdGlvblJlZ2V4ID0gL1lbLV0/XFxkK1suXT9cXGQrLztcclxuICAgICAgICB0aGlzLl96UG9zaXRpb25SZWdleCA9IC9aWy1dP1xcZCtbLl0/XFxkKy87XHJcbiAgICAgICAgdGhpcy5fZmxvYXRSZWdleCA9IC9bLV0/XFxkK1suXT9cXGQqLztcclxuXHJcbiAgICAgICAgdGhpcy5feE9mZnNldCA9IGJ1aWxkVm9sdW1lLnggLyAyO1xyXG4gICAgICAgIHRoaXMuX3lPZmZzZXQgPSBidWlsZFZvbHVtZS55IC8gMjtcclxuICAgICAgICB0aGlzLl90b3RhbFJhZnRMYXllcnMgPSB0b3RhbFJhZnRMYXllcnM7XHJcbiAgICAgICAgdGhpcy5faW5jaGVzX3Blcl9tbSA9IDAuMDM5MzcwMTtcclxuICAgICAgICB0aGlzLl9sYXllckNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5fbG93ZXJQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fdXBwZXJQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fdGhpY2tuZXNzID0gMDtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fdG90YWxNb3ZlcyA9IDA7XHJcbiAgICAgICAgdGhpcy5fdG90YWxUcmF2ZWxNb3ZlcyA9IDA7XHJcbiAgICAgICAgdGhpcy5faXNUcmF2ZWwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2lzTW9kZWwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX21vdmVzTW9kZWwgPSBbXTtcclxuICAgICAgICB0aGlzLl9tb3Zlc1N1cHBvcnQgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBfcGFyc2VUYWcodGFnLCBwcmV2Q21kLCBuZXh0Q21kKSB7XHJcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcclxuICAgICAgICAgICAgY2FzZSAnVHJhaWxpbmcgRXh0cnVzaW9uIE1vdmUnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNUcmF2ZWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdBbmNob3InOlxyXG4gICAgICAgICAgICBjYXNlICdCcmlkZ2UnOlxyXG4gICAgICAgICAgICBjYXNlICdJbmZpbGwnOlxyXG4gICAgICAgICAgICBjYXNlICdJbnNldCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ091dGxpbmUnOlxyXG4gICAgICAgICAgICBjYXNlICdTcHVyJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzVHJhdmVsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc01vZGVsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdTdXBwb3J0JzpcclxuICAgICAgICAgICAgY2FzZSAnUHVyZ2UnOlxyXG4gICAgICAgICAgICBjYXNlICdJbnZhbGlkIE1vdmUnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNUcmF2ZWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzTW9kZWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdCYWNrbGFzaCBDb21wZW5zYXRpb24nOlxyXG4gICAgICAgICAgICBjYXNlICdDb25uZWN0aW9uJzpcclxuICAgICAgICAgICAgY2FzZSAnTG9uZyBSZXN0YXJ0JzpcclxuICAgICAgICAgICAgY2FzZSAnTG9uZyBSZXRyYWN0JzpcclxuICAgICAgICAgICAgY2FzZSAnUmVzdGFydCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1JldHJhY3QnOlxyXG4gICAgICAgICAgICBjYXNlICdMZWFreSBUcmF2ZWwgTW92ZSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1RyYXZlbCBNb3ZlJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzVHJhdmVsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9nZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgdGFnIG5vdCBmb3VuZDogJHt0YWd9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhbGwgcmFmdCBsYXllcnMgYXJlIHRhZ2dlZCBhcyBzdXBwb3J0XHJcbiAgICAgICAgaWYgKHRoaXMuX2xheWVyQ291bnQgPD0gdGhpcy5fdG90YWxSYWZ0TGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzTW9kZWwgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHByZXZpb3VzIGFuZCBuZXh0IGNvbW1hbmQgbW92ZXMgaWYgZWl0aGVyIHRhZ3MgZXF1YWxzXHJcbiAgICAgICAgLy8gXCJzdXBwb3J0XCIuIFRoaXMgc2hvdWxkIGhlbHAgd2l0aCBjZXJ0YWluIHN1cHBvcnQgZmVhdHVyZXNcclxuICAgICAgICAvLyBub3QgcmVuZGVyaW5nIGJlY2F1c2UgaXQgbGFja3MgdGhlIHByZXYgY21kIHRvIGdlbmVyYXRlIHByZXZpZXcuXHJcbiAgICAgICAgY29uc3QgcHJldlRhZyA9XHJcbiAgICAgICAgICAgIHByZXZDbWQgJiZcclxuICAgICAgICAgICAgcHJldkNtZFxyXG4gICAgICAgICAgICAgICAgLm1hdGNoKHRoaXMuX2xpbmVhckNtZFR5cGVSZWdleClbMF1cclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC87IHxcXHMvLCAnJylcclxuICAgICAgICAgICAgICAgIC50cmltKCk7XHJcbiAgICAgICAgY29uc3QgbmV4dFRhZyA9XHJcbiAgICAgICAgICAgIG5leHRDbWQgJiZcclxuICAgICAgICAgICAgbmV4dENtZFxyXG4gICAgICAgICAgICAgICAgLm1hdGNoKHRoaXMuX2xpbmVhckNtZFR5cGVSZWdleClbMF1cclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC87IHxcXHMvLCAnJylcclxuICAgICAgICAgICAgICAgIC50cmltKCk7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBbJ1N1cHBvcnQnLCAnUHVyZ2UnLCAnSW52YWxpZCBNb3ZlJ10uaW5jbHVkZXMocHJldlRhZykgfHxcclxuICAgICAgICAgICAgWydTdXBwb3J0JywgJ1B1cmdlJywgJ0ludmFsaWQgTW92ZSddLmluY2x1ZGVzKG5leHRUYWcpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzTW9kZWwgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX3BhcnNlQ29tbWVudENvbW1hbmRzKCkge1xyXG4gICAgICAgIC8vIDsgTG93ZXIgUG9zaXRpb24gIDBcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICBeXHJcbiAgICAgICAgdGhpcy5fbG93ZXJQb3NpdGlvbiA9XHJcbiAgICAgICAgICAgIHBhcnNlRmxvYXQodGhpcy5fYnVmZmVyLm1hdGNoKHRoaXMuX2xvd1Bvc1JlZ2V4KVswXS5tYXRjaCh0aGlzLl9mbG9hdFJlZ2V4KVswXSkgKiB0aGlzLl9pbmNoZXNfcGVyX21tO1xyXG4gICAgICAgIC8vIDsgVXBwZXIgUG9zaXRpb24gIDBcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICBeXHJcbiAgICAgICAgdGhpcy5fdXBwZXJQb3NpdGlvbiA9XHJcbiAgICAgICAgICAgIHBhcnNlRmxvYXQodGhpcy5fYnVmZmVyLm1hdGNoKHRoaXMuX3VwUG9zUmVnZXgpWzBdLm1hdGNoKHRoaXMuX2Zsb2F0UmVnZXgpWzBdKSAqIHRoaXMuX2luY2hlc19wZXJfbW07XHJcbiAgICAgICAgLy8gOyBUaGlja25lc3MgICAgICAgMC40XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIF5cclxuICAgICAgICB0aGlzLl90aGlja25lc3MgPVxyXG4gICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMuX2J1ZmZlci5tYXRjaCh0aGlzLl90aGlja25lc3NSZWdleClbMF0ubWF0Y2godGhpcy5fZmxvYXRSZWdleClbMF0pICogdGhpcy5faW5jaGVzX3Blcl9tbTtcclxuICAgICAgICAvLyA7IFdpZHRoICAgICAgICAgICAxLjRcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgXlxyXG4gICAgICAgIHRoaXMuX3dpZHRoID1cclxuICAgICAgICAgICAgcGFyc2VGbG9hdCh0aGlzLl9idWZmZXIubWF0Y2godGhpcy5fd2lkdGhSZWdleClbMF0ubWF0Y2godGhpcy5fZmxvYXRSZWdleClbMF0pICogdGhpcy5faW5jaGVzX3Blcl9tbTtcclxuICAgIH1cclxuXHJcbiAgICBfcGFyc2VUYWdzQW5kQ29vcmRpbmF0ZXMoY21kKSB7XHJcbiAgICAgICAgLy8gRzEgWDUuMDkgWTUuMDkgWjAuNCBFMTEuNTk3MjIgRjkwMDsgSW5zZXRcclxuICAgICAgICAvLyAgICAgW3hdICAgW3ldICAgW3pdICAgICAgICAgICAgICAgICBbdGFnXVxyXG4gICAgICAgIGNvbnN0IGNtZFRhZyA9IGNtZFxyXG4gICAgICAgICAgICAubWF0Y2godGhpcy5fbGluZWFyQ21kVHlwZVJlZ2V4KVswXVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvOyB8XFxzLywgJycpXHJcbiAgICAgICAgICAgIC50cmltKCk7XHJcbiAgICAgICAgY29uc3QgeCA9XHJcbiAgICAgICAgICAgIChwYXJzZUZsb2F0KGNtZC5tYXRjaCh0aGlzLl94UG9zaXRpb25SZWdleClbMF0ubWF0Y2godGhpcy5fZmxvYXRSZWdleClbMF0pICsgdGhpcy5feE9mZnNldCkgKlxyXG4gICAgICAgICAgICB0aGlzLl9pbmNoZXNfcGVyX21tO1xyXG4gICAgICAgIGNvbnN0IHkgPVxyXG4gICAgICAgICAgICAocGFyc2VGbG9hdChjbWQubWF0Y2godGhpcy5feVBvc2l0aW9uUmVnZXgpWzBdLm1hdGNoKHRoaXMuX2Zsb2F0UmVnZXgpWzBdKSArIHRoaXMuX3lPZmZzZXQpICpcclxuICAgICAgICAgICAgdGhpcy5faW5jaGVzX3Blcl9tbTtcclxuICAgICAgICBjb25zdCB6ID0gcGFyc2VGbG9hdChjbWQubWF0Y2godGhpcy5felBvc2l0aW9uUmVnZXgpWzBdLm1hdGNoKHRoaXMuX2Zsb2F0UmVnZXgpWzBdKSAqIHRoaXMuX2luY2hlc19wZXJfbW07XHJcblxyXG4gICAgICAgIHJldHVybiB7IHgsIHksIHosIGNtZFRhZyB9O1xyXG4gICAgfVxyXG5cclxuICAgIF9wYXJzZU1vdmVDb21tYW5kcygpIHtcclxuICAgICAgICAvLyBBbGwgJ0cxIC4uLicgYXJlIGxpbmVhciBtb3ZlcyAoaHR0cHM6Ly9tYXJsaW5mdy5vcmcvZG9jcy9nY29kZS9HMDAwLUcwMDEuaHRtbClcclxuICAgICAgICBjb25zdCBsaW5lYXJNb3ZlcyA9IHRoaXMuX2J1ZmZlci5tYXRjaCh0aGlzLl9saW5lYXJDbWRSZWdleCk7XHJcbiAgICAgICAgdGhpcy5fdG90YWxNb3ZlcyA9IGxpbmVhck1vdmVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgbGluZWFyTW92ZXMuZm9yRWFjaCgoY21kLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHgsIHksIHosIGNtZFRhZyB9ID0gdGhpcy5fcGFyc2VUYWdzQW5kQ29vcmRpbmF0ZXMoY21kKTtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoaXMuX2lzVHJhdmVsICYgdGhpcy5faXNNb2RlbCBiYXNlZCBvbiB0YWdcclxuICAgICAgICAgICAgdGhpcy5fcGFyc2VUYWcoY21kVGFnLCBsaW5lYXJNb3Zlc1tpbmRleCAtIDFdLCBsaW5lYXJNb3Zlc1tpbmRleCArIDFdKTtcclxuICAgICAgICAgICAgLy8gRm9yIGFsbCBub24tdHJhdmVsIG1vdmVzLCBhcmVhIGVxdWFscyB0aGlja25lc3MgKiB3aWR0aDtcclxuICAgICAgICAgICAgY29uc3QgYXJlYSA9IHRoaXMuX2lzVHJhdmVsID8gMCA6IHRoaXMuX3RoaWNrbmVzcyAqIHRoaXMuX3dpZHRoO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVHJhdmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbFRyYXZlbE1vdmVzICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFsbCByYWZ0IGxheWVycyBjb3VudCBhcyBzdXBwb3J0IGxheWVyc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNNb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZXNNb2RlbC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgICAgICAgICAgeixcclxuICAgICAgICAgICAgICAgICAgICBhcmVhLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiAoaW5kZXggKz0gMSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVzU3VwcG9ydC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgICAgICAgICAgeixcclxuICAgICAgICAgICAgICAgICAgICBhcmVhLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiAoaW5kZXggKz0gMSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZXNldFRvRGVmYXVsdCgpIHtcclxuICAgICAgICB0aGlzLl9sb3dlclBvc2l0aW9uID0gMDtcclxuICAgICAgICB0aGlzLl91cHBlclBvc2l0aW9uID0gMDtcclxuICAgICAgICB0aGlzLl90aGlja25lc3MgPSAwO1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gMDtcclxuICAgICAgICB0aGlzLl90b3RhbE1vdmVzID0gMDtcclxuICAgICAgICB0aGlzLl90b3RhbFRyYXZlbE1vdmVzID0gMDtcclxuICAgICAgICB0aGlzLl9pc1RyYXZlbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5faXNNb2RlbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fbW92ZXNNb2RlbCA9IFtdO1xyXG4gICAgICAgIHRoaXMuX21vdmVzU3VwcG9ydCA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIGNvbnZlcnQgaW5wdXQgZW5jb2RpbmcgaW50byBvdXRwdXQgZW5jb2RpbmdcclxuICAgICAgICAvLyBhbmQgdXBkYXRlIHRoZSBidWZmZXJcclxuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IGNodW5rLnRvU3RyaW5nKHRoaXMuX2VuY29kaW5nKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVuY29kaW5nID09PSB0aGlzLl9lbmNvZGluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBjaHVuaztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpLnRvU3RyaW5nKHRoaXMuX2VuY29kaW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRyYWNrIGxheWVyIGNvdW50XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJDb3VudCArPSAxO1xyXG4gICAgICAgIC8vIHBhcnNlIHRoZSBoZWFkZXIgcG9ydGlvbiBvZiB0aGUgYnVmZmVyIGxheWVyIGNodW5rXHJcbiAgICAgICAgdGhpcy5fcGFyc2VDb21tZW50Q29tbWFuZHMoKTtcclxuICAgICAgICAvLyBwYXJzZSB0aGUgbGluZWFyIGNvbW1hbmRzIG9mIHRoZSBidWZmZXIgbGF5ZXIgY2h1bmtcclxuICAgICAgICB0aGlzLl9wYXJzZU1vdmVDb21tYW5kcygpO1xyXG4gICAgICAgIC8vIGJ1aWxkIG91dCB0aGUgcGF5bG9hZFxyXG4gICAgICAgIHRoaXMuX2xheWVyID0ge1xyXG4gICAgICAgICAgICB0b3RhbE5yTW92ZXM6IHRoaXMuX3RvdGFsTW92ZXMsXHJcbiAgICAgICAgICAgIHRvdGFsTnJIZWFkTW92ZXM6IHRoaXMuX3RvdGFsVHJhdmVsTW92ZXMsXHJcbiAgICAgICAgICAgIG1vdmVzTWF0ZXJpYWw6IHsgJzE5OSc6IHRoaXMuX21vdmVzTW9kZWwgfSxcclxuICAgICAgICAgICAgbW92ZXNTdXBwb3J0OiB7ICcyMDEnOiB0aGlzLl9tb3Zlc1N1cHBvcnQgfSxcclxuICAgICAgICAgICAgdXBwZXJQb3NpdGlvbjogdGhpcy5fdXBwZXJQb3NpdGlvbixcclxuICAgICAgICAgICAgbG93ZXJQb3NpdGlvbjogdGhpcy5fbG93ZXJQb3NpdGlvbixcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHB1c2ggdGhlIHBheWxvYWRcclxuICAgICAgICB0aGlzLnB1c2godGhpcy5fbGF5ZXIpO1xyXG4gICAgICAgIC8vIHJlc2V0IGNlcnRhaW4gdmFsdWVzIGZvciB0aGUgbmV4dCBpbmNvbWluZyBjaHVua1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0VG9EZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdGhpcy5fYnVmZmVyKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgZnVuY3Rpb24gdGhhdCBwaXBlcyB0aGUgdHdvIHRyYW5zZm9ybSBzdHJlYW1zIHRvIGEgR2NvZGUgcmVhZGFibGVcclxuICogZmlsZSBub2RlanMgc3RyZWFtLCB0aGVuIG91dHB1dHMgdGhlIHJlc3VsdGluZyBzdHJlYW0gb3V0XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyZWFtfSBmaWxlU3RyZWFtIC0gQSBHY29kZSByZWFkYWJsZSBmaWxlIG5vZGVqcyBzdHJlYW1cclxuICogQHBhcmFtIHtvYmp9IHBhcnNpbmdQYXJhbXMgLSBPYmogdGhhdCBjb250YWlucyBidWlsZFZvbHVtZSAmIHRvdGFsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFmdCBsYXllcnMgaW5mb3JtYXRpb25cclxuICoqL1xyXG5jb25zdCBHY29kZVBhcnNlclN0cmVhbSA9IChmaWxlU3RyZWFtLCBwYXJzaW5nUGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gZmlsZVN0cmVhbVxyXG4gICAgICAgIC5waXBlKG5ldyBMYXllckNodW5rc1RyYW5mb3JtKCkpXHJcbiAgICAgICAgLnBpcGUobmV3IEdjb2RlQ21kUGFyc2VyVHJhbnNmb3JtKHBhcnNpbmdQYXJhbXMuYnVpbGRWb2x1bWUsIHBhcnNpbmdQYXJhbXMudG90YWxSYWZ0TGF5ZXJzKSk7XHJcbn07XHJcblxyXG5leHBvcnQgeyBHY29kZVBhcnNlclN0cmVhbSB9O1xyXG4iXX0=
