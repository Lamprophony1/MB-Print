'use strict';

const fs = require('fs-extra');

const q = require('q');

const path = require('path');

const ImportProvider = require('eagle-print/services/providers/importProvider');

const ImportableFormat = require('eagle-print/services/importService').ImportableFormat;

const Toolpath = require('eagle-print/model/toolpath').default;

const MBToolpathProvider = require('./mb_toolpath_parser');

const PrinterGenderString = require('./constants').PrinterGenderString;

class MbImporter extends ImportProvider {
  constructor() {
    super(new ImportableFormat(['makerbot'], 'Makerbot Files (*.makerbot)'), Toolpath);
  }

  importFromData(data, sourceUrl) {
    const loader = new MBToolpathProvider();

    const readFunc = filepath => {
      return q.nfapply(fs.readFile, [filepath]);
    };

    return loader.unzipToolpath(readFunc, sourceUrl).then(parsedData => {
      const idToolpath = `toolpath:${sourceUrl}`; // TODO:  What is the significance of key `targetPrinterModel`?
      // Changed to using the field to pass slicedBotType instead of botType in order
      // to do bot_type check before print.
      //
      // Previous code below.
      // `let botType = 'Replicator 5th Gen';`

      const slicedBotType = PrinterGenderString.get(parsedData.metaData.bot_type); // TODO: Unsure what toolpath.fileSize provides.
      // HACK: setting as 1 to bypass for now.

      const fileSize = 1;
      const toolpath = new Toolpath({
        path: sourceUrl,
        name: path.basename(sourceUrl),
        fileSize,
        targetPrinterModel: slicedBotType,
        targetPrinterVendor: 'MakerBot',
        extraInfo: 'more info!',
        parser: idToolpath
      });
      return {
        toolpath,
        parsedData
      };
    });
  }

}

module.exports = MbImporter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1iSW1wb3J0ZXIuanMiXSwibmFtZXMiOlsiZnMiLCJyZXF1aXJlIiwicSIsInBhdGgiLCJJbXBvcnRQcm92aWRlciIsIkltcG9ydGFibGVGb3JtYXQiLCJUb29scGF0aCIsImRlZmF1bHQiLCJNQlRvb2xwYXRoUHJvdmlkZXIiLCJQcmludGVyR2VuZGVyU3RyaW5nIiwiTWJJbXBvcnRlciIsImNvbnN0cnVjdG9yIiwiaW1wb3J0RnJvbURhdGEiLCJkYXRhIiwic291cmNlVXJsIiwibG9hZGVyIiwicmVhZEZ1bmMiLCJmaWxlcGF0aCIsIm5mYXBwbHkiLCJyZWFkRmlsZSIsInVuemlwVG9vbHBhdGgiLCJ0aGVuIiwicGFyc2VkRGF0YSIsImlkVG9vbHBhdGgiLCJzbGljZWRCb3RUeXBlIiwiZ2V0IiwibWV0YURhdGEiLCJib3RfdHlwZSIsImZpbGVTaXplIiwidG9vbHBhdGgiLCJuYW1lIiwiYmFzZW5hbWUiLCJ0YXJnZXRQcmludGVyTW9kZWwiLCJ0YXJnZXRQcmludGVyVmVuZG9yIiwiZXh0cmFJbmZvIiwicGFyc2VyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsTUFBTUEsRUFBRSxHQUFHQyxPQUFPLENBQUMsVUFBRCxDQUFsQjs7QUFDQSxNQUFNQyxDQUFDLEdBQUdELE9BQU8sQ0FBQyxHQUFELENBQWpCOztBQUNBLE1BQU1FLElBQUksR0FBR0YsT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsTUFBTUcsY0FBYyxHQUFHSCxPQUFPLENBQUMsK0NBQUQsQ0FBOUI7O0FBQ0EsTUFBTUksZ0JBQWdCLEdBQUdKLE9BQU8sQ0FBQyxvQ0FBRCxDQUFQLENBQThDSSxnQkFBdkU7O0FBQ0EsTUFBTUMsUUFBUSxHQUFHTCxPQUFPLENBQUMsNEJBQUQsQ0FBUCxDQUFzQ00sT0FBdkQ7O0FBRUEsTUFBTUMsa0JBQWtCLEdBQUdQLE9BQU8sQ0FBQyxzQkFBRCxDQUFsQzs7QUFDQSxNQUFNUSxtQkFBbUIsR0FBR1IsT0FBTyxDQUFDLGFBQUQsQ0FBUCxDQUF1QlEsbUJBQW5EOztBQUVBLE1BQU1DLFVBQU4sU0FBeUJOLGNBQXpCLENBQXdDO0FBQ3BDTyxFQUFBQSxXQUFXLEdBQUc7QUFDVixVQUFNLElBQUlOLGdCQUFKLENBQXFCLENBQUMsVUFBRCxDQUFyQixFQUFtQyw2QkFBbkMsQ0FBTixFQUF5RUMsUUFBekU7QUFDSDs7QUFFRE0sRUFBQUEsY0FBYyxDQUFDQyxJQUFELEVBQU9DLFNBQVAsRUFBa0I7QUFDNUIsVUFBTUMsTUFBTSxHQUFHLElBQUlQLGtCQUFKLEVBQWY7O0FBRUEsVUFBTVEsUUFBUSxHQUFHQyxRQUFRLElBQUk7QUFDekIsYUFBT2YsQ0FBQyxDQUFDZ0IsT0FBRixDQUFVbEIsRUFBRSxDQUFDbUIsUUFBYixFQUF1QixDQUFDRixRQUFELENBQXZCLENBQVA7QUFDSCxLQUZEOztBQUlBLFdBQU9GLE1BQU0sQ0FBQ0ssYUFBUCxDQUFxQkosUUFBckIsRUFBK0JGLFNBQS9CLEVBQTBDTyxJQUExQyxDQUErQ0MsVUFBVSxJQUFJO0FBQ2hFLFlBQU1DLFVBQVUsR0FBSSxZQUFXVCxTQUFVLEVBQXpDLENBRGdFLENBR2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxZQUFNVSxhQUFhLEdBQUdmLG1CQUFtQixDQUFDZ0IsR0FBcEIsQ0FBd0JILFVBQVUsQ0FBQ0ksUUFBWCxDQUFvQkMsUUFBNUMsQ0FBdEIsQ0FUZ0UsQ0FXaEU7QUFDQTs7QUFDQSxZQUFNQyxRQUFRLEdBQUcsQ0FBakI7QUFFQSxZQUFNQyxRQUFRLEdBQUcsSUFBSXZCLFFBQUosQ0FBYTtBQUMxQkgsUUFBQUEsSUFBSSxFQUFFVyxTQURvQjtBQUUxQmdCLFFBQUFBLElBQUksRUFBRTNCLElBQUksQ0FBQzRCLFFBQUwsQ0FBY2pCLFNBQWQsQ0FGb0I7QUFHMUJjLFFBQUFBLFFBSDBCO0FBSTFCSSxRQUFBQSxrQkFBa0IsRUFBRVIsYUFKTTtBQUsxQlMsUUFBQUEsbUJBQW1CLEVBQUUsVUFMSztBQU0xQkMsUUFBQUEsU0FBUyxFQUFFLFlBTmU7QUFPMUJDLFFBQUFBLE1BQU0sRUFBRVo7QUFQa0IsT0FBYixDQUFqQjtBQVVBLGFBQU87QUFBRU0sUUFBQUEsUUFBRjtBQUFZUCxRQUFBQTtBQUFaLE9BQVA7QUFDSCxLQTFCTSxDQUFQO0FBMkJIOztBQXZDbUM7O0FBMEN4Q2MsTUFBTSxDQUFDQyxPQUFQLEdBQWlCM0IsVUFBakIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XHJcbmNvbnN0IHEgPSByZXF1aXJlKCdxJyk7XHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcbmNvbnN0IEltcG9ydFByb3ZpZGVyID0gcmVxdWlyZSgnZWFnbGUtcHJpbnQvc2VydmljZXMvcHJvdmlkZXJzL2ltcG9ydFByb3ZpZGVyJyk7XHJcbmNvbnN0IEltcG9ydGFibGVGb3JtYXQgPSByZXF1aXJlKCdlYWdsZS1wcmludC9zZXJ2aWNlcy9pbXBvcnRTZXJ2aWNlJykuSW1wb3J0YWJsZUZvcm1hdDtcclxuY29uc3QgVG9vbHBhdGggPSByZXF1aXJlKCdlYWdsZS1wcmludC9tb2RlbC90b29scGF0aCcpLmRlZmF1bHQ7XHJcblxyXG5jb25zdCBNQlRvb2xwYXRoUHJvdmlkZXIgPSByZXF1aXJlKCcuL21iX3Rvb2xwYXRoX3BhcnNlcicpO1xyXG5jb25zdCBQcmludGVyR2VuZGVyU3RyaW5nID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKS5QcmludGVyR2VuZGVyU3RyaW5nO1xyXG5cclxuY2xhc3MgTWJJbXBvcnRlciBleHRlbmRzIEltcG9ydFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKG5ldyBJbXBvcnRhYmxlRm9ybWF0KFsnbWFrZXJib3QnXSwgJ01ha2VyYm90IEZpbGVzICgqLm1ha2VyYm90KScpLCBUb29scGF0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW1wb3J0RnJvbURhdGEoZGF0YSwgc291cmNlVXJsKSB7XHJcbiAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IE1CVG9vbHBhdGhQcm92aWRlcigpO1xyXG5cclxuICAgICAgICBjb25zdCByZWFkRnVuYyA9IGZpbGVwYXRoID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHEubmZhcHBseShmcy5yZWFkRmlsZSwgW2ZpbGVwYXRoXSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxvYWRlci51bnppcFRvb2xwYXRoKHJlYWRGdW5jLCBzb3VyY2VVcmwpLnRoZW4ocGFyc2VkRGF0YSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkVG9vbHBhdGggPSBgdG9vbHBhdGg6JHtzb3VyY2VVcmx9YDtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86ICBXaGF0IGlzIHRoZSBzaWduaWZpY2FuY2Ugb2Yga2V5IGB0YXJnZXRQcmludGVyTW9kZWxgP1xyXG4gICAgICAgICAgICAvLyBDaGFuZ2VkIHRvIHVzaW5nIHRoZSBmaWVsZCB0byBwYXNzIHNsaWNlZEJvdFR5cGUgaW5zdGVhZCBvZiBib3RUeXBlIGluIG9yZGVyXHJcbiAgICAgICAgICAgIC8vIHRvIGRvIGJvdF90eXBlIGNoZWNrIGJlZm9yZSBwcmludC5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gUHJldmlvdXMgY29kZSBiZWxvdy5cclxuICAgICAgICAgICAgLy8gYGxldCBib3RUeXBlID0gJ1JlcGxpY2F0b3IgNXRoIEdlbic7YFxyXG4gICAgICAgICAgICBjb25zdCBzbGljZWRCb3RUeXBlID0gUHJpbnRlckdlbmRlclN0cmluZy5nZXQocGFyc2VkRGF0YS5tZXRhRGF0YS5ib3RfdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBVbnN1cmUgd2hhdCB0b29scGF0aC5maWxlU2l6ZSBwcm92aWRlcy5cclxuICAgICAgICAgICAgLy8gSEFDSzogc2V0dGluZyBhcyAxIHRvIGJ5cGFzcyBmb3Igbm93LlxyXG4gICAgICAgICAgICBjb25zdCBmaWxlU2l6ZSA9IDE7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0b29scGF0aCA9IG5ldyBUb29scGF0aCh7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiBzb3VyY2VVcmwsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXRoLmJhc2VuYW1lKHNvdXJjZVVybCksXHJcbiAgICAgICAgICAgICAgICBmaWxlU2l6ZSxcclxuICAgICAgICAgICAgICAgIHRhcmdldFByaW50ZXJNb2RlbDogc2xpY2VkQm90VHlwZSxcclxuICAgICAgICAgICAgICAgIHRhcmdldFByaW50ZXJWZW5kb3I6ICdNYWtlckJvdCcsXHJcbiAgICAgICAgICAgICAgICBleHRyYUluZm86ICdtb3JlIGluZm8hJyxcclxuICAgICAgICAgICAgICAgIHBhcnNlcjogaWRUb29scGF0aCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyB0b29scGF0aCwgcGFyc2VkRGF0YSB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1iSW1wb3J0ZXI7XHJcbiJdfQ==
