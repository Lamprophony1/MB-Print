'use strict';

const q = require('q');

const path = require('path');

const Printer = require('eagle-print/model/printer');

const EventEmitter = require('eventemitter3');

const _ = require('lodash');

const croissant = require('./croissant');

const MBPluginError = require('./errors').MBPluginError;

const util = require('./util.js');

const PrintJobHelper = require('./print_job_helper.js');

const FirmwareListener = require('./firmwareListener');

const FileTransferHelper = require('./file_transfer_helper');

const {
  maybe
} = require('./utils/maybe');

const {
  PrinterStateEnum,
  PRINTER_CONNECTION_TIMEOUT,
  EXPERIMENTAL_EXTRUDER,
  PrinterGenderToDefaultExtruders,
  ExtruderTypeToPrettyName,
  FifthGenBots,
  SixthGenBots,
  BotTypeEnum,
  ExtruderTypeEnum
} = require('./constants');

const {
  parseConnType
} = require('./utils/printerConnectionUtil');

class MakerBotPrinter extends Printer {
  constructor(printerInfo, gender, machineConfig, connectionManager, flux) {
    const data = {
      id: printerInfo.uid,
      connected: true,
      printer_status: {
        state: 'Unauthenticated'
      }
    };
    super(data, null, gender);
    const self = this;
    self._flux = maybe(flux); // Notifications for critical updates (system, states, machine_config updates, etc..)

    self._updateNotifications = new EventEmitter(); // hook up to notifications from connectionManager

    self._connectionManager = connectionManager;

    self._connectionManager.on('update', self.updateFromPrinterInfo, this);

    self._connectionManager.on('connection_change', function (croissantPrinter) {
      // whenever connection changes, emit message
      self._updateNotifications.emit('conn_type_change', this._connectionManager.currentConnType);

      if (!croissantPrinter) {
        return self._disconnectPrinter();
      } else {
        self._initPrinter(croissantPrinter);
        /**
         * When a sixth gen printer comes back online, attempt to
         * update the spool materials. However, only the current
         * selected printer will complete the flow of updating the
         * spool materials. Check printSettingsActions.js'
         * loadSchema
         *
         * This listener does have a bug where ethernet connection
         * and wifi connection are not treated as the same
         * 'network' connection.
         *
         * --Ray
         **/


        self.updateSpoolMaterialsOnceAlive(); // once printer is authenticated, emit message

        self._updateNotifications.emit('printer_authenticated', this._connectionManager.currentConnType);
      }
    }, this);

    self._connectionManager.on('check_life', self._checkAlive, this);

    self._lastSignOfLife = null;
    self._printerInfo = printerInfo; // let's deprecate usage of this...

    self._printer = null; // croissant printer

    self._disconnectEvent = null; // resolves when printer disconnects
    // obj to hold the callback that gets called when disconnectEvent resolves

    self._disconnectCallbackObj = null;
    self._firmware = null;
    self._networkState = null;
    self._machineConfig = null;
    if (machineConfig) self._machineConfig = machineConfig; // these are status properties generic to eagle-print's printer

    self._info = {};
    self._info.printer_status = {};
    self.setState(PrinterStateEnum.Unauthenticated);
    self._info.printer_status.current_print_job = {};
    self._info.printer_status.current_print_job.percent_done = 0; // these ones are makerbot specific, in case they may come in handy

    self._info.printer_status.current_process = null;
    self._info.printer_status.toolheads = null; // Errors from error_notifications and from processes go in here;
    // an error will get removed when acknowledgeError gets called for it
    // or when an error_acknowledged is received

    self._errors = new Map(); // this should only be available if the bot's process is in the 'failed' state
    // should only ever have one entry - this is incorrect and has been changed now
    // It will contain all state change errors.

    self._info.printer_status.state_change_errors = new Map();
    self._info.update_firmware_available = null;
    self._cameraFeedActive = false;
    self._printJobHelper = new PrintJobHelper(self);
    self.updateFromPrinterInfo(printerInfo);
  }

  addError(error) {
    this._errors.set(error.error_id, error);

    this._updateNotifications.emit('error');
  }

  removeError(errorId) {
    this._errors.delete(errorId);

    this._updateNotifications.emit('error');
  }

  saveStateError(err) {
    err.isStateErr = true;
    this.addError(err);
  }

  clearStateErrors() {
    for (const errEntry of this._errors) {
      const errId = errEntry[0];
      const err = errEntry[1];

      if (err.isStateErr) {
        this.removeError(errId);
      }
    }
  }

  setState(state) {
    if (state !== this.getStatus().state) {
      this._info.printer_status.state = state;

      this._updateNotifications.emit('status', {});

      this._flux.map(flux => flux.actions.PrinterDetailsActions.status(this.getId(), {}));
    }
  }

  isAuthenticating() {
    const state = this.getStatus().state;
    return state === PrinterStateEnum.Authenticating || state === PrinterStateEnum.Reauthenticating;
  }

  _checkAlive(callback) {
    const self = this;
    const now = new Date(); // have heard from this printer recently; alive

    if (now - this._lastSignOfLife < PRINTER_CONNECTION_TIMEOUT) return callback(true); // may be alive; ping to check

    if (this._printer) {
      return q(this._printer.Ping()).timeout(PRINTER_CONNECTION_TIMEOUT).then(function () {
        callback(true);
      }).catch(function (err) {
        // So, zipping the logs makes the printer not respond to
        // ping requests for some reason (or something like that).
        // This is a subject of hot debate as to why. Regardless,
        // we want to ignore timeouts when zipping logs.
        if (self.currentProcess && self.currentProcess.name === 'ZipLogsProcess') return;

        self._updateNotifications.emit('dying_scream', err);

        console.error(`Printer ${self.getName()} disconnected due to error`, err);

        self._flux.map(flux => {
          flux.actions.CopyBotLogs.timeout(self.getId(), err);
          flux.actions.message.printerDisconnect(self.getId());
        });

        callback(false);
      }).done();
    } // have not heard from this printer, and nothing to ping; probably not alive


    if (this.isAuthenticating()) {
      const err = new Error();
      err.type = MBPluginError.DisconnectWhileAuthingError;
      err.message = 'Disconnected while authenticating';
      return callback(false, err);
    }

    return callback(false);
  }

  disconnect() {
    // _printer's disconnect event triggers _disconnectPrinter
    if (this._printer) {
      console.log('Disconnecting', this.getName());

      this._printer.disconnect();
    }

    this._disconnectPrinter();
  } // (sets a bunch of stuff back to default state when printer disconnects


  _disconnectPrinter() {
    this._lastSignOfLife = null;
    this._printer = null;
    this._disconnectEvent = null;
    this._disconnectCallbackObj = null; // TODO: handle this stuff in a more JS-y way with prototypes and stuff?

    this._info.printer_status = {};
    this._info.printer_status.current_print_job = {};
    this._info.printer_status.current_print_job.percent_done = 0;
    this._info.printer_status.current_process = null;
    this._info.printer_status.toolheads = null;
    this._printJobHelper = new PrintJobHelper(this);
    this._errors = new Map();

    this._connectionManager.setInitState();

    this.setState(PrinterStateEnum.Offline);
  }

  _initPrinter(croissantPrinter) {
    const self = this; // When we change _printers, we don't want the old _printer's disconnectEvent
    // continuation causing the MBPrinter object to change to the Offline state,
    // so here we take advantage of some js object stuff and make the old callback
    // null before we set the continuation for the new _printer's disconnectEvent

    if (self._disconnectCallbackObj) self._disconnectCallbackObj.callback = null;
    self._printer = croissantPrinter;
    const disconnObj = {
      callback: self._disconnectPrinter
    };
    self._disconnectCallbackObj = disconnObj; // this will resolve when the printer disconnects (hopefully)

    self._disconnectEvent = q(self._printer.disconnectEvent).catch(err => {
      // disconnected because of error
      self._updateNotifications.emit('dying_scream', err);

      console.error(`Printer ${self.getName()} disconnected because of error:`, err);
    });

    self._updateNotifications.on('doDisconnect', disconnectFlag => {
      /** ** Monkey Patching **
       *
       * To avoid killing the printer when attempting to reconnect via
       * another connType after a "dying_scream" event happened,
       * printerManager.js will emit a "doDisconnect" and pass a
       * flag either to disconnect the printer or wait while auth'ing.
       *
       * -- Ray
       **/
      if (disconnectFlag) {
        if (disconnObj.callback) disconnObj.callback.call(self);
      } else {
        return;
      }
    }); // clear any errors that happened during auth, since we've succeeded
    // at this point


    self._errors = new Map(); // firmware update listener & check

    this._firmware = new FirmwareListener(this);

    this._firmware.check();

    this._fileTransferHelper = new FileTransferHelper(this);

    const doProcessChecks = info => {
      const step = _.get(info, 'current_process.step');

      const cancelled = _.get(info, 'current_process.cancelled');

      if (cancelled && step === 'failed') {
        this._updateNotifications.emit('process_failed', info);
      } else if (cancelled && step === 'done') {
        this._updateNotifications.emit('process_cancelled', info);
      }

      if (step === 'completed' && !cancelled) this._updateNotifications.emit('process_completed', info);

      const id = _.get(info, 'current_process.id');

      if (id && id !== this.currentProcess.id) {
        this._updateNotifications.emit('process_started', info);
      }
    }; // hook up notifications


    self._printer.setSystemNotificationCallback(function (info) {
      self.updateFromSystemInfo(info);

      self._updateNotifications.emit('system', info);

      self._flux.map(flux => flux.actions.PrinterDetailsActions.system(self.getId(), info));
    });

    self._printer.setStateNotificationCallback(function (info) {
      doProcessChecks(info);
      self.updateFromSystemInfo(info);

      self._flux.map(flux => flux.actions.PrinterDetailsActions.state(self.getId(), info)); // this is a thing that should be happening here, but some undesirable
      // behavior with the handling of printer errors becomes visible with it.....
      // to be uncommented when the error handling gets fixed...
      //self._updateNotifications.emit('system', info);

    });

    self._printer.setErrorNotificationCallback(function (errCode, errId, source) {
      self._errorNotificationCallback(errCode, errId, source);

      self._flux.map(flux => flux.actions.PrinterDetailsActions.error(self.getId(), errCode, errId, source));
    });

    self._printer.setErrorAcknowledgedCallback(function (errId) {
      self._errorAcknowledgedCallback(errId);
    });

    self._printer.setExtruderChangeCallback(function (index, config) {
      self._updateFromExtruderChange(index, config);

      self._flux.map(flux => flux.actions.PrinterDetailsActions.extruderChange(self.getId(), index, config));
    });

    self._printer.setNetworkStateChangeCallback(function (state) {
      self._updateFromNetworkStateChange(state); // removing this because apparently nothing uses this action
      // self._flux.map(flux => {
      //     flux.actions.PrinterDetailsActions.networkChange(self.getId(), state);
      // });

    }); // If you thought to yourself, "Hey, 'Firmware' isn't spelled right", you'd be right! There's a typo in Kaiten,
    // so when we build Croissant, the typo carries over:
    // https://github.com/makerbot/Birdwing-Software/blob/master/firmware/kaiten/src/kaiten/firmwareupdates.py#L136


    self._printer.setFirwareUpdatesInfoChangeCallback((version, updateAvailable, isOnline, err, releaseDate, releaseNotes) => {
      self._updateNotifications.emit('firmware_updates_info_change', version, updateAvailable, releaseNotes);
    }); // Change to idle to break out of isAuth check in UpdatePrinterStatus


    self.setState(PrinterStateEnum.Pending); // // once printer is authenticated, emit message
    // self._updateNotifications.emit('printer_authenticated', this._connectionManager.currentConnType);

    self.updatePrinterStatus();
  }

  _errorNotificationCallback(errorCode, errorId, source) {
    const err = {
      code: errorCode,
      id: errorId,
      source
    };
    this.addError(err);
  }

  _errorAcknowledgedCallback(errorId) {
    this.removeError(errorId);
  }

  acknowledgeError(errorId) {
    // If this error was not internally-generated (ie. error code <= 0),
    // acknowledge the error with the printer; the error should then eventually
    // get cleared on this side from feedback from kaiten...
    if (errorId > -1) {
      let ackPromise = q();
      if (this.processMethodExists('acknowledge_error')) ackPromise = this.invoke('ProcessMethod', ['acknowledge_error']);else if (this.processMethodExists('acknowledge_failure')) ackPromise = this.invoke('ProcessMethod', ['acknowledge_failure']);
      return ackPromise.then(() => {
        return this.invoke('Acknowledged', [errorId]);
      }).then(() => {
        // clear the error after calling AcknowledgeError in case for
        // some reason we miss the error_acknowledged notification
        this._errorAcknowledgedCallback(errorId);
      }).done();
    } else {
      // else, just remove it
      this.removeError(errorId);
    }
  } // override getters for properties that can change


  getInfo() {
    const gender = this.getGender();
    return {
      vendor: gender.getVendor(),
      model: gender.getName(),
      firmware_version: this._fwVerDictToString(this._printerInfo.info.firmware_version)
    };
  }

  getSerialNumber() {
    return util.printerIDtoSerial(this.getId());
  }

  getName() {
    return this._printerInfo.name;
  }

  getCodeName() {
    return util.genderToCodeName(this.getGender().getName());
  }

  getConnectionType() {
    if (this._connectionManager) {
      return this._connectionManager.currentConnType;
    }

    return null;
  }

  getNetworkState() {
    if (this._networkState) {
      return this._networkState;
    }

    return null;
  }

  getIpAddress() {
    return this._printerInfo.info.ip;
  }

  getExtruderInfo() {
    return _.get(this._printerInfo, 'info.toolheads.extruder', []);
  }

  getExtruderTrackingInfo() {
    const extruderTrackingInfo = [];

    if (this._extruderStats && this._extruderStats.length > 0) {
      const attached = this.getAttachedExtruders();
      attached.map((extruder, extruderIndex) => {
        const extruderInfo = {
          extruder_id: null,
          extruder_version: null,
          extruder_print_time: null
        }; // Update extruderInfo stats if present...

        if (this._extruderStats[extruderIndex]) {
          extruderInfo.extruder_id = this._extruderStats[extruderIndex].serial;
          extruderInfo.extruder_version = this._extruderStats[extruderIndex].extruder_type;
          extruderInfo.extruder_print_time = this._extruderStats[extruderIndex].extruder_print_time;
        }

        extruderTrackingInfo[extruderIndex] = extruderInfo;
      });
      return extruderTrackingInfo;
    }
  }
  /**
   * Build all the extruder(s) information from systeminfo &
   * get_tool_usage_stats kaiten method.
   */


  getAllExtruderInfo() {
    const extruders = this.getAttachedExtruders();
    const isDual = extruders.length > 1;
    const toolheadInfo = this.getExtruderInfo();
    const toolUsageStatsPromises = [];
    const extruderStats = [];
    return q(extruders.map((extruder, index) => {
      toolUsageStatsPromises[index] = this.invoke('GetToolUsageStats', isDual ? [index] : null);
    })).then(() => Promise.all(toolUsageStatsPromises)).then(results => {
      results.map((result, index) => {
        const extruderType = this._getExtruderTypeName(extruders[index], index);

        const formattedPrintTime = result.extrusion_time_s ? this._getFormattedPrintTime(result.extrusion_time_s) : null;
        extruderStats[index] = _.merge(result, {
          extruder_type: extruderType,
          extruder_print_time: formattedPrintTime
        });
      });
      return _.merge([], extruderStats, toolheadInfo);
    });
  }

  getChamberInfo() {
    return _.get(this._printerInfo, 'info.toolheads.chamber', []);
  }

  getSystemInfo() {
    return this.invoke('GetSystemInformation').then(systemInfo => {
      const redundantInfo = ['current_process', 'firmware_version', 'has_been_connected_to', 'ip', 'machine_name', 'sound'];
      systemInfo = _.omit(systemInfo, redundantInfo);
      return systemInfo;
    });
  }

  getSpoolInfo() {
    if (!this.isSixthGen()) {
      return q(null);
    }

    if (!this.isConnected() || !this.isAuthenticated()) {
      return q([{
        tag_uid: null
      }, {
        tag_uid: null
      }]);
    } // 6th gens on old firmware
    // GetSpoolInfo(bayIndex) = individual spoolInfo


    if (this.compareCurrApiVersionWith('1.11.0') < 0) {
      return q([0, 1].map(spoolIndex => this.invoke('UpdateSpoolInfo', [spoolIndex]).then(() => this.invoke('GetSpoolInfo', [spoolIndex])))).then(spoolInfoPromises => q.all(spoolInfoPromises)).then(spoolInfos => {
        return spoolInfos.map(spoolInfo => {
          const {
            material_type
          } = spoolInfo;
          spoolInfo.material_name = util.getMaterialSliceConfigStringFromCode(material_type);
          return spoolInfo;
        });
      });
    } else {
      // 6th gens on new firmware
      // GetSpoolsInfo() = array of spool infos from both bays
      // remaining spoolInfo is also available via getSystemInfo, but doesn't
      // include other spool data for UI purposes (color, name, etc)
      return this.invoke('GetSpoolsInfo');
    }
  }

  getDisabledErrors() {
    return _.get(this._printerInfo, 'info.disabled_errors', []);
  }

  getCurrentExtruderType(extruderIndex = 0) {
    const extruderProfiles = _.get(this.machineConfig, 'extruder_profiles');

    const attachedExtrudersArray = _.get(extruderProfiles, 'attached_extruders');

    const supportedExtrudersObj = _.get(extruderProfiles, 'supported_extruders');

    if (attachedExtrudersArray && attachedExtrudersArray.length && supportedExtrudersObj) {
      const currentExtruderId = attachedExtrudersArray[extruderIndex].id;
      return supportedExtrudersObj[currentExtruderId];
    }
  } // sigh... I don't really want to put this here, but it looks like it would
  // be the cleanest for now.....


  isMissingExtruder() {
    const extruderInfos = this.getExtruderInfo();

    for (const exInfo of extruderInfos) {
      if (!exInfo.tool_present) return true;
    }

    return false;
  }

  getStatus() {
    return this._info.printer_status;
  }

  getDisplayStatus() {
    return this.getStatus().state;
  }

  getLastError() {
    // gets the most recent error
    let lastErr;

    for (const val of this._errors.values()) lastErr = val;

    return lastErr;
  }

  getStateError() {
    // this doesn't account very well for the possibility that there would be
    // more than one state error, but during correct functioning, there should
    // only be one....
    for (const value of this._errors.values()) {
      if (value.isStateErr) return value;
    }
  }

  acknowledgeLastError() {
    const lastErr = this.getLastError();
    this.acknowledgeError(lastErr.error_id);
  }

  setAttachedExtruders() {
    // This exists for consistency with archetype printers
    // and purposely does nothing.
    return;
  } // Translate an array of toolhead Ids ([100, 101] or [14]) to an
  // array of toolhead names (['mk14', 'mk14_s'] or ['mk13_impla'])


  getAttachedExtruders() {
    const extruders = [];
    const supportedExtruders = this._machineConfig ? this._machineConfig.extruder_profiles.supported_extruders : [];
    /**
     * Hacky Hack
     *
     * There will be a point in time on the first-time connection and/or reconnection
     * that _machineConfig's attached_extruder can conflict with sliceconfig schema's
     * attached_extruder. This hack addresses _machineConfig with mk14_c extruder which
     * has a different purge tower dimension, but in this state will retain the [63, 0]
     * position.
     *
     * -- Ray
     **/

    if (this.getStatus().state === PrinterStateEnum.Reconnecting) {
      const botType = this._machineConfig.bot_type;
      return PrinterGenderToDefaultExtruders[botType];
    } // On first-time connection and possibily on reconnection,
    // this._printerInfo.info.toolheads does not exist. It will
    // result in this.getExtruderInfo() to be empty [].
    // Use this._machineConfig if available and this.getExtruderInfo()
    // returns empty [].


    const attachedExtruders = _.isEmpty(this.getExtruderInfo()) && this._machineConfig ? this._machineConfig.extruder_profiles.attached_extruders : this.getExtruderInfo();
    attachedExtruders.map(attachedExtruder => {
      const id = attachedExtruder.tool_id; // FW issue (fw 2.6.0) - For experimental extruder, we're borrowing
      // one of the 'mk13' tool_ids that weren't being used, 99, which
      // on the firmware supportedExtruder dict is known as 'mk13'.
      // Here we assign the tool_id 99 to 'mk13_experimental':

      if (id === EXPERIMENTAL_EXTRUDER) {
        extruders.push('mk13_experimental');
      } else {
        extruders.push(supportedExtruders[id]);
      }
    });
    return extruders;
  }

  isAuthenticated() {
    return !!this._printer && this.getStatus().state !== PrinterStateEnum.Reconnecting && this.getStatus().state !== PrinterStateEnum.Unauthenticated;
  }

  isConnected() {
    return this.getStatus().state !== PrinterStateEnum.Offline && this.getStatus().state !== PrinterStateEnum.Reconnecting;
  }

  startPrint(filename, cancelToken) {
    const self = this;
    return self._printJobHelper.startPrint(filename, cancelToken);
  }

  acknowledgeBuildPlateCleared() {
    return this.invoke('ProcessMethod', ['build_plate_cleared']);
  } /// toolPath object made from what is returned by 'build' in makerbot.js...


  sendPrintFile(toolPath, progressCallback, cancelToken) {
    const self = this;
    const localPath = toolPath.get('path');
    const filename = path.basename(localPath);
    const remotePath = `/current_thing/${filename}`;
    return self._printJobHelper.sendPrintFile(localPath, remotePath, progressCallback, cancelToken);
  }

  cancel() {
    if (this._printJobHelper.managingPrintJob()) return q(this._printJobHelper.cancel());
    if (this._firmware.managingFwUpdate()) return this._firmware.cancelUpdate();

    if (this._printer) {
      return this.invoke('Cancel');
    }

    return q();
  }

  updateMachineConfig() {
    const self = this;
    return q(self._printer.GetMachineConfig()).then(function (config) {
      self._machineConfig = config;

      self._updateNotifications.emit('machine_config_change', self._machineConfig);
    });
  }

  _updateFromExtruderChange(index, config) {
    // 6th gens on new firmware
    if (this.isSixthGen() && this.isConnected() && this.isAuthenticated() && this.compareCurrApiVersionWith('1.11.0') >= 0) {
      this.invoke('GetExtrudersConfigs').then(configs => {
        this._machineConfig.extruder_profiles.attached_extruders = configs;

        this._updateNotifications.emit('machine_config_change', this._machineConfig);

        this._flux.map(flux => flux.actions.PrintSettingsActions.loadSchema({
          id: this.getId()
        }));
      });
    } else {
      // 5th-gens, and 6th-gens on earlier firmware that doesn't support getting
      // extruder configs from kaiten.
      // Firmware issue (fw 2.6.0)
      // Tool id 99 shares the same supported_extruder name, mk13.
      // However for EE, sliceconfig treats 99 as mk13_experiemental.
      //
      // Let updateFromSystemInfo handle the change for that scenario.
      if (config.id === EXPERIMENTAL_EXTRUDER) return;
      this._machineConfig.extruder_profiles.attached_extruders[index] = config;

      this._updateNotifications.emit('machine_config_change', this._machineConfig); // For all other extruder changes (Smart Extruder+ and Tough Extruder), loadSchema
      // must be called, so that the print setting store can have the new settings.


      this._flux.map(flux => flux.actions.PrintSettingsActions.loadSchema({
        id: this.getId()
      }));
    }
  }

  _updateFromNetworkStateChange(state) {
    this._networkState = state;

    this._updateNotifications.emit('network_state_change', state);
  }

  deauthenticate(username) {
    let deauthPromise = q();
    if (username && this.isAuthenticated() && this._printer.DeauthorizeIsSupported()) deauthPromise = this.invoke('Deauthorize', [username]);
    deauthPromise.then(() => {
      this.disconnect();
    }).done();
  }

  _fwVerDictToString(fwVerDict) {
    if (fwVerDict) {
      return [fwVerDict.major, fwVerDict.minor, fwVerDict.bugfix, fwVerDict.build].join('.');
    }
  }

  _getFormattedPrintTime(timeInSeconds) {
    // Convert seconds to HH:MM:SS
    const hours = Math.floor(timeInSeconds / 3600);
    const minutes = Math.floor(timeInSeconds % 3600 / 60);
    const seconds = timeInSeconds % 60;
    const printTime = `${hours}:${minutes}:${seconds}`;
    return printTime;
  }

  _getExtruderTypeName(extruderCode, extruderIndex) {
    // Use the current extruderCode or grab the default extruderCode
    // from PrinterGenderToDefaultExtruders enum
    const currBotType = this._printerInfo.info.bot_type;
    extruderCode = extruderCode || PrinterGenderToDefaultExtruders[currBotType][extruderIndex]; // Convert extruderCode to pretty name

    const extruderType = ExtruderTypeToPrettyName[extruderCode];
    return extruderType;
  }

  updatePrinterStatus() {
    const self = this;
    self._lastSignOfLife = new Date();
    const state = this.getStatus().state;

    if (state === PrinterStateEnum.Busy || state === PrinterStateEnum.Pending || state === PrinterStateEnum.Idle) {
      if ('current_process' in self.currentState && self.currentState.current_process !== null) {
        const cp = self.currentState.current_process;
        self.setState(PrinterStateEnum.Busy);
        self._info.printer_status.current_process = cp;

        if (cp.name == 'PrintProcess' && cp.step == 'printing') {
          self._info.printer_status.current_print_job.percent_done = cp.progress;
        } // The above logic seems to be incorrect. From the Kaiten API doc,
        // it appears that state change errors do not get cleared out by
        // error_acknowledged notification. So, if we put them in errors map
        // we will need to have special logic to clear them out. Infact,
        // we may not ever clear state change errors because the only way
        // we clear state change errors is when we get a state notification
        // with null errors...with no indication of the error_id to clear
        // Experimenting with following solution for this messy situation
        //     - put all errors (error notifications and state change errors)
        //       in errors map
        //     - also remember state change errors separately. When we get
        //       a state notification with no errors, use the stored error id
        //       to clear from the error map


        if (cp.error) {
          self.saveStateError(cp.error);
        } else {
          self.clearStateErrors();
        }

        self._updateNotifications.emit('status', {});

        this._flux.map(flux => flux.actions.PrinterDetailsActions.status(self.getId(), {}));
      } else {
        self.setState(PrinterStateEnum.Idle);
        self._info.printer_status.current_print_job = {};
        self._info.printer_status.current_process = null;
        self._info.printer_status.current_print_job.percent_done = 0;
        self.clearStateErrors();
      }

      if ('toolheads' in self.currentState) {
        self._info.printer_status.toolheads = self.currentState.toolheads;
      }
    }
  }

  updateFromPrinterInfo(printerInfo) {
    const self = this;

    if (self._printer) {
      // Separate kaiten call to get CloudService information
      q(self._printer.GetCloudServicesInfo()).then(cloudServicesInfo => {
        self._printerInfo.info = _.assign(self._printerInfo.info, cloudServicesInfo);
      });
    }

    self._printerInfo.info = _.assign(self._printerInfo.info, printerInfo.info);

    _.forOwn(printerInfo, (value, key) => {
      // this disallows empty bot names/addresses/uids, but that
      // would be silly anyways...
      if (_.get(printerInfo, key) && key !== 'info') {
        self._printerInfo[key] = value;
      }
    });

    self.updatePrinterStatus();
  }

  getCameraFeed(cameraFrameCallback) {
    if (this._printer) {
      const self = this;
      self._cameraFeedActive = true;

      self._printer.setCameraFrameNotification(function (frame) {
        const frameBuf = new Buffer(new Uint8Array(frame), 'binary'); // convert binary data to base64 for displaying

        const frameAsB64 = `data:image/jpeg;base64,${frameBuf.toString('base64')}`;

        if (util.checkJpeg(frameBuf)) {
          cameraFrameCallback(frameAsB64);
        } else {
          console.log(`Received corrupt camera frame: ${frameAsB64}`);
        }
      });

      q(self.invoke('RequestCameraStream')).catch(function (err) {
        self._cameraFeedActive = false;
        throw err;
      }).done();
    }
  }

  endCameraFeed() {
    if (this._printer) {
      const self = this;
      q(self.invoke('EndCameraStream')).then(function () {
        self._cameraFeedActive = false;

        self._printer.unsetCameraFrameNotification();
      }).catch(console.error).done();
    }
  }

  checkAuthenticated() {
    const self = this;

    if (!self.isAuthenticated()) {
      const err = new Error();
      err.type = 'UnauthenticatedError';
      err.message = 'Printer is Unauthenticated or Offline';
      throw err;
    }
  }

  updateFromSystemInfo(info) {
    /**
     * (Currently in Sombrero firmware 0.54.1.216 and in the distant
     * future...) 'updateSpoolMaterialsFromSystemInfo' is another hack
     * around since kaiten is not emitting a notification for spool
     * changes.
     *
     * For now, update spoolInfo in printSettingsStore when there is a
     * difference between tag_uid(s) or when a printer comes back online.
     * Check 'updateSpoolMaterialsOnceAlive'.
     *
     * ::eelroll::
     *
     * -- Ray xoxoxo
     **/
    this.updateSpoolMaterialsFromSystemInfo(info); // Current Birdwing Firmware (2.6.0) doesn't recongize experimental
    // extruder (tool_id: 99) as an extruder change and won't throw an
    // extruder change notification. This is a work around for that issue.

    info.toolheads.extruder.map(extruder => {
      // escape hatch for when there's no machine config
      if (!this._machineConfig) return; // this is a pointer to the extruder! mutating it will mutate
      // _machineConfig!

      const prevTool = this._machineConfig.extruder_profiles.attached_extruders[extruder.index];
      const currToolId = extruder.tool_id;

      if (currToolId !== 0 && currToolId !== prevTool.id) {
        // Looks like machine_config updates the attached_extruder
        // calibrated flag even though the toolhead ids are different
        prevTool.id = currToolId;

        this._updateNotifications.emit('machine_config_change', this._machineConfig); // Callout to loadSchema to filter out any user_settings vs
        // available_settings in printSettingsStore


        this._flux.map(flux => flux.actions.PrintSettingsActions.loadSchema({
          id: this.getId()
        }));
      }

      const hasExperimental = this._machineConfig.extruder_profiles.attached_extruders.reduce((acc, e) => acc || e.id === EXPERIMENTAL_EXTRUDER, false);

      if (hasExperimental) {
        this._flux.map(flux => flux.actions.PrinterDetailsActions.showEETermsAndConditions());
      }
    });
    const printerInfo = new croissant.PrinterInfo();
    printerInfo.name = info.machine_name;
    printerInfo.address = this._printerInfo.address;
    printerInfo.uid = this._printerInfo.uid;
    printerInfo.info = info;
    printerInfo.connType = parseConnType(this._printerInfo);
    this.updateFromPrinterInfo(printerInfo);
  }
  /**
   * Temporary/Permanent hack for detecting spool changes
   * based on systemInfo updates.
   *
   * There are issues with this hack. On spool changes, it
   * does get called twice in a row. The second call, it will
   * detect an empty spool, but the selectedMaterials
   * in PrintSettingsStore will remain unaffected.
   *
   * -- Ray
   **/


  updateSpoolMaterialsFromSystemInfo(info) {
    if (!this.isSixthGen()) return; // patch work to bypass this check for spool material until
    // the old _printerInfo.info gets updated with spool material
    // --Ray

    let oldTagUids = [];

    if (this._printerInfo.info.filamentbays) {
      oldTagUids = this._printerInfo.info.filamentbays.map(bay => bay.tag_uid);
    } else {
      return;
    }

    const newTagUids = info.filamentbays.map(bay => bay.tag_uid);

    if (!_.isEqual(oldTagUids, newTagUids)) {
      /** OLD 1.3v Method/MethodX support **/
      if (this.isSixthGen() && this.isConnected() && this.isAuthenticated() && this.compareCurrApiVersionWith('1.11.0') < 1) {
        const spoolsInfoPromises = newTagUids.map((tag_uid, index) => {
          const checkSpoolTagUid = () => {
            const spoolInfoPromise = this.invoke('GetSpoolInfo', [index]);

            if (spoolInfoPromise) {
              return spoolInfoPromise.then(result => {
                if (result.tag_uid !== tag_uid) {
                  return checkSpoolTagUid();
                } else {
                  return result;
                }
              });
            } else {
              return null;
            }
          };

          return checkSpoolTagUid();
        });
        q.all(spoolsInfoPromises).then(spoolsInfo => {
          this._flux.map(flux => {
            flux.actions.PrintSettingsActions.updateMaterials({
              id: this.getId(),
              spoolsInfo
            });
          });
        });
      } else {
        // keep invoking 'GetSpoolsInfo' until the RFID reader
        // returns a result with matching tag_uid
        const checkSpoolTagUids = () => {
          return this.invoke('GetSpoolsInfo').then(spoolsInfo => {
            const resultTagUids = spoolsInfo.map(spoolInfo => spoolInfo.tag_uid);

            if (!_.isEqual(resultTagUids, newTagUids)) {
              return checkSpoolTagUids();
            } else {
              return spoolsInfo;
            }
          });
        };

        checkSpoolTagUids().then(spoolsInfo => {
          this._flux.map(flux => {
            flux.actions.PrintSettingsActions.updateMaterials({
              id: this.getId(),
              spoolsInfo
            });
          });
        });
      }
    }
  } // Compare Printer's Croissant API version with a "cutoff" version


  compareCurrApiVersionWith(cutoffApiStr) {
    const currApiStr = this._printerInfo.info.api_version;
    return this.compareVersions(currApiStr, cutoffApiStr);
  }
  /*
   * Takes current and cutoff version numbers in major.minor.bugfix format, and
   * breaks them down and compares them.
   *
   * return 1  if current version greater than the cutoff version
   * return 0  if current version matches the cutoff version
   * return -1 if current version less than the cuttoff version
   */


  compareVersions(current, cutoff) {
    if (cutoff === current) {
      return 0;
    }

    const cutoffArr = cutoff.split('.');
    const currArr = current.split('.');

    for (let i = 0; i < currArr.length; i++) {
      // Current version bigger than Cutoff version
      if (parseInt(currArr[i]) > parseInt(cutoffArr[i])) {
        return 1;
      } // Cutoff version bigger than Current version


      if (parseInt(currArr[i]) < parseInt(cutoffArr[i])) {
        return -1;
      }
    } // Otherwise they are the same.


    return 0;
  }
  /**
   * A method to call out to onGetPrinterSchema in PrintSettingsStore via
   * PrintSettingsAction.
   *
   * This will be called upon connection changed and should cover the
   * scenario of when a printer comes online.
   *
   * -- Ray
   **/


  updateSpoolMaterialsOnceAlive() {
    if (!this.isSixthGen()) return;
    /** OLD 1.3v Method/MethodX support **/

    if (this.isSixthGen() && this.isConnected() && this.isAuthenticated() && this.compareCurrApiVersionWith('1.11.0') < 0) {
      const spoolsInfoPromise = [0, 1].map(bayIndex => {
        return this.invoke('GetSpoolInfo', [bayIndex]);
      });
      q.all(spoolsInfoPromise).then(spoolsInfo => {
        this._flux.map(flux => {
          flux.actions.PrintSettingsActions.updateMaterials({
            id: this.getId(),
            spoolsInfo
          });
        });
      });
    } else {
      this.invoke('GetSpoolsInfo').then(spoolsInfo => {
        this._flux.map(flux => {
          flux.actions.PrintSettingsActions.updateMaterials({
            id: this.getId(),
            spoolsInfo
          });
        });
      });
    }
  }

  checkForUnsupportedExtruderConfigurations() {
    if (!this.isSixthGen() || !this.isConnected() || !this.isAuthenticated()) {
      return {
        extruderSetupError: false
      };
    } else {
      return this._flux.map(flux => {
        const payload = {};
        const printerStore = flux.store('PrinterStore');
        const selectedPrinter = printerStore.getSelectedPrinter();
        /** Update Nov 7th 2019
         * As of firmware 1.4.0.344, get_extruders_configs() will
         * now provide information if extruder slot has incorrect
         * extruder/material.
         *
         * EXECPT ATM material information is not available with
         * the latest 1.4 RC.
         *
         * FYI - extruder update notification will update the
         * machine_config.extruder_profiles.attached_extruders
         * profiles. Check _updateFromExtruderChange
         **/

        const hasUnsupportedExtruderConfigs = () => {
          if (!this._machineConfig) return false;
          return this._machineConfig.extruder_profiles.attached_extruders.reduce((res, extruderConfig) => {
            if (!extruderConfig.can_pair_tools) res = true;
            return res;
          }, false);
        };

        const hasMismatchedExtruderConfigs = () => {
          if (this._machineConfig === null) return false;
          return this._machineConfig.extruder_profiles.attached_extruders.reduce((res, extruderConfig) => {
            if (!extruderConfig.can_dual_print) res = true;
            return res;
          }, false);
        };

        const hasMissingToolheads = () => {
          // Null checking with printerInfo.info.toolheads
          // Happens on first time connections with sombrero printers
          if (!this._printerInfo.info.toolheads) return false;
          return this._printerInfo.info.toolheads.extruder.reduce((res, extruder) => {
            if (!extruder.tool_present) {
              res = true;
            }

            return res;
          }, false);
        };

        const getSupportedPairedExtrudersConfigs = () => {
          return this._machineConfig.extruder_profiles.attached_extruders.reduce((res, extruderInfo, index) => {
            const {
              all_dual_tool_types
            } = extruderInfo; // Remove LABS extruder from the config list, since
            // it has its own rules

            const extrudersForThisIndex = all_dual_tool_types.filter(extruder => {
              if (extruder !== ExtruderTypeEnum.mk14_e) return extruder;
            });
            extrudersForThisIndex.forEach((extruder, index) => {
              if (res[index]) {
                res[index].push(extruder);
              } else {
                res[index] = [extruder];
              }
            });
            return res;
          }, []);
        };

        const getSupportedPerExtruderConfigs = () => {
          return this._machineConfig.extruder_profiles.attached_extruders.map(extruderConfig => extruderConfig.all_dual_tool_types);
        };

        const getErrorTypePerExtruder = () => {
          // Order of Error Priority
          // Missing Extruder > Unsupported Extruder > Mismatched Extruder
          const toolheadErrorPriority = ['missing', 'unsupported', 'mismatched'];
          return this._printerInfo.info.toolheads.extruder // map each extruderInfo/extruderConfig to the three possible
          // error status contained in one array:
          // [    0  ,     1     ,      2     ]
          // [missing, unsupported, mismatched] => slot 1 extruder
          // [missing, unsupported, mismatched] => slot 2 extruder
          .map((extruderInfo, extruderIndex) => {
            const extruderConfig = this._machineConfig.extruder_profiles.attached_extruders[extruderIndex];
            return [1, 2, 3].map(val => {
              let result;

              switch (val) {
                // Check for missing extruder
                case 1:
                  result = !extruderInfo.tool_present;
                  break;
                // Check for unsupported extruder

                case 2:
                  result = !extruderConfig.can_pair_tools && extruderConfig.can_dual_print;
                  break;
                // Check for mismatch extruder

                case 3:
                  result = !extruderConfig.can_pair_tools && !extruderConfig.can_dual_print;
                  break;

                default:
                  result = false;
              }

              return result;
            });
          }) // translate each extruder's array results to toolhead error string
          .map(results => toolheadErrorPriority[results.findIndex(res => !!res)] || 'none');
        }; // only block user if current bot contains unsupported
        // extruder configuration...


        if (selectedPrinter && selectedPrinter.getId() !== this.getId()) {
          payload.extruderSetupError = false;
        } else if (this.isSixthGen() && this.isConnected() && this.isAuthenticated() && this.compareCurrApiVersionWith('1.11.0') < 0) {
          /** OLD 1.3v Method/MethodX support **/
          const hasUnsupportedExtruderConfigs = () => {
            return this._printerInfo.info.toolheads.extruder.reduce((res, extruder) => {
              if (!extruder.tool_type_correct || !extruder.tool_present) {
                res = true;
              }

              return res;
            }, false);
          };

          if (this._printerInfo.info.toolheads && hasUnsupportedExtruderConfigs()) {
            // Order of Error Priority
            // Missing Extruder > Unsupported Extruder > Mismatched Extruder
            const toolheadErrorPriority = ['missing', 'unsupported', 'mismatched'];
            payload.extruderSetupError = true;
            payload.perExtruderErrorType = this._printerInfo.info.toolheads.extruder.map(extruder => {
              return [1, 2, 3].map(val => {
                let result;

                switch (val) {
                  // Error handling for missing extruders
                  case 1:
                    result = !extruder.tool_present;
                    break;
                  // 1.3v fw doesn't report unsupported extruders

                  case 2:
                    result = false;
                    break;
                  // Error handling for mismatch extruders

                  case 3:
                    result = !extruder.tool_type_correct;
                    break;

                  default:
                    result = false;
                }

                return result;
              });
            }) // translate each extruder's array results to toolhead error string
            .map(results => toolheadErrorPriority[results.findIndex(res => !!res)] || 'none'); // Hardcode the supported extruder configurations

            payload.supportedConfigs = this._printerInfo.info.bot_type === BotTypeEnum.fire_e ? {
              pairedExtrudersConfigs: [['mk14', 'mk14_s']],
              perExtruderConfigs: [['mk14'], ['mk14_s']]
            } : {
              pairedExtrudersConfigs: [['mk14', 'mk14_s'], ['mk14_hot', 'mk14_hot_s']],
              perExtruderConfigs: [['mk14', 'mk14_hot'], ['mk14_s', 'mk14_hot_s']]
            };
          } else {
            payload.extruderSetupError = false;
          }
        } else {
          if (this.isSixthGen() && this.isConnected() && this.isAuthenticated() && this._printerInfo.info.toolheads && this._machineConfig && (hasMissingToolheads() || hasMismatchedExtruderConfigs() || hasUnsupportedExtruderConfigs())) {
            payload.extruderSetupError = true;
            payload.perExtruderErrorType = getErrorTypePerExtruder();
            payload.supportedConfigs = {
              pairedExtrudersConfigs: getSupportedPairedExtrudersConfigs(),
              perExtruderConfigs: getSupportedPerExtruderConfigs()
            };
          } else {
            payload.extruderSetupError = false;
          }
        }

        return payload;
      }).lift();
    }
  }

  hasExtruderMaterialMismatch() {
    const supportedMaterialsByExtruder = [];
    const extruders = this._machineConfig ? this._machineConfig.extruder_profiles.attached_extruders : this.getAttachedExtruders();
    extruders.map(extruder => {
      if (extruder && extruder.supported_materials) {
        supportedMaterialsByExtruder.push(extruder.supported_materials);
      }
    });
    return this._flux.map(flux => {
      return flux.store('PrintSettingsStore').hasExtruderMaterialMismatch(supportedMaterialsByExtruder);
    }).lift();
  }

  invoke(kaitenMethod, params) {
    const self = this;
    self.checkAuthenticated();
    if (!(kaitenMethod in self._printer)) throw `Method ${kaitenMethod} does not exist.`;

    try {
      return q(self._printer[kaitenMethod].apply(self._printer, params)).catch(function (err) {
        // jank
        if (err.message === 'null\n') {
          console.log(`Something went wrong when calling method ${kaitenMethod}; printer most likely disconnected`);
        } else {
          throw err;
        }
      });
    } catch (err) {
      console.error(err);
      return err;
    }
  }

  getCurrentJob() {
    if (this.currentState && this.currentState.current_process) {
      const cp = this.currentState.current_process; // TODO GC-26618 - This is dirty fix for 0.9 release. This fixes/enables print jobs in Schedule view in ED.

      return {
        // elapsed_time helps to make sure that we are displaying printing progress (not homing or heating progress)
        percent_done: cp.elapsed_time > 0 ? cp.progress : 0,
        elapsed_build_time: cp.elapsed_time ? cp.elapsed_time / 60 : 0,
        estimated_build_time: cp.time_estimation ? cp.time_estimation / 60 : 0,
        submit_time: cp.start_time ? new Date(cp.start_time).valueOf() / 1000 : 0,
        job_id: cp.id ? cp.id : 0,
        filename: cp.filename ? cp.filename.split('/').pop() : null
      };
    }

    return null;
  }

  updateExtruderStats() {
    this._extruderStats = [];
    const isDual = this.getAttachedExtruders().length > 1;
    const extruderStatsPromises = [];
    q(this.getAttachedExtruders().map((extruder, index) => {
      extruderStatsPromises[index] = this.invoke('GetToolUsageStats', isDual ? [index] : null);
    })).then(() => q.all(extruderStatsPromises)).then(results => {
      results.map((result, index) => {
        const extruderType = this._getExtruderTypeName(this.getAttachedExtruders()[index], index);

        const formattedPrintTime = this._getFormattedPrintTime(results[index].extrusion_time_s);

        result.extruder_type = extruderType;
        result.extruder_print_time = formattedPrintTime;
        this._extruderStats[index] = result;
      });
    });
  }

  getTrackingInfo() {
    const data = util.trackingInfoForPrinter(this);
    data.extruders = this.getExtruderTrackingInfo();
    return data;
  }

  processMethodExists(method) {
    const processMethods = _.get(this.getStatus(), 'current_process.methods', []);

    return processMethods.indexOf(method) >= 0;
  }
  /** @private
   * Handles loading and unloading of the filament.
   */


  _changeFilament(processMethod, idleMethod, extruderIndex) {
    const extruder = extruderIndex === undefined ? 0 : extruderIndex;

    if (this.getStatus().state === PrinterStateEnum.Busy) {
      return this.invoke('ProcessMethod', [processMethod, extruder]);
    }

    return this.invoke(idleMethod, [extruder]);
  }
  /**
   * Getting the printer to load/unload filament while it's idle vs. when it's busy are different,
   * hence the distinction between processMethod and idleMethod.
   */


  loadFilament(extruderIndex) {
    const processMethod = 'load_filament';
    const idleMethod = 'LoadFilament';
    return this._changeFilament(processMethod, idleMethod, extruderIndex);
  }

  unloadFilament(extruderIndex) {
    const processMethod = 'unload_filament';
    const idleMethod = 'UnloadFilament';
    return this._changeFilament(processMethod, idleMethod, extruderIndex);
  }
  /**
   * Handles stopping the filament from extruding after it has been loaded. As in `_changeFilament()`,
   * stopping the filament is different while it's idle vs when it's busy. Furthermore, there seems to
   * be a bug in which when you invoke `stop_filament` while the printer is idle, it will cause the screen
   * to freeze, if it has one.
   */


  stopFilament() {
    if (this.getStatus().state === PrinterStateEnum.Busy) {
      return this.invoke('ProcessMethod', ['stop_filament']);
    } // Can't use "stop_filament" now as it causes a the printer screen to crash.
    // See PEN-1104 for more details.


    return this.cancel();
  }

  isFifthGen() {
    const currentBotType = this._printerInfo.info.bot_type;
    return FifthGenBots.includes(currentBotType);
  }

  isSixthGen() {
    const currentBotType = this._printerInfo.info.bot_type;
    return SixthGenBots.includes(currentBotType);
  }

  isSketchPrinter() {
    return false;
  }

  get machineConfig() {
    return this._machineConfig;
  }

  get currentState() {
    return this._printerInfo.info;
  }

  get cameraFeedActive() {
    return this._cameraFeedActive;
  }

  get currentProcess() {
    return this._info.printer_status.current_process || {};
  }

  get updateNotifications() {
    return this._updateNotifications;
  }

  get networkState() {
    return this._networkState;
  }

  get firmware() {
    return this._firmware;
  }

  get fileTransferHelper() {
    return this._fileTransferHelper;
  }

  get soundState() {
    return _.get(this._printerInfo, 'info.sound');
  }

  get analyticsState() {
    return _.get(this._printerInfo, 'info.analytics_enabled');
  } // /stores/printerStore.js


  injectFlux(flux) {
    this._flux = maybe(flux);
    return this;
  }

}

module.exports = MakerBotPrinter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ha2VyYm90LXByaW50ZXIuanMiXSwibmFtZXMiOlsicSIsInJlcXVpcmUiLCJwYXRoIiwiUHJpbnRlciIsIkV2ZW50RW1pdHRlciIsIl8iLCJjcm9pc3NhbnQiLCJNQlBsdWdpbkVycm9yIiwidXRpbCIsIlByaW50Sm9iSGVscGVyIiwiRmlybXdhcmVMaXN0ZW5lciIsIkZpbGVUcmFuc2ZlckhlbHBlciIsIm1heWJlIiwiUHJpbnRlclN0YXRlRW51bSIsIlBSSU5URVJfQ09OTkVDVElPTl9USU1FT1VUIiwiRVhQRVJJTUVOVEFMX0VYVFJVREVSIiwiUHJpbnRlckdlbmRlclRvRGVmYXVsdEV4dHJ1ZGVycyIsIkV4dHJ1ZGVyVHlwZVRvUHJldHR5TmFtZSIsIkZpZnRoR2VuQm90cyIsIlNpeHRoR2VuQm90cyIsIkJvdFR5cGVFbnVtIiwiRXh0cnVkZXJUeXBlRW51bSIsInBhcnNlQ29ublR5cGUiLCJNYWtlckJvdFByaW50ZXIiLCJjb25zdHJ1Y3RvciIsInByaW50ZXJJbmZvIiwiZ2VuZGVyIiwibWFjaGluZUNvbmZpZyIsImNvbm5lY3Rpb25NYW5hZ2VyIiwiZmx1eCIsImRhdGEiLCJpZCIsInVpZCIsImNvbm5lY3RlZCIsInByaW50ZXJfc3RhdHVzIiwic3RhdGUiLCJzZWxmIiwiX2ZsdXgiLCJfdXBkYXRlTm90aWZpY2F0aW9ucyIsIl9jb25uZWN0aW9uTWFuYWdlciIsIm9uIiwidXBkYXRlRnJvbVByaW50ZXJJbmZvIiwiY3JvaXNzYW50UHJpbnRlciIsImVtaXQiLCJjdXJyZW50Q29ublR5cGUiLCJfZGlzY29ubmVjdFByaW50ZXIiLCJfaW5pdFByaW50ZXIiLCJ1cGRhdGVTcG9vbE1hdGVyaWFsc09uY2VBbGl2ZSIsIl9jaGVja0FsaXZlIiwiX2xhc3RTaWduT2ZMaWZlIiwiX3ByaW50ZXJJbmZvIiwiX3ByaW50ZXIiLCJfZGlzY29ubmVjdEV2ZW50IiwiX2Rpc2Nvbm5lY3RDYWxsYmFja09iaiIsIl9maXJtd2FyZSIsIl9uZXR3b3JrU3RhdGUiLCJfbWFjaGluZUNvbmZpZyIsIl9pbmZvIiwic2V0U3RhdGUiLCJVbmF1dGhlbnRpY2F0ZWQiLCJjdXJyZW50X3ByaW50X2pvYiIsInBlcmNlbnRfZG9uZSIsImN1cnJlbnRfcHJvY2VzcyIsInRvb2xoZWFkcyIsIl9lcnJvcnMiLCJNYXAiLCJzdGF0ZV9jaGFuZ2VfZXJyb3JzIiwidXBkYXRlX2Zpcm13YXJlX2F2YWlsYWJsZSIsIl9jYW1lcmFGZWVkQWN0aXZlIiwiX3ByaW50Sm9iSGVscGVyIiwiYWRkRXJyb3IiLCJlcnJvciIsInNldCIsImVycm9yX2lkIiwicmVtb3ZlRXJyb3IiLCJlcnJvcklkIiwiZGVsZXRlIiwic2F2ZVN0YXRlRXJyb3IiLCJlcnIiLCJpc1N0YXRlRXJyIiwiY2xlYXJTdGF0ZUVycm9ycyIsImVyckVudHJ5IiwiZXJySWQiLCJnZXRTdGF0dXMiLCJtYXAiLCJhY3Rpb25zIiwiUHJpbnRlckRldGFpbHNBY3Rpb25zIiwic3RhdHVzIiwiZ2V0SWQiLCJpc0F1dGhlbnRpY2F0aW5nIiwiQXV0aGVudGljYXRpbmciLCJSZWF1dGhlbnRpY2F0aW5nIiwiY2FsbGJhY2siLCJub3ciLCJEYXRlIiwiUGluZyIsInRpbWVvdXQiLCJ0aGVuIiwiY2F0Y2giLCJjdXJyZW50UHJvY2VzcyIsIm5hbWUiLCJjb25zb2xlIiwiZ2V0TmFtZSIsIkNvcHlCb3RMb2dzIiwibWVzc2FnZSIsInByaW50ZXJEaXNjb25uZWN0IiwiZG9uZSIsIkVycm9yIiwidHlwZSIsIkRpc2Nvbm5lY3RXaGlsZUF1dGhpbmdFcnJvciIsImRpc2Nvbm5lY3QiLCJsb2ciLCJzZXRJbml0U3RhdGUiLCJPZmZsaW5lIiwiZGlzY29ubk9iaiIsImRpc2Nvbm5lY3RFdmVudCIsImRpc2Nvbm5lY3RGbGFnIiwiY2FsbCIsImNoZWNrIiwiX2ZpbGVUcmFuc2ZlckhlbHBlciIsImRvUHJvY2Vzc0NoZWNrcyIsImluZm8iLCJzdGVwIiwiZ2V0IiwiY2FuY2VsbGVkIiwic2V0U3lzdGVtTm90aWZpY2F0aW9uQ2FsbGJhY2siLCJ1cGRhdGVGcm9tU3lzdGVtSW5mbyIsInN5c3RlbSIsInNldFN0YXRlTm90aWZpY2F0aW9uQ2FsbGJhY2siLCJzZXRFcnJvck5vdGlmaWNhdGlvbkNhbGxiYWNrIiwiZXJyQ29kZSIsInNvdXJjZSIsIl9lcnJvck5vdGlmaWNhdGlvbkNhbGxiYWNrIiwic2V0RXJyb3JBY2tub3dsZWRnZWRDYWxsYmFjayIsIl9lcnJvckFja25vd2xlZGdlZENhbGxiYWNrIiwic2V0RXh0cnVkZXJDaGFuZ2VDYWxsYmFjayIsImluZGV4IiwiY29uZmlnIiwiX3VwZGF0ZUZyb21FeHRydWRlckNoYW5nZSIsImV4dHJ1ZGVyQ2hhbmdlIiwic2V0TmV0d29ya1N0YXRlQ2hhbmdlQ2FsbGJhY2siLCJfdXBkYXRlRnJvbU5ldHdvcmtTdGF0ZUNoYW5nZSIsInNldEZpcndhcmVVcGRhdGVzSW5mb0NoYW5nZUNhbGxiYWNrIiwidmVyc2lvbiIsInVwZGF0ZUF2YWlsYWJsZSIsImlzT25saW5lIiwicmVsZWFzZURhdGUiLCJyZWxlYXNlTm90ZXMiLCJQZW5kaW5nIiwidXBkYXRlUHJpbnRlclN0YXR1cyIsImVycm9yQ29kZSIsImNvZGUiLCJhY2tub3dsZWRnZUVycm9yIiwiYWNrUHJvbWlzZSIsInByb2Nlc3NNZXRob2RFeGlzdHMiLCJpbnZva2UiLCJnZXRJbmZvIiwiZ2V0R2VuZGVyIiwidmVuZG9yIiwiZ2V0VmVuZG9yIiwibW9kZWwiLCJmaXJtd2FyZV92ZXJzaW9uIiwiX2Z3VmVyRGljdFRvU3RyaW5nIiwiZ2V0U2VyaWFsTnVtYmVyIiwicHJpbnRlcklEdG9TZXJpYWwiLCJnZXRDb2RlTmFtZSIsImdlbmRlclRvQ29kZU5hbWUiLCJnZXRDb25uZWN0aW9uVHlwZSIsImdldE5ldHdvcmtTdGF0ZSIsImdldElwQWRkcmVzcyIsImlwIiwiZ2V0RXh0cnVkZXJJbmZvIiwiZ2V0RXh0cnVkZXJUcmFja2luZ0luZm8iLCJleHRydWRlclRyYWNraW5nSW5mbyIsIl9leHRydWRlclN0YXRzIiwibGVuZ3RoIiwiYXR0YWNoZWQiLCJnZXRBdHRhY2hlZEV4dHJ1ZGVycyIsImV4dHJ1ZGVyIiwiZXh0cnVkZXJJbmRleCIsImV4dHJ1ZGVySW5mbyIsImV4dHJ1ZGVyX2lkIiwiZXh0cnVkZXJfdmVyc2lvbiIsImV4dHJ1ZGVyX3ByaW50X3RpbWUiLCJzZXJpYWwiLCJleHRydWRlcl90eXBlIiwiZ2V0QWxsRXh0cnVkZXJJbmZvIiwiZXh0cnVkZXJzIiwiaXNEdWFsIiwidG9vbGhlYWRJbmZvIiwidG9vbFVzYWdlU3RhdHNQcm9taXNlcyIsImV4dHJ1ZGVyU3RhdHMiLCJQcm9taXNlIiwiYWxsIiwicmVzdWx0cyIsInJlc3VsdCIsImV4dHJ1ZGVyVHlwZSIsIl9nZXRFeHRydWRlclR5cGVOYW1lIiwiZm9ybWF0dGVkUHJpbnRUaW1lIiwiZXh0cnVzaW9uX3RpbWVfcyIsIl9nZXRGb3JtYXR0ZWRQcmludFRpbWUiLCJtZXJnZSIsImdldENoYW1iZXJJbmZvIiwiZ2V0U3lzdGVtSW5mbyIsInN5c3RlbUluZm8iLCJyZWR1bmRhbnRJbmZvIiwib21pdCIsImdldFNwb29sSW5mbyIsImlzU2l4dGhHZW4iLCJpc0Nvbm5lY3RlZCIsImlzQXV0aGVudGljYXRlZCIsInRhZ191aWQiLCJjb21wYXJlQ3VyckFwaVZlcnNpb25XaXRoIiwic3Bvb2xJbmRleCIsInNwb29sSW5mb1Byb21pc2VzIiwic3Bvb2xJbmZvcyIsInNwb29sSW5mbyIsIm1hdGVyaWFsX3R5cGUiLCJtYXRlcmlhbF9uYW1lIiwiZ2V0TWF0ZXJpYWxTbGljZUNvbmZpZ1N0cmluZ0Zyb21Db2RlIiwiZ2V0RGlzYWJsZWRFcnJvcnMiLCJnZXRDdXJyZW50RXh0cnVkZXJUeXBlIiwiZXh0cnVkZXJQcm9maWxlcyIsImF0dGFjaGVkRXh0cnVkZXJzQXJyYXkiLCJzdXBwb3J0ZWRFeHRydWRlcnNPYmoiLCJjdXJyZW50RXh0cnVkZXJJZCIsImlzTWlzc2luZ0V4dHJ1ZGVyIiwiZXh0cnVkZXJJbmZvcyIsImV4SW5mbyIsInRvb2xfcHJlc2VudCIsImdldERpc3BsYXlTdGF0dXMiLCJnZXRMYXN0RXJyb3IiLCJsYXN0RXJyIiwidmFsIiwidmFsdWVzIiwiZ2V0U3RhdGVFcnJvciIsInZhbHVlIiwiYWNrbm93bGVkZ2VMYXN0RXJyb3IiLCJzZXRBdHRhY2hlZEV4dHJ1ZGVycyIsInN1cHBvcnRlZEV4dHJ1ZGVycyIsImV4dHJ1ZGVyX3Byb2ZpbGVzIiwic3VwcG9ydGVkX2V4dHJ1ZGVycyIsIlJlY29ubmVjdGluZyIsImJvdFR5cGUiLCJib3RfdHlwZSIsImF0dGFjaGVkRXh0cnVkZXJzIiwiaXNFbXB0eSIsImF0dGFjaGVkX2V4dHJ1ZGVycyIsImF0dGFjaGVkRXh0cnVkZXIiLCJ0b29sX2lkIiwicHVzaCIsInN0YXJ0UHJpbnQiLCJmaWxlbmFtZSIsImNhbmNlbFRva2VuIiwiYWNrbm93bGVkZ2VCdWlsZFBsYXRlQ2xlYXJlZCIsInNlbmRQcmludEZpbGUiLCJ0b29sUGF0aCIsInByb2dyZXNzQ2FsbGJhY2siLCJsb2NhbFBhdGgiLCJiYXNlbmFtZSIsInJlbW90ZVBhdGgiLCJjYW5jZWwiLCJtYW5hZ2luZ1ByaW50Sm9iIiwibWFuYWdpbmdGd1VwZGF0ZSIsImNhbmNlbFVwZGF0ZSIsInVwZGF0ZU1hY2hpbmVDb25maWciLCJHZXRNYWNoaW5lQ29uZmlnIiwiY29uZmlncyIsIlByaW50U2V0dGluZ3NBY3Rpb25zIiwibG9hZFNjaGVtYSIsImRlYXV0aGVudGljYXRlIiwidXNlcm5hbWUiLCJkZWF1dGhQcm9taXNlIiwiRGVhdXRob3JpemVJc1N1cHBvcnRlZCIsImZ3VmVyRGljdCIsIm1ham9yIiwibWlub3IiLCJidWdmaXgiLCJidWlsZCIsImpvaW4iLCJ0aW1lSW5TZWNvbmRzIiwiaG91cnMiLCJNYXRoIiwiZmxvb3IiLCJtaW51dGVzIiwic2Vjb25kcyIsInByaW50VGltZSIsImV4dHJ1ZGVyQ29kZSIsImN1cnJCb3RUeXBlIiwiQnVzeSIsIklkbGUiLCJjdXJyZW50U3RhdGUiLCJjcCIsInByb2dyZXNzIiwiR2V0Q2xvdWRTZXJ2aWNlc0luZm8iLCJjbG91ZFNlcnZpY2VzSW5mbyIsImFzc2lnbiIsImZvck93biIsImtleSIsImdldENhbWVyYUZlZWQiLCJjYW1lcmFGcmFtZUNhbGxiYWNrIiwic2V0Q2FtZXJhRnJhbWVOb3RpZmljYXRpb24iLCJmcmFtZSIsImZyYW1lQnVmIiwiQnVmZmVyIiwiVWludDhBcnJheSIsImZyYW1lQXNCNjQiLCJ0b1N0cmluZyIsImNoZWNrSnBlZyIsImVuZENhbWVyYUZlZWQiLCJ1bnNldENhbWVyYUZyYW1lTm90aWZpY2F0aW9uIiwiY2hlY2tBdXRoZW50aWNhdGVkIiwidXBkYXRlU3Bvb2xNYXRlcmlhbHNGcm9tU3lzdGVtSW5mbyIsInByZXZUb29sIiwiY3VyclRvb2xJZCIsImhhc0V4cGVyaW1lbnRhbCIsInJlZHVjZSIsImFjYyIsImUiLCJzaG93RUVUZXJtc0FuZENvbmRpdGlvbnMiLCJQcmludGVySW5mbyIsIm1hY2hpbmVfbmFtZSIsImFkZHJlc3MiLCJjb25uVHlwZSIsIm9sZFRhZ1VpZHMiLCJmaWxhbWVudGJheXMiLCJiYXkiLCJuZXdUYWdVaWRzIiwiaXNFcXVhbCIsInNwb29sc0luZm9Qcm9taXNlcyIsImNoZWNrU3Bvb2xUYWdVaWQiLCJzcG9vbEluZm9Qcm9taXNlIiwic3Bvb2xzSW5mbyIsInVwZGF0ZU1hdGVyaWFscyIsImNoZWNrU3Bvb2xUYWdVaWRzIiwicmVzdWx0VGFnVWlkcyIsImN1dG9mZkFwaVN0ciIsImN1cnJBcGlTdHIiLCJhcGlfdmVyc2lvbiIsImNvbXBhcmVWZXJzaW9ucyIsImN1cnJlbnQiLCJjdXRvZmYiLCJjdXRvZmZBcnIiLCJzcGxpdCIsImN1cnJBcnIiLCJpIiwicGFyc2VJbnQiLCJzcG9vbHNJbmZvUHJvbWlzZSIsImJheUluZGV4IiwiY2hlY2tGb3JVbnN1cHBvcnRlZEV4dHJ1ZGVyQ29uZmlndXJhdGlvbnMiLCJleHRydWRlclNldHVwRXJyb3IiLCJwYXlsb2FkIiwicHJpbnRlclN0b3JlIiwic3RvcmUiLCJzZWxlY3RlZFByaW50ZXIiLCJnZXRTZWxlY3RlZFByaW50ZXIiLCJoYXNVbnN1cHBvcnRlZEV4dHJ1ZGVyQ29uZmlncyIsInJlcyIsImV4dHJ1ZGVyQ29uZmlnIiwiY2FuX3BhaXJfdG9vbHMiLCJoYXNNaXNtYXRjaGVkRXh0cnVkZXJDb25maWdzIiwiY2FuX2R1YWxfcHJpbnQiLCJoYXNNaXNzaW5nVG9vbGhlYWRzIiwiZ2V0U3VwcG9ydGVkUGFpcmVkRXh0cnVkZXJzQ29uZmlncyIsImFsbF9kdWFsX3Rvb2xfdHlwZXMiLCJleHRydWRlcnNGb3JUaGlzSW5kZXgiLCJmaWx0ZXIiLCJtazE0X2UiLCJmb3JFYWNoIiwiZ2V0U3VwcG9ydGVkUGVyRXh0cnVkZXJDb25maWdzIiwiZ2V0RXJyb3JUeXBlUGVyRXh0cnVkZXIiLCJ0b29saGVhZEVycm9yUHJpb3JpdHkiLCJmaW5kSW5kZXgiLCJ0b29sX3R5cGVfY29ycmVjdCIsInBlckV4dHJ1ZGVyRXJyb3JUeXBlIiwic3VwcG9ydGVkQ29uZmlncyIsImZpcmVfZSIsInBhaXJlZEV4dHJ1ZGVyc0NvbmZpZ3MiLCJwZXJFeHRydWRlckNvbmZpZ3MiLCJsaWZ0IiwiaGFzRXh0cnVkZXJNYXRlcmlhbE1pc21hdGNoIiwic3VwcG9ydGVkTWF0ZXJpYWxzQnlFeHRydWRlciIsInN1cHBvcnRlZF9tYXRlcmlhbHMiLCJrYWl0ZW5NZXRob2QiLCJwYXJhbXMiLCJhcHBseSIsImdldEN1cnJlbnRKb2IiLCJlbGFwc2VkX3RpbWUiLCJlbGFwc2VkX2J1aWxkX3RpbWUiLCJlc3RpbWF0ZWRfYnVpbGRfdGltZSIsInRpbWVfZXN0aW1hdGlvbiIsInN1Ym1pdF90aW1lIiwic3RhcnRfdGltZSIsInZhbHVlT2YiLCJqb2JfaWQiLCJwb3AiLCJ1cGRhdGVFeHRydWRlclN0YXRzIiwiZXh0cnVkZXJTdGF0c1Byb21pc2VzIiwiZ2V0VHJhY2tpbmdJbmZvIiwidHJhY2tpbmdJbmZvRm9yUHJpbnRlciIsIm1ldGhvZCIsInByb2Nlc3NNZXRob2RzIiwiaW5kZXhPZiIsIl9jaGFuZ2VGaWxhbWVudCIsInByb2Nlc3NNZXRob2QiLCJpZGxlTWV0aG9kIiwidW5kZWZpbmVkIiwibG9hZEZpbGFtZW50IiwidW5sb2FkRmlsYW1lbnQiLCJzdG9wRmlsYW1lbnQiLCJpc0ZpZnRoR2VuIiwiY3VycmVudEJvdFR5cGUiLCJpbmNsdWRlcyIsImlzU2tldGNoUHJpbnRlciIsImNhbWVyYUZlZWRBY3RpdmUiLCJ1cGRhdGVOb3RpZmljYXRpb25zIiwibmV0d29ya1N0YXRlIiwiZmlybXdhcmUiLCJmaWxlVHJhbnNmZXJIZWxwZXIiLCJzb3VuZFN0YXRlIiwiYW5hbHl0aWNzU3RhdGUiLCJpbmplY3RGbHV4IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsTUFBTUEsQ0FBQyxHQUFHQyxPQUFPLENBQUMsR0FBRCxDQUFqQjs7QUFDQSxNQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQyxNQUFELENBQXBCOztBQUNBLE1BQU1FLE9BQU8sR0FBR0YsT0FBTyxDQUFDLDJCQUFELENBQXZCOztBQUNBLE1BQU1HLFlBQVksR0FBR0gsT0FBTyxDQUFDLGVBQUQsQ0FBNUI7O0FBQ0EsTUFBTUksQ0FBQyxHQUFHSixPQUFPLENBQUMsUUFBRCxDQUFqQjs7QUFFQSxNQUFNSyxTQUFTLEdBQUdMLE9BQU8sQ0FBQyxhQUFELENBQXpCOztBQUNBLE1BQU1NLGFBQWEsR0FBR04sT0FBTyxDQUFDLFVBQUQsQ0FBUCxDQUFvQk0sYUFBMUM7O0FBQ0EsTUFBTUMsSUFBSSxHQUFHUCxPQUFPLENBQUMsV0FBRCxDQUFwQjs7QUFDQSxNQUFNUSxjQUFjLEdBQUdSLE9BQU8sQ0FBQyx1QkFBRCxDQUE5Qjs7QUFDQSxNQUFNUyxnQkFBZ0IsR0FBR1QsT0FBTyxDQUFDLG9CQUFELENBQWhDOztBQUNBLE1BQU1VLGtCQUFrQixHQUFHVixPQUFPLENBQUMsd0JBQUQsQ0FBbEM7O0FBQ0EsTUFBTTtBQUFFVyxFQUFBQTtBQUFGLElBQVlYLE9BQU8sQ0FBQyxlQUFELENBQXpCOztBQUNBLE1BQU07QUFDRlksRUFBQUEsZ0JBREU7QUFFRkMsRUFBQUEsMEJBRkU7QUFHRkMsRUFBQUEscUJBSEU7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NkIsY0FBWjtBQUNIOztBQUVELE1BQUkyTyxZQUFKLEdBQW1CO0FBQ2YsV0FBTyxLQUFLalAsWUFBTCxDQUFrQnVFLElBQXpCO0FBQ0g7O0FBRUQsTUFBSXFTLGdCQUFKLEdBQXVCO0FBQ25CLFdBQU8sS0FBSzFWLGlCQUFaO0FBQ0g7O0FBRUQsTUFBSStCLGNBQUosR0FBcUI7QUFDakIsV0FBTyxLQUFLMUMsS0FBTCxDQUFXdkIsY0FBWCxDQUEwQjRCLGVBQTFCLElBQTZDLEVBQXBEO0FBQ0g7O0FBRUQsTUFBSWlXLG1CQUFKLEdBQTBCO0FBQ3RCLFdBQU8sS0FBS3pYLG9CQUFaO0FBQ0g7O0FBRUQsTUFBSTBYLFlBQUosR0FBbUI7QUFDZixXQUFPLEtBQUt6VyxhQUFaO0FBQ0g7O0FBRUQsTUFBSTBXLFFBQUosR0FBZTtBQUNYLFdBQU8sS0FBSzNXLFNBQVo7QUFDSDs7QUFFRCxNQUFJNFcsa0JBQUosR0FBeUI7QUFDckIsV0FBTyxLQUFLM1MsbUJBQVo7QUFDSDs7QUFDRCxNQUFJNFMsVUFBSixHQUFpQjtBQUNiLFdBQU85WixDQUFDLENBQUNzSCxHQUFGLENBQU0sS0FBS3pFLFlBQVgsRUFBeUIsWUFBekIsQ0FBUDtBQUNIOztBQUNELE1BQUlrWCxjQUFKLEdBQXFCO0FBQ2pCLFdBQU8vWixDQUFDLENBQUNzSCxHQUFGLENBQU0sS0FBS3pFLFlBQVgsRUFBeUIsd0JBQXpCLENBQVA7QUFDSCxHQXovQ2lDLENBMi9DbEM7OztBQUNBbVgsRUFBQUEsVUFBVSxDQUFDeFksSUFBRCxFQUFPO0FBQ2IsU0FBS1EsS0FBTCxHQUFhekIsS0FBSyxDQUFDaUIsSUFBRCxDQUFsQjtBQUNBLFdBQU8sSUFBUDtBQUNIOztBQS8vQ2lDOztBQWtnRHRDeVksTUFBTSxDQUFDQyxPQUFQLEdBQWlCaFosZUFBakIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBxID0gcmVxdWlyZSgncScpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCBQcmludGVyID0gcmVxdWlyZSgnZWFnbGUtcHJpbnQvbW9kZWwvcHJpbnRlcicpO1xyXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XHJcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuXHJcbmNvbnN0IGNyb2lzc2FudCA9IHJlcXVpcmUoJy4vY3JvaXNzYW50Jyk7XHJcbmNvbnN0IE1CUGx1Z2luRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1CUGx1Z2luRXJyb3I7XHJcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwuanMnKTtcclxuY29uc3QgUHJpbnRKb2JIZWxwZXIgPSByZXF1aXJlKCcuL3ByaW50X2pvYl9oZWxwZXIuanMnKTtcclxuY29uc3QgRmlybXdhcmVMaXN0ZW5lciA9IHJlcXVpcmUoJy4vZmlybXdhcmVMaXN0ZW5lcicpO1xyXG5jb25zdCBGaWxlVHJhbnNmZXJIZWxwZXIgPSByZXF1aXJlKCcuL2ZpbGVfdHJhbnNmZXJfaGVscGVyJyk7XHJcbmNvbnN0IHsgbWF5YmUgfSA9IHJlcXVpcmUoJy4vdXRpbHMvbWF5YmUnKTtcclxuY29uc3Qge1xyXG4gICAgUHJpbnRlclN0YXRlRW51bSxcclxuICAgIFBSSU5URVJfQ09OTkVDVElPTl9USU1FT1VULFxyXG4gICAgRVhQRVJJTUVOVEFMX0VYVFJVREVSLFxyXG4gICAgUHJpbnRlckdlbmRlclRvRGVmYXVsdEV4dHJ1ZGVycyxcclxuICAgIEV4dHJ1ZGVyVHlwZVRvUHJldHR5TmFtZSxcclxuICAgIEZpZnRoR2VuQm90cyxcclxuICAgIFNpeHRoR2VuQm90cyxcclxuICAgIEJvdFR5cGVFbnVtLFxyXG4gICAgRXh0cnVkZXJUeXBlRW51bSxcclxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbmNvbnN0IHsgcGFyc2VDb25uVHlwZSB9ID0gcmVxdWlyZSgnLi91dGlscy9wcmludGVyQ29ubmVjdGlvblV0aWwnKTtcclxuXHJcbmNsYXNzIE1ha2VyQm90UHJpbnRlciBleHRlbmRzIFByaW50ZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJpbnRlckluZm8sIGdlbmRlciwgbWFjaGluZUNvbmZpZywgY29ubmVjdGlvbk1hbmFnZXIsIGZsdXgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICBpZDogcHJpbnRlckluZm8udWlkLFxyXG4gICAgICAgICAgICBjb25uZWN0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIHByaW50ZXJfc3RhdHVzOiB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1VuYXV0aGVudGljYXRlZCcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBzdXBlcihkYXRhLCBudWxsLCBnZW5kZXIpO1xyXG5cclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgICBzZWxmLl9mbHV4ID0gbWF5YmUoZmx1eCk7XHJcblxyXG4gICAgICAgIC8vIE5vdGlmaWNhdGlvbnMgZm9yIGNyaXRpY2FsIHVwZGF0ZXMgKHN5c3RlbSwgc3RhdGVzLCBtYWNoaW5lX2NvbmZpZyB1cGRhdGVzLCBldGMuLilcclxuICAgICAgICBzZWxmLl91cGRhdGVOb3RpZmljYXRpb25zID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICAgICAgICAvLyBob29rIHVwIHRvIG5vdGlmaWNhdGlvbnMgZnJvbSBjb25uZWN0aW9uTWFuYWdlclxyXG4gICAgICAgIHNlbGYuX2Nvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbk1hbmFnZXI7XHJcbiAgICAgICAgc2VsZi5fY29ubmVjdGlvbk1hbmFnZXIub24oJ3VwZGF0ZScsIHNlbGYudXBkYXRlRnJvbVByaW50ZXJJbmZvLCB0aGlzKTtcclxuICAgICAgICBzZWxmLl9jb25uZWN0aW9uTWFuYWdlci5vbihcclxuICAgICAgICAgICAgJ2Nvbm5lY3Rpb25fY2hhbmdlJyxcclxuICAgICAgICAgICAgZnVuY3Rpb24oY3JvaXNzYW50UHJpbnRlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbmV2ZXIgY29ubmVjdGlvbiBjaGFuZ2VzLCBlbWl0IG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIHNlbGYuX3VwZGF0ZU5vdGlmaWNhdGlvbnMuZW1pdCgnY29ubl90eXBlX2NoYW5nZScsIHRoaXMuX2Nvbm5lY3Rpb25NYW5hZ2VyLmN1cnJlbnRDb25uVHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFjcm9pc3NhbnRQcmludGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2Rpc2Nvbm5lY3RQcmludGVyKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2luaXRQcmludGVyKGNyb2lzc2FudFByaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFdoZW4gYSBzaXh0aCBnZW4gcHJpbnRlciBjb21lcyBiYWNrIG9ubGluZSwgYXR0ZW1wdCB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAqIHVwZGF0ZSB0aGUgc3Bvb2wgbWF0ZXJpYWxzLiBIb3dldmVyLCBvbmx5IHRoZSBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICogc2VsZWN0ZWQgcHJpbnRlciB3aWxsIGNvbXBsZXRlIHRoZSBmbG93IG9mIHVwZGF0aW5nIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIHNwb29sIG1hdGVyaWFscy4gQ2hlY2sgcHJpbnRTZXR0aW5nc0FjdGlvbnMuanMnXHJcbiAgICAgICAgICAgICAgICAgICAgICogbG9hZFNjaGVtYVxyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhpcyBsaXN0ZW5lciBkb2VzIGhhdmUgYSBidWcgd2hlcmUgZXRoZXJuZXQgY29ubmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIGFuZCB3aWZpIGNvbm5lY3Rpb24gYXJlIG5vdCB0cmVhdGVkIGFzIHRoZSBzYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICogJ25ldHdvcmsnIGNvbm5lY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiAtLVJheVxyXG4gICAgICAgICAgICAgICAgICAgICAqKi9cclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVNwb29sTWF0ZXJpYWxzT25jZUFsaXZlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uY2UgcHJpbnRlciBpcyBhdXRoZW50aWNhdGVkLCBlbWl0IG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl91cGRhdGVOb3RpZmljYXRpb25zLmVtaXQoJ3ByaW50ZXJfYXV0aGVudGljYXRlZCcsIHRoaXMuX2Nvbm5lY3Rpb25NYW5hZ2VyLmN1cnJlbnRDb25uVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRoaXNcclxuICAgICAgICApO1xyXG4gICAgICAgIHNlbGYuX2Nvbm5lY3Rpb25NYW5hZ2VyLm9uKCdjaGVja19saWZlJywgc2VsZi5fY2hlY2tBbGl2ZSwgdGhpcyk7XHJcbiAgICAgICAgc2VsZi5fbGFzdFNpZ25PZkxpZmUgPSBudWxsO1xyXG5cclxuICAgICAgICBzZWxmLl9wcmludGVySW5mbyA9IHByaW50ZXJJbmZvOyAvLyBsZXQncyBkZXByZWNhdGUgdXNhZ2Ugb2YgdGhpcy4uLlxyXG4gICAgICAgIHNlbGYuX3ByaW50ZXIgPSBudWxsOyAvLyBjcm9pc3NhbnQgcHJpbnRlclxyXG4gICAgICAgIHNlbGYuX2Rpc2Nvbm5lY3RFdmVudCA9IG51bGw7IC8vIHJlc29sdmVzIHdoZW4gcHJpbnRlciBkaXNjb25uZWN0c1xyXG4gICAgICAgIC8vIG9iaiB0byBob2xkIHRoZSBjYWxsYmFjayB0aGF0IGdldHMgY2FsbGVkIHdoZW4gZGlzY29ubmVjdEV2ZW50IHJlc29sdmVzXHJcbiAgICAgICAgc2VsZi5fZGlzY29ubmVjdENhbGxiYWNrT2JqID0gbnVsbDtcclxuXHJcbiAgICAgICAgc2VsZi5fZmlybXdhcmUgPSBudWxsO1xyXG4gICAgICAgIHNlbGYuX25ldHdvcmtTdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgICAgIHNlbGYuX21hY2hpbmVDb25maWcgPSBudWxsO1xyXG4gICAgICAgIGlmIChtYWNoaW5lQ29uZmlnKSBzZWxmLl9tYWNoaW5lQ29uZmlnID0gbWFjaGluZUNvbmZpZztcclxuXHJcbiAgICAgICAgLy8gdGhlc2UgYXJlIHN0YXR1cyBwcm9wZXJ0aWVzIGdlbmVyaWMgdG8gZWFnbGUtcHJpbnQncyBwcmludGVyXHJcbiAgICAgICAgc2VsZi5faW5mbyA9IHt9O1xyXG4gICAgICAgIHNlbGYuX2luZm8ucHJpbnRlcl9zdGF0dXMgPSB7fTtcclxuICAgICAgICBzZWxmLnNldFN0YXRlKFByaW50ZXJTdGF0ZUVudW0uVW5hdXRoZW50aWNhdGVkKTtcclxuICAgICAgICBzZWxmLl9pbmZvLnByaW50ZXJfc3RhdHVzLmN1cnJlbnRfcHJpbnRfam9iID0ge307XHJcbiAgICAgICAgc2VsZi5faW5mby5wcmludGVyX3N0YXR1cy5jdXJyZW50X3ByaW50X2pvYi5wZXJjZW50X2RvbmUgPSAwO1xyXG5cclxuICAgICAgICAvLyB0aGVzZSBvbmVzIGFyZSBtYWtlcmJvdCBzcGVjaWZpYywgaW4gY2FzZSB0aGV5IG1heSBjb21lIGluIGhhbmR5XHJcbiAgICAgICAgc2VsZi5faW5mby5wcmludGVyX3N0YXR1cy5jdXJyZW50X3Byb2Nlc3MgPSBudWxsO1xyXG4gICAgICAgIHNlbGYuX2luZm8ucHJpbnRlcl9zdGF0dXMudG9vbGhlYWRzID0gbnVsbDtcclxuICAgICAgICAvLyBFcnJvcnMgZnJvbSBlcnJvcl9ub3RpZmljYXRpb25zIGFuZCBmcm9tIHByb2Nlc3NlcyBnbyBpbiBoZXJlO1xyXG4gICAgICAgIC8vIGFuIGVycm9yIHdpbGwgZ2V0IHJlbW92ZWQgd2hlbiBhY2tub3dsZWRnZUVycm9yIGdldHMgY2FsbGVkIGZvciBpdFxyXG4gICAgICAgIC8vIG9yIHdoZW4gYW4gZXJyb3JfYWNrbm93bGVkZ2VkIGlzIHJlY2VpdmVkXHJcbiAgICAgICAgc2VsZi5fZXJyb3JzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGJlIGF2YWlsYWJsZSBpZiB0aGUgYm90J3MgcHJvY2VzcyBpcyBpbiB0aGUgJ2ZhaWxlZCcgc3RhdGVcclxuICAgICAgICAvLyBzaG91bGQgb25seSBldmVyIGhhdmUgb25lIGVudHJ5IC0gdGhpcyBpcyBpbmNvcnJlY3QgYW5kIGhhcyBiZWVuIGNoYW5nZWQgbm93XHJcbiAgICAgICAgLy8gSXQgd2lsbCBjb250YWluIGFsbCBzdGF0ZSBjaGFuZ2UgZXJyb3JzLlxyXG4gICAgICAgIHNlbGYuX2luZm8ucHJpbnRlcl9zdGF0dXMuc3RhdGVfY2hhbmdlX2Vycm9ycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBzZWxmLl9pbmZvLnVwZGF0ZV9maXJtd2FyZV9hdmFpbGFibGUgPSBudWxsO1xyXG5cclxuICAgICAgICBzZWxmLl9jYW1lcmFGZWVkQWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHNlbGYuX3ByaW50Sm9iSGVscGVyID0gbmV3IFByaW50Sm9iSGVscGVyKHNlbGYpO1xyXG5cclxuICAgICAgICBzZWxmLnVwZGF0ZUZyb21QcmludGVySW5mbyhwcmludGVySW5mbyk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9lcnJvcnMuc2V0KGVycm9yLmVycm9yX2lkLCBlcnJvcik7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTm90aWZpY2F0aW9ucy5lbWl0KCdlcnJvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZUVycm9yKGVycm9ySWQpIHtcclxuICAgICAgICB0aGlzLl9lcnJvcnMuZGVsZXRlKGVycm9ySWQpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU5vdGlmaWNhdGlvbnMuZW1pdCgnZXJyb3InKTtcclxuICAgIH1cclxuXHJcbiAgICBzYXZlU3RhdGVFcnJvcihlcnIpIHtcclxuICAgICAgICBlcnIuaXNTdGF0ZUVyciA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hZGRFcnJvcihlcnIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyU3RhdGVFcnJvcnMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlcnJFbnRyeSBvZiB0aGlzLl9lcnJvcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJySWQgPSBlcnJFbnRyeVswXTtcclxuICAgICAgICAgICAgY29uc3QgZXJyID0gZXJyRW50cnlbMV07XHJcbiAgICAgICAgICAgIGlmIChlcnIuaXNTdGF0ZUVycikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFcnJvcihlcnJJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBpZiAoc3RhdGUgIT09IHRoaXMuZ2V0U3RhdHVzKCkuc3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5mby5wcmludGVyX3N0YXR1cy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVOb3RpZmljYXRpb25zLmVtaXQoJ3N0YXR1cycsIHt9KTtcclxuICAgICAgICAgICAgdGhpcy5fZmx1eC5tYXAoZmx1eCA9PiBmbHV4LmFjdGlvbnMuUHJpbnRlckRldGFpbHNBY3Rpb25zLnN0YXR1cyh0aGlzLmdldElkKCksIHt9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlzQXV0aGVudGljYXRpbmcoKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXR1cygpLnN0YXRlO1xyXG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gUHJpbnRlclN0YXRlRW51bS5BdXRoZW50aWNhdGluZyB8fCBzdGF0ZSA9PT0gUHJpbnRlclN0YXRlRW51bS5SZWF1dGhlbnRpY2F0aW5nO1xyXG4gICAgfVxyXG5cclxuICAgIF9jaGVja0FsaXZlKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgLy8gaGF2ZSBoZWFyZCBmcm9tIHRoaXMgcHJpbnRlciByZWNlbnRseTsgYWxpdmVcclxuICAgICAgICBpZiAobm93IC0gdGhpcy5fbGFzdFNpZ25PZkxpZmUgPCBQUklOVEVSX0NPTk5FQ1RJT05fVElNRU9VVCkgcmV0dXJuIGNhbGxiYWNrKHRydWUpO1xyXG4gICAgICAgIC8vIG1heSBiZSBhbGl2ZTsgcGluZyB0byBjaGVja1xyXG4gICAgICAgIGlmICh0aGlzLl9wcmludGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBxKHRoaXMuX3ByaW50ZXIuUGluZygpKVxyXG4gICAgICAgICAgICAgICAgLnRpbWVvdXQoUFJJTlRFUl9DT05ORUNUSU9OX1RJTUVPVVQpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU28sIHppcHBpbmcgdGhlIGxvZ3MgbWFrZXMgdGhlIHByaW50ZXIgbm90IHJlc3BvbmQgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyBwaW5nIHJlcXVlc3RzIGZvciBzb21lIHJlYXNvbiAob3Igc29tZXRoaW5nIGxpa2UgdGhhdCkuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHN1YmplY3Qgb2YgaG90IGRlYmF0ZSBhcyB0byB3aHkuIFJlZ2FyZGxlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBpZ25vcmUgdGltZW91dHMgd2hlbiB6aXBwaW5nIGxvZ3MuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY3VycmVudFByb2Nlc3MgJiYgc2VsZi5jdXJyZW50UHJvY2Vzcy5uYW1lID09PSAnWmlwTG9nc1Byb2Nlc3MnKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdXBkYXRlTm90aWZpY2F0aW9ucy5lbWl0KCdkeWluZ19zY3JlYW0nLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFByaW50ZXIgJHtzZWxmLmdldE5hbWUoKX0gZGlzY29ubmVjdGVkIGR1ZSB0byBlcnJvcmAsIGVycik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZsdXgubWFwKGZsdXggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbHV4LmFjdGlvbnMuQ29weUJvdExvZ3MudGltZW91dChzZWxmLmdldElkKCksIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXguYWN0aW9ucy5tZXNzYWdlLnByaW50ZXJEaXNjb25uZWN0KHNlbGYuZ2V0SWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5kb25lKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBoYXZlIG5vdCBoZWFyZCBmcm9tIHRoaXMgcHJpbnRlciwgYW5kIG5vdGhpbmcgdG8gcGluZzsgcHJvYmFibHkgbm90IGFsaXZlXHJcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRoZW50aWNhdGluZygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcigpO1xyXG4gICAgICAgICAgICBlcnIudHlwZSA9IE1CUGx1Z2luRXJyb3IuRGlzY29ubmVjdFdoaWxlQXV0aGluZ0Vycm9yO1xyXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9ICdEaXNjb25uZWN0ZWQgd2hpbGUgYXV0aGVudGljYXRpbmcnO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZmFsc2UsIGVycik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc2Nvbm5lY3QoKSB7XHJcbiAgICAgICAgLy8gX3ByaW50ZXIncyBkaXNjb25uZWN0IGV2ZW50IHRyaWdnZXJzIF9kaXNjb25uZWN0UHJpbnRlclxyXG4gICAgICAgIGlmICh0aGlzLl9wcmludGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEaXNjb25uZWN0aW5nJywgdGhpcy5nZXROYW1lKCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcmludGVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdFByaW50ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAoc2V0cyBhIGJ1bmNoIG9mIHN0dWZmIGJhY2sgdG8gZGVmYXVsdCBzdGF0ZSB3aGVuIHByaW50ZXIgZGlzY29ubmVjdHNcclxuICAgIF9kaXNjb25uZWN0UHJpbnRlcigpIHtcclxuICAgICAgICB0aGlzLl9sYXN0U2lnbk9mTGlmZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcHJpbnRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdEV2ZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9kaXNjb25uZWN0Q2FsbGJhY2tPYmogPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgdGhpcyBzdHVmZiBpbiBhIG1vcmUgSlMteSB3YXkgd2l0aCBwcm90b3R5cGVzIGFuZCBzdHVmZj9cclxuICAgICAgICB0aGlzLl9pbmZvLnByaW50ZXJfc3RhdHVzID0ge307XHJcbiAgICAgICAgdGhpcy5faW5mby5wcmludGVyX3N0YXR1cy5jdXJyZW50X3ByaW50X2pvYiA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2luZm8ucHJpbnRlcl9zdGF0dXMuY3VycmVudF9wcmludF9qb2IucGVyY2VudF9kb25lID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5faW5mby5wcmludGVyX3N0YXR1cy5jdXJyZW50X3Byb2Nlc3MgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2luZm8ucHJpbnRlcl9zdGF0dXMudG9vbGhlYWRzID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5fcHJpbnRKb2JIZWxwZXIgPSBuZXcgUHJpbnRKb2JIZWxwZXIodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbk1hbmFnZXIuc2V0SW5pdFN0YXRlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoUHJpbnRlclN0YXRlRW51bS5PZmZsaW5lKTtcclxuICAgIH1cclxuXHJcbiAgICBfaW5pdFByaW50ZXIoY3JvaXNzYW50UHJpbnRlcikge1xyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIC8vIFdoZW4gd2UgY2hhbmdlIF9wcmludGVycywgd2UgZG9uJ3Qgd2FudCB0aGUgb2xkIF9wcmludGVyJ3MgZGlzY29ubmVjdEV2ZW50XHJcbiAgICAgICAgLy8gY29udGludWF0aW9uIGNhdXNpbmcgdGhlIE1CUHJpbnRlciBvYmplY3QgdG8gY2hhbmdlIHRvIHRoZSBPZmZsaW5lIHN0YXRlLFxyXG4gICAgICAgIC8vIHNvIGhlcmUgd2UgdGFrZSBhZHZhbnRhZ2Ugb2Ygc29tZSBqcyBvYmplY3Qgc3R1ZmYgYW5kIG1ha2UgdGhlIG9sZCBjYWxsYmFja1xyXG4gICAgICAgIC8vIG51bGwgYmVmb3JlIHdlIHNldCB0aGUgY29udGludWF0aW9uIGZvciB0aGUgbmV3IF9wcmludGVyJ3MgZGlzY29ubmVjdEV2ZW50XHJcbiAgICAgICAgaWYgKHNlbGYuX2Rpc2Nvbm5lY3RDYWxsYmFja09iaikgc2VsZi5fZGlzY29ubmVjdENhbGxiYWNrT2JqLmNhbGxiYWNrID0gbnVsbDtcclxuXHJcbiAgICAgICAgc2VsZi5fcHJpbnRlciA9IGNyb2lzc2FudFByaW50ZXI7XHJcbiAgICAgICAgY29uc3QgZGlzY29ubk9iaiA9IHtcclxuICAgICAgICAgICAgY2FsbGJhY2s6IHNlbGYuX2Rpc2Nvbm5lY3RQcmludGVyLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2VsZi5fZGlzY29ubmVjdENhbGxiYWNrT2JqID0gZGlzY29ubk9iajtcclxuXHJcbiAgICAgICAgLy8gdGhpcyB3aWxsIHJlc29sdmUgd2hlbiB0aGUgcHJpbnRlciBkaXNjb25uZWN0cyAoaG9wZWZ1bGx5KVxyXG4gICAgICAgIHNlbGYuX2Rpc2Nvbm5lY3RFdmVudCA9IHEoc2VsZi5fcHJpbnRlci5kaXNjb25uZWN0RXZlbnQpLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgIC8vIGRpc2Nvbm5lY3RlZCBiZWNhdXNlIG9mIGVycm9yXHJcbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZU5vdGlmaWNhdGlvbnMuZW1pdCgnZHlpbmdfc2NyZWFtJywgZXJyKTtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUHJpbnRlciAke3NlbGYuZ2V0TmFtZSgpfSBkaXNjb25uZWN0ZWQgYmVjYXVzZSBvZiBlcnJvcjpgLCBlcnIpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZWxmLl91cGRhdGVOb3RpZmljYXRpb25zLm9uKCdkb0Rpc2Nvbm5lY3QnLCBkaXNjb25uZWN0RmxhZyA9PiB7XHJcbiAgICAgICAgICAgIC8qKiAqKiBNb25rZXkgUGF0Y2hpbmcgKipcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogVG8gYXZvaWQga2lsbGluZyB0aGUgcHJpbnRlciB3aGVuIGF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IHZpYVxyXG4gICAgICAgICAgICAgKiBhbm90aGVyIGNvbm5UeXBlIGFmdGVyIGEgXCJkeWluZ19zY3JlYW1cIiBldmVudCBoYXBwZW5lZCxcclxuICAgICAgICAgICAgICogcHJpbnRlck1hbmFnZXIuanMgd2lsbCBlbWl0IGEgXCJkb0Rpc2Nvbm5lY3RcIiBhbmQgcGFzcyBhXHJcbiAgICAgICAgICAgICAqIGZsYWcgZWl0aGVyIHRvIGRpc2Nvbm5lY3QgdGhlIHByaW50ZXIgb3Igd2FpdCB3aGlsZSBhdXRoJ2luZy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogLS0gUmF5XHJcbiAgICAgICAgICAgICAqKi9cclxuICAgICAgICAgICAgaWYgKGRpc2Nvbm5lY3RGbGFnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzY29ubk9iai5jYWxsYmFjaykgZGlzY29ubk9iai5jYWxsYmFjay5jYWxsKHNlbGYpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGNsZWFyIGFueSBlcnJvcnMgdGhhdCBoYXBwZW5lZCBkdXJpbmcgYXV0aCwgc2luY2Ugd2UndmUgc3VjY2VlZGVkXHJcbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludFxyXG4gICAgICAgIHNlbGYuX2Vycm9ycyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgLy8gZmlybXdhcmUgdXBkYXRlIGxpc3RlbmVyICYgY2hlY2tcclxuICAgICAgICB0aGlzLl9maXJtd2FyZSA9IG5ldyBGaXJtd2FyZUxpc3RlbmVyKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2Zpcm13YXJlLmNoZWNrKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2ZpbGVUcmFuc2ZlckhlbHBlciA9IG5ldyBGaWxlVHJhbnNmZXJIZWxwZXIodGhpcyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRvUHJvY2Vzc0NoZWNrcyA9IGluZm8gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdGVwID0gXy5nZXQoaW5mbywgJ2N1cnJlbnRfcHJvY2Vzcy5zdGVwJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlZCA9IF8uZ2V0KGluZm8sICdjdXJyZW50X3Byb2Nlc3MuY2FuY2VsbGVkJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkICYmIHN0ZXAgPT09ICdmYWlsZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVOb3RpZmljYXRpb25zLmVtaXQoJ3Byb2Nlc3NfZmFpbGVkJywgaW5mbyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FuY2VsbGVkICYmIHN0ZXAgPT09ICdkb25lJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTm90aWZpY2F0aW9ucy5lbWl0KCdwcm9jZXNzX2NhbmNlbGxlZCcsIGluZm8pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RlcCA9PT0gJ2NvbXBsZXRlZCcgJiYgIWNhbmNlbGxlZCkgdGhpcy5fdXBkYXRlTm90aWZpY2F0aW9ucy5lbWl0KCdwcm9jZXNzX2NvbXBsZXRlZCcsIGluZm8pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaWQgPSBfLmdldChpbmZvLCAnY3VycmVudF9wcm9jZXNzLmlkJyk7XHJcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gdGhpcy5jdXJyZW50UHJvY2Vzcy5pZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTm90aWZpY2F0aW9ucy5lbWl0KCdwcm9jZXNzX3N0YXJ0ZWQnLCBpbmZvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGhvb2sgdXAgbm90aWZpY2F0aW9uc1xyXG4gICAgICAgIHNlbGYuX3ByaW50ZXIuc2V0U3lzdGVtTm90aWZpY2F0aW9uQ2FsbGJhY2soZnVuY3Rpb24oaW5mbykge1xyXG4gICAgICAgICAgICBzZWxmLnVwZGF0ZUZyb21TeXN0ZW1JbmZvKGluZm8pO1xyXG4gICAgICAgICAgICBzZWxmLl91cGRhdGVOb3RpZmljYXRpb25zLmVtaXQoJ3N5c3RlbScsIGluZm8pO1xyXG5cclxuICAgICAgICAgICAgc2VsZi5fZmx1eC5tYXAoZmx1eCA9PiBmbHV4LmFjdGlvbnMuUHJpbnRlckRldGFpbHNBY3Rpb25zLnN5c3RlbShzZWxmLmdldElkKCksIGluZm8pKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2VsZi5fcHJpbnRlci5zZXRTdGF0ZU5vdGlmaWNhdGlvbkNhbGxiYWNrKGZ1bmN0aW9uKGluZm8pIHtcclxuICAgICAgICAgICAgZG9Qcm9jZXNzQ2hlY2tzKGluZm8pO1xyXG4gICAgICAgICAgICBzZWxmLnVwZGF0ZUZyb21TeXN0ZW1JbmZvKGluZm8pO1xyXG4gICAgICAgICAgICBzZWxmLl9mbHV4Lm1hcChmbHV4ID0+IGZsdXguYWN0aW9ucy5QcmludGVyRGV0YWlsc0FjdGlvbnMuc3RhdGUoc2VsZi5nZXRJZCgpLCBpbmZvKSk7XHJcblxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgdGhpbmcgdGhhdCBzaG91bGQgYmUgaGFwcGVuaW5nIGhlcmUsIGJ1dCBzb21lIHVuZGVzaXJhYmxlXHJcbiAgICAgICAgICAgIC8vIGJlaGF2aW9yIHdpdGggdGhlIGhhbmRsaW5nIG9mIHByaW50ZXIgZXJyb3JzIGJlY29tZXMgdmlzaWJsZSB3aXRoIGl0Li4uLi5cclxuICAgICAgICAgICAgLy8gdG8gYmUgdW5jb21tZW50ZWQgd2hlbiB0aGUgZXJyb3IgaGFuZGxpbmcgZ2V0cyBmaXhlZC4uLlxyXG4gICAgICAgICAgICAvL3NlbGYuX3VwZGF0ZU5vdGlmaWNhdGlvbnMuZW1pdCgnc3lzdGVtJywgaW5mbyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNlbGYuX3ByaW50ZXIuc2V0RXJyb3JOb3RpZmljYXRpb25DYWxsYmFjayhmdW5jdGlvbihlcnJDb2RlLCBlcnJJZCwgc291cmNlKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX2Vycm9yTm90aWZpY2F0aW9uQ2FsbGJhY2soZXJyQ29kZSwgZXJySWQsIHNvdXJjZSk7XHJcbiAgICAgICAgICAgIHNlbGYuX2ZsdXgubWFwKGZsdXggPT4gZmx1eC5hY3Rpb25zLlByaW50ZXJEZXRhaWxzQWN0aW9ucy5lcnJvcihzZWxmLmdldElkKCksIGVyckNvZGUsIGVycklkLCBzb3VyY2UpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2VsZi5fcHJpbnRlci5zZXRFcnJvckFja25vd2xlZGdlZENhbGxiYWNrKGZ1bmN0aW9uKGVycklkKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX2Vycm9yQWNrbm93bGVkZ2VkQ2FsbGJhY2soZXJySWQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZWxmLl9wcmludGVyLnNldEV4dHJ1ZGVyQ2hhbmdlQ2FsbGJhY2soZnVuY3Rpb24oaW5kZXgsIGNvbmZpZykge1xyXG4gICAgICAgICAgICBzZWxmLl91cGRhdGVGcm9tRXh0cnVkZXJDaGFuZ2UoaW5kZXgsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHNlbGYuX2ZsdXgubWFwKGZsdXggPT4gZmx1eC5hY3Rpb25zLlByaW50ZXJEZXRhaWxzQWN0aW9ucy5leHRydWRlckNoYW5nZShzZWxmLmdldElkKCksIGluZGV4LCBjb25maWcpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2VsZi5fcHJpbnRlci5zZXROZXR3b3JrU3RhdGVDaGFuZ2VDYWxsYmFjayhmdW5jdGlvbihzdGF0ZSkge1xyXG4gICAgICAgICAgICBzZWxmLl91cGRhdGVGcm9tTmV0d29ya1N0YXRlQ2hhbmdlKHN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlbW92aW5nIHRoaXMgYmVjYXVzZSBhcHBhcmVudGx5IG5vdGhpbmcgdXNlcyB0aGlzIGFjdGlvblxyXG4gICAgICAgICAgICAvLyBzZWxmLl9mbHV4Lm1hcChmbHV4ID0+IHtcclxuICAgICAgICAgICAgLy8gICAgIGZsdXguYWN0aW9ucy5QcmludGVyRGV0YWlsc0FjdGlvbnMubmV0d29ya0NoYW5nZShzZWxmLmdldElkKCksIHN0YXRlKTtcclxuICAgICAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIElmIHlvdSB0aG91Z2h0IHRvIHlvdXJzZWxmLCBcIkhleSwgJ0Zpcm13YXJlJyBpc24ndCBzcGVsbGVkIHJpZ2h0XCIsIHlvdSdkIGJlIHJpZ2h0ISBUaGVyZSdzIGEgdHlwbyBpbiBLYWl0ZW4sXHJcbiAgICAgICAgLy8gc28gd2hlbiB3ZSBidWlsZCBDcm9pc3NhbnQsIHRoZSB0eXBvIGNhcnJpZXMgb3ZlcjpcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFrZXJib3QvQmlyZHdpbmctU29mdHdhcmUvYmxvYi9tYXN0ZXIvZmlybXdhcmUva2FpdGVuL3NyYy9rYWl0ZW4vZmlybXdhcmV1cGRhdGVzLnB5I0wxMzZcclxuICAgICAgICBzZWxmLl9wcmludGVyLnNldEZpcndhcmVVcGRhdGVzSW5mb0NoYW5nZUNhbGxiYWNrKFxyXG4gICAgICAgICAgICAodmVyc2lvbiwgdXBkYXRlQXZhaWxhYmxlLCBpc09ubGluZSwgZXJyLCByZWxlYXNlRGF0ZSwgcmVsZWFzZU5vdGVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl91cGRhdGVOb3RpZmljYXRpb25zLmVtaXQoJ2Zpcm13YXJlX3VwZGF0ZXNfaW5mb19jaGFuZ2UnLCB2ZXJzaW9uLCB1cGRhdGVBdmFpbGFibGUsIHJlbGVhc2VOb3Rlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBDaGFuZ2UgdG8gaWRsZSB0byBicmVhayBvdXQgb2YgaXNBdXRoIGNoZWNrIGluIFVwZGF0ZVByaW50ZXJTdGF0dXNcclxuICAgICAgICBzZWxmLnNldFN0YXRlKFByaW50ZXJTdGF0ZUVudW0uUGVuZGluZyk7XHJcblxyXG4gICAgICAgIC8vIC8vIG9uY2UgcHJpbnRlciBpcyBhdXRoZW50aWNhdGVkLCBlbWl0IG1lc3NhZ2VcclxuICAgICAgICAvLyBzZWxmLl91cGRhdGVOb3RpZmljYXRpb25zLmVtaXQoJ3ByaW50ZXJfYXV0aGVudGljYXRlZCcsIHRoaXMuX2Nvbm5lY3Rpb25NYW5hZ2VyLmN1cnJlbnRDb25uVHlwZSk7XHJcbiAgICAgICAgc2VsZi51cGRhdGVQcmludGVyU3RhdHVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2Vycm9yTm90aWZpY2F0aW9uQ2FsbGJhY2soZXJyb3JDb2RlLCBlcnJvcklkLCBzb3VyY2UpIHtcclxuICAgICAgICBjb25zdCBlcnIgPSB7XHJcbiAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcclxuICAgICAgICAgICAgaWQ6IGVycm9ySWQsXHJcbiAgICAgICAgICAgIHNvdXJjZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkRXJyb3IoZXJyKTtcclxuICAgIH1cclxuXHJcbiAgICBfZXJyb3JBY2tub3dsZWRnZWRDYWxsYmFjayhlcnJvcklkKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVFcnJvcihlcnJvcklkKTtcclxuICAgIH1cclxuXHJcbiAgICBhY2tub3dsZWRnZUVycm9yKGVycm9ySWQpIHtcclxuICAgICAgICAvLyBJZiB0aGlzIGVycm9yIHdhcyBub3QgaW50ZXJuYWxseS1nZW5lcmF0ZWQgKGllLiBlcnJvciBjb2RlIDw9IDApLFxyXG4gICAgICAgIC8vIGFja25vd2xlZGdlIHRoZSBlcnJvciB3aXRoIHRoZSBwcmludGVyOyB0aGUgZXJyb3Igc2hvdWxkIHRoZW4gZXZlbnR1YWxseVxyXG4gICAgICAgIC8vIGdldCBjbGVhcmVkIG9uIHRoaXMgc2lkZSBmcm9tIGZlZWRiYWNrIGZyb20ga2FpdGVuLi4uXHJcbiAgICAgICAgaWYgKGVycm9ySWQgPiAtMSkge1xyXG4gICAgICAgICAgICBsZXQgYWNrUHJvbWlzZSA9IHEoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc01ldGhvZEV4aXN0cygnYWNrbm93bGVkZ2VfZXJyb3InKSlcclxuICAgICAgICAgICAgICAgIGFja1Byb21pc2UgPSB0aGlzLmludm9rZSgnUHJvY2Vzc01ldGhvZCcsIFsnYWNrbm93bGVkZ2VfZXJyb3InXSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucHJvY2Vzc01ldGhvZEV4aXN0cygnYWNrbm93bGVkZ2VfZmFpbHVyZScpKVxyXG4gICAgICAgICAgICAgICAgYWNrUHJvbWlzZSA9IHRoaXMuaW52b2tlKCdQcm9jZXNzTWV0aG9kJywgWydhY2tub3dsZWRnZV9mYWlsdXJlJ10pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFja1Byb21pc2VcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnZva2UoJ0Fja25vd2xlZGdlZCcsIFtlcnJvcklkXSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBlcnJvciBhZnRlciBjYWxsaW5nIEFja25vd2xlZGdlRXJyb3IgaW4gY2FzZSBmb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBzb21lIHJlYXNvbiB3ZSBtaXNzIHRoZSBlcnJvcl9hY2tub3dsZWRnZWQgbm90aWZpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JBY2tub3dsZWRnZWRDYWxsYmFjayhlcnJvcklkKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuZG9uZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGVsc2UsIGp1c3QgcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXJyb3IoZXJyb3JJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIG92ZXJyaWRlIGdldHRlcnMgZm9yIHByb3BlcnRpZXMgdGhhdCBjYW4gY2hhbmdlXHJcbiAgICBnZXRJbmZvKCkge1xyXG4gICAgICAgIGNvbnN0IGdlbmRlciA9IHRoaXMuZ2V0R2VuZGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVuZG9yOiBnZW5kZXIuZ2V0VmVuZG9yKCksXHJcbiAgICAgICAgICAgIG1vZGVsOiBnZW5kZXIuZ2V0TmFtZSgpLFxyXG4gICAgICAgICAgICBmaXJtd2FyZV92ZXJzaW9uOiB0aGlzLl9md1ZlckRpY3RUb1N0cmluZyh0aGlzLl9wcmludGVySW5mby5pbmZvLmZpcm13YXJlX3ZlcnNpb24pLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2VyaWFsTnVtYmVyKCkge1xyXG4gICAgICAgIHJldHVybiB1dGlsLnByaW50ZXJJRHRvU2VyaWFsKHRoaXMuZ2V0SWQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpbnRlckluZm8ubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRDb2RlTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdXRpbC5nZW5kZXJUb0NvZGVOYW1lKHRoaXMuZ2V0R2VuZGVyKCkuZ2V0TmFtZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRDb25uZWN0aW9uVHlwZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGlvbk1hbmFnZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25NYW5hZ2VyLmN1cnJlbnRDb25uVHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TmV0d29ya1N0YXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9uZXR3b3JrU3RhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcmtTdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SXBBZGRyZXNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcmludGVySW5mby5pbmZvLmlwO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEV4dHJ1ZGVySW5mbygpIHtcclxuICAgICAgICByZXR1cm4gXy5nZXQodGhpcy5fcHJpbnRlckluZm8sICdpbmZvLnRvb2xoZWFkcy5leHRydWRlcicsIFtdKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRFeHRydWRlclRyYWNraW5nSW5mbygpIHtcclxuICAgICAgICBjb25zdCBleHRydWRlclRyYWNraW5nSW5mbyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLl9leHRydWRlclN0YXRzICYmIHRoaXMuX2V4dHJ1ZGVyU3RhdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBhdHRhY2hlZCA9IHRoaXMuZ2V0QXR0YWNoZWRFeHRydWRlcnMoKTtcclxuICAgICAgICAgICAgYXR0YWNoZWQubWFwKChleHRydWRlciwgZXh0cnVkZXJJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cnVkZXJJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJ1ZGVyX2lkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJ1ZGVyX3ZlcnNpb246IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cnVkZXJfcHJpbnRfdGltZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4dHJ1ZGVySW5mbyBzdGF0cyBpZiBwcmVzZW50Li4uXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXh0cnVkZXJTdGF0c1tleHRydWRlckluZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJ1ZGVySW5mby5leHRydWRlcl9pZCA9IHRoaXMuX2V4dHJ1ZGVyU3RhdHNbZXh0cnVkZXJJbmRleF0uc2VyaWFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJ1ZGVySW5mby5leHRydWRlcl92ZXJzaW9uID0gdGhpcy5fZXh0cnVkZXJTdGF0c1tleHRydWRlckluZGV4XS5leHRydWRlcl90eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJ1ZGVySW5mby5leHRydWRlcl9wcmludF90aW1lID0gdGhpcy5fZXh0cnVkZXJTdGF0c1tleHRydWRlckluZGV4XS5leHRydWRlcl9wcmludF90aW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXh0cnVkZXJUcmFja2luZ0luZm9bZXh0cnVkZXJJbmRleF0gPSBleHRydWRlckluZm87XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0cnVkZXJUcmFja2luZ0luZm87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgYWxsIHRoZSBleHRydWRlcihzKSBpbmZvcm1hdGlvbiBmcm9tIHN5c3RlbWluZm8gJlxyXG4gICAgICogZ2V0X3Rvb2xfdXNhZ2Vfc3RhdHMga2FpdGVuIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgZ2V0QWxsRXh0cnVkZXJJbmZvKCkge1xyXG4gICAgICAgIGNvbnN0IGV4dHJ1ZGVycyA9IHRoaXMuZ2V0QXR0YWNoZWRFeHRydWRlcnMoKTtcclxuICAgICAgICBjb25zdCBpc0R1YWwgPSBleHRydWRlcnMubGVuZ3RoID4gMTtcclxuICAgICAgICBjb25zdCB0b29saGVhZEluZm8gPSB0aGlzLmdldEV4dHJ1ZGVySW5mbygpO1xyXG4gICAgICAgIGNvbnN0IHRvb2xVc2FnZVN0YXRzUHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBleHRydWRlclN0YXRzID0gW107XHJcblxyXG4gICAgICAgIHJldHVybiBxKFxyXG4gICAgICAgICAgICBleHRydWRlcnMubWFwKChleHRydWRlciwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRvb2xVc2FnZVN0YXRzUHJvbWlzZXNbaW5kZXhdID0gdGhpcy5pbnZva2UoJ0dldFRvb2xVc2FnZVN0YXRzJywgaXNEdWFsID8gW2luZGV4XSA6IG51bGwpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gUHJvbWlzZS5hbGwodG9vbFVzYWdlU3RhdHNQcm9taXNlcykpXHJcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5tYXAoKHJlc3VsdCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRydWRlclR5cGUgPSB0aGlzLl9nZXRFeHRydWRlclR5cGVOYW1lKGV4dHJ1ZGVyc1tpbmRleF0sIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRQcmludFRpbWUgPSByZXN1bHQuZXh0cnVzaW9uX3RpbWVfc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX2dldEZvcm1hdHRlZFByaW50VGltZShyZXN1bHQuZXh0cnVzaW9uX3RpbWVfcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBleHRydWRlclN0YXRzW2luZGV4XSA9IF8ubWVyZ2UocmVzdWx0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJ1ZGVyX3R5cGU6IGV4dHJ1ZGVyVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cnVkZXJfcHJpbnRfdGltZTogZm9ybWF0dGVkUHJpbnRUaW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ubWVyZ2UoW10sIGV4dHJ1ZGVyU3RhdHMsIHRvb2xoZWFkSW5mbyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldENoYW1iZXJJbmZvKCkge1xyXG4gICAgICAgIHJldHVybiBfLmdldCh0aGlzLl9wcmludGVySW5mbywgJ2luZm8udG9vbGhlYWRzLmNoYW1iZXInLCBbXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3lzdGVtSW5mbygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnZva2UoJ0dldFN5c3RlbUluZm9ybWF0aW9uJykudGhlbihzeXN0ZW1JbmZvID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVkdW5kYW50SW5mbyA9IFtcclxuICAgICAgICAgICAgICAgICdjdXJyZW50X3Byb2Nlc3MnLFxyXG4gICAgICAgICAgICAgICAgJ2Zpcm13YXJlX3ZlcnNpb24nLFxyXG4gICAgICAgICAgICAgICAgJ2hhc19iZWVuX2Nvbm5lY3RlZF90bycsXHJcbiAgICAgICAgICAgICAgICAnaXAnLFxyXG4gICAgICAgICAgICAgICAgJ21hY2hpbmVfbmFtZScsXHJcbiAgICAgICAgICAgICAgICAnc291bmQnLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBzeXN0ZW1JbmZvID0gXy5vbWl0KHN5c3RlbUluZm8sIHJlZHVuZGFudEluZm8pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHN5c3RlbUluZm87XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3Bvb2xJbmZvKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1NpeHRoR2VuKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHEobnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSB8fCAhdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcShbeyB0YWdfdWlkOiBudWxsIH0sIHsgdGFnX3VpZDogbnVsbCB9XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA2dGggZ2VucyBvbiBvbGQgZmlybXdhcmVcclxuICAgICAgICAvLyBHZXRTcG9vbEluZm8oYmF5SW5kZXgpID0gaW5kaXZpZHVhbCBzcG9vbEluZm9cclxuICAgICAgICBpZiAodGhpcy5jb21wYXJlQ3VyckFwaVZlcnNpb25XaXRoKCcxLjExLjAnKSA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHEoXHJcbiAgICAgICAgICAgICAgICBbMCwgMV0ubWFwKHNwb29sSW5kZXggPT5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmludm9rZSgnVXBkYXRlU3Bvb2xJbmZvJywgW3Nwb29sSW5kZXhdKS50aGVuKCgpID0+IHRoaXMuaW52b2tlKCdHZXRTcG9vbEluZm8nLCBbc3Bvb2xJbmRleF0pKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAudGhlbihzcG9vbEluZm9Qcm9taXNlcyA9PiBxLmFsbChzcG9vbEluZm9Qcm9taXNlcykpXHJcbiAgICAgICAgICAgICAgICAudGhlbihzcG9vbEluZm9zID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Bvb2xJbmZvcy5tYXAoc3Bvb2xJbmZvID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBtYXRlcmlhbF90eXBlIH0gPSBzcG9vbEluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwb29sSW5mby5tYXRlcmlhbF9uYW1lID0gdXRpbC5nZXRNYXRlcmlhbFNsaWNlQ29uZmlnU3RyaW5nRnJvbUNvZGUobWF0ZXJpYWxfdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Bvb2xJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gNnRoIGdlbnMgb24gbmV3IGZpcm13YXJlXHJcbiAgICAgICAgICAgIC8vIEdldFNwb29sc0luZm8oKSA9IGFycmF5IG9mIHNwb29sIGluZm9zIGZyb20gYm90aCBiYXlzXHJcbiAgICAgICAgICAgIC8vIHJlbWFpbmluZyBzcG9vbEluZm8gaXMgYWxzbyBhdmFpbGFibGUgdmlhIGdldFN5c3RlbUluZm8sIGJ1dCBkb2Vzbid0XHJcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgb3RoZXIgc3Bvb2wgZGF0YSBmb3IgVUkgcHVycG9zZXMgKGNvbG9yLCBuYW1lLCBldGMpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludm9rZSgnR2V0U3Bvb2xzSW5mbycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXREaXNhYmxlZEVycm9ycygpIHtcclxuICAgICAgICByZXR1cm4gXy5nZXQodGhpcy5fcHJpbnRlckluZm8sICdpbmZvLmRpc2FibGVkX2Vycm9ycycsIFtdKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRDdXJyZW50RXh0cnVkZXJUeXBlKGV4dHJ1ZGVySW5kZXggPSAwKSB7XHJcbiAgICAgICAgY29uc3QgZXh0cnVkZXJQcm9maWxlcyA9IF8uZ2V0KHRoaXMubWFjaGluZUNvbmZpZywgJ2V4dHJ1ZGVyX3Byb2ZpbGVzJyk7XHJcbiAgICAgICAgY29uc3QgYXR0YWNoZWRFeHRydWRlcnNBcnJheSA9IF8uZ2V0KGV4dHJ1ZGVyUHJvZmlsZXMsICdhdHRhY2hlZF9leHRydWRlcnMnKTtcclxuICAgICAgICBjb25zdCBzdXBwb3J0ZWRFeHRydWRlcnNPYmogPSBfLmdldChleHRydWRlclByb2ZpbGVzLCAnc3VwcG9ydGVkX2V4dHJ1ZGVycycpO1xyXG5cclxuICAgICAgICBpZiAoYXR0YWNoZWRFeHRydWRlcnNBcnJheSAmJiBhdHRhY2hlZEV4dHJ1ZGVyc0FycmF5Lmxlbmd0aCAmJiBzdXBwb3J0ZWRFeHRydWRlcnNPYmopIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudEV4dHJ1ZGVySWQgPSBhdHRhY2hlZEV4dHJ1ZGVyc0FycmF5W2V4dHJ1ZGVySW5kZXhdLmlkO1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydGVkRXh0cnVkZXJzT2JqW2N1cnJlbnRFeHRydWRlcklkXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2lnaC4uLiBJIGRvbid0IHJlYWxseSB3YW50IHRvIHB1dCB0aGlzIGhlcmUsIGJ1dCBpdCBsb29rcyBsaWtlIGl0IHdvdWxkXHJcbiAgICAvLyBiZSB0aGUgY2xlYW5lc3QgZm9yIG5vdy4uLi4uXHJcbiAgICBpc01pc3NpbmdFeHRydWRlcigpIHtcclxuICAgICAgICBjb25zdCBleHRydWRlckluZm9zID0gdGhpcy5nZXRFeHRydWRlckluZm8oKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGV4SW5mbyBvZiBleHRydWRlckluZm9zKSB7XHJcbiAgICAgICAgICAgIGlmICghZXhJbmZvLnRvb2xfcHJlc2VudCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTdGF0dXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm8ucHJpbnRlcl9zdGF0dXM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGlzcGxheVN0YXR1cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0dXMoKS5zdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRMYXN0RXJyb3IoKSB7XHJcbiAgICAgICAgLy8gZ2V0cyB0aGUgbW9zdCByZWNlbnQgZXJyb3JcclxuICAgICAgICBsZXQgbGFzdEVycjtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9lcnJvcnMudmFsdWVzKCkpIGxhc3RFcnIgPSB2YWw7XHJcbiAgICAgICAgcmV0dXJuIGxhc3RFcnI7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3RhdGVFcnJvcigpIHtcclxuICAgICAgICAvLyB0aGlzIGRvZXNuJ3QgYWNjb3VudCB2ZXJ5IHdlbGwgZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IHRoZXJlIHdvdWxkIGJlXHJcbiAgICAgICAgLy8gbW9yZSB0aGFuIG9uZSBzdGF0ZSBlcnJvciwgYnV0IGR1cmluZyBjb3JyZWN0IGZ1bmN0aW9uaW5nLCB0aGVyZSBzaG91bGRcclxuICAgICAgICAvLyBvbmx5IGJlIG9uZS4uLi5cclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuX2Vycm9ycy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUuaXNTdGF0ZUVycikgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhY2tub3dsZWRnZUxhc3RFcnJvcigpIHtcclxuICAgICAgICBjb25zdCBsYXN0RXJyID0gdGhpcy5nZXRMYXN0RXJyb3IoKTtcclxuICAgICAgICB0aGlzLmFja25vd2xlZGdlRXJyb3IobGFzdEVyci5lcnJvcl9pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0QXR0YWNoZWRFeHRydWRlcnMoKSB7XHJcbiAgICAgICAgLy8gVGhpcyBleGlzdHMgZm9yIGNvbnNpc3RlbmN5IHdpdGggYXJjaGV0eXBlIHByaW50ZXJzXHJcbiAgICAgICAgLy8gYW5kIHB1cnBvc2VseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyYW5zbGF0ZSBhbiBhcnJheSBvZiB0b29saGVhZCBJZHMgKFsxMDAsIDEwMV0gb3IgWzE0XSkgdG8gYW5cclxuICAgIC8vIGFycmF5IG9mIHRvb2xoZWFkIG5hbWVzIChbJ21rMTQnLCAnbWsxNF9zJ10gb3IgWydtazEzX2ltcGxhJ10pXHJcbiAgICBnZXRBdHRhY2hlZEV4dHJ1ZGVycygpIHtcclxuICAgICAgICBjb25zdCBleHRydWRlcnMgPSBbXTtcclxuICAgICAgICBjb25zdCBzdXBwb3J0ZWRFeHRydWRlcnMgPSB0aGlzLl9tYWNoaW5lQ29uZmlnID8gdGhpcy5fbWFjaGluZUNvbmZpZy5leHRydWRlcl9wcm9maWxlcy5zdXBwb3J0ZWRfZXh0cnVkZXJzIDogW107XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhY2t5IEhhY2tcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZXJlIHdpbGwgYmUgYSBwb2ludCBpbiB0aW1lIG9uIHRoZSBmaXJzdC10aW1lIGNvbm5lY3Rpb24gYW5kL29yIHJlY29ubmVjdGlvblxyXG4gICAgICAgICAqIHRoYXQgX21hY2hpbmVDb25maWcncyBhdHRhY2hlZF9leHRydWRlciBjYW4gY29uZmxpY3Qgd2l0aCBzbGljZWNvbmZpZyBzY2hlbWEnc1xyXG4gICAgICAgICAqIGF0dGFjaGVkX2V4dHJ1ZGVyLiBUaGlzIGhhY2sgYWRkcmVzc2VzIF9tYWNoaW5lQ29uZmlnIHdpdGggbWsxNF9jIGV4dHJ1ZGVyIHdoaWNoXHJcbiAgICAgICAgICogaGFzIGEgZGlmZmVyZW50IHB1cmdlIHRvd2VyIGRpbWVuc2lvbiwgYnV0IGluIHRoaXMgc3RhdGUgd2lsbCByZXRhaW4gdGhlIFs2MywgMF1cclxuICAgICAgICAgKiBwb3NpdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC0tIFJheVxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBpZiAodGhpcy5nZXRTdGF0dXMoKS5zdGF0ZSA9PT0gUHJpbnRlclN0YXRlRW51bS5SZWNvbm5lY3RpbmcpIHtcclxuICAgICAgICAgICAgY29uc3QgYm90VHlwZSA9IHRoaXMuX21hY2hpbmVDb25maWcuYm90X3R5cGU7XHJcbiAgICAgICAgICAgIHJldHVybiBQcmludGVyR2VuZGVyVG9EZWZhdWx0RXh0cnVkZXJzW2JvdFR5cGVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT24gZmlyc3QtdGltZSBjb25uZWN0aW9uIGFuZCBwb3NzaWJpbHkgb24gcmVjb25uZWN0aW9uLFxyXG4gICAgICAgIC8vIHRoaXMuX3ByaW50ZXJJbmZvLmluZm8udG9vbGhlYWRzIGRvZXMgbm90IGV4aXN0LiBJdCB3aWxsXHJcbiAgICAgICAgLy8gcmVzdWx0IGluIHRoaXMuZ2V0RXh0cnVkZXJJbmZvKCkgdG8gYmUgZW1wdHkgW10uXHJcbiAgICAgICAgLy8gVXNlIHRoaXMuX21hY2hpbmVDb25maWcgaWYgYXZhaWxhYmxlIGFuZCB0aGlzLmdldEV4dHJ1ZGVySW5mbygpXHJcbiAgICAgICAgLy8gcmV0dXJucyBlbXB0eSBbXS5cclxuICAgICAgICBjb25zdCBhdHRhY2hlZEV4dHJ1ZGVycyA9XHJcbiAgICAgICAgICAgIF8uaXNFbXB0eSh0aGlzLmdldEV4dHJ1ZGVySW5mbygpKSAmJiB0aGlzLl9tYWNoaW5lQ29uZmlnXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21hY2hpbmVDb25maWcuZXh0cnVkZXJfcHJvZmlsZXMuYXR0YWNoZWRfZXh0cnVkZXJzXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0RXh0cnVkZXJJbmZvKCk7XHJcblxyXG4gICAgICAgIGF0dGFjaGVkRXh0cnVkZXJzLm1hcChhdHRhY2hlZEV4dHJ1ZGVyID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBhdHRhY2hlZEV4dHJ1ZGVyLnRvb2xfaWQ7XHJcbiAgICAgICAgICAgIC8vIEZXIGlzc3VlIChmdyAyLjYuMCkgLSBGb3IgZXhwZXJpbWVudGFsIGV4dHJ1ZGVyLCB3ZSdyZSBib3Jyb3dpbmdcclxuICAgICAgICAgICAgLy8gb25lIG9mIHRoZSAnbWsxMycgdG9vbF9pZHMgdGhhdCB3ZXJlbid0IGJlaW5nIHVzZWQsIDk5LCB3aGljaFxyXG4gICAgICAgICAgICAvLyBvbiB0aGUgZmlybXdhcmUgc3VwcG9ydGVkRXh0cnVkZXIgZGljdCBpcyBrbm93biBhcyAnbWsxMycuXHJcbiAgICAgICAgICAgIC8vIEhlcmUgd2UgYXNzaWduIHRoZSB0b29sX2lkIDk5IHRvICdtazEzX2V4cGVyaW1lbnRhbCc6XHJcbiAgICAgICAgICAgIGlmIChpZCA9PT0gRVhQRVJJTUVOVEFMX0VYVFJVREVSKSB7XHJcbiAgICAgICAgICAgICAgICBleHRydWRlcnMucHVzaCgnbWsxM19leHBlcmltZW50YWwnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4dHJ1ZGVycy5wdXNoKHN1cHBvcnRlZEV4dHJ1ZGVyc1tpZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJ1ZGVycztcclxuICAgIH1cclxuXHJcbiAgICBpc0F1dGhlbnRpY2F0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgISF0aGlzLl9wcmludGVyICYmXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0U3RhdHVzKCkuc3RhdGUgIT09IFByaW50ZXJTdGF0ZUVudW0uUmVjb25uZWN0aW5nICYmXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0U3RhdHVzKCkuc3RhdGUgIT09IFByaW50ZXJTdGF0ZUVudW0uVW5hdXRoZW50aWNhdGVkXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpc0Nvbm5lY3RlZCgpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLmdldFN0YXR1cygpLnN0YXRlICE9PSBQcmludGVyU3RhdGVFbnVtLk9mZmxpbmUgJiZcclxuICAgICAgICAgICAgdGhpcy5nZXRTdGF0dXMoKS5zdGF0ZSAhPT0gUHJpbnRlclN0YXRlRW51bS5SZWNvbm5lY3RpbmdcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0UHJpbnQoZmlsZW5hbWUsIGNhbmNlbFRva2VuKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmLl9wcmludEpvYkhlbHBlci5zdGFydFByaW50KGZpbGVuYW1lLCBjYW5jZWxUb2tlbik7XHJcbiAgICB9XHJcblxyXG4gICAgYWNrbm93bGVkZ2VCdWlsZFBsYXRlQ2xlYXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnZva2UoJ1Byb2Nlc3NNZXRob2QnLCBbJ2J1aWxkX3BsYXRlX2NsZWFyZWQnXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIHRvb2xQYXRoIG9iamVjdCBtYWRlIGZyb20gd2hhdCBpcyByZXR1cm5lZCBieSAnYnVpbGQnIGluIG1ha2VyYm90LmpzLi4uXHJcbiAgICBzZW5kUHJpbnRGaWxlKHRvb2xQYXRoLCBwcm9ncmVzc0NhbGxiYWNrLCBjYW5jZWxUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBjb25zdCBsb2NhbFBhdGggPSB0b29sUGF0aC5nZXQoJ3BhdGgnKTtcclxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUobG9jYWxQYXRoKTtcclxuICAgICAgICBjb25zdCByZW1vdGVQYXRoID0gYC9jdXJyZW50X3RoaW5nLyR7ZmlsZW5hbWV9YDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGYuX3ByaW50Sm9iSGVscGVyLnNlbmRQcmludEZpbGUobG9jYWxQYXRoLCByZW1vdGVQYXRoLCBwcm9ncmVzc0NhbGxiYWNrLCBjYW5jZWxUb2tlbik7XHJcbiAgICB9XHJcblxyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcmludEpvYkhlbHBlci5tYW5hZ2luZ1ByaW50Sm9iKCkpIHJldHVybiBxKHRoaXMuX3ByaW50Sm9iSGVscGVyLmNhbmNlbCgpKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2Zpcm13YXJlLm1hbmFnaW5nRndVcGRhdGUoKSkgcmV0dXJuIHRoaXMuX2Zpcm13YXJlLmNhbmNlbFVwZGF0ZSgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fcHJpbnRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnZva2UoJ0NhbmNlbCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHEoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVNYWNoaW5lQ29uZmlnKCkge1xyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gcShzZWxmLl9wcmludGVyLkdldE1hY2hpbmVDb25maWcoKSkudGhlbihmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICAgICAgc2VsZi5fbWFjaGluZUNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICAgICAgc2VsZi5fdXBkYXRlTm90aWZpY2F0aW9ucy5lbWl0KCdtYWNoaW5lX2NvbmZpZ19jaGFuZ2UnLCBzZWxmLl9tYWNoaW5lQ29uZmlnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfdXBkYXRlRnJvbUV4dHJ1ZGVyQ2hhbmdlKGluZGV4LCBjb25maWcpIHtcclxuICAgICAgICAvLyA2dGggZ2VucyBvbiBuZXcgZmlybXdhcmVcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHRoaXMuaXNTaXh0aEdlbigpICYmXHJcbiAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0ZWQoKSAmJlxyXG4gICAgICAgICAgICB0aGlzLmlzQXV0aGVudGljYXRlZCgpICYmXHJcbiAgICAgICAgICAgIHRoaXMuY29tcGFyZUN1cnJBcGlWZXJzaW9uV2l0aCgnMS4xMS4wJykgPj0gMFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB0aGlzLmludm9rZSgnR2V0RXh0cnVkZXJzQ29uZmlncycpLnRoZW4oY29uZmlncyA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWNoaW5lQ29uZmlnLmV4dHJ1ZGVyX3Byb2ZpbGVzLmF0dGFjaGVkX2V4dHJ1ZGVycyA9IGNvbmZpZ3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVOb3RpZmljYXRpb25zLmVtaXQoJ21hY2hpbmVfY29uZmlnX2NoYW5nZScsIHRoaXMuX21hY2hpbmVDb25maWcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmx1eC5tYXAoZmx1eCA9PiBmbHV4LmFjdGlvbnMuUHJpbnRTZXR0aW5nc0FjdGlvbnMubG9hZFNjaGVtYSh7IGlkOiB0aGlzLmdldElkKCkgfSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyA1dGgtZ2VucywgYW5kIDZ0aC1nZW5zIG9uIGVhcmxpZXIgZmlybXdhcmUgdGhhdCBkb2Vzbid0IHN1cHBvcnQgZ2V0dGluZ1xyXG4gICAgICAgICAgICAvLyBleHRydWRlciBjb25maWdzIGZyb20ga2FpdGVuLlxyXG5cclxuICAgICAgICAgICAgLy8gRmlybXdhcmUgaXNzdWUgKGZ3IDIuNi4wKVxyXG4gICAgICAgICAgICAvLyBUb29sIGlkIDk5IHNoYXJlcyB0aGUgc2FtZSBzdXBwb3J0ZWRfZXh0cnVkZXIgbmFtZSwgbWsxMy5cclxuICAgICAgICAgICAgLy8gSG93ZXZlciBmb3IgRUUsIHNsaWNlY29uZmlnIHRyZWF0cyA5OSBhcyBtazEzX2V4cGVyaWVtZW50YWwuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIExldCB1cGRhdGVGcm9tU3lzdGVtSW5mbyBoYW5kbGUgdGhlIGNoYW5nZSBmb3IgdGhhdCBzY2VuYXJpby5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5pZCA9PT0gRVhQRVJJTUVOVEFMX0VYVFJVREVSKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9tYWNoaW5lQ29uZmlnLmV4dHJ1ZGVyX3Byb2ZpbGVzLmF0dGFjaGVkX2V4dHJ1ZGVyc1tpbmRleF0gPSBjb25maWc7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU5vdGlmaWNhdGlvbnMuZW1pdCgnbWFjaGluZV9jb25maWdfY2hhbmdlJywgdGhpcy5fbWFjaGluZUNvbmZpZyk7XHJcbiAgICAgICAgICAgIC8vIEZvciBhbGwgb3RoZXIgZXh0cnVkZXIgY2hhbmdlcyAoU21hcnQgRXh0cnVkZXIrIGFuZCBUb3VnaCBFeHRydWRlciksIGxvYWRTY2hlbWFcclxuICAgICAgICAgICAgLy8gbXVzdCBiZSBjYWxsZWQsIHNvIHRoYXQgdGhlIHByaW50IHNldHRpbmcgc3RvcmUgY2FuIGhhdmUgdGhlIG5ldyBzZXR0aW5ncy5cclxuICAgICAgICAgICAgdGhpcy5fZmx1eC5tYXAoZmx1eCA9PiBmbHV4LmFjdGlvbnMuUHJpbnRTZXR0aW5nc0FjdGlvbnMubG9hZFNjaGVtYSh7IGlkOiB0aGlzLmdldElkKCkgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfdXBkYXRlRnJvbU5ldHdvcmtTdGF0ZUNoYW5nZShzdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuX25ldHdvcmtTdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU5vdGlmaWNhdGlvbnMuZW1pdCgnbmV0d29ya19zdGF0ZV9jaGFuZ2UnLCBzdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVhdXRoZW50aWNhdGUodXNlcm5hbWUpIHtcclxuICAgICAgICBsZXQgZGVhdXRoUHJvbWlzZSA9IHEoKTtcclxuICAgICAgICBpZiAodXNlcm5hbWUgJiYgdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSAmJiB0aGlzLl9wcmludGVyLkRlYXV0aG9yaXplSXNTdXBwb3J0ZWQoKSlcclxuICAgICAgICAgICAgZGVhdXRoUHJvbWlzZSA9IHRoaXMuaW52b2tlKCdEZWF1dGhvcml6ZScsIFt1c2VybmFtZV0pO1xyXG5cclxuICAgICAgICBkZWF1dGhQcm9taXNlXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZG9uZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIF9md1ZlckRpY3RUb1N0cmluZyhmd1ZlckRpY3QpIHtcclxuICAgICAgICBpZiAoZndWZXJEaWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbZndWZXJEaWN0Lm1ham9yLCBmd1ZlckRpY3QubWlub3IsIGZ3VmVyRGljdC5idWdmaXgsIGZ3VmVyRGljdC5idWlsZF0uam9pbignLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZ2V0Rm9ybWF0dGVkUHJpbnRUaW1lKHRpbWVJblNlY29uZHMpIHtcclxuICAgICAgICAvLyBDb252ZXJ0IHNlY29uZHMgdG8gSEg6TU06U1NcclxuICAgICAgICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IodGltZUluU2Vjb25kcyAvIDM2MDApO1xyXG4gICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKCh0aW1lSW5TZWNvbmRzICUgMzYwMCkgLyA2MCk7XHJcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IHRpbWVJblNlY29uZHMgJSA2MDtcclxuICAgICAgICBjb25zdCBwcmludFRpbWUgPSBgJHtob3Vyc306JHttaW51dGVzfToke3NlY29uZHN9YDtcclxuICAgICAgICByZXR1cm4gcHJpbnRUaW1lO1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXRFeHRydWRlclR5cGVOYW1lKGV4dHJ1ZGVyQ29kZSwgZXh0cnVkZXJJbmRleCkge1xyXG4gICAgICAgIC8vIFVzZSB0aGUgY3VycmVudCBleHRydWRlckNvZGUgb3IgZ3JhYiB0aGUgZGVmYXVsdCBleHRydWRlckNvZGVcclxuICAgICAgICAvLyBmcm9tIFByaW50ZXJHZW5kZXJUb0RlZmF1bHRFeHRydWRlcnMgZW51bVxyXG4gICAgICAgIGNvbnN0IGN1cnJCb3RUeXBlID0gdGhpcy5fcHJpbnRlckluZm8uaW5mby5ib3RfdHlwZTtcclxuICAgICAgICBleHRydWRlckNvZGUgPSBleHRydWRlckNvZGUgfHwgUHJpbnRlckdlbmRlclRvRGVmYXVsdEV4dHJ1ZGVyc1tjdXJyQm90VHlwZV1bZXh0cnVkZXJJbmRleF07XHJcbiAgICAgICAgLy8gQ29udmVydCBleHRydWRlckNvZGUgdG8gcHJldHR5IG5hbWVcclxuICAgICAgICBjb25zdCBleHRydWRlclR5cGUgPSBFeHRydWRlclR5cGVUb1ByZXR0eU5hbWVbZXh0cnVkZXJDb2RlXTtcclxuICAgICAgICByZXR1cm4gZXh0cnVkZXJUeXBlO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVByaW50ZXJTdGF0dXMoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc2VsZi5fbGFzdFNpZ25PZkxpZmUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0dXMoKS5zdGF0ZTtcclxuXHJcbiAgICAgICAgaWYgKHN0YXRlID09PSBQcmludGVyU3RhdGVFbnVtLkJ1c3kgfHwgc3RhdGUgPT09IFByaW50ZXJTdGF0ZUVudW0uUGVuZGluZyB8fCBzdGF0ZSA9PT0gUHJpbnRlclN0YXRlRW51bS5JZGxlKSB7XHJcbiAgICAgICAgICAgIGlmICgnY3VycmVudF9wcm9jZXNzJyBpbiBzZWxmLmN1cnJlbnRTdGF0ZSAmJiBzZWxmLmN1cnJlbnRTdGF0ZS5jdXJyZW50X3Byb2Nlc3MgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNwID0gc2VsZi5jdXJyZW50U3RhdGUuY3VycmVudF9wcm9jZXNzO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRTdGF0ZShQcmludGVyU3RhdGVFbnVtLkJ1c3kpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5faW5mby5wcmludGVyX3N0YXR1cy5jdXJyZW50X3Byb2Nlc3MgPSBjcDtcclxuICAgICAgICAgICAgICAgIGlmIChjcC5uYW1lID09ICdQcmludFByb2Nlc3MnICYmIGNwLnN0ZXAgPT0gJ3ByaW50aW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2luZm8ucHJpbnRlcl9zdGF0dXMuY3VycmVudF9wcmludF9qb2IucGVyY2VudF9kb25lID0gY3AucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFib3ZlIGxvZ2ljIHNlZW1zIHRvIGJlIGluY29ycmVjdC4gRnJvbSB0aGUgS2FpdGVuIEFQSSBkb2MsXHJcbiAgICAgICAgICAgICAgICAvLyBpdCBhcHBlYXJzIHRoYXQgc3RhdGUgY2hhbmdlIGVycm9ycyBkbyBub3QgZ2V0IGNsZWFyZWQgb3V0IGJ5XHJcbiAgICAgICAgICAgICAgICAvLyBlcnJvcl9hY2tub3dsZWRnZWQgbm90aWZpY2F0aW9uLiBTbywgaWYgd2UgcHV0IHRoZW0gaW4gZXJyb3JzIG1hcFxyXG4gICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRvIGhhdmUgc3BlY2lhbCBsb2dpYyB0byBjbGVhciB0aGVtIG91dC4gSW5mYWN0LFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgbWF5IG5vdCBldmVyIGNsZWFyIHN0YXRlIGNoYW5nZSBlcnJvcnMgYmVjYXVzZSB0aGUgb25seSB3YXlcclxuICAgICAgICAgICAgICAgIC8vIHdlIGNsZWFyIHN0YXRlIGNoYW5nZSBlcnJvcnMgaXMgd2hlbiB3ZSBnZXQgYSBzdGF0ZSBub3RpZmljYXRpb25cclxuICAgICAgICAgICAgICAgIC8vIHdpdGggbnVsbCBlcnJvcnMuLi53aXRoIG5vIGluZGljYXRpb24gb2YgdGhlIGVycm9yX2lkIHRvIGNsZWFyXHJcbiAgICAgICAgICAgICAgICAvLyBFeHBlcmltZW50aW5nIHdpdGggZm9sbG93aW5nIHNvbHV0aW9uIGZvciB0aGlzIG1lc3N5IHNpdHVhdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC0gcHV0IGFsbCBlcnJvcnMgKGVycm9yIG5vdGlmaWNhdGlvbnMgYW5kIHN0YXRlIGNoYW5nZSBlcnJvcnMpXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICBpbiBlcnJvcnMgbWFwXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLSBhbHNvIHJlbWVtYmVyIHN0YXRlIGNoYW5nZSBlcnJvcnMgc2VwYXJhdGVseS4gV2hlbiB3ZSBnZXRcclxuICAgICAgICAgICAgICAgIC8vICAgICAgIGEgc3RhdGUgbm90aWZpY2F0aW9uIHdpdGggbm8gZXJyb3JzLCB1c2UgdGhlIHN0b3JlZCBlcnJvciBpZFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgdG8gY2xlYXIgZnJvbSB0aGUgZXJyb3IgbWFwXHJcbiAgICAgICAgICAgICAgICBpZiAoY3AuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNhdmVTdGF0ZUVycm9yKGNwLmVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhclN0YXRlRXJyb3JzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLl91cGRhdGVOb3RpZmljYXRpb25zLmVtaXQoJ3N0YXR1cycsIHt9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXgubWFwKGZsdXggPT4gZmx1eC5hY3Rpb25zLlByaW50ZXJEZXRhaWxzQWN0aW9ucy5zdGF0dXMoc2VsZi5nZXRJZCgpLCB7fSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRTdGF0ZShQcmludGVyU3RhdGVFbnVtLklkbGUpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5faW5mby5wcmludGVyX3N0YXR1cy5jdXJyZW50X3ByaW50X2pvYiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5faW5mby5wcmludGVyX3N0YXR1cy5jdXJyZW50X3Byb2Nlc3MgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5faW5mby5wcmludGVyX3N0YXR1cy5jdXJyZW50X3ByaW50X2pvYi5wZXJjZW50X2RvbmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jbGVhclN0YXRlRXJyb3JzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCd0b29saGVhZHMnIGluIHNlbGYuY3VycmVudFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9pbmZvLnByaW50ZXJfc3RhdHVzLnRvb2xoZWFkcyA9IHNlbGYuY3VycmVudFN0YXRlLnRvb2xoZWFkcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVGcm9tUHJpbnRlckluZm8ocHJpbnRlckluZm8pIHtcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKHNlbGYuX3ByaW50ZXIpIHtcclxuICAgICAgICAgICAgLy8gU2VwYXJhdGUga2FpdGVuIGNhbGwgdG8gZ2V0IENsb3VkU2VydmljZSBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICBxKHNlbGYuX3ByaW50ZXIuR2V0Q2xvdWRTZXJ2aWNlc0luZm8oKSkudGhlbihjbG91ZFNlcnZpY2VzSW5mbyA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9wcmludGVySW5mby5pbmZvID0gXy5hc3NpZ24oc2VsZi5fcHJpbnRlckluZm8uaW5mbywgY2xvdWRTZXJ2aWNlc0luZm8pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuX3ByaW50ZXJJbmZvLmluZm8gPSBfLmFzc2lnbihzZWxmLl9wcmludGVySW5mby5pbmZvLCBwcmludGVySW5mby5pbmZvKTtcclxuICAgICAgICBfLmZvck93bihwcmludGVySW5mbywgKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgLy8gdGhpcyBkaXNhbGxvd3MgZW1wdHkgYm90IG5hbWVzL2FkZHJlc3Nlcy91aWRzLCBidXQgdGhhdFxyXG4gICAgICAgICAgICAvLyB3b3VsZCBiZSBzaWxseSBhbnl3YXlzLi4uXHJcbiAgICAgICAgICAgIGlmIChfLmdldChwcmludGVySW5mbywga2V5KSAmJiBrZXkgIT09ICdpbmZvJykge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fcHJpbnRlckluZm9ba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNlbGYudXBkYXRlUHJpbnRlclN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldENhbWVyYUZlZWQoY2FtZXJhRnJhbWVDYWxsYmFjaykge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcmludGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgc2VsZi5fY2FtZXJhRmVlZEFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHNlbGYuX3ByaW50ZXIuc2V0Q2FtZXJhRnJhbWVOb3RpZmljYXRpb24oZnVuY3Rpb24oZnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lQnVmID0gbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShmcmFtZSksICdiaW5hcnknKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGJpbmFyeSBkYXRhIHRvIGJhc2U2NCBmb3IgZGlzcGxheWluZ1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJhbWVBc0I2NCA9IGBkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCR7ZnJhbWVCdWYudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5jaGVja0pwZWcoZnJhbWVCdWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FtZXJhRnJhbWVDYWxsYmFjayhmcmFtZUFzQjY0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlY2VpdmVkIGNvcnJ1cHQgY2FtZXJhIGZyYW1lOiAke2ZyYW1lQXNCNjR9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcShzZWxmLmludm9rZSgnUmVxdWVzdENhbWVyYVN0cmVhbScpKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2NhbWVyYUZlZWRBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmRvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZW5kQ2FtZXJhRmVlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcHJpbnRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgcShzZWxmLmludm9rZSgnRW5kQ2FtZXJhU3RyZWFtJykpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jYW1lcmFGZWVkQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJpbnRlci51bnNldENhbWVyYUZyYW1lTm90aWZpY2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpXHJcbiAgICAgICAgICAgICAgICAuZG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjaGVja0F1dGhlbnRpY2F0ZWQoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFzZWxmLmlzQXV0aGVudGljYXRlZCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcigpO1xyXG4gICAgICAgICAgICBlcnIudHlwZSA9ICdVbmF1dGhlbnRpY2F0ZWRFcnJvcic7XHJcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gJ1ByaW50ZXIgaXMgVW5hdXRoZW50aWNhdGVkIG9yIE9mZmxpbmUnO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUZyb21TeXN0ZW1JbmZvKGluZm8pIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAoQ3VycmVudGx5IGluIFNvbWJyZXJvIGZpcm13YXJlIDAuNTQuMS4yMTYgYW5kIGluIHRoZSBkaXN0YW50XHJcbiAgICAgICAgICogZnV0dXJlLi4uKSAndXBkYXRlU3Bvb2xNYXRlcmlhbHNGcm9tU3lzdGVtSW5mbycgaXMgYW5vdGhlciBoYWNrXHJcbiAgICAgICAgICogYXJvdW5kIHNpbmNlIGthaXRlbiBpcyBub3QgZW1pdHRpbmcgYSBub3RpZmljYXRpb24gZm9yIHNwb29sXHJcbiAgICAgICAgICogY2hhbmdlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEZvciBub3csIHVwZGF0ZSBzcG9vbEluZm8gaW4gcHJpbnRTZXR0aW5nc1N0b3JlIHdoZW4gdGhlcmUgaXMgYVxyXG4gICAgICAgICAqIGRpZmZlcmVuY2UgYmV0d2VlbiB0YWdfdWlkKHMpIG9yIHdoZW4gYSBwcmludGVyIGNvbWVzIGJhY2sgb25saW5lLlxyXG4gICAgICAgICAqIENoZWNrICd1cGRhdGVTcG9vbE1hdGVyaWFsc09uY2VBbGl2ZScuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiA6OmVlbHJvbGw6OlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLS0gUmF5IHhveG94b1xyXG4gICAgICAgICAqKi9cclxuICAgICAgICB0aGlzLnVwZGF0ZVNwb29sTWF0ZXJpYWxzRnJvbVN5c3RlbUluZm8oaW5mbyk7XHJcblxyXG4gICAgICAgIC8vIEN1cnJlbnQgQmlyZHdpbmcgRmlybXdhcmUgKDIuNi4wKSBkb2Vzbid0IHJlY29uZ2l6ZSBleHBlcmltZW50YWxcclxuICAgICAgICAvLyBleHRydWRlciAodG9vbF9pZDogOTkpIGFzIGFuIGV4dHJ1ZGVyIGNoYW5nZSBhbmQgd29uJ3QgdGhyb3cgYW5cclxuICAgICAgICAvLyBleHRydWRlciBjaGFuZ2Ugbm90aWZpY2F0aW9uLiBUaGlzIGlzIGEgd29yayBhcm91bmQgZm9yIHRoYXQgaXNzdWUuXHJcbiAgICAgICAgaW5mby50b29saGVhZHMuZXh0cnVkZXIubWFwKGV4dHJ1ZGVyID0+IHtcclxuICAgICAgICAgICAgLy8gZXNjYXBlIGhhdGNoIGZvciB3aGVuIHRoZXJlJ3Mgbm8gbWFjaGluZSBjb25maWdcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9tYWNoaW5lQ29uZmlnKSByZXR1cm47XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBwb2ludGVyIHRvIHRoZSBleHRydWRlciEgbXV0YXRpbmcgaXQgd2lsbCBtdXRhdGVcclxuICAgICAgICAgICAgLy8gX21hY2hpbmVDb25maWchXHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZUb29sID0gdGhpcy5fbWFjaGluZUNvbmZpZy5leHRydWRlcl9wcm9maWxlcy5hdHRhY2hlZF9leHRydWRlcnNbZXh0cnVkZXIuaW5kZXhdO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyVG9vbElkID0gZXh0cnVkZXIudG9vbF9pZDtcclxuXHJcbiAgICAgICAgICAgIGlmIChjdXJyVG9vbElkICE9PSAwICYmIGN1cnJUb29sSWQgIT09IHByZXZUb29sLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMb29rcyBsaWtlIG1hY2hpbmVfY29uZmlnIHVwZGF0ZXMgdGhlIGF0dGFjaGVkX2V4dHJ1ZGVyXHJcbiAgICAgICAgICAgICAgICAvLyBjYWxpYnJhdGVkIGZsYWcgZXZlbiB0aG91Z2ggdGhlIHRvb2xoZWFkIGlkcyBhcmUgZGlmZmVyZW50XHJcbiAgICAgICAgICAgICAgICBwcmV2VG9vbC5pZCA9IGN1cnJUb29sSWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVOb3RpZmljYXRpb25zLmVtaXQoJ21hY2hpbmVfY29uZmlnX2NoYW5nZScsIHRoaXMuX21hY2hpbmVDb25maWcpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGxvdXQgdG8gbG9hZFNjaGVtYSB0byBmaWx0ZXIgb3V0IGFueSB1c2VyX3NldHRpbmdzIHZzXHJcbiAgICAgICAgICAgICAgICAvLyBhdmFpbGFibGVfc2V0dGluZ3MgaW4gcHJpbnRTZXR0aW5nc1N0b3JlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mbHV4Lm1hcChmbHV4ID0+IGZsdXguYWN0aW9ucy5QcmludFNldHRpbmdzQWN0aW9ucy5sb2FkU2NoZW1hKHsgaWQ6IHRoaXMuZ2V0SWQoKSB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGhhc0V4cGVyaW1lbnRhbCA9IHRoaXMuX21hY2hpbmVDb25maWcuZXh0cnVkZXJfcHJvZmlsZXMuYXR0YWNoZWRfZXh0cnVkZXJzLnJlZHVjZShcclxuICAgICAgICAgICAgICAgIChhY2MsIGUpID0+IGFjYyB8fCBlLmlkID09PSBFWFBFUklNRU5UQUxfRVhUUlVERVIsXHJcbiAgICAgICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhhc0V4cGVyaW1lbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmx1eC5tYXAoZmx1eCA9PiBmbHV4LmFjdGlvbnMuUHJpbnRlckRldGFpbHNBY3Rpb25zLnNob3dFRVRlcm1zQW5kQ29uZGl0aW9ucygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBwcmludGVySW5mbyA9IG5ldyBjcm9pc3NhbnQuUHJpbnRlckluZm8oKTtcclxuICAgICAgICBwcmludGVySW5mby5uYW1lID0gaW5mby5tYWNoaW5lX25hbWU7XHJcbiAgICAgICAgcHJpbnRlckluZm8uYWRkcmVzcyA9IHRoaXMuX3ByaW50ZXJJbmZvLmFkZHJlc3M7XHJcbiAgICAgICAgcHJpbnRlckluZm8udWlkID0gdGhpcy5fcHJpbnRlckluZm8udWlkO1xyXG4gICAgICAgIHByaW50ZXJJbmZvLmluZm8gPSBpbmZvO1xyXG4gICAgICAgIHByaW50ZXJJbmZvLmNvbm5UeXBlID0gcGFyc2VDb25uVHlwZSh0aGlzLl9wcmludGVySW5mbyk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tUHJpbnRlckluZm8ocHJpbnRlckluZm8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVtcG9yYXJ5L1Blcm1hbmVudCBoYWNrIGZvciBkZXRlY3Rpbmcgc3Bvb2wgY2hhbmdlc1xyXG4gICAgICogYmFzZWQgb24gc3lzdGVtSW5mbyB1cGRhdGVzLlxyXG4gICAgICpcclxuICAgICAqIFRoZXJlIGFyZSBpc3N1ZXMgd2l0aCB0aGlzIGhhY2suIE9uIHNwb29sIGNoYW5nZXMsIGl0XHJcbiAgICAgKiBkb2VzIGdldCBjYWxsZWQgdHdpY2UgaW4gYSByb3cuIFRoZSBzZWNvbmQgY2FsbCwgaXQgd2lsbFxyXG4gICAgICogZGV0ZWN0IGFuIGVtcHR5IHNwb29sLCBidXQgdGhlIHNlbGVjdGVkTWF0ZXJpYWxzXHJcbiAgICAgKiBpbiBQcmludFNldHRpbmdzU3RvcmUgd2lsbCByZW1haW4gdW5hZmZlY3RlZC5cclxuICAgICAqXHJcbiAgICAgKiAtLSBSYXlcclxuICAgICAqKi9cclxuICAgIHVwZGF0ZVNwb29sTWF0ZXJpYWxzRnJvbVN5c3RlbUluZm8oaW5mbykge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1NpeHRoR2VuKCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gcGF0Y2ggd29yayB0byBieXBhc3MgdGhpcyBjaGVjayBmb3Igc3Bvb2wgbWF0ZXJpYWwgdW50aWxcclxuICAgICAgICAvLyB0aGUgb2xkIF9wcmludGVySW5mby5pbmZvIGdldHMgdXBkYXRlZCB3aXRoIHNwb29sIG1hdGVyaWFsXHJcbiAgICAgICAgLy8gLS1SYXlcclxuICAgICAgICBsZXQgb2xkVGFnVWlkcyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLl9wcmludGVySW5mby5pbmZvLmZpbGFtZW50YmF5cykge1xyXG4gICAgICAgICAgICBvbGRUYWdVaWRzID0gdGhpcy5fcHJpbnRlckluZm8uaW5mby5maWxhbWVudGJheXMubWFwKGJheSA9PiBiYXkudGFnX3VpZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbmV3VGFnVWlkcyA9IGluZm8uZmlsYW1lbnRiYXlzLm1hcChiYXkgPT4gYmF5LnRhZ191aWQpO1xyXG5cclxuICAgICAgICBpZiAoIV8uaXNFcXVhbChvbGRUYWdVaWRzLCBuZXdUYWdVaWRzKSkge1xyXG4gICAgICAgICAgICAvKiogT0xEIDEuM3YgTWV0aG9kL01ldGhvZFggc3VwcG9ydCAqKi9cclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NpeHRoR2VuKCkgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0ZWQoKSAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlQ3VyckFwaVZlcnNpb25XaXRoKCcxLjExLjAnKSA8IDFcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcG9vbHNJbmZvUHJvbWlzZXMgPSBuZXdUYWdVaWRzLm1hcCgodGFnX3VpZCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja1Nwb29sVGFnVWlkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcG9vbEluZm9Qcm9taXNlID0gdGhpcy5pbnZva2UoJ0dldFNwb29sSW5mbycsIFtpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Bvb2xJbmZvUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwb29sSW5mb1Byb21pc2UudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudGFnX3VpZCAhPT0gdGFnX3VpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tTcG9vbFRhZ1VpZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1Nwb29sVGFnVWlkKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBxLmFsbChzcG9vbHNJbmZvUHJvbWlzZXMpLnRoZW4oc3Bvb2xzSW5mbyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmx1eC5tYXAoZmx1eCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXguYWN0aW9ucy5QcmludFNldHRpbmdzQWN0aW9ucy51cGRhdGVNYXRlcmlhbHMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0SWQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwb29sc0luZm8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBrZWVwIGludm9raW5nICdHZXRTcG9vbHNJbmZvJyB1bnRpbCB0aGUgUkZJRCByZWFkZXJcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgYSByZXN1bHQgd2l0aCBtYXRjaGluZyB0YWdfdWlkXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja1Nwb29sVGFnVWlkcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnZva2UoJ0dldFNwb29sc0luZm8nKS50aGVuKHNwb29sc0luZm8gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRUYWdVaWRzID0gc3Bvb2xzSW5mby5tYXAoc3Bvb2xJbmZvID0+IHNwb29sSW5mby50YWdfdWlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmlzRXF1YWwocmVzdWx0VGFnVWlkcywgbmV3VGFnVWlkcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1Nwb29sVGFnVWlkcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwb29sc0luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgY2hlY2tTcG9vbFRhZ1VpZHMoKS50aGVuKHNwb29sc0luZm8gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXgubWFwKGZsdXggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbHV4LmFjdGlvbnMuUHJpbnRTZXR0aW5nc0FjdGlvbnMudXBkYXRlTWF0ZXJpYWxzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLmdldElkKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcG9vbHNJbmZvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbXBhcmUgUHJpbnRlcidzIENyb2lzc2FudCBBUEkgdmVyc2lvbiB3aXRoIGEgXCJjdXRvZmZcIiB2ZXJzaW9uXHJcbiAgICBjb21wYXJlQ3VyckFwaVZlcnNpb25XaXRoKGN1dG9mZkFwaVN0cikge1xyXG4gICAgICAgIGNvbnN0IGN1cnJBcGlTdHIgPSB0aGlzLl9wcmludGVySW5mby5pbmZvLmFwaV92ZXJzaW9uO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVWZXJzaW9ucyhjdXJyQXBpU3RyLCBjdXRvZmZBcGlTdHIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUYWtlcyBjdXJyZW50IGFuZCBjdXRvZmYgdmVyc2lvbiBudW1iZXJzIGluIG1ham9yLm1pbm9yLmJ1Z2ZpeCBmb3JtYXQsIGFuZFxyXG4gICAgICogYnJlYWtzIHRoZW0gZG93biBhbmQgY29tcGFyZXMgdGhlbS5cclxuICAgICAqXHJcbiAgICAgKiByZXR1cm4gMSAgaWYgY3VycmVudCB2ZXJzaW9uIGdyZWF0ZXIgdGhhbiB0aGUgY3V0b2ZmIHZlcnNpb25cclxuICAgICAqIHJldHVybiAwICBpZiBjdXJyZW50IHZlcnNpb24gbWF0Y2hlcyB0aGUgY3V0b2ZmIHZlcnNpb25cclxuICAgICAqIHJldHVybiAtMSBpZiBjdXJyZW50IHZlcnNpb24gbGVzcyB0aGFuIHRoZSBjdXR0b2ZmIHZlcnNpb25cclxuICAgICAqL1xyXG4gICAgY29tcGFyZVZlcnNpb25zKGN1cnJlbnQsIGN1dG9mZikge1xyXG4gICAgICAgIGlmIChjdXRvZmYgPT09IGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjdXRvZmZBcnIgPSBjdXRvZmYuc3BsaXQoJy4nKTtcclxuICAgICAgICBjb25zdCBjdXJyQXJyID0gY3VycmVudC5zcGxpdCgnLicpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJBcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gQ3VycmVudCB2ZXJzaW9uIGJpZ2dlciB0aGFuIEN1dG9mZiB2ZXJzaW9uXHJcbiAgICAgICAgICAgIGlmIChwYXJzZUludChjdXJyQXJyW2ldKSA+IHBhcnNlSW50KGN1dG9mZkFycltpXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDdXRvZmYgdmVyc2lvbiBiaWdnZXIgdGhhbiBDdXJyZW50IHZlcnNpb25cclxuICAgICAgICAgICAgaWYgKHBhcnNlSW50KGN1cnJBcnJbaV0pIDwgcGFyc2VJbnQoY3V0b2ZmQXJyW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UgdGhleSBhcmUgdGhlIHNhbWUuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIG1ldGhvZCB0byBjYWxsIG91dCB0byBvbkdldFByaW50ZXJTY2hlbWEgaW4gUHJpbnRTZXR0aW5nc1N0b3JlIHZpYVxyXG4gICAgICogUHJpbnRTZXR0aW5nc0FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHdpbGwgYmUgY2FsbGVkIHVwb24gY29ubmVjdGlvbiBjaGFuZ2VkIGFuZCBzaG91bGQgY292ZXIgdGhlXHJcbiAgICAgKiBzY2VuYXJpbyBvZiB3aGVuIGEgcHJpbnRlciBjb21lcyBvbmxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogLS0gUmF5XHJcbiAgICAgKiovXHJcbiAgICB1cGRhdGVTcG9vbE1hdGVyaWFsc09uY2VBbGl2ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNTaXh0aEdlbigpKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8qKiBPTEQgMS4zdiBNZXRob2QvTWV0aG9kWCBzdXBwb3J0ICoqL1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgdGhpcy5pc1NpeHRoR2VuKCkgJiZcclxuICAgICAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCgpICYmXHJcbiAgICAgICAgICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkKCkgJiZcclxuICAgICAgICAgICAgdGhpcy5jb21wYXJlQ3VyckFwaVZlcnNpb25XaXRoKCcxLjExLjAnKSA8IDBcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgY29uc3Qgc3Bvb2xzSW5mb1Byb21pc2UgPSBbMCwgMV0ubWFwKGJheUluZGV4ID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludm9rZSgnR2V0U3Bvb2xJbmZvJywgW2JheUluZGV4XSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBxLmFsbChzcG9vbHNJbmZvUHJvbWlzZSkudGhlbihzcG9vbHNJbmZvID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXgubWFwKGZsdXggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsdXguYWN0aW9ucy5QcmludFNldHRpbmdzQWN0aW9ucy51cGRhdGVNYXRlcmlhbHMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5nZXRJZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcG9vbHNJbmZvLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW52b2tlKCdHZXRTcG9vbHNJbmZvJykudGhlbihzcG9vbHNJbmZvID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXgubWFwKGZsdXggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsdXguYWN0aW9ucy5QcmludFNldHRpbmdzQWN0aW9ucy51cGRhdGVNYXRlcmlhbHMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5nZXRJZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcG9vbHNJbmZvLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjaGVja0ZvclVuc3VwcG9ydGVkRXh0cnVkZXJDb25maWd1cmF0aW9ucygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNTaXh0aEdlbigpIHx8ICF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGV4dHJ1ZGVyU2V0dXBFcnJvcjogZmFsc2UsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZsdXhcclxuICAgICAgICAgICAgICAgIC5tYXAoZmx1eCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaW50ZXJTdG9yZSA9IGZsdXguc3RvcmUoJ1ByaW50ZXJTdG9yZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkUHJpbnRlciA9IHByaW50ZXJTdG9yZS5nZXRTZWxlY3RlZFByaW50ZXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqIFVwZGF0ZSBOb3YgN3RoIDIwMTlcclxuICAgICAgICAgICAgICAgICAgICAgKiBBcyBvZiBmaXJtd2FyZSAxLjQuMC4zNDQsIGdldF9leHRydWRlcnNfY29uZmlncygpIHdpbGxcclxuICAgICAgICAgICAgICAgICAgICAgKiBub3cgcHJvdmlkZSBpbmZvcm1hdGlvbiBpZiBleHRydWRlciBzbG90IGhhcyBpbmNvcnJlY3RcclxuICAgICAgICAgICAgICAgICAgICAgKiBleHRydWRlci9tYXRlcmlhbC5cclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEVYRUNQVCBBVE0gbWF0ZXJpYWwgaW5mb3JtYXRpb24gaXMgbm90IGF2YWlsYWJsZSB3aXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIGxhdGVzdCAxLjQgUkMuXHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiBGWUkgLSBleHRydWRlciB1cGRhdGUgbm90aWZpY2F0aW9uIHdpbGwgdXBkYXRlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIG1hY2hpbmVfY29uZmlnLmV4dHJ1ZGVyX3Byb2ZpbGVzLmF0dGFjaGVkX2V4dHJ1ZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAqIHByb2ZpbGVzLiBDaGVjayBfdXBkYXRlRnJvbUV4dHJ1ZGVyQ2hhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgICoqL1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc1Vuc3VwcG9ydGVkRXh0cnVkZXJDb25maWdzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX21hY2hpbmVDb25maWcpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hY2hpbmVDb25maWcuZXh0cnVkZXJfcHJvZmlsZXMuYXR0YWNoZWRfZXh0cnVkZXJzLnJlZHVjZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXMsIGV4dHJ1ZGVyQ29uZmlnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleHRydWRlckNvbmZpZy5jYW5fcGFpcl90b29scykgcmVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTWlzbWF0Y2hlZEV4dHJ1ZGVyQ29uZmlncyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hY2hpbmVDb25maWcgPT09IG51bGwpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWNoaW5lQ29uZmlnLmV4dHJ1ZGVyX3Byb2ZpbGVzLmF0dGFjaGVkX2V4dHJ1ZGVycy5yZWR1Y2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzLCBleHRydWRlckNvbmZpZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXh0cnVkZXJDb25maWcuY2FuX2R1YWxfcHJpbnQpIHJlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc01pc3NpbmdUb29saGVhZHMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE51bGwgY2hlY2tpbmcgd2l0aCBwcmludGVySW5mby5pbmZvLnRvb2xoZWFkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXBwZW5zIG9uIGZpcnN0IHRpbWUgY29ubmVjdGlvbnMgd2l0aCBzb21icmVybyBwcmludGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3ByaW50ZXJJbmZvLmluZm8udG9vbGhlYWRzKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJpbnRlckluZm8uaW5mby50b29saGVhZHMuZXh0cnVkZXIucmVkdWNlKChyZXMsIGV4dHJ1ZGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dHJ1ZGVyLnRvb2xfcHJlc2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldFN1cHBvcnRlZFBhaXJlZEV4dHJ1ZGVyc0NvbmZpZ3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWNoaW5lQ29uZmlnLmV4dHJ1ZGVyX3Byb2ZpbGVzLmF0dGFjaGVkX2V4dHJ1ZGVycy5yZWR1Y2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzLCBleHRydWRlckluZm8sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhbGxfZHVhbF90b29sX3R5cGVzIH0gPSBleHRydWRlckluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIExBQlMgZXh0cnVkZXIgZnJvbSB0aGUgY29uZmlnIGxpc3QsIHNpbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgaGFzIGl0cyBvd24gcnVsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRydWRlcnNGb3JUaGlzSW5kZXggPSBhbGxfZHVhbF90b29sX3R5cGVzLmZpbHRlcihleHRydWRlciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRydWRlciAhPT0gRXh0cnVkZXJUeXBlRW51bS5tazE0X2UpIHJldHVybiBleHRydWRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cnVkZXJzRm9yVGhpc0luZGV4LmZvckVhY2goKGV4dHJ1ZGVyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzW2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2luZGV4XS5wdXNoKGV4dHJ1ZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc1tpbmRleF0gPSBbZXh0cnVkZXJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldFN1cHBvcnRlZFBlckV4dHJ1ZGVyQ29uZmlncyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hY2hpbmVDb25maWcuZXh0cnVkZXJfcHJvZmlsZXMuYXR0YWNoZWRfZXh0cnVkZXJzLm1hcChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJ1ZGVyQ29uZmlnID0+IGV4dHJ1ZGVyQ29uZmlnLmFsbF9kdWFsX3Rvb2xfdHlwZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZXRFcnJvclR5cGVQZXJFeHRydWRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3JkZXIgb2YgRXJyb3IgUHJpb3JpdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWlzc2luZyBFeHRydWRlciA+IFVuc3VwcG9ydGVkIEV4dHJ1ZGVyID4gTWlzbWF0Y2hlZCBFeHRydWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29saGVhZEVycm9yUHJpb3JpdHkgPSBbJ21pc3NpbmcnLCAndW5zdXBwb3J0ZWQnLCAnbWlzbWF0Y2hlZCddO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaW50ZXJJbmZvLmluZm8udG9vbGhlYWRzLmV4dHJ1ZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFwIGVhY2ggZXh0cnVkZXJJbmZvL2V4dHJ1ZGVyQ29uZmlnIHRvIHRoZSB0aHJlZSBwb3NzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIHN0YXR1cyBjb250YWluZWQgaW4gb25lIGFycmF5OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFsgICAgMCAgLCAgICAgMSAgICAgLCAgICAgIDIgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbbWlzc2luZywgdW5zdXBwb3J0ZWQsIG1pc21hdGNoZWRdID0+IHNsb3QgMSBleHRydWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFttaXNzaW5nLCB1bnN1cHBvcnRlZCwgbWlzbWF0Y2hlZF0gPT4gc2xvdCAyIGV4dHJ1ZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoZXh0cnVkZXJJbmZvLCBleHRydWRlckluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJ1ZGVyQ29uZmlnID0gdGhpcy5fbWFjaGluZUNvbmZpZy5leHRydWRlcl9wcm9maWxlcy5hdHRhY2hlZF9leHRydWRlcnNbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRydWRlckluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzEsIDIsIDNdLm1hcCh2YWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBtaXNzaW5nIGV4dHJ1ZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAhZXh0cnVkZXJJbmZvLnRvb2xfcHJlc2VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHVuc3VwcG9ydGVkIGV4dHJ1ZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWV4dHJ1ZGVyQ29uZmlnLmNhbl9wYWlyX3Rvb2xzICYmIGV4dHJ1ZGVyQ29uZmlnLmNhbl9kdWFsX3ByaW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgbWlzbWF0Y2ggZXh0cnVkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZXh0cnVkZXJDb25maWcuY2FuX3BhaXJfdG9vbHMgJiYgIWV4dHJ1ZGVyQ29uZmlnLmNhbl9kdWFsX3ByaW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSBlYWNoIGV4dHJ1ZGVyJ3MgYXJyYXkgcmVzdWx0cyB0byB0b29saGVhZCBlcnJvciBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHJlc3VsdHMgPT4gdG9vbGhlYWRFcnJvclByaW9yaXR5W3Jlc3VsdHMuZmluZEluZGV4KHJlcyA9PiAhIXJlcyldIHx8ICdub25lJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGJsb2NrIHVzZXIgaWYgY3VycmVudCBib3QgY29udGFpbnMgdW5zdXBwb3J0ZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBleHRydWRlciBjb25maWd1cmF0aW9uLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkUHJpbnRlciAmJiBzZWxlY3RlZFByaW50ZXIuZ2V0SWQoKSAhPT0gdGhpcy5nZXRJZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuZXh0cnVkZXJTZXR1cEVycm9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1NpeHRoR2VuKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wYXJlQ3VyckFwaVZlcnNpb25XaXRoKCcxLjExLjAnKSA8IDBcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIE9MRCAxLjN2IE1ldGhvZC9NZXRob2RYIHN1cHBvcnQgKiovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc1Vuc3VwcG9ydGVkRXh0cnVkZXJDb25maWdzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW50ZXJJbmZvLmluZm8udG9vbGhlYWRzLmV4dHJ1ZGVyLnJlZHVjZSgocmVzLCBleHRydWRlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXh0cnVkZXIudG9vbF90eXBlX2NvcnJlY3QgfHwgIWV4dHJ1ZGVyLnRvb2xfcHJlc2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByaW50ZXJJbmZvLmluZm8udG9vbGhlYWRzICYmIGhhc1Vuc3VwcG9ydGVkRXh0cnVkZXJDb25maWdzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9yZGVyIG9mIEVycm9yIFByaW9yaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIEV4dHJ1ZGVyID4gVW5zdXBwb3J0ZWQgRXh0cnVkZXIgPiBNaXNtYXRjaGVkIEV4dHJ1ZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29saGVhZEVycm9yUHJpb3JpdHkgPSBbJ21pc3NpbmcnLCAndW5zdXBwb3J0ZWQnLCAnbWlzbWF0Y2hlZCddO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuZXh0cnVkZXJTZXR1cEVycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQucGVyRXh0cnVkZXJFcnJvclR5cGUgPSB0aGlzLl9wcmludGVySW5mby5pbmZvLnRvb2xoZWFkcy5leHRydWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZXh0cnVkZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzEsIDIsIDNdLm1hcCh2YWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIGhhbmRsaW5nIGZvciBtaXNzaW5nIGV4dHJ1ZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gIWV4dHJ1ZGVyLnRvb2xfcHJlc2VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4zdiBmdyBkb2Vzbid0IHJlcG9ydCB1bnN1cHBvcnRlZCBleHRydWRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFcnJvciBoYW5kbGluZyBmb3IgbWlzbWF0Y2ggZXh0cnVkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAhZXh0cnVkZXIudG9vbF90eXBlX2NvcnJlY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIC8vIHRyYW5zbGF0ZSBlYWNoIGV4dHJ1ZGVyJ3MgYXJyYXkgcmVzdWx0cyB0byB0b29saGVhZCBlcnJvciBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHJlc3VsdHMgPT4gdG9vbGhlYWRFcnJvclByaW9yaXR5W3Jlc3VsdHMuZmluZEluZGV4KHJlcyA9PiAhIXJlcyldIHx8ICdub25lJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXJkY29kZSB0aGUgc3VwcG9ydGVkIGV4dHJ1ZGVyIGNvbmZpZ3VyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnN1cHBvcnRlZENvbmZpZ3MgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaW50ZXJJbmZvLmluZm8uYm90X3R5cGUgPT09IEJvdFR5cGVFbnVtLmZpcmVfZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFpcmVkRXh0cnVkZXJzQ29uZmlnczogW1snbWsxNCcsICdtazE0X3MnXV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlckV4dHJ1ZGVyQ29uZmlnczogW1snbWsxNCddLCBbJ21rMTRfcyddXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWlyZWRFeHRydWRlcnNDb25maWdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ21rMTQnLCAnbWsxNF9zJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ21rMTRfaG90JywgJ21rMTRfaG90X3MnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyRXh0cnVkZXJDb25maWdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ21rMTQnLCAnbWsxNF9ob3QnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsnbWsxNF9zJywgJ21rMTRfaG90X3MnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5leHRydWRlclNldHVwRXJyb3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTaXh0aEdlbigpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29ubmVjdGVkKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaW50ZXJJbmZvLmluZm8udG9vbGhlYWRzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWNoaW5lQ29uZmlnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaGFzTWlzc2luZ1Rvb2xoZWFkcygpIHx8IGhhc01pc21hdGNoZWRFeHRydWRlckNvbmZpZ3MoKSB8fCBoYXNVbnN1cHBvcnRlZEV4dHJ1ZGVyQ29uZmlncygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuZXh0cnVkZXJTZXR1cEVycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQucGVyRXh0cnVkZXJFcnJvclR5cGUgPSBnZXRFcnJvclR5cGVQZXJFeHRydWRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5zdXBwb3J0ZWRDb25maWdzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJlZEV4dHJ1ZGVyc0NvbmZpZ3M6IGdldFN1cHBvcnRlZFBhaXJlZEV4dHJ1ZGVyc0NvbmZpZ3MoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJFeHRydWRlckNvbmZpZ3M6IGdldFN1cHBvcnRlZFBlckV4dHJ1ZGVyQ29uZmlncygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuZXh0cnVkZXJTZXR1cEVycm9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5saWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhc0V4dHJ1ZGVyTWF0ZXJpYWxNaXNtYXRjaCgpIHtcclxuICAgICAgICBjb25zdCBzdXBwb3J0ZWRNYXRlcmlhbHNCeUV4dHJ1ZGVyID0gW107XHJcbiAgICAgICAgY29uc3QgZXh0cnVkZXJzID0gdGhpcy5fbWFjaGluZUNvbmZpZ1xyXG4gICAgICAgICAgICA/IHRoaXMuX21hY2hpbmVDb25maWcuZXh0cnVkZXJfcHJvZmlsZXMuYXR0YWNoZWRfZXh0cnVkZXJzXHJcbiAgICAgICAgICAgIDogdGhpcy5nZXRBdHRhY2hlZEV4dHJ1ZGVycygpO1xyXG4gICAgICAgIGV4dHJ1ZGVycy5tYXAoZXh0cnVkZXIgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXh0cnVkZXIgJiYgZXh0cnVkZXIuc3VwcG9ydGVkX21hdGVyaWFscykge1xyXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkTWF0ZXJpYWxzQnlFeHRydWRlci5wdXNoKGV4dHJ1ZGVyLnN1cHBvcnRlZF9tYXRlcmlhbHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsdXhcclxuICAgICAgICAgICAgLm1hcChmbHV4ID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbHV4LnN0b3JlKCdQcmludFNldHRpbmdzU3RvcmUnKS5oYXNFeHRydWRlck1hdGVyaWFsTWlzbWF0Y2goc3VwcG9ydGVkTWF0ZXJpYWxzQnlFeHRydWRlcik7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5saWZ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW52b2tlKGthaXRlbk1ldGhvZCwgcGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc2VsZi5jaGVja0F1dGhlbnRpY2F0ZWQoKTtcclxuICAgICAgICBpZiAoIShrYWl0ZW5NZXRob2QgaW4gc2VsZi5fcHJpbnRlcikpIHRocm93IGBNZXRob2QgJHtrYWl0ZW5NZXRob2R9IGRvZXMgbm90IGV4aXN0LmA7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHEoc2VsZi5fcHJpbnRlcltrYWl0ZW5NZXRob2RdLmFwcGx5KHNlbGYuX3ByaW50ZXIsIHBhcmFtcykpLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgLy8gamFua1xyXG4gICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSAnbnVsbFxcbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgYFNvbWV0aGluZyB3ZW50IHdyb25nIHdoZW4gY2FsbGluZyBtZXRob2QgJHtrYWl0ZW5NZXRob2R9OyBwcmludGVyIG1vc3QgbGlrZWx5IGRpc2Nvbm5lY3RlZGBcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldEN1cnJlbnRKb2IoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlICYmIHRoaXMuY3VycmVudFN0YXRlLmN1cnJlbnRfcHJvY2Vzcykge1xyXG4gICAgICAgICAgICBjb25zdCBjcCA9IHRoaXMuY3VycmVudFN0YXRlLmN1cnJlbnRfcHJvY2VzcztcclxuICAgICAgICAgICAgLy8gVE9ETyBHQy0yNjYxOCAtIFRoaXMgaXMgZGlydHkgZml4IGZvciAwLjkgcmVsZWFzZS4gVGhpcyBmaXhlcy9lbmFibGVzIHByaW50IGpvYnMgaW4gU2NoZWR1bGUgdmlldyBpbiBFRC5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC8vIGVsYXBzZWRfdGltZSBoZWxwcyB0byBtYWtlIHN1cmUgdGhhdCB3ZSBhcmUgZGlzcGxheWluZyBwcmludGluZyBwcm9ncmVzcyAobm90IGhvbWluZyBvciBoZWF0aW5nIHByb2dyZXNzKVxyXG4gICAgICAgICAgICAgICAgcGVyY2VudF9kb25lOiBjcC5lbGFwc2VkX3RpbWUgPiAwID8gY3AucHJvZ3Jlc3MgOiAwLFxyXG4gICAgICAgICAgICAgICAgZWxhcHNlZF9idWlsZF90aW1lOiBjcC5lbGFwc2VkX3RpbWUgPyBjcC5lbGFwc2VkX3RpbWUgLyA2MCA6IDAsXHJcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZWRfYnVpbGRfdGltZTogY3AudGltZV9lc3RpbWF0aW9uID8gY3AudGltZV9lc3RpbWF0aW9uIC8gNjAgOiAwLFxyXG4gICAgICAgICAgICAgICAgc3VibWl0X3RpbWU6IGNwLnN0YXJ0X3RpbWUgPyBuZXcgRGF0ZShjcC5zdGFydF90aW1lKS52YWx1ZU9mKCkgLyAxMDAwIDogMCxcclxuICAgICAgICAgICAgICAgIGpvYl9pZDogY3AuaWQgPyBjcC5pZCA6IDAsXHJcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogY3AuZmlsZW5hbWUgPyBjcC5maWxlbmFtZS5zcGxpdCgnLycpLnBvcCgpIDogbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRXh0cnVkZXJTdGF0cygpIHtcclxuICAgICAgICB0aGlzLl9leHRydWRlclN0YXRzID0gW107XHJcbiAgICAgICAgY29uc3QgaXNEdWFsID0gdGhpcy5nZXRBdHRhY2hlZEV4dHJ1ZGVycygpLmxlbmd0aCA+IDE7XHJcbiAgICAgICAgY29uc3QgZXh0cnVkZXJTdGF0c1Byb21pc2VzID0gW107XHJcblxyXG4gICAgICAgIHEoXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0QXR0YWNoZWRFeHRydWRlcnMoKS5tYXAoKGV4dHJ1ZGVyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXh0cnVkZXJTdGF0c1Byb21pc2VzW2luZGV4XSA9IHRoaXMuaW52b2tlKCdHZXRUb29sVXNhZ2VTdGF0cycsIGlzRHVhbCA/IFtpbmRleF0gOiBudWxsKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHEuYWxsKGV4dHJ1ZGVyU3RhdHNQcm9taXNlcykpXHJcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5tYXAoKHJlc3VsdCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRydWRlclR5cGUgPSB0aGlzLl9nZXRFeHRydWRlclR5cGVOYW1lKHRoaXMuZ2V0QXR0YWNoZWRFeHRydWRlcnMoKVtpbmRleF0sIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRQcmludFRpbWUgPSB0aGlzLl9nZXRGb3JtYXR0ZWRQcmludFRpbWUocmVzdWx0c1tpbmRleF0uZXh0cnVzaW9uX3RpbWVfcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmV4dHJ1ZGVyX3R5cGUgPSBleHRydWRlclR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmV4dHJ1ZGVyX3ByaW50X3RpbWUgPSBmb3JtYXR0ZWRQcmludFRpbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJ1ZGVyU3RhdHNbaW5kZXhdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRyYWNraW5nSW5mbygpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gdXRpbC50cmFja2luZ0luZm9Gb3JQcmludGVyKHRoaXMpO1xyXG4gICAgICAgIGRhdGEuZXh0cnVkZXJzID0gdGhpcy5nZXRFeHRydWRlclRyYWNraW5nSW5mbygpO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHByb2Nlc3NNZXRob2RFeGlzdHMobWV0aG9kKSB7XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc01ldGhvZHMgPSBfLmdldCh0aGlzLmdldFN0YXR1cygpLCAnY3VycmVudF9wcm9jZXNzLm1ldGhvZHMnLCBbXSk7XHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NNZXRob2RzLmluZGV4T2YobWV0aG9kKSA+PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcHJpdmF0ZVxyXG4gICAgICogSGFuZGxlcyBsb2FkaW5nIGFuZCB1bmxvYWRpbmcgb2YgdGhlIGZpbGFtZW50LlxyXG4gICAgICovXHJcbiAgICBfY2hhbmdlRmlsYW1lbnQocHJvY2Vzc01ldGhvZCwgaWRsZU1ldGhvZCwgZXh0cnVkZXJJbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGV4dHJ1ZGVyID0gZXh0cnVkZXJJbmRleCA9PT0gdW5kZWZpbmVkID8gMCA6IGV4dHJ1ZGVySW5kZXg7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmdldFN0YXR1cygpLnN0YXRlID09PSBQcmludGVyU3RhdGVFbnVtLkJ1c3kpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW52b2tlKCdQcm9jZXNzTWV0aG9kJywgW3Byb2Nlc3NNZXRob2QsIGV4dHJ1ZGVyXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnZva2UoaWRsZU1ldGhvZCwgW2V4dHJ1ZGVyXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXR0aW5nIHRoZSBwcmludGVyIHRvIGxvYWQvdW5sb2FkIGZpbGFtZW50IHdoaWxlIGl0J3MgaWRsZSB2cy4gd2hlbiBpdCdzIGJ1c3kgYXJlIGRpZmZlcmVudCxcclxuICAgICAqIGhlbmNlIHRoZSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHByb2Nlc3NNZXRob2QgYW5kIGlkbGVNZXRob2QuXHJcbiAgICAgKi9cclxuXHJcbiAgICBsb2FkRmlsYW1lbnQoZXh0cnVkZXJJbmRleCkge1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NNZXRob2QgPSAnbG9hZF9maWxhbWVudCc7XHJcbiAgICAgICAgY29uc3QgaWRsZU1ldGhvZCA9ICdMb2FkRmlsYW1lbnQnO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VGaWxhbWVudChwcm9jZXNzTWV0aG9kLCBpZGxlTWV0aG9kLCBleHRydWRlckluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICB1bmxvYWRGaWxhbWVudChleHRydWRlckluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc01ldGhvZCA9ICd1bmxvYWRfZmlsYW1lbnQnO1xyXG4gICAgICAgIGNvbnN0IGlkbGVNZXRob2QgPSAnVW5sb2FkRmlsYW1lbnQnO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VGaWxhbWVudChwcm9jZXNzTWV0aG9kLCBpZGxlTWV0aG9kLCBleHRydWRlckluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgc3RvcHBpbmcgdGhlIGZpbGFtZW50IGZyb20gZXh0cnVkaW5nIGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZC4gQXMgaW4gYF9jaGFuZ2VGaWxhbWVudCgpYCxcclxuICAgICAqIHN0b3BwaW5nIHRoZSBmaWxhbWVudCBpcyBkaWZmZXJlbnQgd2hpbGUgaXQncyBpZGxlIHZzIHdoZW4gaXQncyBidXN5LiBGdXJ0aGVybW9yZSwgdGhlcmUgc2VlbXMgdG9cclxuICAgICAqIGJlIGEgYnVnIGluIHdoaWNoIHdoZW4geW91IGludm9rZSBgc3RvcF9maWxhbWVudGAgd2hpbGUgdGhlIHByaW50ZXIgaXMgaWRsZSwgaXQgd2lsbCBjYXVzZSB0aGUgc2NyZWVuXHJcbiAgICAgKiB0byBmcmVlemUsIGlmIGl0IGhhcyBvbmUuXHJcbiAgICAgKi9cclxuICAgIHN0b3BGaWxhbWVudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5nZXRTdGF0dXMoKS5zdGF0ZSA9PT0gUHJpbnRlclN0YXRlRW51bS5CdXN5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludm9rZSgnUHJvY2Vzc01ldGhvZCcsIFsnc3RvcF9maWxhbWVudCddKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhbid0IHVzZSBcInN0b3BfZmlsYW1lbnRcIiBub3cgYXMgaXQgY2F1c2VzIGEgdGhlIHByaW50ZXIgc2NyZWVuIHRvIGNyYXNoLlxyXG4gICAgICAgIC8vIFNlZSBQRU4tMTEwNCBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbmNlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzRmlmdGhHZW4oKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEJvdFR5cGUgPSB0aGlzLl9wcmludGVySW5mby5pbmZvLmJvdF90eXBlO1xyXG4gICAgICAgIHJldHVybiBGaWZ0aEdlbkJvdHMuaW5jbHVkZXMoY3VycmVudEJvdFR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzU2l4dGhHZW4oKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEJvdFR5cGUgPSB0aGlzLl9wcmludGVySW5mby5pbmZvLmJvdF90eXBlO1xyXG4gICAgICAgIHJldHVybiBTaXh0aEdlbkJvdHMuaW5jbHVkZXMoY3VycmVudEJvdFR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzU2tldGNoUHJpbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG1hY2hpbmVDb25maWcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hY2hpbmVDb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpbnRlckluZm8uaW5mbztcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY2FtZXJhRmVlZEFjdGl2ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FtZXJhRmVlZEFjdGl2ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY3VycmVudFByb2Nlc3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm8ucHJpbnRlcl9zdGF0dXMuY3VycmVudF9wcm9jZXNzIHx8IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB1cGRhdGVOb3RpZmljYXRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVOb3RpZmljYXRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBuZXR3b3JrU3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcmtTdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZmlybXdhcmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zpcm13YXJlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBmaWxlVHJhbnNmZXJIZWxwZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGVUcmFuc2ZlckhlbHBlcjtcclxuICAgIH1cclxuICAgIGdldCBzb3VuZFN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiBfLmdldCh0aGlzLl9wcmludGVySW5mbywgJ2luZm8uc291bmQnKTtcclxuICAgIH1cclxuICAgIGdldCBhbmFseXRpY3NTdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gXy5nZXQodGhpcy5fcHJpbnRlckluZm8sICdpbmZvLmFuYWx5dGljc19lbmFibGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gL3N0b3Jlcy9wcmludGVyU3RvcmUuanNcclxuICAgIGluamVjdEZsdXgoZmx1eCkge1xyXG4gICAgICAgIHRoaXMuX2ZsdXggPSBtYXliZShmbHV4KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYWtlckJvdFByaW50ZXI7XHJcbiJdfQ==
