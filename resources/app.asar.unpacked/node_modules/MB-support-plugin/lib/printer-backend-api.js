'use strict';

const EventEmitter = require('eventemitter3');

const q = require('q');

const { PrinterStateEnum } = require('./constants');

const DEFAULT_FRAME_ENCODING = 'base64';
const SUPPORTED_FRAME_ENCODINGS = new Set(['base64', 'binary']);

class PrinterBackendApi extends EventEmitter {
  constructor(printerManager, options = {}) {
    super();

    if (!printerManager) {
      throw new Error('PrinterBackendApi requires a printerManager instance');
    }

    this._printerManager = printerManager;
    this._frameEncoding = SUPPORTED_FRAME_ENCODINGS.has(options.frameEncoding) ? options.frameEncoding : DEFAULT_FRAME_ENCODING;
    this._stateByUid = new Map();
    this._statusListeners = new Map();
  }

  connectByIp(ip) {
    return q(this._printerManager.addByIp(ip)).then(printer => {
      if (!printer) {
        throw new Error(`No compatible printer found for IP ${ip}`);
      }

      this._trackPrinter(printer);
      return this._serializePrinter(printer);
    });
  }

  authenticate(uid) {
    const printer = this._getPrinterOrThrow(uid);
    this._trackPrinter(printer);

    return q(this._printerManager.authenticate(printer)).then(() => {
      this._syncState(printer);
      return this._serializePrinter(printer);
    });
  }

  reauth(uid) {
    const printer = this._getPrinterOrThrow(uid);
    this._trackPrinter(printer);

    const connManager = this._printerManager._connectionManagers.get(uid);
    if (!connManager) {
      throw new Error(`Printer ${uid} has no connection manager`);
    }

    const printerInfo = connManager.getHighestPriorityConnInfo();
    if (!printerInfo) {
      throw new Error(`Cannot reauthenticate offline printer ${uid}`);
    }

    return q(this._printerManager.authFromStored(printerInfo)).then(() => {
      this._syncState(printer);
      return this._serializePrinter(printer);
    });
  }

  startCamera(uid, options = {}) {
    const printer = this._getPrinterOrThrow(uid);
    this._trackPrinter(printer);

    const frameEncoding = this._resolveFrameEncoding(options.frameEncoding);

    printer.getCameraFeed(frame => {
      const payload = this._convertFrame(frame, frameEncoding);

      this.emit('camera-frame', {
        uid,
        encoding: frameEncoding,
        frame: payload
      });
    });

    return {
      uid,
      active: true,
      encoding: frameEncoding
    };
  }

  stopCamera(uid) {
    const printer = this._getPrinterOrThrow(uid);

    printer.endCameraFeed();

    return {
      uid,
      active: false
    };
  }

  getState(uid) {
    if (this._stateByUid.has(uid)) {
      return this._stateByUid.get(uid);
    }

    const printer = this._getPrinterOrThrow(uid);

    return this._syncState(printer);
  }

  _resolveFrameEncoding(encoding) {
    if (!encoding) {
      return this._frameEncoding;
    }

    if (SUPPORTED_FRAME_ENCODINGS.has(encoding)) {
      return encoding;
    }

    throw new Error(`Unsupported frame encoding "${encoding}"`);
  }

  _convertFrame(frame, frameEncoding) {
    if (frameEncoding === 'base64') {
      return frame;
    }

    const base64Data = typeof frame === 'string' ? frame.split(',').pop() : '';

    return Buffer.from(base64Data, 'base64');
  }

  _trackPrinter(printer) {
    const uid = printer.getId();

    if (this._statusListeners.has(uid)) {
      this._syncState(printer);
      return;
    }

    const listener = () => this._syncState(printer);

    if (printer._updateNotifications && typeof printer._updateNotifications.on === 'function') {
      printer._updateNotifications.on('status', listener);
    }

    this._statusListeners.set(uid, listener);
    this._syncState(printer);
  }

  _syncState(printer) {
    const uid = printer.getId();
    const nextState = this._normalizeState(printer.getStatus().state);
    const prevState = this._stateByUid.get(uid);

    this._stateByUid.set(uid, nextState);

    if (prevState !== nextState) {
      this.emit('state-changed', {
        uid,
        previous: prevState,
        current: nextState
      });
    }

    return nextState;
  }

  _normalizeState(state) {
    if ([PrinterStateEnum.Offline, PrinterStateEnum.Unauthenticated, PrinterStateEnum.Authenticating, PrinterStateEnum.Idle].includes(state)) {
      return state;
    }

    if (state === PrinterStateEnum.Reauthenticating || state === PrinterStateEnum.Reconnecting) {
      return PrinterStateEnum.Authenticating;
    }

    if (state === PrinterStateEnum.Busy || state === PrinterStateEnum.Pending) {
      return PrinterStateEnum.Idle;
    }

    return PrinterStateEnum.Offline;
  }

  _getPrinterOrThrow(uid) {
    const printer = this._printerManager._printerCache.get(uid);

    if (!printer) {
      throw new Error(`Unknown printer uid ${uid}`);
    }

    return printer;
  }

  _serializePrinter(printer) {
    return {
      uid: printer.getId(),
      name: printer.getName(),
      ip: printer.getIpAddress ? printer.getIpAddress() : undefined,
      state: this._syncState(printer)
    };
  }
}

module.exports = PrinterBackendApi;
