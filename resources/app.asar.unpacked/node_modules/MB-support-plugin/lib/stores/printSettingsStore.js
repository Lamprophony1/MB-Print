/**
 * @module PrintSettingsStore
 * @desc
 * The Print Settings Store attempt to simplify the tedious business of adding overrides to print settings. Using the
 * store is fairly straight forward, however the way it's put together under the hood may be a little confusing at
 * first glance. Fortunately, I'm here to explain.
 *
 * @example
 * class myComponent extends FluxComponent {
 *   constructor(props) {
 *      super(props);
 *      this._store = this.getFlux().store('PrintSettingsStore');
 *      this.state = this._store.getState();
 *   }
 *
 *   componentDidMount() {
 *      this._store.on("change", () => this.setState(this._store.getState()));
 *   }
 *
 *   render() {
 *      // render only active settings and their values
 *      return (
 *          <ul>
 *              {
 *                  R.pipe(
 *                      R.pickBy(propOr(false, 'active')),
 *                      R.mapObjIndexed((v, k) => <li>{v.name}: {v.value})
 *                  )(this.state.settings)
 *              }
 *          </ul>
 *      );
 *   }
 * }
 *
 * @author Jon Laing & Wenson Tsai
 */

/**
 * NOTE!
 * Every setting that Slice Config/Miracle Grue slices with
 * is currently validated when saving and loading from project.json.
 * When a new setting is added,
 * we MUST UPDATE mb-plugin/mb-project-validator-provider.js
 * adding property to the schema, or else projects with these schemas
 * will not be able to load!
 */
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const Fluxxor = require('fluxxor');

const R = require('ramda');

const _ = require('lodash');

const fs = require('fs-extra');

const q = require('q');

const {
  decodeKey
} = require('@makerbot/settingsui');

const CHANGE_EVENT = 'change';
const ONUPDATE_EXTRUDERS_COMPLETED_EVENT = 'ONUPDATE_EXTRUDERS_COMPLETED_EVENT';

const makerbot = require('../makerbot');

const L = require('../utils/printSettings/lenses');

const reducers = require('../utils/printSettings/reducers');

const format = require('../utils/printSettings/format');

const Constants = require('../constants/print_settings');

const printStoreUtils = require('../utils/printSettings/printSettingsStoreUtils');

const {
  Actions
} = Constants;

const {
  ExtruderTypeEnum,
  ExtruderToDefaultMaterial
} = require('../constants');

const {
  fileSafeString,
  getI18n
} = require('../util');

const {
  just,
  nothing
} = require('../utils/maybe');

let sanitizePreset, presetToJSON;
makerbot.getVersion().then(R.trim).then(v => {
  sanitizePreset = reducers.sanitizePreset(v);
  presetToJSON = reducers.presetToJSON(v);
}).done();
/**
 * Dictionary of all the settings mappings for the Print Settings Panel.
 * We use this so we don't have to keep passing strings around and then
 * type them wrong, causing them to fail silently.
 * @constant {Object<string, string[]>}
 * @private
 */

const SettingsKeys = Constants.SettingsKeys;
const PresetKeyBlacklist = Constants.PresetKeyBlacklist; /////////// STORED VALUES ///////////////

/**
 * This holds all the possible override settings that comes
 * from the Slice Config. This is NOT for holding values. The
 * user should not have any ability to change this. The only
 * time this should change is if the printer changed. We keep this
 * separate from the user-bound data to make sure the schema of possible
 * overrides stays clean. We do this in hopes of avoiding bugs caused
 * by too many confusing tree traversals and inline mutations.
 * @see Store.getState()
 * @private
 * @type {Object<string, any>}
 */

let availableSettings = {};
/**
 * This indicates whether a particular override has been
 * activated by the user. This becomes more powerful when
 * it is combined with `availableOverrides` and `values`.
 * @see Store.getState()
 * @example
 * R.prop('infill', visibleSettings) == true;
 * @type {Object<string, boolean>}
 * @private
 */

let visibleSettings = {};
/**
 * This holds that values of the active settings.
 * @see Store.getState()
 * @example
 * R.prop('layer_height', values); // 0.2
 * @type {Object<string, any>}
 * @private
 */

let values = {};
let supportedExtruders = []; // Lists supported extruders per extruder-index
// ie. [[mk13, mk13_impla, mk13_experimental]]  ** 5th Gen Printers **
// ie. [[mk14, mk14_hot], [mk14_s, mk14_hot_s]] ** 6th Gen Printers **

let supportedExtrudersPerIndex = []; // Lists supported extruder pair configurations
// ie. [[mk13], [mk13_impla], [mk13_experimental]]  ** 5th Gen Printers **
// ie. [[mk14, mk14_s], [mk14_hot, mk14_hot_s]]     ** 6th Gen Printers **

let supportedExtruderPairConfigs = [];
let selectedMaterials = [];
let supportedMaterials = [];
let materialTranslations = {};
let spoolMaterials = [];
let printMode = null;
let supportedPrintModes = [];
/**
 * This array will hold the x,y coordinates for the purgeWallCenter.
 * For 4th & 5th gen printers, purgeWallCenter will be an empty array [].
 *
 * For 6th gen printers, the purgeWallCenter will either be initial_value
 * -or- the value return by the viewer
 *
 * -- Ray
 **/

let purgeWallCenter = [];
/**
 * Flag to determine if the settings have been loaded from user_config.json
 * @type {boolean}
 * @private
 */

let settingsLoaded = false;
let firstTrayLoaded = false;
let supportedConfigurations = [];
const PRESET_EXT = Constants.PRESET_EXT; // User presets are held here in memory, copied from the user config

let presets = []; // the current preset the user has selected. It will not be set if the user
// hasn't set anything

let currentPreset = null;
let presetError = nothing(); //////////// END STORED VALUES ///////////

module.exports = Fluxxor.createStore({
  actions: {
    [Actions.ToggleProp]: 'onAdvancedToggle',
    [Actions.BulkToggleProp]: 'onBulkAdvancedToggle',
    [Actions.ResetToDefault]: 'resetToDefault',
    [Actions.GetPrinterSchema]: 'onGetPrinterSchema',
    [Actions.UpdateProperty]: 'onUpdateProperty',
    [Actions.SelectPrinter]: 'onSelectPrinter',
    [Actions.GetExtruderTypes]: 'getExtruderTypes',
    [Actions.GetSupportedConfigurations]: 'getSupportedConfigurations',
    [Actions.InitalizeValues]: 'initializeValues',
    [Actions.AuthenticationWaiting]: 'onSelectPrinter',
    [Actions.ResetAllToDefault]: 'onResetAllToDefault',
    [Actions.RemoveAllSettings]: 'onRemoveAllSettings',
    [Actions.CompareSettings]: 'compareSettings',
    [Actions.CreatePreset]: 'onCreatePreset',
    [Actions.WritePreset]: 'onWritePreset',
    [Actions.UpdatePreset]: 'onUpdatePreset',
    [Actions.DestroyPreset]: 'onDestroyPreset',
    [Actions.ReadPresets]: 'onReadPresets',
    [Actions.ApplyPreset]: 'onApplyPreset',
    [Actions.UnapplyPreset]: 'onUnapplyPreset',
    [Actions.RenamePreset]: 'onRenamePreset',
    [Actions.PresetError]: 'onPresetError',
    [Actions.CloseModal]: 'onCloseModal',
    [Actions.RevertChanges]: 'onRevertChanges',
    [Actions.UpdateExtruder]: 'onUpdateExtruder',
    [Actions.UpdateExtruderPair]: 'onUpdateExtruderPair',
    [Actions.UpdateMaterial]: 'onUpdateMaterial',
    [Actions.UpdateMaterials]: 'onUpdateMaterials',
    [Actions.UpdateSupports]: 'onUpdateSupports',
    [Actions.UpdatePrintMode]: 'onUpdatePrintMode',
    [Actions.UpdatePurgeWallCenter]: 'onUpdatePurgeWallCenter'
  },

  /**
   * @typedef {Object} PrintSettingsStoreState
   * @property {Object<String, Object>} settings - All of the settings formatted for consumption by the view
   */

  /**
   * This returns the current state fully formatted for the UI
   *
   * @example
   * // inside a React component
   * this.setState(this.getFlux().store('PrintSettingsStore').getState());
   *
   * // getting all the settings for a particular tab
   * let infillSettings = R.filter(v => v.groups.includes('infill', this.state.settings);
   *
   * // getting all active settings
   * let visibleSettings = R.filter(R.propOr(false, 'visible'), this.state.settings);
   *
   * // getting the value for a particular override
   * let val = R.path(['layer_height', 'value'], this.state.settings);
   *
   * @returns {PrintSettingsStoreState}
   */
  getState() {
    const settings = reducers.state(availableSettings, visibleSettings, values, Constants.GroupDict, Constants.Options, Constants.Format, Constants.Sanitization, Constants.SettingsTypes);
    return {
      // extruders lives outside of settings now
      // in contrast to attached_extruder0, which used to live in settings
      extruders: {
        supported: supportedExtruders,
        supportedExtrudersPerIndex,
        supportedExtruderPairConfigs
      },
      materials: {
        selected: selectedMaterials,
        supported: supportedMaterials,
        translations: materialTranslations,
        spoolMaterials
      },
      printMode: {
        selected: printMode,
        supported: supportedPrintModes
      },
      settings,
      presets,
      currentPreset,
      presetError,
      purgeWallCenter
    };
  },

  hasExtruderMaterialMismatch(supportedMaterialsFromFirmware) {
    const printer = this.flux.store('PrinterStore').getSelectedPrinter();
    const isLiveBot = printer && printer.isConnected() && printer.isAuthenticated();
    let hasMismatch = false;

    if (isLiveBot && printer.isSixthGen()) {
      const attachedExtruders = printer.getAttachedExtruders(); // Only the newer versions of Method/Method X firmware give us supported materials
      // If we don't get that info, use the hardcoded values from _getSupportedMaterialsByExtruder()

      const supportedMaterialsByExtruder = supportedMaterialsFromFirmware.length > 0 ? supportedMaterialsFromFirmware : this._getSupportedMaterialsByExtruder(attachedExtruders, printer);

      if (spoolMaterials.length > 0 && supportedMaterialsByExtruder.length > 0) {
        spoolMaterials.map((spoolMaterial, index) => {
          if (spoolMaterial && supportedMaterialsByExtruder[index] && !supportedMaterialsByExtruder[index].includes(spoolMaterial) && attachedExtruders[index] !== ExtruderTypeEnum.mk14_e) {
            hasMismatch = true;
          }
        });
      }
    }

    return hasMismatch;
  },

  setSupportVisibility() {
    const printer = this.flux.store('PrinterStore').getSelectedPrinter();

    if (printer && printer.isSixthGen()) {
      visibleSettings.doSupport = false;
    } else {
      visibleSettings.supportType = true;
    }
  },

  getVisibleSettings() {
    return visibleSettings;
  },

  getOverrides() {
    return _.mapKeys(_.omit(values, PresetKeyBlacklist), (val, key) => {
      return decodeKey(key);
    });
  },

  hasOverridesForPrintMode(currentPrintMode) {
    const currentPrintModeChanged = currentPrintMode === printMode;
    const hasOverride = R.pipe(R.omit(PresetKeyBlacklist), R.values, R.length, R.lt(0))(values);
    return !currentPreset && currentPrintModeChanged && hasOverride;
  },

  hasOverridesForPreset(preset) {
    return preset && currentPreset === preset && !R.equals(reducers.getPresetByName(preset, presets).settings, R.omit(PresetKeyBlacklist, values));
  },

  hasPresetWithName(name) {
    return reducers.getPresetByName(name, presets) != null;
  },

  /**
   * Fires when an advanced setting is toggled in the Advanced Settings Panel,
   * or when we update a setting in that panel.
   * It manipulates visibleSettings and then emits a change event.
   * @param {object} payload - the payload of the dispatched event. Should have `key` in it.
   * If we call it from onUpdateProperty(), it should have `visible` in it, set to true,
   * so that newly-changed settings are always made visible.
   * @private
   */
  onAdvancedToggle(payload) {
    const setting = payload.key; // If we know what value we want to set visibility to, use that. If not, just do a straightforward toggle

    const toggledOn = payload.visible !== undefined ? payload.visible : !R.propOr(false, setting, visibleSettings);
    visibleSettings = R.assoc(setting, toggledOn, visibleSettings); // So, product decided things should work in a certain way, but I think
    // they're going to regret that decision in a month or two, so I'm
    // leaving this here, commented out, so it's nice and easy to revert
    // to the intuitive way it used to work. -- xoxo, Jon
    // if(!toggledOn) {
    //     printStoreUtils.updateProjectStoreProp(setting, undefined);
    //     values = R.dissoc(setting, values);
    // }
    // emitting up here so the interface can proceed while we do some background stuff

    this.emit(CHANGE_EVENT);

    const schemaInitialValue = this._loadSchemaInitialValue();

    if (schemaInitialValue) {
      schemaInitialValue.then(() => {
        // Save Toggled (Active) settings to user_config
        // (APP-WIDE settings).
        printStoreUtils.saveToUserConfig('activeAdvSettings', visibleSettings, this.flux);
        printStoreUtils.saveToUserConfig('printSettings', values, this.flux);
        printStoreUtils.updateProjectStoreProp(SettingsKeys.Materials, selectedMaterials, true, this.flux);
        printStoreUtils.updateProjectStoreProp(SettingsKeys.PrintModes, values.printMode, true, this.flux);
      }).catch(console.error).done();
    }
  },

  /**
   * Resets setting back to Slice Config evaluated `initial_value` for setting.
   * This requires calling Slice Config with print_mode and overrides object with the
   * setting which we want `initial_value` (default) for removed from overrides.
   * getSchema will always override value as `initial_value` if there is one set.
   * @param {object} payload - the payload of the dispatched event. Should have `key` in it.
   * @private
   */
  resetToDefault(payload) {
    const setting = payload.key;
    values = printStoreUtils.persistValues(setting, undefined, false, values, this.flux);
    printStoreUtils.clearBuilds(this.flux);
    return this._loadSchemaInitialValue().then(() => this.emit(CHANGE_EVENT)).catch(console.error);
  },

  /**
   * Fires when a property on a print setting changes
   * @param {object} payload - the payload of the dispatched event. Should have `path` and `value` in it.
   * @private
   */
  onUpdateProperty(payload) {
    const key = format.keyFromPath(payload.path);

    if (key === SettingsKeys.Supports) {
      // Reset to default with 'doPurgeWall' when switching between support types
      // Applies mainly to the sixth gen printers
      values = printStoreUtils.persistValues(SettingsKeys.PurgeWall, undefined, false, values, this.flux);
    }

    if (R.has(key, visibleSettings)) {
      if (key === SettingsKeys.PrintModes) ({
        values,
        currentPreset
      } = printStoreUtils.resetAllToDefault(this.flux, values));

      if (R.has(key, availableSettings) || key === SettingsKeys.PrintModes) {
        values = printStoreUtils.persistValues(key, payload.value, false, values, this.flux);
        this.emit(CHANGE_EVENT);

        this._loadSchemaInitialValue().done();
      }
    } else {
      // Avoid passing non print settings related properties; info.extruder, info.meshColor, etc..
      if (R.has(key, availableSettings) || key === SettingsKeys.PrintModes) {
        values = printStoreUtils.persistValues(key, payload.value, false, values, this.flux); // toggle the visibilty on print setting and run through
        // the _loadSchemaInitalValue routine

        this.onAdvancedToggle({
          key,
          visible: true
        });
      }
    }
  },

  onResetAllToDefault() {
    ({
      values,
      currentPreset
    } = printStoreUtils.resetAllToDefault(this.flux, values));
    this.emit('initialize_values');
  },

  onRemoveAllSettings() {
    visibleSettings = printStoreUtils.removeAllSettings(this.flux);
    this.setSupportVisibility();
    this.emit(CHANGE_EVENT);
  },

  onRevertChanges() {
    if (currentPreset) {
      // have to set currentPreset to null for onApplyPreset to work properly
      const presetBuf = currentPreset;
      currentPreset = null;
      this.onApplyPreset({
        name: presetBuf
      });
    } else {
      const printModeBuf = R.view(L.printMode, values);
      ({
        values,
        currentPreset
      } = printStoreUtils.resetAllToDefault(this.flux, values));
      values = printStoreUtils.persistValues(SettingsKeys.PrintModes, printModeBuf, false, values, this.flux);
      this.emit(CHANGE_EVENT);

      this._loadSchemaInitialValue().done();
    }
  },

  onBulkAdvancedToggle(payload) {
    visibleSettings = R.merge(visibleSettings, payload.active);
    values = reducers.cleanValues(values, visibleSettings);
    this.emit(CHANGE_EVENT);
  },

  onGetPrinterSchema(payload) {
    const printer = this.flux.store('PrinterStore').getSelectedPrinter();
    const extruders = printer && printer.getAttachedExtruders();
    const {
      resetToDefaultExtruders
    } = payload;
    const isPrinterConnectedAndAuthed = printer && printer.isConnected() && printer.isAuthenticated(); // Ignore Extruder Args if offline/archetype printers and get default extruders

    const ignoreExtruderArgs = resetToDefaultExtruders && !isPrinterConnectedAndAuthed; // For archetype printers, exit out of loading schema

    if (!printer) return; // if payload has spoolsInfo, then it means spools have been changed
    // on a live printer

    if (payload.spoolsInfo) {
      this._persistValues(SettingsKeys.ChamberTemp, null, true); // this._persistValues(SettingsKeys.BuildPlaneTemp, null, true);

    }

    const ConfigService = this.flux.getService('ConfigService');
    const activeTray = this.flux.store('ProjectStore').getProject().getActiveTray();
    const tray = activeTray.getBuildInfo(printer);
    if (R.isEmpty(presets)) presets = ConfigService.get('presets') || [];
    return this.updatePrinterSpoolInfo(printer, payload) // Passing `resetToDefaultsExtruders` from 'onSelectPrinter'
    // to avoid passing extruders as args to sliceconfig
    // BUT we don't ignore extruder selections if it's a live printer
    .then(() => makerbot.getSchema(tray, printer, ignoreExtruderArgs, this.flux)).then(schema => {
      // In rare cases, if getSchema gets called too quickly, it
      // will return empty string as a result. Let's exit before
      // things error out.
      // -- Ray
      if (_.isEmpty(schema)) return; // Passing `resetToDefaultExtruders` from 'onSelectPrinter'
      // to force update `extruders` to the schema's attached extruders

      this._parseSchema(schema.getFullSchema(), resetToDefaultExtruders); // emit early so the UI can render while we do the rest of the updating


      this.emit(CHANGE_EVENT);
      printStoreUtils.updateProjectStoreProp(SettingsKeys.Extruders, extruders, true, this.flux);
      printStoreUtils.updateProjectStoreProp(SettingsKeys.Materials, selectedMaterials, true, this.flux);
      printStoreUtils.updateProjectStoreProp(SettingsKeys.PrintModes, values.printMode, true, this.flux);
    }).catch(err => console.error(err));
  },

  updatePrinterSpoolInfo(printer, payload) {
    /**
     * update spoolsMaterials if...
     *   payload contains spoolsInfo sent from makerbot-printer.js
     *   on spool material changes or on reconnect
     *   -or-
     *   invoke getSpoolInfo from printer when switching between printers
     **/
    const parseSpoolsInfo = spoolsInfo => {
      return spoolsInfo ? spoolsInfo.map((spoolInfo, bayIndex) => {
        const {
          material_name
        } = spoolInfo;
        const attachedExtruders = printer.getAttachedExtruders(); // If we have information from the spool, show that

        if (!R.isNil(material_name)) {
          return material_name;
        } else if (bayIndex === 0 && printer.isConnected() && printer.isAuthenticated()) {
          // Live bots with no spool info (for the first bay only)
          return null;
        } else {
          return ExtruderToDefaultMaterial[attachedExtruders[bayIndex]];
        }
      }) : []; // 4th & 5th Gen Printers + Sketch Printers, set to empty
    };

    if (payload && payload.spoolsInfo) {
      return q().then(() => {
        spoolMaterials = parseSpoolsInfo(payload.spoolsInfo);
      });
    }

    return printer.getSpoolInfo().then(spoolsInfo => {
      spoolMaterials = parseSpoolsInfo(spoolsInfo);
    });
  },

  /**
   * Clears all values when the printer is changed, and sets the panel to prepare to close.
   * @private
   */
  onSelectPrinter() {
    this.waitFor(['PrinterStore'], () => {
      selectedMaterials = [];
      spoolMaterials = [];
      purgeWallCenter = [];
      const settingsWithBotSpecificValues = [SettingsKeys.ChamberTemp, SettingsKeys.Supports // SettingsKeys.BuildPlaneTemp,
      ];
      settingsWithBotSpecificValues.map(setting => {
        this._persistValues(setting, null, true);
      });
      /**
       * *** HACK ***
       * Pass a flag down to makerbot.js and _parseSchema to
       * avoid using tray.bodyProperties' extruder.value when
       * switching between different 6th gen printers; ie.
       * Method => Method X.
       *
       * It will reset extruders back to defaults instead of
       * persisting as sticky extruders. This hack will maintain
       * all 5th gen's sticky extruder selection.
       *
       * -- Ray
       **/

      const printer = this.flux.store('PrinterStore').getSelectedPrinter();
      const resetToDefaultExtruders = printer && printer.isSixthGen();
      const isPrinterConnectedAndAuthed = printer && printer.isConnected() && printer.isAuthenticated();

      if (resetToDefaultExtruders && !isPrinterConnectedAndAuthed) {
        const botType = printer.getGender().botType;
        let defaultExtruders = [];

        if (botType === 'lava_f') {
          defaultExtruders = ['mk14_hot', 'mk14_hot_s'];
        } else {
          defaultExtruders = ['mk14', 'mk14_s'];
        } // Update attachedExtruders to archetype_printer


        printer.setAttachedExtruders(defaultExtruders); // Update the side-effects

        printStoreUtils.updateProjectStoreProp(SettingsKeys.Extruders, defaultExtruders, true, this.flux); // Reset materials & support settings

        this.onUpdateExtruderPair();
      }

      this.onGetPrinterSchema({
        resetToDefaultExtruders
      });
      this.setSupportVisibility();
      this.emit('close_panel');
    });
  },

  /**
   * Loads the project settings into this store and sets the active settings.
   * @param {object} filteredSettings - Project Settings that have been filtered for things we do not want.
   * @param {Immutable Map} projectSettings - Settings from the project.
   */
  loadProjectSettings(filteredSettings, projectSettings) {
    const ConfigService = this.flux.getService('ConfigService');
    let extruders;
    values = R.mapObjIndexed((v, k) => projectSettings.getProperty(k).getValue(), filteredSettings);
    const isActive = R.pipe(R.mapObjIndexed(() => true), R.omit([SettingsKeys.Extruders, SettingsKeys.Materials, SettingsKeys.PrintModes]));
    visibleSettings = isActive(values);
    ConfigService.delete('printSettings');
    ConfigService.delete('activeAdvSettings');
    ConfigService.delete('extruders');
    ConfigService.delete('materials');
    R.mapObjIndexed((v, k) => {
      if (k === 'extruders') {
        extruders = v;
      }

      if (k === 'materials') {
        selectedMaterials = v;
      }

      if (k === 'printMode') {
        printMode = v;
      }

      values = printStoreUtils.persistValues(k, v, false, values, this.flux);
    }, values);
    printStoreUtils.saveToUserConfig('activeAdvSettings', visibleSettings, this.flux);
    printStoreUtils.saveToUserConfig('printSettings', values, this.flux);
    printStoreUtils.saveToUserConfig('extruders', extruders, this.flux);
    printStoreUtils.saveToUserConfig('materials', selectedMaterials, this.flux);

    this._loadSchemaInitialValue();

    this.emit(CHANGE_EVENT);
  },

  /**
   * Compares this stores settings vs project settings and fires modal if they differ.
   * @param  {object} payload - Contains the project object, dispached from fileActions.
   */
  compareSettings(payload) {
    const i18n = this.flux.getService('TranslationService');
    const ModalService = this.flux.getService('ModalService');
    const project = payload.project;
    const activeTray = project.getActiveTray();
    const trayBodies = activeTray.getTrayBodies();
    const bodyProperties = trayBodies.map(body => body.getOccurrence().getProperties()).toArray();
    const projectSettings = bodyProperties[0]; // Remove all references to 'defaultSupportMaterial' from occurrences in the project

    const projectSettingsJsonKeys = Object.keys(projectSettings.toJSON());
    projectSettingsJsonKeys.includes('defaultSupportMaterial') && printStoreUtils.updateProjectStoreProp('defaultSupportMaterial', // undefined value will remove the property from occurrence
    undefined, false, this.flux);
    const filterSettings = R.pipe(R.pickBy((v, k) => R.contains(k, R.values(SettingsKeys))), R.mapObjIndexed(R.prop('value')));
    const filteredSettings = filterSettings(projectSettings.toJSON()); // Ok so we do not have values/custom settings when we open the app and
    // do not have a model on the build plate. So if that is the case then
    // lets automatically load project settings.
    // if (valuesJSON.hasOwnProperty('applyToAll') &&
    //     Object.keys(valuesJSON).length == 1 ) {

    if (R.keys(values).length === 0) {
      this.loadProjectSettings(filteredSettings, projectSettings);
    } else if (!R.equals(values, filteredSettings)) {
      ModalService.confirm({
        body: i18n.t('mb:projectSettingsModal.body'),
        cancelText: i18n.t('mb:projectSettingsModal.projectSettingsText'),
        confirmText: i18n.t('mb:projectSettingsModal.currentSettingsText'),
        modalClass: 'w400 warningModal',
        hideClose: true,
        backdrop: 'static',
        keyboard: false,
        onCancel: () => {
          // Load project settings into this store. Project Store is already updated.
          this.loadProjectSettings(filteredSettings, projectSettings);
        },
        onConfirm: () => {
          // Load project then overwrite settings since the project
          // settings were already loaded.
          //Does not exist in values so lets not use it in project.
          R.mapObjIndexed((v, k) => R.has(k, values) ? printStoreUtils.updateProjectStoreProp(k, R.prop(k, values), true, this.flux) : printStoreUtils.updateProjectStoreProp(k, undefined, true, this.flux), filteredSettings);
        }
      });
    }
  },

  /**
   * Fires when a property on a print setting changes
   * @param {object} payload - the payload of the dispatched event. Should have `path` and `value` in it.
   * @private
   */
  initializeValues() {
    const ConfigService = this.flux.getService('ConfigService');
    const userConfigPrintSettings = ConfigService.get('printSettings');
    const userConfigActiveAdvSettings = ConfigService.get('activeAdvSettings');
    const activeTray = this.flux.store('ProjectStore').getProject().getActiveTray();
    const trayBodiesExist = activeTray.toJSON().trayBodies.size > 0;

    if (!settingsLoaded) {
      // Load 'activeAdvSettings' from user_config.json if app just loaded, and settings exist
      if (userConfigActiveAdvSettings) {
        // If app just started, use user_config 'activeAdvSettings'
        // set values (overrides) to 'printSettings'
        visibleSettings = userConfigActiveAdvSettings;
      } // If this is the first time we are seeing a tray with bodies, we need
      // to load up user_config.json's saved 'printSettings'


      if (!firstTrayLoaded && userConfigPrintSettings) {
        // If app just started, use user_config 'printSettings'
        // set values (overrides) to 'printSettings'
        values = userConfigPrintSettings; // Leaving this here to remove any previous references in
        // user_config's print settings

        values = R.dissoc('defaultSupportMaterial', values);
      }
    } // moving this up so the ui can chug along while we update the project store


    this.emit('initialize_values'); // Toggle to false until next app start.

    if (!settingsLoaded) settingsLoaded = true;
    if (!firstTrayLoaded) firstTrayLoaded = true; // Re-organizing this code to read from saved user config once at store init time,
    // saving it in store's values and visibleSettings objects.
    // However, we need to update the tray body properties every time or else we miss
    // some cases and the overrides go missing.
    // For example: when a model is added and deleted, we need to reapply overrides.
    // Not the most efficient way of doing things, and maybe someone else has
    // better ideas, but, definitely applying overrides only the first time will not work.

    if (userConfigPrintSettings && trayBodiesExist) {
      R.mapObjIndexed((v, k) => printStoreUtils.updateProjectStoreProp(k, v, true, this.flux), values);
    }
  },

  /**
   * We have this separate function for processing extruder types, partly because the offline
   * bots have some odd behavior in this context, but mainly because we need to grab this to
   * appropriately process Print Modes.
   * @param {object} data - the available configurations as well as the default
   * @private
   */
  getExtruderTypes(payload) {
    const normalized = this._extruder(payload);

    printStoreUtils.updateProjectStoreProp(SettingsKeys.Extruder, normalized, true, this.flux);
    this.emit(CHANGE_EVENT);
  },

  /**
   * Cache the supported configs once from sliceconfig on application load
   **/
  getSupportedConfigurations() {
    if (!supportedConfigurations.length) {
      supportedConfigurations = makerbot.getSupportedConfigurations();
    }
  },

  onCreatePreset({
    name
  }) {
    if (this.hasPresetWithName(name)) return;
    const preset = reducers.valuesToPreset(name, values);
    presets = R.append(preset, presets);
    currentPreset = name;
    presetError = nothing();

    this._savePresets();

    this.emit(CHANGE_EVENT);
  },

  onUpdatePreset() {
    if (!currentPreset) return;
    const preset = reducers.valuesToPreset(currentPreset, values);
    presets = reducers.updatePresetByName(currentPreset, preset, presets);

    this._savePresets();

    this.emit(CHANGE_EVENT);
  },

  onWritePreset() {
    if (!currentPreset) return;

    const {
      dialog
    } = require('electron').remote;

    const i18n = getI18n(this.flux);
    const messageStore = this.flux.store('MessageStore');
    const preset = reducers.getPresetByName(currentPreset, presets); // really not sure how this would happen, but I'd rather not debug it later if it does

    if (!preset) {
      console.error("Couldn't find preset:", currentPreset);
      return;
    }

    dialog.showSaveDialog({
      title: i18n.t('mb:printSettings.prests.saveDialog'),
      defaultPath: `${R.isEmpty(fileSafeString(currentPreset)) ? fileSafeString('New Custom Preset') : fileSafeString(currentPreset)}.${PRESET_EXT}`,
      filters: [{
        name: 'Makerbot Print Presets',
        extensions: [PRESET_EXT]
      }]
    }, filename => {
      if (filename) fs.writeJson(filename, presetToJSON(preset), err => {
        if (err) throw err;
        messageStore.onMessage({
          type: 'information',
          message: i18n.t('mb:printSettings.presets.exportSuccess')
        });
      });
      this.emit(CHANGE_EVENT);
    });
  },

  onDestroyPreset() {
    if (!currentPreset) return;
    presets = reducers.removePresetByName(currentPreset, presets);
    ({
      values,
      currentPreset
    } = printStoreUtils.resetAllToDefault(this.flux, values));

    this._savePresets(presets);

    this.emit(CHANGE_EVENT);
  },

  onReadPresets() {
    const {
      dialog
    } = require('electron').remote;

    const i18n = getI18n(this.flux);
    const messageStore = this.flux.store('MessageStore');

    const readJSON = path => fs.readJson(path, (err, obj) => {
      if (err) {
        messageStore.onMessage({
          type: 'error',
          message: i18n.t('mb:printSettings.presets.importFailure')
        });
        return;
      }

      const preset = sanitizePreset(obj, presets);
      presets = R.append(preset, presets);
      messageStore.onMessage({
        type: 'information',
        message: i18n.t('mb:printSettings.presets.importSuccess')
      });

      this._savePresets();

      this.emit(CHANGE_EVENT);
    });

    dialog.showOpenDialog({
      title: i18n.t('mb:printSettings.presets.import'),
      properties: ['openFile', 'multiSelections'],
      filters: [{
        name: 'Makerbot Print Presets',
        extensions: [PRESET_EXT]
      }]
    }, R.pipe(R.defaultTo([]), R.sortBy(R.prop('name')), R.when(R.compose(R.not, R.isEmpty), R.map(readJSON))));
  },

  onApplyPreset({
    name
  }) {
    if (currentPreset && currentPreset === name) return;
    const preset = reducers.getPresetByName(name, presets);
    if (!preset) console.error('No preset by that name');
    const filteredSettings = {};
    Object.keys(preset.settings).map(setting => {
      /**
       * Preset settings need to be filtered based on the
       * availableSettings, which gets updated upon loadSchema,
       * depending on what extruder is attached. (This is mainly for
       * filtering out EE settings on non-EE-attached printer)
       **/
      if (Object.keys(availableSettings).includes(setting)) {
        filteredSettings[setting] = preset.settings[setting];
      } // If the setting we're looking at is a print mode,
      // we check if it's supported by the current printer


      if (setting === Constants.SettingsKeys.PrintModes && supportedPrintModes.includes(preset.settings[setting])) {
        printMode = preset.settings[setting];
        filteredSettings[setting] = preset.settings[setting];
      }
    });
    const projectStoreSettings = R.merge(R.mapObjIndexed((v, k) => R.contains(k, PresetKeyBlacklist) ? v : undefined, values), filteredSettings); // taking this async so as not to block with these slow operations

    q().then(() => {
      /**
       * 'printStoreUtils.resetAllToDefault' handles the values in projectSettings
       * '_loadSchemaInitialValue' will handle the
       * printSettingsStore's state
       **/
      ({
        values,
        currentPreset
      } = printStoreUtils.resetAllToDefault(this.flux, values));

      this._loadSchemaInitialValue();
    }).then(() => {
      values = R.merge(filteredSettings, R.pick(PresetKeyBlacklist, values));
      currentPreset = name;
      this.emit(CHANGE_EVENT);
    }).then(() => {
      printStoreUtils.saveToUserConfig('printSettings', values, this.flux);
      R.mapObjIndexed((v, k) => printStoreUtils.updateProjectStoreProp(k, v, false, this.flux), projectStoreSettings);
    }).catch(console.error).done();
  },

  onRenamePreset({
    name
  }) {
    this.onDestroyPreset();
    this.onCreatePreset({
      name
    });
  },

  onUnapplyPreset() {
    if (!currentPreset) return;
    ({
      values,
      currentPreset
    } = printStoreUtils.resetAllToDefault(this.flux, values));
    this.emit(CHANGE_EVENT);
  },

  onPresetError({
    error
  }) {
    presetError = just(error);
    this.emit(CHANGE_EVENT);
  },

  onCloseModal() {
    presetError = nothing();
    this.emit(CHANGE_EVENT);
  },

  resetMaterialSpecificSettings(selectedMaterials) {
    //Since these settings are material-specific, they need to be
    //reset each time the material changes. (This includes when the
    //extruder changes)
    purgeWallCenter = [];

    this._persistValues('materials', selectedMaterials, true);

    this._persistValues(SettingsKeys.ChamberTemp, null, true);

    this._persistValues(SettingsKeys.Supports, null, true); // this._persistValues(SettingsKeys.BuildPlaneTemp, null, true);

  },

  onUpdateExtruder() {
    // A change in extruders implies a change in materials
    selectedMaterials = [];
    this.resetMaterialSpecificSettings(selectedMaterials);

    this._loadSchemaInitialValue().then(() => this.emit(CHANGE_EVENT)) // emit event for diagnostics purposes
    .then(() => this.emit(ONUPDATE_EXTRUDERS_COMPLETED_EVENT)).done();
  },

  onUpdateExtruderPair() {
    // A change in extruders implies a change in materials
    selectedMaterials = [];
    /**
     * Since we're essentially allowing sliceocnfig get_schema to return
     * default materials, but ATM sliceconfig has an issue where it doesn't
     * return proper initial values for certain settings.
     * Instead, we'll update the `selectedMaterials` based on default
     * material per extruder type.
     *
     * -- Ray
     **/

    selectedMaterials = this._getDefaultMaterialsBasedOnExtruders();
    this.resetMaterialSpecificSettings(selectedMaterials);

    this._loadSchemaInitialValue().then(() => this.emit(CHANGE_EVENT)) // emit event for diagnostics purposes
    .then(() => this.emit(ONUPDATE_EXTRUDERS_COMPLETED_EVENT)).done();
  },

  onUpdateMaterial({
    index,
    val
  }) {
    if (index > 1 || index < 0) return;
    selectedMaterials[index] = val;
    this.resetMaterialSpecificSettings(selectedMaterials);

    this._loadSchemaInitialValue().then(() => this.emit(CHANGE_EVENT)).done();
  },

  onUpdateMaterials({
    id,
    spoolsInfo
  }) {
    const currentPrinter = this.flux.store('PrinterStore').getSelectedPrinter();
    if (!(id === currentPrinter.getId())) return;
    q(this.updatePrinterSpoolInfo(currentPrinter, {
      spoolsInfo
    })).then(() => {
      selectedMaterials = spoolMaterials;
      this.resetMaterialSpecificSettings(selectedMaterials);
    }).then(() => {
      this._loadSchemaInitialValue().then(() => this.emit(CHANGE_EVENT)).done();
    }).done();
  },

  onUpdateSupports({
    supportExtruder,
    supportType
  }) {
    this._persistValues(SettingsKeys.Supports, supportType);

    this.emit(CHANGE_EVENT);
    printStoreUtils.clearBuilds(this.flux);
  },

  onUpdatePrintMode(newPrintMode) {
    const printer = this.flux.store('PrinterStore').getSelectedPrinter();
    printMode = newPrintMode;

    this._persistValues(SettingsKeys.PrintModes, printMode, true);

    this._loadSchemaInitialValue().then(() => this.emit(CHANGE_EVENT)).done();
  },

  onUpdatePurgeWallCenter(newPurgeWallcenter) {
    purgeWallCenter = newPurgeWallcenter;

    this._loadSchemaInitialValue().then(() => this.emit(CHANGE_EVENT)).done();
  },

  /************************************************************************/

  /*                          UTILITY METHODS                             */

  /************************************************************************/

  /**
   * TODO: Potential for refactor, maybe not manage 3 independently...
   *
   * Saves values across 3 objects that need to be in sync:
   * (1) tray.bodyProperties through Project Store - necessary for slicing
   * (2) values object from current store - representation of overrides
   * (3) user_config.json - app-wide saved settings under `printSettings`
   * @param {string} setting - setting key
   * @param {string} value - value to persist on key
   * @private
   */
  _persistValues(setting, value, skipUndoStack = false) {
    // Save to tray.bodyProperties for slicing
    printStoreUtils.updateProjectStoreProp(setting, value, skipUndoStack, this.flux);
    if (value != null) values = R.assoc(setting, value, values);else values = R.dissoc(setting, values); // Save to user_config as APP-WIDE settings.

    printStoreUtils.saveToUserConfig('printSettings', values, this.flux);
  },

  /**
   * Calls sliceConfig get_schema with overrides and print_mode
   * to get new initial_value for a setting, saves to override object,
   * and sets as new `initial_value` within availableSettings object.
   * @param {string} setting - the advanced setting key
   * @returns {string} - new evaluated initial_value
   * @private
   */
  _loadSchemaInitialValue() {
    const printer = this.flux.store('PrinterStore').getSelectedPrinter();

    if (printer) {
      const activeTray = this.flux.store('ProjectStore').getProject().getActiveTray();
      const tray = activeTray.getBuildInfo(printer);
      return makerbot.getSchema(tray, printer, null, this.flux).then(schema => {
        // In rare cases, if getSchema gets called too quickly, it
        // will return empty string as a result. Let's exit before
        // things error out.
        // -- Ray
        if (_.isEmpty(schema)) return;
        const fullSchema = schema.getFullSchema();

        this._parseSchema(fullSchema); // emitting again because the setting might have changed its
        // initial value, so we want the UI to reflect this change.
        // There may be a slight delay, but as long as the rest of the
        // UI changes quickly, this slight lag here shouldn't be an
        // issue for the user.


        this.emit(CHANGE_EVENT);
      });
    }
  },

  /**
   * This is a helper function to parse the JSON that comes from
   * Slice Config into a useable format for availableSettings.
   * @private
   * @param {object} schema - the object that comes from Slice Config
   */
  _parseSchema(schema, resetToDefaultExtruders = false) {
    if (!schema || !schema.user_settings) return;
    const {
      user_settings,
      extruders: schemaExtruders,
      materials: schemaMaterials,
      materials_translations: schemaMaterialTranslations,
      print_modes: schemaPrintModes
    } = schema;
    if (!user_settings || !schemaExtruders) return;
    const printer = this.flux.store('PrinterStore').getSelectedPrinter();
    const currentBotType = printer.getGender().botType;
    const filteredSettings = printStoreUtils.filterIncompatibleOverrides(user_settings, currentBotType); // list of the settings no longer available (if any) from the last time we parsed the schema

    const schemaKeyDiff = R.pipe(R.keys, R.without(R.keys(filteredSettings)), R.without([SettingsKeys.PrintModes, SettingsKeys.Extruders, SettingsKeys.Materials]))(availableSettings);
    availableSettings = reducers.availableSettings(filteredSettings); // if a setting is no longer available remove it

    R.map(k => values = printStoreUtils.persistValues(k, undefined, false, values, this.flux), schemaKeyDiff);
    supportedExtruders = schemaExtruders.supported;
    ({
      supportedExtruderPairConfigs,
      supportedExtrudersPerIndex
    } = this.generateSupportedExtrudersInfo({
      supportedConfigurations,
      printer
    }));
    supportedPrintModes = schemaPrintModes.supported;

    const supportedMaterialsByExtruder = this._getSupportedMaterialsByExtruder(printer.getAttachedExtruders(), printer, schemaMaterials, supportedConfigurations);

    supportedMaterials = supportedMaterialsByExtruder;
    materialTranslations = schemaMaterialTranslations; // Assign materials to selectedMaterials from either spoolMaterials or through schema's default materials

    selectedMaterials = this._getSelectedMaterials({
      spoolMaterials,
      selectedMaterials,
      supportedMaterialsByExtruder,
      extruders: printer.getAttachedExtruders(),
      printerIsConnected: printer.isConnected(),
      printMode,
      isSketchPrinter: printer.isSketchPrinter(),
      isFifthGen: printer.isFifthGen()
    }); // If a newly selected printer doesn't support the currently selected print mode, reset to default
    // Otherwise, persist the previously-selected print mode.

    if (printMode === null || !supportedPrintModes.includes(printMode)) {
      printMode = schemaPrintModes.default;
      values = R.assoc('printMode', printMode, values);
    }
    /**
     * NOTE:
     * Regardless if a `supporType` selection triggers an initial value of false
     * with `doPurgeWall`, `purgeWallCenter` will report an initial value. No longer
     * we can use `user_settings.purgeWallCenter` to reset `purgeWallCenter` back to an
     * empty array. ::eelroll::
     * -- Ray
     **/


    if (user_settings.doPurgeWall && user_settings.doPurgeWall.initial_value || values.doPurgeWall) {
      if (_.isEmpty(purgeWallCenter)) {
        purgeWallCenter = user_settings.purgeWallCenter && user_settings.purgeWallCenter.initial_value || [];
      }
    } else {
      purgeWallCenter = [];
    }
  },

  _getSelectedMaterials(payload) {
    const {
      spoolMaterials,
      supportedMaterialsByExtruder,
      extruders,
      printerIsConnected,
      printMode,
      isSketchPrinter,
      isFifthGen
    } = payload;
    let selectedMaterials = payload.selectedMaterials;
    const hasLabsExtruder = extruders[0] === ExtruderTypeEnum.mk14_e;

    if (printerIsConnected && !isFifthGen && spoolMaterials !== null && !hasLabsExtruder) {
      // Live bot with smart spool capabilities (so, live 6th gen bots)
      // but without a LABS Extruder.
      // This includes 6th gen bots with empty spool bays.
      // xoxo Leor
      spoolMaterials.forEach((material, bayIndex) => {
        if (material && selectedMaterials[bayIndex] !== material) {
          selectedMaterials[bayIndex] = material;
        }
      });
    } else {
      // Any archetype bot, or a live bot without smart spool capabilities
      // (so, all 5th gens), or any 6th gen with an experimental LABS extruder
      const shouldMaterialChange = selectedMaterials.length === 0 || selectedMaterials[0] === undefined || !supportedMaterialsByExtruder[0].includes(selectedMaterials[0] || hasLabsExtruder);

      if (shouldMaterialChange) {
        if (extruders.length > 1) {
          selectedMaterials[0] = supportedMaterialsByExtruder[0][0];
          selectedMaterials[1] = supportedMaterialsByExtruder[1][0];
        } else if (isSketchPrinter) {
          // Default to [ PLA ]
          selectedMaterials[0] = supportedMaterialsByExtruder[0][1];
        } else {
          selectedMaterials = supportedMaterialsByExtruder[0];
        }
      }
    }

    return selectedMaterials;
  },

  getDefaultMaterials(supportedConfigurations, options) {
    // returns nested array of materials per extruder by way
    // of slice config's supportedConfigurations' e.g. [['abs'],['sr30']]
    const {
      printer,
      printMode,
      extruders
    } = options;

    try {
      return supportedConfigurations.filter(config => config.machine_id === printer.getGender().botType).filter(config => printMode ? config.print_mode === printMode : true).filter(config => _.isEqual(config.extruder_ids, extruders)).map(config => config.material_ids).reduce((accArr, materials) => {
        materials.map((material, index) => {
          !accArr[index] ? accArr[index] = [material] : accArr[index].push(material);
        });
        return accArr;
      }, []).map(bayMaterials => _.uniq(bayMaterials));
    } catch (err) {
      console.error(err);
    }
  },

  generateSupportedExtrudersInfo(payload) {
    const {
      printer,
      supportedConfigurations
    } = payload;
    const {
      botType
    } = printer.getGender();
    const filteredResults = supportedConfigurations.filter(config => config.machine_id === botType) // Don't want to filter by printMode or else we'll limit
    // the extruders lists. Extruder dropdown should dictate
    // supported print modes...
    .map(config => config.extruder_ids);
    const supportedExtruderPairConfigs = filteredResults.reduce((accArr, extruderIds) => {
      // if [mk14, mk14_s] not contain in [[mk14_hot, mk14_hots], [...]]
      !R.contains(extruderIds, accArr) // Update R.contains (Deprecated) to R.includes
      ? accArr.push(extruderIds) : null;
      return accArr;
    }, []);
    const supportedExtrudersPerIndex = filteredResults.reduce((accArr, extruderIds) => {
      extruderIds.map((extruderId, index) => {
        // ie. if accArr == [undefined, undefined]
        if (!accArr[index]) {
          accArr[index] = [extruderId];
        } else {
          // ie. if mk13_impla not in [[mk12, mk13, ...]]
          // Update R.contains (Deprecated) to R.includes
          // w/ Ramda ^0.26
          if (!R.contains(extruderId, accArr[index]) && extruderId !== ExtruderTypeEnum.mk13_experimental) {
            accArr[index].push(extruderId);
          }
        }
      });
      return accArr;
    }, []);
    return {
      supportedExtruderPairConfigs,
      supportedExtrudersPerIndex
    };
  },

  _getSupportedMaterialsByExtruder(extruders, printer) {
    const currentBotType = printer.getGender().botType; //materials supported by each extruder on the bot

    const materials = extruders.map((extruder, index) => {
      return supportedConfigurations.reduce(function (materialsForThisExtruder, config) {
        if (config.machine_id === currentBotType && _.isEqual(config.extruder_ids, extruders) && !materialsForThisExtruder.includes(config.material_ids[index])) {
          materialsForThisExtruder.push(config.material_ids[index]);
        }

        return materialsForThisExtruder;
      }, []);
    });
    return materials;
  },

  _savePresets() {
    printStoreUtils.saveToUserConfig('presets', presets, this.flux);
  },

  _getDefaultMaterialsBasedOnExtruders() {
    const enumExtruderToDefaultMaterials = _objectSpread({}, ExtruderToDefaultMaterial);

    const printer = this.flux.store('PrinterStore').getSelectedPrinter();
    const extruders = printer && printer.getAttachedExtruders();
    return extruders.map(extruder => enumExtruderToDefaultMaterials[extruder]);
  }

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByaW50U2V0dGluZ3NTdG9yZS5qcyJdLCJuYW1lcyI6WyJGbHV4eG9yIiwicmVxdWlyZSIsIlIiLCJfIiwiZnMiLCJxIiwiZGVjb2RlS2V5IiwiQ0hBTkdFX0VWRU5UIiwiT05VUERBVEVfRVhUUlVERVJTX0NPTVBMRVRFRF9FVkVOVCIsIm1ha2VyYm90IiwiTCIsInJlZHVjZXJzIiwiZm9ybWF0IiwiQ29uc3RhbnRzIiwicHJpbnRTdG9yZVV0aWxzIiwiQWN0aW9ucyIsIkV4dHJ1ZGVyVHlwZUVudW0iLCJFeHRydWRlclRvRGVmYXVsdE1hdGVyaWFsIiwiZmlsZVNhZmVTdHJpbmciLCJnZXRJMThuIiwianVzdCIsIm5vdGhpbmciLCJzYW5pdGl6ZVByZXNldCIsInByZXNldFRvSlNPTiIsImdldFZlcnNpb24iLCJ0aGVuIiwidHJpbSIsInYiLCJkb25lIiwiU2V0dGluZ3NLZXlzIiwiUHJlc2V0S2V5QmxhY2tsaXN0IiwiYXZhaWxhYmxlU2V0dGluZ3MiLCJ2aXNpYmxlU2V0dGluZ3MiLCJ2YWx1ZXMiLCJzdXBwb3J0ZWRFeHRydWRlcnMiLCJzdXBwb3J0ZWRFeHRydWRlcnNQZXJJbmRleCIsInN1cHBvcnRlZEV4dHJ1ZGVyUGFpckNvbmZpZ3MiLCJzZWxlY3RlZE1hdGVyaWFscyIsInN1cHBvcnRlZE1hdGVyaWFscyIsIm1hdGVyaWFsVHJhbnNsYXRpb25zIiwic3Bvb2xNYXRlcmlhbHMiLCJwcmludE1vZGUiLCJzdXBwb3J0ZWRQcmludE1vZGVzIiwicHVyZ2VXYWxsQ2VudGVyIiwic2V0dGluZ3NMb2FkZWQiLCJmaXJzdFRyYXlMb2FkZWQiLCJzdXBwb3J0ZWRDb25maWd1cmF0aW9ucyIsIlBSRVNFVF9FWFQiLCJwcmVzZXRzIiwiY3VycmVudFByZXNldCIsInByZXNldEVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsImNyZWF0ZVN0b3JlIiwiYWN0aW9ucyIsIlRvZ2dsZVByb3AiLCJCdWxrVG9nZ2xlUHJvcCIsIlJlc2V0VG9EZWZhdWx0IiwiR2V0UHJpbnRlclNjaGVtYSIsIlVwZGF0ZVByb3BlcnR5IiwiU2VsZWN0UHJpbnRlciIsIkdldEV4dHJ1ZGVyVHlwZXMiLCJHZXRTdXBwb3J0ZWRDb25maWd1cmF0aW9ucyIsIkluaXRhbGl6ZVZhbHVlcyIsIkF1dGhlbnRpY2F0aW9uV2FpdGluZyIsIlJlc2V0QWxsVG9EZWZhdWx0IiwiUmVtb3ZlQWxsU2V0dGluZ3MiLCJDb21wYXJlU2V0dGluZ3MiLCJDcmVhdGVQcmVzZXQiLCJXcml0ZVByZXNldCIsIlVwZGF0ZVByZXNldCIsIkRlc3Ryb3lQcmVzZXQiLCJSZWFkUHJlc2V0cyIsIkFwcGx5UHJlc2V0IiwiVW5hcHBseVByZXNldCIsIlJlbmFtZVByZXNldCIsIlByZXNldEVycm9yIiwiQ2xvc2VNb2RhbCIsIlJldmVydENoYW5nZXMiLCJVcGRhdGVFeHRydWRlciIsIlVwZGF0ZUV4dHJ1ZGVyUGFpciIsIlVwZGF0ZU1hdGVyaWFsIiwiVXBkYXRlTWF0ZXJpYWxzIiwiVXBkYXRlU3VwcG9ydHMiLCJVcGRhdGVQcmludE1vZGUiLCJVcGRhdGVQdXJnZVdhbGxDZW50ZXIiLCJnZXRTdGF0ZSIsInNldHRpbmdzIiwic3RhdGUiLCJHcm91cERpY3QiLCJPcHRpb25zIiwiRm9ybWF0IiwiU2FuaXRpemF0aW9uIiwiU2V0dGluZ3NUeXBlcyIsImV4dHJ1ZGVycyIsInN1cHBvcnRlZCIsIm1hdGVyaWFscyIsInNlbGVjdGVkIiwidHJhbnNsYXRpb25zIiwiaGFzRXh0cnVkZXJNYXRlcmlhbE1pc21hdGNoIiwic3VwcG9ydGVkTWF0ZXJpYWxzRnJvbUZpcm13YXJlIiwicHJpbnRlciIsImZsdXgiLCJzdG9yZSIsImdldFNlbGVjdGVkUHJpbnRlciIsImlzTGl2ZUJvdCIsImlzQ29ubmVjdGVkIiwiaXNBdXRoZW50aWNhdGVkIiwiaGFzTWlzbWF0Y2giLCJpc1NpeHRoR2VuIiwiYXR0YWNoZWRFeHRydWRlcnMiLCJnZXRBdHRhY2hlZEV4dHJ1ZGVycyIsInN1cHBvcnRlZE1hdGVyaWFsc0J5RXh0cnVkZXIiLCJsZW5ndGgiLCJfZ2V0U3VwcG9ydGVkTWF0ZXJpYWxzQnlFeHRydWRlciIsIm1hcCIsInNwb29sTWF0ZXJpYWwiLCJpbmRleCIsImluY2x1ZGVzIiwibWsxNF9lIiwic2V0U3VwcG9ydFZpc2liaWxpdHkiLCJkb1N1cHBvcnQiLCJzdXBwb3J0VHlwZSIsImdldFZpc2libGVTZXR0aW5ncyIsImdldE92ZXJyaWRlcyIsIm1hcEtleXMiLCJvbWl0IiwidmFsIiwia2V5IiwiaGFzT3ZlcnJpZGVzRm9yUHJpbnRNb2RlIiwiY3VycmVudFByaW50TW9kZSIsImN1cnJlbnRQcmludE1vZGVDaGFuZ2VkIiwiaGFzT3ZlcnJpZGUiLCJwaXBlIiwibHQiLCJoYXNPdmVycmlkZXNGb3JQcmVzZXQiLCJwcmVzZXQiLCJlcXVhbHMiLCJnZXRQcmVzZXRCeU5hbWUiLCJoYXNQcmVzZXRXaXRoTmFtZSIsIm5hbWUiLCJvbkFkdmFuY2VkVG9nZ2xlIiwicGF5bG9hZCIsInNldHRpbmciLCJ0b2dnbGVkT24iLCJ2aXNpYmxlIiwidW5kZWZpbmVkIiwicHJvcE9yIiwiYXNzb2MiLCJlbWl0Iiwic2NoZW1hSW5pdGlhbFZhbHVlIiwiX2xvYWRTY2hlbWFJbml0aWFsVmFsdWUiLCJzYXZlVG9Vc2VyQ29uZmlnIiwidXBkYXRlUHJvamVjdFN0b3JlUHJvcCIsIk1hdGVyaWFscyIsIlByaW50TW9kZXMiLCJjYXRjaCIsImNvbnNvbGUiLCJlcnJvciIsInJlc2V0VG9EZWZhdWx0IiwicGVyc2lzdFZhbHVlcyIsImNsZWFyQnVpbGRzIiwib25VcGRhdGVQcm9wZXJ0eSIsImtleUZyb21QYXRoIiwicGF0aCIsIlN1cHBvcnRzIiwiUHVyZ2VXYWxsIiwiaGFzIiwicmVzZXRBbGxUb0RlZmF1bHQiLCJ2YWx1ZSIsIm9uUmVzZXRBbGxUb0RlZmF1bHQiLCJvblJlbW92ZUFsbFNldHRpbmdzIiwicmVtb3ZlQWxsU2V0dGluZ3MiLCJvblJldmVydENoYW5nZXMiLCJwcmVzZXRCdWYiLCJvbkFwcGx5UHJlc2V0IiwicHJpbnRNb2RlQnVmIiwidmlldyIsIm9uQnVsa0FkdmFuY2VkVG9nZ2xlIiwibWVyZ2UiLCJhY3RpdmUiLCJjbGVhblZhbHVlcyIsIm9uR2V0UHJpbnRlclNjaGVtYSIsInJlc2V0VG9EZWZhdWx0RXh0cnVkZXJzIiwiaXNQcmludGVyQ29ubmVjdGVkQW5kQXV0aGVkIiwiaWdub3JlRXh0cnVkZXJBcmdzIiwic3Bvb2xzSW5mbyIsIl9wZXJzaXN0VmFsdWVzIiwiQ2hhbWJlclRlbXAiLCJDb25maWdTZXJ2aWNlIiwiZ2V0U2VydmljZSIsImFjdGl2ZVRyYXkiLCJnZXRQcm9qZWN0IiwiZ2V0QWN0aXZlVHJheSIsInRyYXkiLCJnZXRCdWlsZEluZm8iLCJpc0VtcHR5IiwiZ2V0IiwidXBkYXRlUHJpbnRlclNwb29sSW5mbyIsImdldFNjaGVtYSIsInNjaGVtYSIsIl9wYXJzZVNjaGVtYSIsImdldEZ1bGxTY2hlbWEiLCJFeHRydWRlcnMiLCJlcnIiLCJwYXJzZVNwb29sc0luZm8iLCJzcG9vbEluZm8iLCJiYXlJbmRleCIsIm1hdGVyaWFsX25hbWUiLCJpc05pbCIsImdldFNwb29sSW5mbyIsIm9uU2VsZWN0UHJpbnRlciIsIndhaXRGb3IiLCJzZXR0aW5nc1dpdGhCb3RTcGVjaWZpY1ZhbHVlcyIsImJvdFR5cGUiLCJnZXRHZW5kZXIiLCJkZWZhdWx0RXh0cnVkZXJzIiwic2V0QXR0YWNoZWRFeHRydWRlcnMiLCJvblVwZGF0ZUV4dHJ1ZGVyUGFpciIsImxvYWRQcm9qZWN0U2V0dGluZ3MiLCJmaWx0ZXJlZFNldHRpbmdzIiwicHJvamVjdFNldHRpbmdzIiwibWFwT2JqSW5kZXhlZCIsImsiLCJnZXRQcm9wZXJ0eSIsImdldFZhbHVlIiwiaXNBY3RpdmUiLCJkZWxldGUiLCJjb21wYXJlU2V0dGluZ3MiLCJpMThuIiwiTW9kYWxTZXJ2aWNlIiwicHJvamVjdCIsInRyYXlCb2RpZXMiLCJnZXRUcmF5Qm9kaWVzIiwiYm9keVByb3BlcnRpZXMiLCJib2R5IiwiZ2V0T2NjdXJyZW5jZSIsImdldFByb3BlcnRpZXMiLCJ0b0FycmF5IiwicHJvamVjdFNldHRpbmdzSnNvbktleXMiLCJPYmplY3QiLCJrZXlzIiwidG9KU09OIiwiZmlsdGVyU2V0dGluZ3MiLCJwaWNrQnkiLCJjb250YWlucyIsInByb3AiLCJjb25maXJtIiwidCIsImNhbmNlbFRleHQiLCJjb25maXJtVGV4dCIsIm1vZGFsQ2xhc3MiLCJoaWRlQ2xvc2UiLCJiYWNrZHJvcCIsImtleWJvYXJkIiwib25DYW5jZWwiLCJvbkNvbmZpcm0iLCJpbml0aWFsaXplVmFsdWVzIiwidXNlckNvbmZpZ1ByaW50U2V0dGluZ3MiLCJ1c2VyQ29uZmlnQWN0aXZlQWR2U2V0dGluZ3MiLCJ0cmF5Qm9kaWVzRXhpc3QiLCJzaXplIiwiZGlzc29jIiwiZ2V0RXh0cnVkZXJUeXBlcyIsIm5vcm1hbGl6ZWQiLCJfZXh0cnVkZXIiLCJFeHRydWRlciIsImdldFN1cHBvcnRlZENvbmZpZ3VyYXRpb25zIiwib25DcmVhdGVQcmVzZXQiLCJ2YWx1ZXNUb1ByZXNldCIsImFwcGVuZCIsIl9zYXZlUHJlc2V0cyIsIm9uVXBkYXRlUHJlc2V0IiwidXBkYXRlUHJlc2V0QnlOYW1lIiwib25Xcml0ZVByZXNldCIsImRpYWxvZyIsInJlbW90ZSIsIm1lc3NhZ2VTdG9yZSIsInNob3dTYXZlRGlhbG9nIiwidGl0bGUiLCJkZWZhdWx0UGF0aCIsImZpbHRlcnMiLCJleHRlbnNpb25zIiwiZmlsZW5hbWUiLCJ3cml0ZUpzb24iLCJvbk1lc3NhZ2UiLCJ0eXBlIiwibWVzc2FnZSIsIm9uRGVzdHJveVByZXNldCIsInJlbW92ZVByZXNldEJ5TmFtZSIsIm9uUmVhZFByZXNldHMiLCJyZWFkSlNPTiIsInJlYWRKc29uIiwib2JqIiwic2hvd09wZW5EaWFsb2ciLCJwcm9wZXJ0aWVzIiwiZGVmYXVsdFRvIiwic29ydEJ5Iiwid2hlbiIsImNvbXBvc2UiLCJub3QiLCJwcm9qZWN0U3RvcmVTZXR0aW5ncyIsInBpY2siLCJvblJlbmFtZVByZXNldCIsIm9uVW5hcHBseVByZXNldCIsIm9uUHJlc2V0RXJyb3IiLCJvbkNsb3NlTW9kYWwiLCJyZXNldE1hdGVyaWFsU3BlY2lmaWNTZXR0aW5ncyIsIm9uVXBkYXRlRXh0cnVkZXIiLCJfZ2V0RGVmYXVsdE1hdGVyaWFsc0Jhc2VkT25FeHRydWRlcnMiLCJvblVwZGF0ZU1hdGVyaWFsIiwib25VcGRhdGVNYXRlcmlhbHMiLCJpZCIsImN1cnJlbnRQcmludGVyIiwiZ2V0SWQiLCJvblVwZGF0ZVN1cHBvcnRzIiwic3VwcG9ydEV4dHJ1ZGVyIiwib25VcGRhdGVQcmludE1vZGUiLCJuZXdQcmludE1vZGUiLCJvblVwZGF0ZVB1cmdlV2FsbENlbnRlciIsIm5ld1B1cmdlV2FsbGNlbnRlciIsInNraXBVbmRvU3RhY2siLCJmdWxsU2NoZW1hIiwidXNlcl9zZXR0aW5ncyIsInNjaGVtYUV4dHJ1ZGVycyIsInNjaGVtYU1hdGVyaWFscyIsIm1hdGVyaWFsc190cmFuc2xhdGlvbnMiLCJzY2hlbWFNYXRlcmlhbFRyYW5zbGF0aW9ucyIsInByaW50X21vZGVzIiwic2NoZW1hUHJpbnRNb2RlcyIsImN1cnJlbnRCb3RUeXBlIiwiZmlsdGVySW5jb21wYXRpYmxlT3ZlcnJpZGVzIiwic2NoZW1hS2V5RGlmZiIsIndpdGhvdXQiLCJnZW5lcmF0ZVN1cHBvcnRlZEV4dHJ1ZGVyc0luZm8iLCJfZ2V0U2VsZWN0ZWRNYXRlcmlhbHMiLCJwcmludGVySXNDb25uZWN0ZWQiLCJpc1NrZXRjaFByaW50ZXIiLCJpc0ZpZnRoR2VuIiwiZGVmYXVsdCIsImRvUHVyZ2VXYWxsIiwiaW5pdGlhbF92YWx1ZSIsImhhc0xhYnNFeHRydWRlciIsImZvckVhY2giLCJtYXRlcmlhbCIsInNob3VsZE1hdGVyaWFsQ2hhbmdlIiwiZ2V0RGVmYXVsdE1hdGVyaWFscyIsIm9wdGlvbnMiLCJmaWx0ZXIiLCJjb25maWciLCJtYWNoaW5lX2lkIiwicHJpbnRfbW9kZSIsImlzRXF1YWwiLCJleHRydWRlcl9pZHMiLCJtYXRlcmlhbF9pZHMiLCJyZWR1Y2UiLCJhY2NBcnIiLCJwdXNoIiwiYmF5TWF0ZXJpYWxzIiwidW5pcSIsImZpbHRlcmVkUmVzdWx0cyIsImV4dHJ1ZGVySWRzIiwiZXh0cnVkZXJJZCIsIm1rMTNfZXhwZXJpbWVudGFsIiwiZXh0cnVkZXIiLCJtYXRlcmlhbHNGb3JUaGlzRXh0cnVkZXIiLCJlbnVtRXh0cnVkZXJUb0RlZmF1bHRNYXRlcmlhbHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFFQSxNQUFNQSxPQUFPLEdBQUdDLE9BQU8sQ0FBQyxTQUFELENBQXZCOztBQUNBLE1BQU1DLENBQUMsR0FBR0QsT0FBTyxDQUFDLE9BQUQsQ0FBakI7O0FBQ0EsTUFBTUUsQ0FBQyxHQUFHRixPQUFPLENBQUMsUUFBRCxDQUFqQjs7QUFDQSxNQUFNRyxFQUFFLEdBQUdILE9BQU8sQ0FBQyxVQUFELENBQWxCOztBQUNBLE1BQU1JLENBQUMsR0FBR0osT0FBTyxDQUFDLEdBQUQsQ0FBakI7O0FBQ0EsTUFBTTtBQUFFSyxFQUFBQTtBQUFGLElBQWdCTCxPQUFPLENBQUMsc0JBQUQsQ0FBN0I7O0FBRUEsTUFBTU0sWUFBWSxHQUFHLFFBQXJCO0FBQ0EsTUFBTUMsa0NBQWtDLEdBQUcsb0NBQTNDOztBQUNBLE1BQU1DLFFBQVEsR0FBR1IsT0FBTyxDQUFDLGFBQUQsQ0FBeEI7O0FBQ0EsTUFBTVMsQ0FBQyxHQUFHVCxPQUFPLENBQUMsK0JBQUQsQ0FBakI7O0FBQ0EsTUFBTVUsUUFBUSxHQUFHVixPQUFPLENBQUMsaUNBQUQsQ0FBeEI7O0FBQ0EsTUFBTVcsTUFBTSxHQUFHWCxPQUFPLENBQUMsK0JBQUQs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LEtBQUtDLElBQUwsQ0FBVUMsS0FBVixDQUFnQixjQUFoQixFQUFnQ0Msa0JBQWhDLEVBQWhCO0FBQ0EsVUFBTVYsU0FBUyxHQUFHTyxPQUFPLElBQUlBLE9BQU8sQ0FBQ1Usb0JBQVIsRUFBN0I7QUFFQSxXQUFPakIsU0FBUyxDQUFDcUIsR0FBVixDQUFjeVAsUUFBUSxJQUFJRSw4QkFBOEIsQ0FBQ0YsUUFBRCxDQUF4RCxDQUFQO0FBQ0g7O0FBcHRDZ0MsQ0FBcEIsQ0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQG1vZHVsZSBQcmludFNldHRpbmdzU3RvcmVcclxuICogQGRlc2NcclxuICogVGhlIFByaW50IFNldHRpbmdzIFN0b3JlIGF0dGVtcHQgdG8gc2ltcGxpZnkgdGhlIHRlZGlvdXMgYnVzaW5lc3Mgb2YgYWRkaW5nIG92ZXJyaWRlcyB0byBwcmludCBzZXR0aW5ncy4gVXNpbmcgdGhlXHJcbiAqIHN0b3JlIGlzIGZhaXJseSBzdHJhaWdodCBmb3J3YXJkLCBob3dldmVyIHRoZSB3YXkgaXQncyBwdXQgdG9nZXRoZXIgdW5kZXIgdGhlIGhvb2QgbWF5IGJlIGEgbGl0dGxlIGNvbmZ1c2luZyBhdFxyXG4gKiBmaXJzdCBnbGFuY2UuIEZvcnR1bmF0ZWx5LCBJJ20gaGVyZSB0byBleHBsYWluLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBjbGFzcyBteUNvbXBvbmVudCBleHRlbmRzIEZsdXhDb21wb25lbnQge1xyXG4gKiAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAqICAgICAgc3VwZXIocHJvcHMpO1xyXG4gKiAgICAgIHRoaXMuX3N0b3JlID0gdGhpcy5nZXRGbHV4KCkuc3RvcmUoJ1ByaW50U2V0dGluZ3NTdG9yZScpO1xyXG4gKiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpO1xyXG4gKiAgIH1cclxuICpcclxuICogICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICogICAgICB0aGlzLl9zdG9yZS5vbihcImNoYW5nZVwiLCAoKSA9PiB0aGlzLnNldFN0YXRlKHRoaXMuX3N0b3JlLmdldFN0YXRlKCkpKTtcclxuICogICB9XHJcbiAqXHJcbiAqICAgcmVuZGVyKCkge1xyXG4gKiAgICAgIC8vIHJlbmRlciBvbmx5IGFjdGl2ZSBzZXR0aW5ncyBhbmQgdGhlaXIgdmFsdWVzXHJcbiAqICAgICAgcmV0dXJuIChcclxuICogICAgICAgICAgPHVsPlxyXG4gKiAgICAgICAgICAgICAge1xyXG4gKiAgICAgICAgICAgICAgICAgIFIucGlwZShcclxuICogICAgICAgICAgICAgICAgICAgICAgUi5waWNrQnkocHJvcE9yKGZhbHNlLCAnYWN0aXZlJykpLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICBSLm1hcE9iakluZGV4ZWQoKHYsIGspID0+IDxsaT57di5uYW1lfToge3YudmFsdWV9KVxyXG4gKiAgICAgICAgICAgICAgICAgICkodGhpcy5zdGF0ZS5zZXR0aW5ncylcclxuICogICAgICAgICAgICAgIH1cclxuICogICAgICAgICAgPC91bD5cclxuICogICAgICApO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvbiBMYWluZyAmIFdlbnNvbiBUc2FpXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE5PVEUhXHJcbiAqIEV2ZXJ5IHNldHRpbmcgdGhhdCBTbGljZSBDb25maWcvTWlyYWNsZSBHcnVlIHNsaWNlcyB3aXRoXHJcbiAqIGlzIGN1cnJlbnRseSB2YWxpZGF0ZWQgd2hlbiBzYXZpbmcgYW5kIGxvYWRpbmcgZnJvbSBwcm9qZWN0Lmpzb24uXHJcbiAqIFdoZW4gYSBuZXcgc2V0dGluZyBpcyBhZGRlZCxcclxuICogd2UgTVVTVCBVUERBVEUgbWItcGx1Z2luL21iLXByb2plY3QtdmFsaWRhdG9yLXByb3ZpZGVyLmpzXHJcbiAqIGFkZGluZyBwcm9wZXJ0eSB0byB0aGUgc2NoZW1hLCBvciBlbHNlIHByb2plY3RzIHdpdGggdGhlc2Ugc2NoZW1hc1xyXG4gKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGxvYWQhXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBGbHV4eG9yID0gcmVxdWlyZSgnZmx1eHhvcicpO1xyXG5jb25zdCBSID0gcmVxdWlyZSgncmFtZGEnKTtcclxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XHJcbmNvbnN0IHEgPSByZXF1aXJlKCdxJyk7XHJcbmNvbnN0IHsgZGVjb2RlS2V5IH0gPSByZXF1aXJlKCdAbWFrZXJib3Qvc2V0dGluZ3N1aScpO1xyXG5cclxuY29uc3QgQ0hBTkdFX0VWRU5UID0gJ2NoYW5nZSc7XHJcbmNvbnN0IE9OVVBEQVRFX0VYVFJVREVSU19DT01QTEVURURfRVZFTlQgPSAnT05VUERBVEVfRVhUUlVERVJTX0NPTVBMRVRFRF9FVkVOVCc7XHJcbmNvbnN0IG1ha2VyYm90ID0gcmVxdWlyZSgnLi4vbWFrZXJib3QnKTtcclxuY29uc3QgTCA9IHJlcXVpcmUoJy4uL3V0aWxzL3ByaW50U2V0dGluZ3MvbGVuc2VzJyk7XHJcbmNvbnN0IHJlZHVjZXJzID0gcmVxdWlyZSgnLi4vdXRpbHMvcHJpbnRTZXR0aW5ncy9yZWR1Y2VycycpO1xyXG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCcuLi91dGlscy9wcmludFNldHRpbmdzL2Zvcm1hdCcpO1xyXG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvcHJpbnRfc2V0dGluZ3MnKTtcclxuY29uc3QgcHJpbnRTdG9yZVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvcHJpbnRTZXR0aW5ncy9wcmludFNldHRpbmdzU3RvcmVVdGlscycpO1xyXG5jb25zdCB7IEFjdGlvbnMgfSA9IENvbnN0YW50cztcclxuY29uc3QgeyBFeHRydWRlclR5cGVFbnVtLCBFeHRydWRlclRvRGVmYXVsdE1hdGVyaWFsIH0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcclxuY29uc3QgeyBmaWxlU2FmZVN0cmluZywgZ2V0STE4biB9ID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG5jb25zdCB7IGp1c3QsIG5vdGhpbmcgfSA9IHJlcXVpcmUoJy4uL3V0aWxzL21heWJlJyk7XHJcblxyXG5sZXQgc2FuaXRpemVQcmVzZXQsIHByZXNldFRvSlNPTjtcclxuXHJcbm1ha2VyYm90XHJcbiAgICAuZ2V0VmVyc2lvbigpXHJcbiAgICAudGhlbihSLnRyaW0pXHJcbiAgICAudGhlbih2ID0+IHtcclxuICAgICAgICBzYW5pdGl6ZVByZXNldCA9IHJlZHVjZXJzLnNhbml0aXplUHJlc2V0KHYpO1xyXG4gICAgICAgIHByZXNldFRvSlNPTiA9IHJlZHVjZXJzLnByZXNldFRvSlNPTih2KTtcclxuICAgIH0pXHJcbiAgICAuZG9uZSgpO1xyXG5cclxuLyoqXHJcbiAqIERpY3Rpb25hcnkgb2YgYWxsIHRoZSBzZXR0aW5ncyBtYXBwaW5ncyBmb3IgdGhlIFByaW50IFNldHRpbmdzIFBhbmVsLlxyXG4gKiBXZSB1c2UgdGhpcyBzbyB3ZSBkb24ndCBoYXZlIHRvIGtlZXAgcGFzc2luZyBzdHJpbmdzIGFyb3VuZCBhbmQgdGhlblxyXG4gKiB0eXBlIHRoZW0gd3JvbmcsIGNhdXNpbmcgdGhlbSB0byBmYWlsIHNpbGVudGx5LlxyXG4gKiBAY29uc3RhbnQge09iamVjdDxzdHJpbmcsIHN0cmluZ1tdPn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IFNldHRpbmdzS2V5cyA9IENvbnN0YW50cy5TZXR0aW5nc0tleXM7XHJcbmNvbnN0IFByZXNldEtleUJsYWNrbGlzdCA9IENvbnN0YW50cy5QcmVzZXRLZXlCbGFja2xpc3Q7XHJcblxyXG4vLy8vLy8vLy8vLyBTVE9SRUQgVkFMVUVTIC8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaG9sZHMgYWxsIHRoZSBwb3NzaWJsZSBvdmVycmlkZSBzZXR0aW5ncyB0aGF0IGNvbWVzXHJcbiAqIGZyb20gdGhlIFNsaWNlIENvbmZpZy4gVGhpcyBpcyBOT1QgZm9yIGhvbGRpbmcgdmFsdWVzLiBUaGVcclxuICogdXNlciBzaG91bGQgbm90IGhhdmUgYW55IGFiaWxpdHkgdG8gY2hhbmdlIHRoaXMuIFRoZSBvbmx5XHJcbiAqIHRpbWUgdGhpcyBzaG91bGQgY2hhbmdlIGlzIGlmIHRoZSBwcmludGVyIGNoYW5nZWQuIFdlIGtlZXAgdGhpc1xyXG4gKiBzZXBhcmF0ZSBmcm9tIHRoZSB1c2VyLWJvdW5kIGRhdGEgdG8gbWFrZSBzdXJlIHRoZSBzY2hlbWEgb2YgcG9zc2libGVcclxuICogb3ZlcnJpZGVzIHN0YXlzIGNsZWFuLiBXZSBkbyB0aGlzIGluIGhvcGVzIG9mIGF2b2lkaW5nIGJ1Z3MgY2F1c2VkXHJcbiAqIGJ5IHRvbyBtYW55IGNvbmZ1c2luZyB0cmVlIHRyYXZlcnNhbHMgYW5kIGlubGluZSBtdXRhdGlvbnMuXHJcbiAqIEBzZWUgU3RvcmUuZ2V0U3RhdGUoKVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgYW55Pn1cclxuICovXHJcbmxldCBhdmFpbGFibGVTZXR0aW5ncyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaW5kaWNhdGVzIHdoZXRoZXIgYSBwYXJ0aWN1bGFyIG92ZXJyaWRlIGhhcyBiZWVuXHJcbiAqIGFjdGl2YXRlZCBieSB0aGUgdXNlci4gVGhpcyBiZWNvbWVzIG1vcmUgcG93ZXJmdWwgd2hlblxyXG4gKiBpdCBpcyBjb21iaW5lZCB3aXRoIGBhdmFpbGFibGVPdmVycmlkZXNgIGFuZCBgdmFsdWVzYC5cclxuICogQHNlZSBTdG9yZS5nZXRTdGF0ZSgpXHJcbiAqIEBleGFtcGxlXHJcbiAqIFIucHJvcCgnaW5maWxsJywgdmlzaWJsZVNldHRpbmdzKSA9PSB0cnVlO1xyXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgYm9vbGVhbj59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5sZXQgdmlzaWJsZVNldHRpbmdzID0ge307XHJcblxyXG4vKipcclxuICogVGhpcyBob2xkcyB0aGF0IHZhbHVlcyBvZiB0aGUgYWN0aXZlIHNldHRpbmdzLlxyXG4gKiBAc2VlIFN0b3JlLmdldFN0YXRlKClcclxuICogQGV4YW1wbGVcclxuICogUi5wcm9wKCdsYXllcl9oZWlnaHQnLCB2YWx1ZXMpOyAvLyAwLjJcclxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIGFueT59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5sZXQgdmFsdWVzID0ge307XHJcblxyXG5sZXQgc3VwcG9ydGVkRXh0cnVkZXJzID0gW107XHJcbi8vIExpc3RzIHN1cHBvcnRlZCBleHRydWRlcnMgcGVyIGV4dHJ1ZGVyLWluZGV4XHJcbi8vIGllLiBbW21rMTMsIG1rMTNfaW1wbGEsIG1rMTNfZXhwZXJpbWVudGFsXV0gICoqIDV0aCBHZW4gUHJpbnRlcnMgKipcclxuLy8gaWUuIFtbbWsxNCwgbWsxNF9ob3RdLCBbbWsxNF9zLCBtazE0X2hvdF9zXV0gKiogNnRoIEdlbiBQcmludGVycyAqKlxyXG5sZXQgc3VwcG9ydGVkRXh0cnVkZXJzUGVySW5kZXggPSBbXTtcclxuLy8gTGlzdHMgc3VwcG9ydGVkIGV4dHJ1ZGVyIHBhaXIgY29uZmlndXJhdGlvbnNcclxuLy8gaWUuIFtbbWsxM10sIFttazEzX2ltcGxhXSwgW21rMTNfZXhwZXJpbWVudGFsXV0gICoqIDV0aCBHZW4gUHJpbnRlcnMgKipcclxuLy8gaWUuIFtbbWsxNCwgbWsxNF9zXSwgW21rMTRfaG90LCBtazE0X2hvdF9zXV0gICAgICoqIDZ0aCBHZW4gUHJpbnRlcnMgKipcclxubGV0IHN1cHBvcnRlZEV4dHJ1ZGVyUGFpckNvbmZpZ3MgPSBbXTtcclxuXHJcbmxldCBzZWxlY3RlZE1hdGVyaWFscyA9IFtdO1xyXG5sZXQgc3VwcG9ydGVkTWF0ZXJpYWxzID0gW107XHJcbmxldCBtYXRlcmlhbFRyYW5zbGF0aW9ucyA9IHt9O1xyXG5sZXQgc3Bvb2xNYXRlcmlhbHMgPSBbXTtcclxuXHJcbmxldCBwcmludE1vZGUgPSBudWxsO1xyXG5sZXQgc3VwcG9ydGVkUHJpbnRNb2RlcyA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgYXJyYXkgd2lsbCBob2xkIHRoZSB4LHkgY29vcmRpbmF0ZXMgZm9yIHRoZSBwdXJnZVdhbGxDZW50ZXIuXHJcbiAqIEZvciA0dGggJiA1dGggZ2VuIHByaW50ZXJzLCBwdXJnZVdhbGxDZW50ZXIgd2lsbCBiZSBhbiBlbXB0eSBhcnJheSBbXS5cclxuICpcclxuICogRm9yIDZ0aCBnZW4gcHJpbnRlcnMsIHRoZSBwdXJnZVdhbGxDZW50ZXIgd2lsbCBlaXRoZXIgYmUgaW5pdGlhbF92YWx1ZVxyXG4gKiAtb3ItIHRoZSB2YWx1ZSByZXR1cm4gYnkgdGhlIHZpZXdlclxyXG4gKlxyXG4gKiAtLSBSYXlcclxuICoqL1xyXG5sZXQgcHVyZ2VXYWxsQ2VudGVyID0gW107XHJcblxyXG4vKipcclxuICogRmxhZyB0byBkZXRlcm1pbmUgaWYgdGhlIHNldHRpbmdzIGhhdmUgYmVlbiBsb2FkZWQgZnJvbSB1c2VyX2NvbmZpZy5qc29uXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxubGV0IHNldHRpbmdzTG9hZGVkID0gZmFsc2U7XHJcbmxldCBmaXJzdFRyYXlMb2FkZWQgPSBmYWxzZTtcclxuXHJcbmxldCBzdXBwb3J0ZWRDb25maWd1cmF0aW9ucyA9IFtdO1xyXG5cclxuY29uc3QgUFJFU0VUX0VYVCA9IENvbnN0YW50cy5QUkVTRVRfRVhUO1xyXG5cclxuLy8gVXNlciBwcmVzZXRzIGFyZSBoZWxkIGhlcmUgaW4gbWVtb3J5LCBjb3BpZWQgZnJvbSB0aGUgdXNlciBjb25maWdcclxubGV0IHByZXNldHMgPSBbXTtcclxuXHJcbi8vIHRoZSBjdXJyZW50IHByZXNldCB0aGUgdXNlciBoYXMgc2VsZWN0ZWQuIEl0IHdpbGwgbm90IGJlIHNldCBpZiB0aGUgdXNlclxyXG4vLyBoYXNuJ3Qgc2V0IGFueXRoaW5nXHJcbmxldCBjdXJyZW50UHJlc2V0ID0gbnVsbDtcclxubGV0IHByZXNldEVycm9yID0gbm90aGluZygpO1xyXG5cclxuLy8vLy8vLy8vLy8vIEVORCBTVE9SRUQgVkFMVUVTIC8vLy8vLy8vLy8vXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsdXh4b3IuY3JlYXRlU3RvcmUoe1xyXG4gICAgYWN0aW9uczoge1xyXG4gICAgICAgIFtBY3Rpb25zLlRvZ2dsZVByb3BdOiAnb25BZHZhbmNlZFRvZ2dsZScsXHJcbiAgICAgICAgW0FjdGlvbnMuQnVsa1RvZ2dsZVByb3BdOiAnb25CdWxrQWR2YW5jZWRUb2dnbGUnLFxyXG4gICAgICAgIFtBY3Rpb25zLlJlc2V0VG9EZWZhdWx0XTogJ3Jlc2V0VG9EZWZhdWx0JyxcclxuICAgICAgICBbQWN0aW9ucy5HZXRQcmludGVyU2NoZW1hXTogJ29uR2V0UHJpbnRlclNjaGVtYScsXHJcbiAgICAgICAgW0FjdGlvbnMuVXBkYXRlUHJvcGVydHldOiAnb25VcGRhdGVQcm9wZXJ0eScsXHJcbiAgICAgICAgW0FjdGlvbnMuU2VsZWN0UHJpbnRlcl06ICdvblNlbGVjdFByaW50ZXInLFxyXG4gICAgICAgIFtBY3Rpb25zLkdldEV4dHJ1ZGVyVHlwZXNdOiAnZ2V0RXh0cnVkZXJUeXBlcycsXHJcbiAgICAgICAgW0FjdGlvbnMuR2V0U3VwcG9ydGVkQ29uZmlndXJhdGlvbnNdOiAnZ2V0U3VwcG9ydGVkQ29uZmlndXJhdGlvbnMnLFxyXG4gICAgICAgIFtBY3Rpb25zLkluaXRhbGl6ZVZhbHVlc106ICdpbml0aWFsaXplVmFsdWVzJyxcclxuICAgICAgICBbQWN0aW9ucy5BdXRoZW50aWNhdGlvbldhaXRpbmddOiAnb25TZWxlY3RQcmludGVyJyxcclxuICAgICAgICBbQWN0aW9ucy5SZXNldEFsbFRvRGVmYXVsdF06ICdvblJlc2V0QWxsVG9EZWZhdWx0JyxcclxuICAgICAgICBbQWN0aW9ucy5SZW1vdmVBbGxTZXR0aW5nc106ICdvblJlbW92ZUFsbFNldHRpbmdzJyxcclxuICAgICAgICBbQWN0aW9ucy5Db21wYXJlU2V0dGluZ3NdOiAnY29tcGFyZVNldHRpbmdzJyxcclxuICAgICAgICBbQWN0aW9ucy5DcmVhdGVQcmVzZXRdOiAnb25DcmVhdGVQcmVzZXQnLFxyXG4gICAgICAgIFtBY3Rpb25zLldyaXRlUHJlc2V0XTogJ29uV3JpdGVQcmVzZXQnLFxyXG4gICAgICAgIFtBY3Rpb25zLlVwZGF0ZVByZXNldF06ICdvblVwZGF0ZVByZXNldCcsXHJcbiAgICAgICAgW0FjdGlvbnMuRGVzdHJveVByZXNldF06ICdvbkRlc3Ryb3lQcmVzZXQnLFxyXG4gICAgICAgIFtBY3Rpb25zLlJlYWRQcmVzZXRzXTogJ29uUmVhZFByZXNldHMnLFxyXG4gICAgICAgIFtBY3Rpb25zLkFwcGx5UHJlc2V0XTogJ29uQXBwbHlQcmVzZXQnLFxyXG4gICAgICAgIFtBY3Rpb25zLlVuYXBwbHlQcmVzZXRdOiAnb25VbmFwcGx5UHJlc2V0JyxcclxuICAgICAgICBbQWN0aW9ucy5SZW5hbWVQcmVzZXRdOiAnb25SZW5hbWVQcmVzZXQnLFxyXG4gICAgICAgIFtBY3Rpb25zLlByZXNldEVycm9yXTogJ29uUHJlc2V0RXJyb3InLFxyXG4gICAgICAgIFtBY3Rpb25zLkNsb3NlTW9kYWxdOiAnb25DbG9zZU1vZGFsJyxcclxuICAgICAgICBbQWN0aW9ucy5SZXZlcnRDaGFuZ2VzXTogJ29uUmV2ZXJ0Q2hhbmdlcycsXHJcbiAgICAgICAgW0FjdGlvbnMuVXBkYXRlRXh0cnVkZXJdOiAnb25VcGRhdGVFeHRydWRlcicsXHJcbiAgICAgICAgW0FjdGlvbnMuVXBkYXRlRXh0cnVkZXJQYWlyXTogJ29uVXBkYXRlRXh0cnVkZXJQYWlyJyxcclxuICAgICAgICBbQWN0aW9ucy5VcGRhdGVNYXRlcmlhbF06ICdvblVwZGF0ZU1hdGVyaWFsJyxcclxuICAgICAgICBbQWN0aW9ucy5VcGRhdGVNYXRlcmlhbHNdOiAnb25VcGRhdGVNYXRlcmlhbHMnLFxyXG4gICAgICAgIFtBY3Rpb25zLlVwZGF0ZVN1cHBvcnRzXTogJ29uVXBkYXRlU3VwcG9ydHMnLFxyXG4gICAgICAgIFtBY3Rpb25zLlVwZGF0ZVByaW50TW9kZV06ICdvblVwZGF0ZVByaW50TW9kZScsXHJcbiAgICAgICAgW0FjdGlvbnMuVXBkYXRlUHVyZ2VXYWxsQ2VudGVyXTogJ29uVXBkYXRlUHVyZ2VXYWxsQ2VudGVyJyxcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcmludFNldHRpbmdzU3RvcmVTdGF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3Q8U3RyaW5nLCBPYmplY3Q+fSBzZXR0aW5ncyAtIEFsbCBvZiB0aGUgc2V0dGluZ3MgZm9ybWF0dGVkIGZvciBjb25zdW1wdGlvbiBieSB0aGUgdmlld1xyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgZnVsbHkgZm9ybWF0dGVkIGZvciB0aGUgVUlcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gaW5zaWRlIGEgUmVhY3QgY29tcG9uZW50XHJcbiAgICAgKiB0aGlzLnNldFN0YXRlKHRoaXMuZ2V0Rmx1eCgpLnN0b3JlKCdQcmludFNldHRpbmdzU3RvcmUnKS5nZXRTdGF0ZSgpKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBnZXR0aW5nIGFsbCB0aGUgc2V0dGluZ3MgZm9yIGEgcGFydGljdWxhciB0YWJcclxuICAgICAqIGxldCBpbmZpbGxTZXR0aW5ncyA9IFIuZmlsdGVyKHYgPT4gdi5ncm91cHMuaW5jbHVkZXMoJ2luZmlsbCcsIHRoaXMuc3RhdGUuc2V0dGluZ3MpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGdldHRpbmcgYWxsIGFjdGl2ZSBzZXR0aW5nc1xyXG4gICAgICogbGV0IHZpc2libGVTZXR0aW5ncyA9IFIuZmlsdGVyKFIucHJvcE9yKGZhbHNlLCAndmlzaWJsZScpLCB0aGlzLnN0YXRlLnNldHRpbmdzKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBnZXR0aW5nIHRoZSB2YWx1ZSBmb3IgYSBwYXJ0aWN1bGFyIG92ZXJyaWRlXHJcbiAgICAgKiBsZXQgdmFsID0gUi5wYXRoKFsnbGF5ZXJfaGVpZ2h0JywgJ3ZhbHVlJ10sIHRoaXMuc3RhdGUuc2V0dGluZ3MpO1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtQcmludFNldHRpbmdzU3RvcmVTdGF0ZX1cclxuICAgICAqL1xyXG4gICAgZ2V0U3RhdGUoKSB7XHJcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSByZWR1Y2Vycy5zdGF0ZShcclxuICAgICAgICAgICAgYXZhaWxhYmxlU2V0dGluZ3MsXHJcbiAgICAgICAgICAgIHZpc2libGVTZXR0aW5ncyxcclxuICAgICAgICAgICAgdmFsdWVzLFxyXG4gICAgICAgICAgICBDb25zdGFudHMuR3JvdXBEaWN0LFxyXG4gICAgICAgICAgICBDb25zdGFudHMuT3B0aW9ucyxcclxuICAgICAgICAgICAgQ29uc3RhbnRzLkZvcm1hdCxcclxuICAgICAgICAgICAgQ29uc3RhbnRzLlNhbml0aXphdGlvbixcclxuICAgICAgICAgICAgQ29uc3RhbnRzLlNldHRpbmdzVHlwZXNcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyBleHRydWRlcnMgbGl2ZXMgb3V0c2lkZSBvZiBzZXR0aW5ncyBub3dcclxuICAgICAgICAgICAgLy8gaW4gY29udHJhc3QgdG8gYXR0YWNoZWRfZXh0cnVkZXIwLCB3aGljaCB1c2VkIHRvIGxpdmUgaW4gc2V0dGluZ3NcclxuICAgICAgICAgICAgZXh0cnVkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWQ6IHN1cHBvcnRlZEV4dHJ1ZGVycyxcclxuICAgICAgICAgICAgICAgIHN1cHBvcnRlZEV4dHJ1ZGVyc1BlckluZGV4LFxyXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkRXh0cnVkZXJQYWlyQ29uZmlncyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWF0ZXJpYWxzOiB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRNYXRlcmlhbHMsXHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWQ6IHN1cHBvcnRlZE1hdGVyaWFscyxcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uczogbWF0ZXJpYWxUcmFuc2xhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBzcG9vbE1hdGVyaWFscyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJpbnRNb2RlOiB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogcHJpbnRNb2RlLFxyXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkOiBzdXBwb3J0ZWRQcmludE1vZGVzLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXR0aW5ncyxcclxuICAgICAgICAgICAgcHJlc2V0cyxcclxuICAgICAgICAgICAgY3VycmVudFByZXNldCxcclxuICAgICAgICAgICAgcHJlc2V0RXJyb3IsXHJcbiAgICAgICAgICAgIHB1cmdlV2FsbENlbnRlcixcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXNFeHRydWRlck1hdGVyaWFsTWlzbWF0Y2goc3VwcG9ydGVkTWF0ZXJpYWxzRnJvbUZpcm13YXJlKSB7XHJcbiAgICAgICAgY29uc3QgcHJpbnRlciA9IHRoaXMuZmx1eC5zdG9yZSgnUHJpbnRlclN0b3JlJykuZ2V0U2VsZWN0ZWRQcmludGVyKCk7XHJcbiAgICAgICAgY29uc3QgaXNMaXZlQm90ID0gcHJpbnRlciAmJiBwcmludGVyLmlzQ29ubmVjdGVkKCkgJiYgcHJpbnRlci5pc0F1dGhlbnRpY2F0ZWQoKTtcclxuXHJcbiAgICAgICAgbGV0IGhhc01pc21hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGlzTGl2ZUJvdCAmJiBwcmludGVyLmlzU2l4dGhHZW4oKSkge1xyXG4gICAgICAgICAgICBjb25zdCBhdHRhY2hlZEV4dHJ1ZGVycyA9IHByaW50ZXIuZ2V0QXR0YWNoZWRFeHRydWRlcnMoKTtcclxuICAgICAgICAgICAgLy8gT25seSB0aGUgbmV3ZXIgdmVyc2lvbnMgb2YgTWV0aG9kL01ldGhvZCBYIGZpcm13YXJlIGdpdmUgdXMgc3VwcG9ydGVkIG1hdGVyaWFsc1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBnZXQgdGhhdCBpbmZvLCB1c2UgdGhlIGhhcmRjb2RlZCB2YWx1ZXMgZnJvbSBfZ2V0U3VwcG9ydGVkTWF0ZXJpYWxzQnlFeHRydWRlcigpXHJcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRlZE1hdGVyaWFsc0J5RXh0cnVkZXIgPVxyXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkTWF0ZXJpYWxzRnJvbUZpcm13YXJlLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgICAgICAgICA/IHN1cHBvcnRlZE1hdGVyaWFsc0Zyb21GaXJtd2FyZVxyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZ2V0U3VwcG9ydGVkTWF0ZXJpYWxzQnlFeHRydWRlcihhdHRhY2hlZEV4dHJ1ZGVycywgcHJpbnRlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3Bvb2xNYXRlcmlhbHMubGVuZ3RoID4gMCAmJiBzdXBwb3J0ZWRNYXRlcmlhbHNCeUV4dHJ1ZGVyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHNwb29sTWF0ZXJpYWxzLm1hcCgoc3Bvb2xNYXRlcmlhbCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwb29sTWF0ZXJpYWwgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkTWF0ZXJpYWxzQnlFeHRydWRlcltpbmRleF0gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXN1cHBvcnRlZE1hdGVyaWFsc0J5RXh0cnVkZXJbaW5kZXhdLmluY2x1ZGVzKHNwb29sTWF0ZXJpYWwpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaGVkRXh0cnVkZXJzW2luZGV4XSAhPT0gRXh0cnVkZXJUeXBlRW51bS5tazE0X2VcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNNaXNtYXRjaDtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0U3VwcG9ydFZpc2liaWxpdHkoKSB7XHJcbiAgICAgICAgY29uc3QgcHJpbnRlciA9IHRoaXMuZmx1eC5zdG9yZSgnUHJpbnRlclN0b3JlJykuZ2V0U2VsZWN0ZWRQcmludGVyKCk7XHJcblxyXG4gICAgICAgIGlmIChwcmludGVyICYmIHByaW50ZXIuaXNTaXh0aEdlbigpKSB7XHJcbiAgICAgICAgICAgIHZpc2libGVTZXR0aW5ncy5kb1N1cHBvcnQgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2aXNpYmxlU2V0dGluZ3Muc3VwcG9ydFR5cGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VmlzaWJsZVNldHRpbmdzKCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpYmxlU2V0dGluZ3M7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE92ZXJyaWRlcygpIHtcclxuICAgICAgICByZXR1cm4gXy5tYXBLZXlzKF8ub21pdCh2YWx1ZXMsIFByZXNldEtleUJsYWNrbGlzdCksICh2YWwsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlS2V5KGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhc092ZXJyaWRlc0ZvclByaW50TW9kZShjdXJyZW50UHJpbnRNb2RlKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFByaW50TW9kZUNoYW5nZWQgPSBjdXJyZW50UHJpbnRNb2RlID09PSBwcmludE1vZGU7XHJcbiAgICAgICAgY29uc3QgaGFzT3ZlcnJpZGUgPSBSLnBpcGUoUi5vbWl0KFByZXNldEtleUJsYWNrbGlzdCksIFIudmFsdWVzLCBSLmxlbmd0aCwgUi5sdCgwKSkodmFsdWVzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICFjdXJyZW50UHJlc2V0ICYmIGN1cnJlbnRQcmludE1vZGVDaGFuZ2VkICYmIGhhc092ZXJyaWRlO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXNPdmVycmlkZXNGb3JQcmVzZXQocHJlc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgcHJlc2V0ICYmXHJcbiAgICAgICAgICAgIGN1cnJlbnRQcmVzZXQgPT09IHByZXNldCAmJlxyXG4gICAgICAgICAgICAhUi5lcXVhbHMocmVkdWNlcnMuZ2V0UHJlc2V0QnlOYW1lKHByZXNldCwgcHJlc2V0cykuc2V0dGluZ3MsIFIub21pdChQcmVzZXRLZXlCbGFja2xpc3QsIHZhbHVlcykpXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgaGFzUHJlc2V0V2l0aE5hbWUobmFtZSkge1xyXG4gICAgICAgIHJldHVybiByZWR1Y2Vycy5nZXRQcmVzZXRCeU5hbWUobmFtZSwgcHJlc2V0cykgIT0gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlcyB3aGVuIGFuIGFkdmFuY2VkIHNldHRpbmcgaXMgdG9nZ2xlZCBpbiB0aGUgQWR2YW5jZWQgU2V0dGluZ3MgUGFuZWwsXHJcbiAgICAgKiBvciB3aGVuIHdlIHVwZGF0ZSBhIHNldHRpbmcgaW4gdGhhdCBwYW5lbC5cclxuICAgICAqIEl0IG1hbmlwdWxhdGVzIHZpc2libGVTZXR0aW5ncyBhbmQgdGhlbiBlbWl0cyBhIGNoYW5nZSBldmVudC5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXlsb2FkIC0gdGhlIHBheWxvYWQgb2YgdGhlIGRpc3BhdGNoZWQgZXZlbnQuIFNob3VsZCBoYXZlIGBrZXlgIGluIGl0LlxyXG4gICAgICogSWYgd2UgY2FsbCBpdCBmcm9tIG9uVXBkYXRlUHJvcGVydHkoKSwgaXQgc2hvdWxkIGhhdmUgYHZpc2libGVgIGluIGl0LCBzZXQgdG8gdHJ1ZSxcclxuICAgICAqIHNvIHRoYXQgbmV3bHktY2hhbmdlZCBzZXR0aW5ncyBhcmUgYWx3YXlzIG1hZGUgdmlzaWJsZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIG9uQWR2YW5jZWRUb2dnbGUocGF5bG9hZCkge1xyXG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBwYXlsb2FkLmtleTtcclxuXHJcbiAgICAgICAgLy8gSWYgd2Uga25vdyB3aGF0IHZhbHVlIHdlIHdhbnQgdG8gc2V0IHZpc2liaWxpdHkgdG8sIHVzZSB0aGF0LiBJZiBub3QsIGp1c3QgZG8gYSBzdHJhaWdodGZvcndhcmQgdG9nZ2xlXHJcbiAgICAgICAgY29uc3QgdG9nZ2xlZE9uID0gcGF5bG9hZC52aXNpYmxlICE9PSB1bmRlZmluZWQgPyBwYXlsb2FkLnZpc2libGUgOiAhUi5wcm9wT3IoZmFsc2UsIHNldHRpbmcsIHZpc2libGVTZXR0aW5ncyk7XHJcblxyXG4gICAgICAgIHZpc2libGVTZXR0aW5ncyA9IFIuYXNzb2Moc2V0dGluZywgdG9nZ2xlZE9uLCB2aXNpYmxlU2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAvLyBTbywgcHJvZHVjdCBkZWNpZGVkIHRoaW5ncyBzaG91bGQgd29yayBpbiBhIGNlcnRhaW4gd2F5LCBidXQgSSB0aGlua1xyXG4gICAgICAgIC8vIHRoZXkncmUgZ29pbmcgdG8gcmVncmV0IHRoYXQgZGVjaXNpb24gaW4gYSBtb250aCBvciB0d28sIHNvIEknbVxyXG4gICAgICAgIC8vIGxlYXZpbmcgdGhpcyBoZXJlLCBjb21tZW50ZWQgb3V0LCBzbyBpdCdzIG5pY2UgYW5kIGVhc3kgdG8gcmV2ZXJ0XHJcbiAgICAgICAgLy8gdG8gdGhlIGludHVpdGl2ZSB3YXkgaXQgdXNlZCB0byB3b3JrLiAtLSB4b3hvLCBKb25cclxuICAgICAgICAvLyBpZighdG9nZ2xlZE9uKSB7XHJcbiAgICAgICAgLy8gICAgIHByaW50U3RvcmVVdGlscy51cGRhdGVQcm9qZWN0U3RvcmVQcm9wKHNldHRpbmcsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgLy8gICAgIHZhbHVlcyA9IFIuZGlzc29jKHNldHRpbmcsIHZhbHVlcyk7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAvLyBlbWl0dGluZyB1cCBoZXJlIHNvIHRoZSBpbnRlcmZhY2UgY2FuIHByb2NlZWQgd2hpbGUgd2UgZG8gc29tZSBiYWNrZ3JvdW5kIHN0dWZmXHJcbiAgICAgICAgdGhpcy5lbWl0KENIQU5HRV9FVkVOVCk7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hSW5pdGlhbFZhbHVlID0gdGhpcy5fbG9hZFNjaGVtYUluaXRpYWxWYWx1ZSgpO1xyXG4gICAgICAgIGlmIChzY2hlbWFJbml0aWFsVmFsdWUpIHtcclxuICAgICAgICAgICAgc2NoZW1hSW5pdGlhbFZhbHVlXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBUb2dnbGVkIChBY3RpdmUpIHNldHRpbmdzIHRvIHVzZXJfY29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKEFQUC1XSURFIHNldHRpbmdzKS5cclxuICAgICAgICAgICAgICAgICAgICBwcmludFN0b3JlVXRpbHMuc2F2ZVRvVXNlckNvbmZpZygnYWN0aXZlQWR2U2V0dGluZ3MnLCB2aXNpYmxlU2V0dGluZ3MsIHRoaXMuZmx1eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRTdG9yZVV0aWxzLnNhdmVUb1VzZXJDb25maWcoJ3ByaW50U2V0dGluZ3MnLCB2YWx1ZXMsIHRoaXMuZmx1eCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHByaW50U3RvcmVVdGlscy51cGRhdGVQcm9qZWN0U3RvcmVQcm9wKFNldHRpbmdzS2V5cy5NYXRlcmlhbHMsIHNlbGVjdGVkTWF0ZXJpYWxzLCB0cnVlLCB0aGlzLmZsdXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW50U3RvcmVVdGlscy51cGRhdGVQcm9qZWN0U3RvcmVQcm9wKFNldHRpbmdzS2V5cy5QcmludE1vZGVzLCB2YWx1ZXMucHJpbnRNb2RlLCB0cnVlLCB0aGlzLmZsdXgpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKVxyXG4gICAgICAgICAgICAgICAgLmRvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHNldHRpbmcgYmFjayB0byBTbGljZSBDb25maWcgZXZhbHVhdGVkIGBpbml0aWFsX3ZhbHVlYCBmb3Igc2V0dGluZy5cclxuICAgICAqIFRoaXMgcmVxdWlyZXMgY2FsbGluZyBTbGljZSBDb25maWcgd2l0aCBwcmludF9tb2RlIGFuZCBvdmVycmlkZXMgb2JqZWN0IHdpdGggdGhlXHJcbiAgICAgKiBzZXR0aW5nIHdoaWNoIHdlIHdhbnQgYGluaXRpYWxfdmFsdWVgIChkZWZhdWx0KSBmb3IgcmVtb3ZlZCBmcm9tIG92ZXJyaWRlcy5cclxuICAgICAqIGdldFNjaGVtYSB3aWxsIGFsd2F5cyBvdmVycmlkZSB2YWx1ZSBhcyBgaW5pdGlhbF92YWx1ZWAgaWYgdGhlcmUgaXMgb25lIHNldC5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXlsb2FkIC0gdGhlIHBheWxvYWQgb2YgdGhlIGRpc3BhdGNoZWQgZXZlbnQuIFNob3VsZCBoYXZlIGBrZXlgIGluIGl0LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcmVzZXRUb0RlZmF1bHQocGF5bG9hZCkge1xyXG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBwYXlsb2FkLmtleTtcclxuXHJcbiAgICAgICAgdmFsdWVzID0gcHJpbnRTdG9yZVV0aWxzLnBlcnNpc3RWYWx1ZXMoc2V0dGluZywgdW5kZWZpbmVkLCBmYWxzZSwgdmFsdWVzLCB0aGlzLmZsdXgpO1xyXG4gICAgICAgIHByaW50U3RvcmVVdGlscy5jbGVhckJ1aWxkcyh0aGlzLmZsdXgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFNjaGVtYUluaXRpYWxWYWx1ZSgpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuZW1pdChDSEFOR0VfRVZFTlQpKVxyXG4gICAgICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZXMgd2hlbiBhIHByb3BlcnR5IG9uIGEgcHJpbnQgc2V0dGluZyBjaGFuZ2VzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGF5bG9hZCAtIHRoZSBwYXlsb2FkIG9mIHRoZSBkaXNwYXRjaGVkIGV2ZW50LiBTaG91bGQgaGF2ZSBgcGF0aGAgYW5kIGB2YWx1ZWAgaW4gaXQuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBvblVwZGF0ZVByb3BlcnR5KHBheWxvYWQpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBmb3JtYXQua2V5RnJvbVBhdGgocGF5bG9hZC5wYXRoKTtcclxuXHJcbiAgICAgICAgaWYgKGtleSA9PT0gU2V0dGluZ3NLZXlzLlN1cHBvcnRzKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IHRvIGRlZmF1bHQgd2l0aCAnZG9QdXJnZVdhbGwnIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gc3VwcG9ydCB0eXBlc1xyXG4gICAgICAgICAgICAvLyBBcHBsaWVzIG1haW5seSB0byB0aGUgc2l4dGggZ2VuIHByaW50ZXJzXHJcbiAgICAgICAgICAgIHZhbHVlcyA9IHByaW50U3RvcmVVdGlscy5wZXJzaXN0VmFsdWVzKFNldHRpbmdzS2V5cy5QdXJnZVdhbGwsIHVuZGVmaW5lZCwgZmFsc2UsIHZhbHVlcywgdGhpcy5mbHV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChSLmhhcyhrZXksIHZpc2libGVTZXR0aW5ncykpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gU2V0dGluZ3NLZXlzLlByaW50TW9kZXMpXHJcbiAgICAgICAgICAgICAgICAoeyB2YWx1ZXMsIGN1cnJlbnRQcmVzZXQgfSA9IHByaW50U3RvcmVVdGlscy5yZXNldEFsbFRvRGVmYXVsdCh0aGlzLmZsdXgsIHZhbHVlcykpO1xyXG5cclxuICAgICAgICAgICAgaWYgKFIuaGFzKGtleSwgYXZhaWxhYmxlU2V0dGluZ3MpIHx8IGtleSA9PT0gU2V0dGluZ3NLZXlzLlByaW50TW9kZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHByaW50U3RvcmVVdGlscy5wZXJzaXN0VmFsdWVzKGtleSwgcGF5bG9hZC52YWx1ZSwgZmFsc2UsIHZhbHVlcywgdGhpcy5mbHV4KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChDSEFOR0VfRVZFTlQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFNjaGVtYUluaXRpYWxWYWx1ZSgpLmRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEF2b2lkIHBhc3Npbmcgbm9uIHByaW50IHNldHRpbmdzIHJlbGF0ZWQgcHJvcGVydGllczsgaW5mby5leHRydWRlciwgaW5mby5tZXNoQ29sb3IsIGV0Yy4uXHJcbiAgICAgICAgICAgIGlmIChSLmhhcyhrZXksIGF2YWlsYWJsZVNldHRpbmdzKSB8fCBrZXkgPT09IFNldHRpbmdzS2V5cy5QcmludE1vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBwcmludFN0b3JlVXRpbHMucGVyc2lzdFZhbHVlcyhrZXksIHBheWxvYWQudmFsdWUsIGZhbHNlLCB2YWx1ZXMsIHRoaXMuZmx1eCk7XHJcbiAgICAgICAgICAgICAgICAvLyB0b2dnbGUgdGhlIHZpc2liaWx0eSBvbiBwcmludCBzZXR0aW5nIGFuZCBydW4gdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIF9sb2FkU2NoZW1hSW5pdGFsVmFsdWUgcm91dGluZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkFkdmFuY2VkVG9nZ2xlKHsga2V5LCB2aXNpYmxlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvblJlc2V0QWxsVG9EZWZhdWx0KCkge1xyXG4gICAgICAgICh7IHZhbHVlcywgY3VycmVudFByZXNldCB9ID0gcHJpbnRTdG9yZVV0aWxzLnJlc2V0QWxsVG9EZWZhdWx0KHRoaXMuZmx1eCwgdmFsdWVzKSk7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdpbml0aWFsaXplX3ZhbHVlcycpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblJlbW92ZUFsbFNldHRpbmdzKCkge1xyXG4gICAgICAgIHZpc2libGVTZXR0aW5ncyA9IHByaW50U3RvcmVVdGlscy5yZW1vdmVBbGxTZXR0aW5ncyh0aGlzLmZsdXgpO1xyXG4gICAgICAgIHRoaXMuc2V0U3VwcG9ydFZpc2liaWxpdHkoKTtcclxuICAgICAgICB0aGlzLmVtaXQoQ0hBTkdFX0VWRU5UKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25SZXZlcnRDaGFuZ2VzKCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50UHJlc2V0KSB7XHJcbiAgICAgICAgICAgIC8vIGhhdmUgdG8gc2V0IGN1cnJlbnRQcmVzZXQgdG8gbnVsbCBmb3Igb25BcHBseVByZXNldCB0byB3b3JrIHByb3Blcmx5XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXNldEJ1ZiA9IGN1cnJlbnRQcmVzZXQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQcmVzZXQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5vbkFwcGx5UHJlc2V0KHsgbmFtZTogcHJlc2V0QnVmIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByaW50TW9kZUJ1ZiA9IFIudmlldyhMLnByaW50TW9kZSwgdmFsdWVzKTtcclxuXHJcbiAgICAgICAgICAgICh7IHZhbHVlcywgY3VycmVudFByZXNldCB9ID0gcHJpbnRTdG9yZVV0aWxzLnJlc2V0QWxsVG9EZWZhdWx0KHRoaXMuZmx1eCwgdmFsdWVzKSk7XHJcblxyXG4gICAgICAgICAgICB2YWx1ZXMgPSBwcmludFN0b3JlVXRpbHMucGVyc2lzdFZhbHVlcyhTZXR0aW5nc0tleXMuUHJpbnRNb2RlcywgcHJpbnRNb2RlQnVmLCBmYWxzZSwgdmFsdWVzLCB0aGlzLmZsdXgpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoQ0hBTkdFX0VWRU5UKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZFNjaGVtYUluaXRpYWxWYWx1ZSgpLmRvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG9uQnVsa0FkdmFuY2VkVG9nZ2xlKHBheWxvYWQpIHtcclxuICAgICAgICB2aXNpYmxlU2V0dGluZ3MgPSBSLm1lcmdlKHZpc2libGVTZXR0aW5ncywgcGF5bG9hZC5hY3RpdmUpO1xyXG4gICAgICAgIHZhbHVlcyA9IHJlZHVjZXJzLmNsZWFuVmFsdWVzKHZhbHVlcywgdmlzaWJsZVNldHRpbmdzKTtcclxuICAgICAgICB0aGlzLmVtaXQoQ0hBTkdFX0VWRU5UKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25HZXRQcmludGVyU2NoZW1hKHBheWxvYWQpIHtcclxuICAgICAgICBjb25zdCBwcmludGVyID0gdGhpcy5mbHV4LnN0b3JlKCdQcmludGVyU3RvcmUnKS5nZXRTZWxlY3RlZFByaW50ZXIoKTtcclxuICAgICAgICBjb25zdCBleHRydWRlcnMgPSBwcmludGVyICYmIHByaW50ZXIuZ2V0QXR0YWNoZWRFeHRydWRlcnMoKTtcclxuICAgICAgICBjb25zdCB7IHJlc2V0VG9EZWZhdWx0RXh0cnVkZXJzIH0gPSBwYXlsb2FkO1xyXG4gICAgICAgIGNvbnN0IGlzUHJpbnRlckNvbm5lY3RlZEFuZEF1dGhlZCA9IHByaW50ZXIgJiYgcHJpbnRlci5pc0Nvbm5lY3RlZCgpICYmIHByaW50ZXIuaXNBdXRoZW50aWNhdGVkKCk7XHJcbiAgICAgICAgLy8gSWdub3JlIEV4dHJ1ZGVyIEFyZ3MgaWYgb2ZmbGluZS9hcmNoZXR5cGUgcHJpbnRlcnMgYW5kIGdldCBkZWZhdWx0IGV4dHJ1ZGVyc1xyXG4gICAgICAgIGNvbnN0IGlnbm9yZUV4dHJ1ZGVyQXJncyA9IHJlc2V0VG9EZWZhdWx0RXh0cnVkZXJzICYmICFpc1ByaW50ZXJDb25uZWN0ZWRBbmRBdXRoZWQ7XHJcblxyXG4gICAgICAgIC8vIEZvciBhcmNoZXR5cGUgcHJpbnRlcnMsIGV4aXQgb3V0IG9mIGxvYWRpbmcgc2NoZW1hXHJcbiAgICAgICAgaWYgKCFwcmludGVyKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIGlmIHBheWxvYWQgaGFzIHNwb29sc0luZm8sIHRoZW4gaXQgbWVhbnMgc3Bvb2xzIGhhdmUgYmVlbiBjaGFuZ2VkXHJcbiAgICAgICAgLy8gb24gYSBsaXZlIHByaW50ZXJcclxuICAgICAgICBpZiAocGF5bG9hZC5zcG9vbHNJbmZvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlcnNpc3RWYWx1ZXMoU2V0dGluZ3NLZXlzLkNoYW1iZXJUZW1wLCBudWxsLCB0cnVlKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5fcGVyc2lzdFZhbHVlcyhTZXR0aW5nc0tleXMuQnVpbGRQbGFuZVRlbXAsIG51bGwsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgQ29uZmlnU2VydmljZSA9IHRoaXMuZmx1eC5nZXRTZXJ2aWNlKCdDb25maWdTZXJ2aWNlJyk7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlVHJheSA9IHRoaXMuZmx1eFxyXG4gICAgICAgICAgICAuc3RvcmUoJ1Byb2plY3RTdG9yZScpXHJcbiAgICAgICAgICAgIC5nZXRQcm9qZWN0KClcclxuICAgICAgICAgICAgLmdldEFjdGl2ZVRyYXkoKTtcclxuICAgICAgICBjb25zdCB0cmF5ID0gYWN0aXZlVHJheS5nZXRCdWlsZEluZm8ocHJpbnRlcik7XHJcblxyXG4gICAgICAgIGlmIChSLmlzRW1wdHkocHJlc2V0cykpIHByZXNldHMgPSBDb25maWdTZXJ2aWNlLmdldCgncHJlc2V0cycpIHx8IFtdO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByaW50ZXJTcG9vbEluZm8ocHJpbnRlciwgcGF5bG9hZClcclxuICAgICAgICAgICAgICAgIC8vIFBhc3NpbmcgYHJlc2V0VG9EZWZhdWx0c0V4dHJ1ZGVyc2AgZnJvbSAnb25TZWxlY3RQcmludGVyJ1xyXG4gICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgcGFzc2luZyBleHRydWRlcnMgYXMgYXJncyB0byBzbGljZWNvbmZpZ1xyXG4gICAgICAgICAgICAgICAgLy8gQlVUIHdlIGRvbid0IGlnbm9yZSBleHRydWRlciBzZWxlY3Rpb25zIGlmIGl0J3MgYSBsaXZlIHByaW50ZXJcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IG1ha2VyYm90LmdldFNjaGVtYSh0cmF5LCBwcmludGVyLCBpZ25vcmVFeHRydWRlckFyZ3MsIHRoaXMuZmx1eCkpXHJcbiAgICAgICAgICAgICAgICAudGhlbihzY2hlbWEgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHJhcmUgY2FzZXMsIGlmIGdldFNjaGVtYSBnZXRzIGNhbGxlZCB0b28gcXVpY2tseSwgaXRcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHJldHVybiBlbXB0eSBzdHJpbmcgYXMgYSByZXN1bHQuIExldCdzIGV4aXQgYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpbmdzIGVycm9yIG91dC5cclxuICAgICAgICAgICAgICAgICAgICAvLyAtLSBSYXlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc0VtcHR5KHNjaGVtYSkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzc2luZyBgcmVzZXRUb0RlZmF1bHRFeHRydWRlcnNgIGZyb20gJ29uU2VsZWN0UHJpbnRlcidcclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBmb3JjZSB1cGRhdGUgYGV4dHJ1ZGVyc2AgdG8gdGhlIHNjaGVtYSdzIGF0dGFjaGVkIGV4dHJ1ZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlU2NoZW1hKHNjaGVtYS5nZXRGdWxsU2NoZW1hKCksIHJlc2V0VG9EZWZhdWx0RXh0cnVkZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbWl0IGVhcmx5IHNvIHRoZSBVSSBjYW4gcmVuZGVyIHdoaWxlIHdlIGRvIHRoZSByZXN0IG9mIHRoZSB1cGRhdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChDSEFOR0VfRVZFTlQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwcmludFN0b3JlVXRpbHMudXBkYXRlUHJvamVjdFN0b3JlUHJvcChTZXR0aW5nc0tleXMuRXh0cnVkZXJzLCBleHRydWRlcnMsIHRydWUsIHRoaXMuZmx1eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRTdG9yZVV0aWxzLnVwZGF0ZVByb2plY3RTdG9yZVByb3AoU2V0dGluZ3NLZXlzLk1hdGVyaWFscywgc2VsZWN0ZWRNYXRlcmlhbHMsIHRydWUsIHRoaXMuZmx1eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRTdG9yZVV0aWxzLnVwZGF0ZVByb2plY3RTdG9yZVByb3AoU2V0dGluZ3NLZXlzLlByaW50TW9kZXMsIHZhbHVlcy5wcmludE1vZGUsIHRydWUsIHRoaXMuZmx1eCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlUHJpbnRlclNwb29sSW5mbyhwcmludGVyLCBwYXlsb2FkKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogdXBkYXRlIHNwb29sc01hdGVyaWFscyBpZi4uLlxyXG4gICAgICAgICAqICAgcGF5bG9hZCBjb250YWlucyBzcG9vbHNJbmZvIHNlbnQgZnJvbSBtYWtlcmJvdC1wcmludGVyLmpzXHJcbiAgICAgICAgICogICBvbiBzcG9vbCBtYXRlcmlhbCBjaGFuZ2VzIG9yIG9uIHJlY29ubmVjdFxyXG4gICAgICAgICAqICAgLW9yLVxyXG4gICAgICAgICAqICAgaW52b2tlIGdldFNwb29sSW5mbyBmcm9tIHByaW50ZXIgd2hlbiBzd2l0Y2hpbmcgYmV0d2VlbiBwcmludGVyc1xyXG4gICAgICAgICAqKi9cclxuICAgICAgICBjb25zdCBwYXJzZVNwb29sc0luZm8gPSBzcG9vbHNJbmZvID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHNwb29sc0luZm9cclxuICAgICAgICAgICAgICAgID8gc3Bvb2xzSW5mby5tYXAoKHNwb29sSW5mbywgYmF5SW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbWF0ZXJpYWxfbmFtZSB9ID0gc3Bvb2xJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0YWNoZWRFeHRydWRlcnMgPSBwcmludGVyLmdldEF0dGFjaGVkRXh0cnVkZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGluZm9ybWF0aW9uIGZyb20gdGhlIHNwb29sLCBzaG93IHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICghUi5pc05pbChtYXRlcmlhbF9uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRlcmlhbF9uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYXlJbmRleCA9PT0gMCAmJiBwcmludGVyLmlzQ29ubmVjdGVkKCkgJiYgcHJpbnRlci5pc0F1dGhlbnRpY2F0ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpdmUgYm90cyB3aXRoIG5vIHNwb29sIGluZm8gKGZvciB0aGUgZmlyc3QgYmF5IG9ubHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHRydWRlclRvRGVmYXVsdE1hdGVyaWFsW2F0dGFjaGVkRXh0cnVkZXJzW2JheUluZGV4XV07XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICA6IFtdOyAvLyA0dGggJiA1dGggR2VuIFByaW50ZXJzICsgU2tldGNoIFByaW50ZXJzLCBzZXQgdG8gZW1wdHlcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLnNwb29sc0luZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHEoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNwb29sTWF0ZXJpYWxzID0gcGFyc2VTcG9vbHNJbmZvKHBheWxvYWQuc3Bvb2xzSW5mbyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHByaW50ZXIuZ2V0U3Bvb2xJbmZvKCkudGhlbihzcG9vbHNJbmZvID0+IHtcclxuICAgICAgICAgICAgc3Bvb2xNYXRlcmlhbHMgPSBwYXJzZVNwb29sc0luZm8oc3Bvb2xzSW5mbyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGFsbCB2YWx1ZXMgd2hlbiB0aGUgcHJpbnRlciBpcyBjaGFuZ2VkLCBhbmQgc2V0cyB0aGUgcGFuZWwgdG8gcHJlcGFyZSB0byBjbG9zZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIG9uU2VsZWN0UHJpbnRlcigpIHtcclxuICAgICAgICB0aGlzLndhaXRGb3IoWydQcmludGVyU3RvcmUnXSwgKCkgPT4ge1xyXG4gICAgICAgICAgICBzZWxlY3RlZE1hdGVyaWFscyA9IFtdO1xyXG4gICAgICAgICAgICBzcG9vbE1hdGVyaWFscyA9IFtdO1xyXG4gICAgICAgICAgICBwdXJnZVdhbGxDZW50ZXIgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzV2l0aEJvdFNwZWNpZmljVmFsdWVzID0gW1xyXG4gICAgICAgICAgICAgICAgU2V0dGluZ3NLZXlzLkNoYW1iZXJUZW1wLFxyXG4gICAgICAgICAgICAgICAgU2V0dGluZ3NLZXlzLlN1cHBvcnRzLFxyXG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZ3NLZXlzLkJ1aWxkUGxhbmVUZW1wLFxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgc2V0dGluZ3NXaXRoQm90U3BlY2lmaWNWYWx1ZXMubWFwKHNldHRpbmcgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVyc2lzdFZhbHVlcyhzZXR0aW5nLCBudWxsLCB0cnVlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogKioqIEhBQ0sgKioqXHJcbiAgICAgICAgICAgICAqIFBhc3MgYSBmbGFnIGRvd24gdG8gbWFrZXJib3QuanMgYW5kIF9wYXJzZVNjaGVtYSB0b1xyXG4gICAgICAgICAgICAgKiBhdm9pZCB1c2luZyB0cmF5LmJvZHlQcm9wZXJ0aWVzJyBleHRydWRlci52YWx1ZSB3aGVuXHJcbiAgICAgICAgICAgICAqIHN3aXRjaGluZyBiZXR3ZWVuIGRpZmZlcmVudCA2dGggZ2VuIHByaW50ZXJzOyBpZS5cclxuICAgICAgICAgICAgICogTWV0aG9kID0+IE1ldGhvZCBYLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBJdCB3aWxsIHJlc2V0IGV4dHJ1ZGVycyBiYWNrIHRvIGRlZmF1bHRzIGluc3RlYWQgb2ZcclxuICAgICAgICAgICAgICogcGVyc2lzdGluZyBhcyBzdGlja3kgZXh0cnVkZXJzLiBUaGlzIGhhY2sgd2lsbCBtYWludGFpblxyXG4gICAgICAgICAgICAgKiBhbGwgNXRoIGdlbidzIHN0aWNreSBleHRydWRlciBzZWxlY3Rpb24uXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIC0tIFJheVxyXG4gICAgICAgICAgICAgKiovXHJcbiAgICAgICAgICAgIGNvbnN0IHByaW50ZXIgPSB0aGlzLmZsdXguc3RvcmUoJ1ByaW50ZXJTdG9yZScpLmdldFNlbGVjdGVkUHJpbnRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCByZXNldFRvRGVmYXVsdEV4dHJ1ZGVycyA9IHByaW50ZXIgJiYgcHJpbnRlci5pc1NpeHRoR2VuKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzUHJpbnRlckNvbm5lY3RlZEFuZEF1dGhlZCA9IHByaW50ZXIgJiYgcHJpbnRlci5pc0Nvbm5lY3RlZCgpICYmIHByaW50ZXIuaXNBdXRoZW50aWNhdGVkKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzZXRUb0RlZmF1bHRFeHRydWRlcnMgJiYgIWlzUHJpbnRlckNvbm5lY3RlZEFuZEF1dGhlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm90VHlwZSA9IHByaW50ZXIuZ2V0R2VuZGVyKCkuYm90VHlwZTtcclxuICAgICAgICAgICAgICAgIGxldCBkZWZhdWx0RXh0cnVkZXJzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJvdFR5cGUgPT09ICdsYXZhX2YnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEV4dHJ1ZGVycyA9IFsnbWsxNF9ob3QnLCAnbWsxNF9ob3RfcyddO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RXh0cnVkZXJzID0gWydtazE0JywgJ21rMTRfcyddO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhdHRhY2hlZEV4dHJ1ZGVycyB0byBhcmNoZXR5cGVfcHJpbnRlclxyXG4gICAgICAgICAgICAgICAgcHJpbnRlci5zZXRBdHRhY2hlZEV4dHJ1ZGVycyhkZWZhdWx0RXh0cnVkZXJzKTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2lkZS1lZmZlY3RzXHJcbiAgICAgICAgICAgICAgICBwcmludFN0b3JlVXRpbHMudXBkYXRlUHJvamVjdFN0b3JlUHJvcChTZXR0aW5nc0tleXMuRXh0cnVkZXJzLCBkZWZhdWx0RXh0cnVkZXJzLCB0cnVlLCB0aGlzLmZsdXgpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgbWF0ZXJpYWxzICYgc3VwcG9ydCBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblVwZGF0ZUV4dHJ1ZGVyUGFpcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLm9uR2V0UHJpbnRlclNjaGVtYSh7IHJlc2V0VG9EZWZhdWx0RXh0cnVkZXJzIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNldFN1cHBvcnRWaXNpYmlsaXR5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2VfcGFuZWwnKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyB0aGUgcHJvamVjdCBzZXR0aW5ncyBpbnRvIHRoaXMgc3RvcmUgYW5kIHNldHMgdGhlIGFjdGl2ZSBzZXR0aW5ncy5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmaWx0ZXJlZFNldHRpbmdzIC0gUHJvamVjdCBTZXR0aW5ncyB0aGF0IGhhdmUgYmVlbiBmaWx0ZXJlZCBmb3IgdGhpbmdzIHdlIGRvIG5vdCB3YW50LlxyXG4gICAgICogQHBhcmFtIHtJbW11dGFibGUgTWFwfSBwcm9qZWN0U2V0dGluZ3MgLSBTZXR0aW5ncyBmcm9tIHRoZSBwcm9qZWN0LlxyXG4gICAgICovXHJcbiAgICBsb2FkUHJvamVjdFNldHRpbmdzKGZpbHRlcmVkU2V0dGluZ3MsIHByb2plY3RTZXR0aW5ncykge1xyXG4gICAgICAgIGNvbnN0IENvbmZpZ1NlcnZpY2UgPSB0aGlzLmZsdXguZ2V0U2VydmljZSgnQ29uZmlnU2VydmljZScpO1xyXG4gICAgICAgIGxldCBleHRydWRlcnM7XHJcblxyXG4gICAgICAgIHZhbHVlcyA9IFIubWFwT2JqSW5kZXhlZCgodiwgaykgPT4gcHJvamVjdFNldHRpbmdzLmdldFByb3BlcnR5KGspLmdldFZhbHVlKCksIGZpbHRlcmVkU2V0dGluZ3MpO1xyXG5cclxuICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IFIucGlwZShcclxuICAgICAgICAgICAgUi5tYXBPYmpJbmRleGVkKCgpID0+IHRydWUpLFxyXG4gICAgICAgICAgICBSLm9taXQoW1NldHRpbmdzS2V5cy5FeHRydWRlcnMsIFNldHRpbmdzS2V5cy5NYXRlcmlhbHMsIFNldHRpbmdzS2V5cy5QcmludE1vZGVzXSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB2aXNpYmxlU2V0dGluZ3MgPSBpc0FjdGl2ZSh2YWx1ZXMpO1xyXG5cclxuICAgICAgICBDb25maWdTZXJ2aWNlLmRlbGV0ZSgncHJpbnRTZXR0aW5ncycpO1xyXG4gICAgICAgIENvbmZpZ1NlcnZpY2UuZGVsZXRlKCdhY3RpdmVBZHZTZXR0aW5ncycpO1xyXG4gICAgICAgIENvbmZpZ1NlcnZpY2UuZGVsZXRlKCdleHRydWRlcnMnKTtcclxuICAgICAgICBDb25maWdTZXJ2aWNlLmRlbGV0ZSgnbWF0ZXJpYWxzJyk7XHJcblxyXG4gICAgICAgIFIubWFwT2JqSW5kZXhlZCgodiwgaykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoayA9PT0gJ2V4dHJ1ZGVycycpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJ1ZGVycyA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGsgPT09ICdtYXRlcmlhbHMnKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE1hdGVyaWFscyA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGsgPT09ICdwcmludE1vZGUnKSB7XHJcbiAgICAgICAgICAgICAgICBwcmludE1vZGUgPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IHByaW50U3RvcmVVdGlscy5wZXJzaXN0VmFsdWVzKGssIHYsIGZhbHNlLCB2YWx1ZXMsIHRoaXMuZmx1eCk7XHJcbiAgICAgICAgfSwgdmFsdWVzKTtcclxuXHJcbiAgICAgICAgcHJpbnRTdG9yZVV0aWxzLnNhdmVUb1VzZXJDb25maWcoJ2FjdGl2ZUFkdlNldHRpbmdzJywgdmlzaWJsZVNldHRpbmdzLCB0aGlzLmZsdXgpO1xyXG4gICAgICAgIHByaW50U3RvcmVVdGlscy5zYXZlVG9Vc2VyQ29uZmlnKCdwcmludFNldHRpbmdzJywgdmFsdWVzLCB0aGlzLmZsdXgpO1xyXG4gICAgICAgIHByaW50U3RvcmVVdGlscy5zYXZlVG9Vc2VyQ29uZmlnKCdleHRydWRlcnMnLCBleHRydWRlcnMsIHRoaXMuZmx1eCk7XHJcbiAgICAgICAgcHJpbnRTdG9yZVV0aWxzLnNhdmVUb1VzZXJDb25maWcoJ21hdGVyaWFscycsIHNlbGVjdGVkTWF0ZXJpYWxzLCB0aGlzLmZsdXgpO1xyXG5cclxuICAgICAgICB0aGlzLl9sb2FkU2NoZW1hSW5pdGlhbFZhbHVlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZW1pdChDSEFOR0VfRVZFTlQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgc3RvcmVzIHNldHRpbmdzIHZzIHByb2plY3Qgc2V0dGluZ3MgYW5kIGZpcmVzIG1vZGFsIGlmIHRoZXkgZGlmZmVyLlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBwYXlsb2FkIC0gQ29udGFpbnMgdGhlIHByb2plY3Qgb2JqZWN0LCBkaXNwYWNoZWQgZnJvbSBmaWxlQWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgY29tcGFyZVNldHRpbmdzKHBheWxvYWQpIHtcclxuICAgICAgICBjb25zdCBpMThuID0gdGhpcy5mbHV4LmdldFNlcnZpY2UoJ1RyYW5zbGF0aW9uU2VydmljZScpO1xyXG4gICAgICAgIGNvbnN0IE1vZGFsU2VydmljZSA9IHRoaXMuZmx1eC5nZXRTZXJ2aWNlKCdNb2RhbFNlcnZpY2UnKTtcclxuICAgICAgICBjb25zdCBwcm9qZWN0ID0gcGF5bG9hZC5wcm9qZWN0O1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZVRyYXkgPSBwcm9qZWN0LmdldEFjdGl2ZVRyYXkoKTtcclxuICAgICAgICBjb25zdCB0cmF5Qm9kaWVzID0gYWN0aXZlVHJheS5nZXRUcmF5Qm9kaWVzKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJvZHlQcm9wZXJ0aWVzID0gdHJheUJvZGllcy5tYXAoYm9keSA9PiBib2R5LmdldE9jY3VycmVuY2UoKS5nZXRQcm9wZXJ0aWVzKCkpLnRvQXJyYXkoKTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdFNldHRpbmdzID0gYm9keVByb3BlcnRpZXNbMF07XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgcmVmZXJlbmNlcyB0byAnZGVmYXVsdFN1cHBvcnRNYXRlcmlhbCcgZnJvbSBvY2N1cnJlbmNlcyBpbiB0aGUgcHJvamVjdFxyXG4gICAgICAgIGNvbnN0IHByb2plY3RTZXR0aW5nc0pzb25LZXlzID0gT2JqZWN0LmtleXMocHJvamVjdFNldHRpbmdzLnRvSlNPTigpKTtcclxuICAgICAgICBwcm9qZWN0U2V0dGluZ3NKc29uS2V5cy5pbmNsdWRlcygnZGVmYXVsdFN1cHBvcnRNYXRlcmlhbCcpICYmXHJcbiAgICAgICAgICAgIHByaW50U3RvcmVVdGlscy51cGRhdGVQcm9qZWN0U3RvcmVQcm9wKFxyXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHRTdXBwb3J0TWF0ZXJpYWwnLFxyXG4gICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIHZhbHVlIHdpbGwgcmVtb3ZlIHRoZSBwcm9wZXJ0eSBmcm9tIG9jY3VycmVuY2VcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5mbHV4XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbHRlclNldHRpbmdzID0gUi5waXBlKFxyXG4gICAgICAgICAgICBSLnBpY2tCeSgodiwgaykgPT4gUi5jb250YWlucyhrLCBSLnZhbHVlcyhTZXR0aW5nc0tleXMpKSksXHJcbiAgICAgICAgICAgIFIubWFwT2JqSW5kZXhlZChSLnByb3AoJ3ZhbHVlJykpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWRTZXR0aW5ncyA9IGZpbHRlclNldHRpbmdzKHByb2plY3RTZXR0aW5ncy50b0pTT04oKSk7XHJcblxyXG4gICAgICAgIC8vIE9rIHNvIHdlIGRvIG5vdCBoYXZlIHZhbHVlcy9jdXN0b20gc2V0dGluZ3Mgd2hlbiB3ZSBvcGVuIHRoZSBhcHAgYW5kXHJcbiAgICAgICAgLy8gZG8gbm90IGhhdmUgYSBtb2RlbCBvbiB0aGUgYnVpbGQgcGxhdGUuIFNvIGlmIHRoYXQgaXMgdGhlIGNhc2UgdGhlblxyXG4gICAgICAgIC8vIGxldHMgYXV0b21hdGljYWxseSBsb2FkIHByb2plY3Qgc2V0dGluZ3MuXHJcbiAgICAgICAgLy8gaWYgKHZhbHVlc0pTT04uaGFzT3duUHJvcGVydHkoJ2FwcGx5VG9BbGwnKSAmJlxyXG4gICAgICAgIC8vICAgICBPYmplY3Qua2V5cyh2YWx1ZXNKU09OKS5sZW5ndGggPT0gMSApIHtcclxuICAgICAgICBpZiAoUi5rZXlzKHZhbHVlcykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFByb2plY3RTZXR0aW5ncyhmaWx0ZXJlZFNldHRpbmdzLCBwcm9qZWN0U2V0dGluZ3MpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIVIuZXF1YWxzKHZhbHVlcywgZmlsdGVyZWRTZXR0aW5ncykpIHtcclxuICAgICAgICAgICAgTW9kYWxTZXJ2aWNlLmNvbmZpcm0oe1xyXG4gICAgICAgICAgICAgICAgYm9keTogaTE4bi50KCdtYjpwcm9qZWN0U2V0dGluZ3NNb2RhbC5ib2R5JyksXHJcbiAgICAgICAgICAgICAgICBjYW5jZWxUZXh0OiBpMThuLnQoJ21iOnByb2plY3RTZXR0aW5nc01vZGFsLnByb2plY3RTZXR0aW5nc1RleHQnKSxcclxuICAgICAgICAgICAgICAgIGNvbmZpcm1UZXh0OiBpMThuLnQoJ21iOnByb2plY3RTZXR0aW5nc01vZGFsLmN1cnJlbnRTZXR0aW5nc1RleHQnKSxcclxuICAgICAgICAgICAgICAgIG1vZGFsQ2xhc3M6ICd3NDAwIHdhcm5pbmdNb2RhbCcsXHJcbiAgICAgICAgICAgICAgICBoaWRlQ2xvc2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBiYWNrZHJvcDogJ3N0YXRpYycsXHJcbiAgICAgICAgICAgICAgICBrZXlib2FyZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvbkNhbmNlbDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIExvYWQgcHJvamVjdCBzZXR0aW5ncyBpbnRvIHRoaXMgc3RvcmUuIFByb2plY3QgU3RvcmUgaXMgYWxyZWFkeSB1cGRhdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZFByb2plY3RTZXR0aW5ncyhmaWx0ZXJlZFNldHRpbmdzLCBwcm9qZWN0U2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uQ29uZmlybTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIExvYWQgcHJvamVjdCB0aGVuIG92ZXJ3cml0ZSBzZXR0aW5ncyBzaW5jZSB0aGUgcHJvamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmdzIHdlcmUgYWxyZWFkeSBsb2FkZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9Eb2VzIG5vdCBleGlzdCBpbiB2YWx1ZXMgc28gbGV0cyBub3QgdXNlIGl0IGluIHByb2plY3QuXHJcbiAgICAgICAgICAgICAgICAgICAgUi5tYXBPYmpJbmRleGVkKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodiwgaykgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFIuaGFzKGssIHZhbHVlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHByaW50U3RvcmVVdGlscy51cGRhdGVQcm9qZWN0U3RvcmVQcm9wKGssIFIucHJvcChrLCB2YWx1ZXMpLCB0cnVlLCB0aGlzLmZsdXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwcmludFN0b3JlVXRpbHMudXBkYXRlUHJvamVjdFN0b3JlUHJvcChrLCB1bmRlZmluZWQsIHRydWUsIHRoaXMuZmx1eCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkU2V0dGluZ3NcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVzIHdoZW4gYSBwcm9wZXJ0eSBvbiBhIHByaW50IHNldHRpbmcgY2hhbmdlc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBheWxvYWQgLSB0aGUgcGF5bG9hZCBvZiB0aGUgZGlzcGF0Y2hlZCBldmVudC4gU2hvdWxkIGhhdmUgYHBhdGhgIGFuZCBgdmFsdWVgIGluIGl0LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgaW5pdGlhbGl6ZVZhbHVlcygpIHtcclxuICAgICAgICBjb25zdCBDb25maWdTZXJ2aWNlID0gdGhpcy5mbHV4LmdldFNlcnZpY2UoJ0NvbmZpZ1NlcnZpY2UnKTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlckNvbmZpZ1ByaW50U2V0dGluZ3MgPSBDb25maWdTZXJ2aWNlLmdldCgncHJpbnRTZXR0aW5ncycpO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VyQ29uZmlnQWN0aXZlQWR2U2V0dGluZ3MgPSBDb25maWdTZXJ2aWNlLmdldCgnYWN0aXZlQWR2U2V0dGluZ3MnKTtcclxuXHJcbiAgICAgICAgY29uc3QgYWN0aXZlVHJheSA9IHRoaXMuZmx1eFxyXG4gICAgICAgICAgICAuc3RvcmUoJ1Byb2plY3RTdG9yZScpXHJcbiAgICAgICAgICAgIC5nZXRQcm9qZWN0KClcclxuICAgICAgICAgICAgLmdldEFjdGl2ZVRyYXkoKTtcclxuICAgICAgICBjb25zdCB0cmF5Qm9kaWVzRXhpc3QgPSBhY3RpdmVUcmF5LnRvSlNPTigpLnRyYXlCb2RpZXMuc2l6ZSA+IDA7XHJcblxyXG4gICAgICAgIGlmICghc2V0dGluZ3NMb2FkZWQpIHtcclxuICAgICAgICAgICAgLy8gTG9hZCAnYWN0aXZlQWR2U2V0dGluZ3MnIGZyb20gdXNlcl9jb25maWcuanNvbiBpZiBhcHAganVzdCBsb2FkZWQsIGFuZCBzZXR0aW5ncyBleGlzdFxyXG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZ0FjdGl2ZUFkdlNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhcHAganVzdCBzdGFydGVkLCB1c2UgdXNlcl9jb25maWcgJ2FjdGl2ZUFkdlNldHRpbmdzJ1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IHZhbHVlcyAob3ZlcnJpZGVzKSB0byAncHJpbnRTZXR0aW5ncydcclxuICAgICAgICAgICAgICAgIHZpc2libGVTZXR0aW5ncyA9IHVzZXJDb25maWdBY3RpdmVBZHZTZXR0aW5ncztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSBhcmUgc2VlaW5nIGEgdHJheSB3aXRoIGJvZGllcywgd2UgbmVlZFxyXG4gICAgICAgICAgICAvLyB0byBsb2FkIHVwIHVzZXJfY29uZmlnLmpzb24ncyBzYXZlZCAncHJpbnRTZXR0aW5ncydcclxuICAgICAgICAgICAgaWYgKCFmaXJzdFRyYXlMb2FkZWQgJiYgdXNlckNvbmZpZ1ByaW50U2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGFwcCBqdXN0IHN0YXJ0ZWQsIHVzZSB1c2VyX2NvbmZpZyAncHJpbnRTZXR0aW5ncydcclxuICAgICAgICAgICAgICAgIC8vIHNldCB2YWx1ZXMgKG92ZXJyaWRlcykgdG8gJ3ByaW50U2V0dGluZ3MnXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSB1c2VyQ29uZmlnUHJpbnRTZXR0aW5ncztcclxuICAgICAgICAgICAgICAgIC8vIExlYXZpbmcgdGhpcyBoZXJlIHRvIHJlbW92ZSBhbnkgcHJldmlvdXMgcmVmZXJlbmNlcyBpblxyXG4gICAgICAgICAgICAgICAgLy8gdXNlcl9jb25maWcncyBwcmludCBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gUi5kaXNzb2MoJ2RlZmF1bHRTdXBwb3J0TWF0ZXJpYWwnLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtb3ZpbmcgdGhpcyB1cCBzbyB0aGUgdWkgY2FuIGNodWcgYWxvbmcgd2hpbGUgd2UgdXBkYXRlIHRoZSBwcm9qZWN0IHN0b3JlXHJcbiAgICAgICAgdGhpcy5lbWl0KCdpbml0aWFsaXplX3ZhbHVlcycpO1xyXG5cclxuICAgICAgICAvLyBUb2dnbGUgdG8gZmFsc2UgdW50aWwgbmV4dCBhcHAgc3RhcnQuXHJcbiAgICAgICAgaWYgKCFzZXR0aW5nc0xvYWRlZCkgc2V0dGluZ3NMb2FkZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoIWZpcnN0VHJheUxvYWRlZCkgZmlyc3RUcmF5TG9hZGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gUmUtb3JnYW5pemluZyB0aGlzIGNvZGUgdG8gcmVhZCBmcm9tIHNhdmVkIHVzZXIgY29uZmlnIG9uY2UgYXQgc3RvcmUgaW5pdCB0aW1lLFxyXG4gICAgICAgIC8vIHNhdmluZyBpdCBpbiBzdG9yZSdzIHZhbHVlcyBhbmQgdmlzaWJsZVNldHRpbmdzIG9iamVjdHMuXHJcbiAgICAgICAgLy8gSG93ZXZlciwgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHRyYXkgYm9keSBwcm9wZXJ0aWVzIGV2ZXJ5IHRpbWUgb3IgZWxzZSB3ZSBtaXNzXHJcbiAgICAgICAgLy8gc29tZSBjYXNlcyBhbmQgdGhlIG92ZXJyaWRlcyBnbyBtaXNzaW5nLlxyXG4gICAgICAgIC8vIEZvciBleGFtcGxlOiB3aGVuIGEgbW9kZWwgaXMgYWRkZWQgYW5kIGRlbGV0ZWQsIHdlIG5lZWQgdG8gcmVhcHBseSBvdmVycmlkZXMuXHJcbiAgICAgICAgLy8gTm90IHRoZSBtb3N0IGVmZmljaWVudCB3YXkgb2YgZG9pbmcgdGhpbmdzLCBhbmQgbWF5YmUgc29tZW9uZSBlbHNlIGhhc1xyXG4gICAgICAgIC8vIGJldHRlciBpZGVhcywgYnV0LCBkZWZpbml0ZWx5IGFwcGx5aW5nIG92ZXJyaWRlcyBvbmx5IHRoZSBmaXJzdCB0aW1lIHdpbGwgbm90IHdvcmsuXHJcbiAgICAgICAgaWYgKHVzZXJDb25maWdQcmludFNldHRpbmdzICYmIHRyYXlCb2RpZXNFeGlzdCkge1xyXG4gICAgICAgICAgICBSLm1hcE9iakluZGV4ZWQoKHYsIGspID0+IHByaW50U3RvcmVVdGlscy51cGRhdGVQcm9qZWN0U3RvcmVQcm9wKGssIHYsIHRydWUsIHRoaXMuZmx1eCksIHZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdlIGhhdmUgdGhpcyBzZXBhcmF0ZSBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBleHRydWRlciB0eXBlcywgcGFydGx5IGJlY2F1c2UgdGhlIG9mZmxpbmVcclxuICAgICAqIGJvdHMgaGF2ZSBzb21lIG9kZCBiZWhhdmlvciBpbiB0aGlzIGNvbnRleHQsIGJ1dCBtYWlubHkgYmVjYXVzZSB3ZSBuZWVkIHRvIGdyYWIgdGhpcyB0b1xyXG4gICAgICogYXBwcm9wcmlhdGVseSBwcm9jZXNzIFByaW50IE1vZGVzLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSB0aGUgYXZhaWxhYmxlIGNvbmZpZ3VyYXRpb25zIGFzIHdlbGwgYXMgdGhlIGRlZmF1bHRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldEV4dHJ1ZGVyVHlwZXMocGF5bG9hZCkge1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB0aGlzLl9leHRydWRlcihwYXlsb2FkKTtcclxuICAgICAgICBwcmludFN0b3JlVXRpbHMudXBkYXRlUHJvamVjdFN0b3JlUHJvcChTZXR0aW5nc0tleXMuRXh0cnVkZXIsIG5vcm1hbGl6ZWQsIHRydWUsIHRoaXMuZmx1eCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KENIQU5HRV9FVkVOVCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FjaGUgdGhlIHN1cHBvcnRlZCBjb25maWdzIG9uY2UgZnJvbSBzbGljZWNvbmZpZyBvbiBhcHBsaWNhdGlvbiBsb2FkXHJcbiAgICAgKiovXHJcbiAgICBnZXRTdXBwb3J0ZWRDb25maWd1cmF0aW9ucygpIHtcclxuICAgICAgICBpZiAoIXN1cHBvcnRlZENvbmZpZ3VyYXRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzdXBwb3J0ZWRDb25maWd1cmF0aW9ucyA9IG1ha2VyYm90LmdldFN1cHBvcnRlZENvbmZpZ3VyYXRpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkNyZWF0ZVByZXNldCh7IG5hbWUgfSkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1ByZXNldFdpdGhOYW1lKG5hbWUpKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IHByZXNldCA9IHJlZHVjZXJzLnZhbHVlc1RvUHJlc2V0KG5hbWUsIHZhbHVlcyk7XHJcblxyXG4gICAgICAgIHByZXNldHMgPSBSLmFwcGVuZChwcmVzZXQsIHByZXNldHMpO1xyXG4gICAgICAgIGN1cnJlbnRQcmVzZXQgPSBuYW1lO1xyXG4gICAgICAgIHByZXNldEVycm9yID0gbm90aGluZygpO1xyXG4gICAgICAgIHRoaXMuX3NhdmVQcmVzZXRzKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZW1pdChDSEFOR0VfRVZFTlQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblVwZGF0ZVByZXNldCgpIHtcclxuICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZXQpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgcHJlc2V0ID0gcmVkdWNlcnMudmFsdWVzVG9QcmVzZXQoY3VycmVudFByZXNldCwgdmFsdWVzKTtcclxuXHJcbiAgICAgICAgcHJlc2V0cyA9IHJlZHVjZXJzLnVwZGF0ZVByZXNldEJ5TmFtZShjdXJyZW50UHJlc2V0LCBwcmVzZXQsIHByZXNldHMpO1xyXG5cclxuICAgICAgICB0aGlzLl9zYXZlUHJlc2V0cygpO1xyXG5cclxuICAgICAgICB0aGlzLmVtaXQoQ0hBTkdFX0VWRU5UKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Xcml0ZVByZXNldCgpIHtcclxuICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZXQpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgeyBkaWFsb2cgfSA9IHJlcXVpcmUoJ2VsZWN0cm9uJykucmVtb3RlO1xyXG4gICAgICAgIGNvbnN0IGkxOG4gPSBnZXRJMThuKHRoaXMuZmx1eCk7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZVN0b3JlID0gdGhpcy5mbHV4LnN0b3JlKCdNZXNzYWdlU3RvcmUnKTtcclxuICAgICAgICBjb25zdCBwcmVzZXQgPSByZWR1Y2Vycy5nZXRQcmVzZXRCeU5hbWUoY3VycmVudFByZXNldCwgcHJlc2V0cyk7XHJcblxyXG4gICAgICAgIC8vIHJlYWxseSBub3Qgc3VyZSBob3cgdGhpcyB3b3VsZCBoYXBwZW4sIGJ1dCBJJ2QgcmF0aGVyIG5vdCBkZWJ1ZyBpdCBsYXRlciBpZiBpdCBkb2VzXHJcbiAgICAgICAgaWYgKCFwcmVzZXQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkbid0IGZpbmQgcHJlc2V0OlwiLCBjdXJyZW50UHJlc2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGlhbG9nLnNob3dTYXZlRGlhbG9nKFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogaTE4bi50KCdtYjpwcmludFNldHRpbmdzLnByZXN0cy5zYXZlRGlhbG9nJyksXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0UGF0aDogYCR7XHJcbiAgICAgICAgICAgICAgICAgICAgUi5pc0VtcHR5KGZpbGVTYWZlU3RyaW5nKGN1cnJlbnRQcmVzZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGZpbGVTYWZlU3RyaW5nKCdOZXcgQ3VzdG9tIFByZXNldCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmlsZVNhZmVTdHJpbmcoY3VycmVudFByZXNldClcclxuICAgICAgICAgICAgICAgIH0uJHtQUkVTRVRfRVhUfWAsXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWFrZXJib3QgUHJpbnQgUHJlc2V0cycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IFtQUkVTRVRfRVhUXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZmlsZW5hbWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIGZzLndyaXRlSnNvbihmaWxlbmFtZSwgcHJlc2V0VG9KU09OKHByZXNldCksIGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHRocm93IGVycjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VTdG9yZS5vbk1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2luZm9ybWF0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGkxOG4udCgnbWI6cHJpbnRTZXR0aW5ncy5wcmVzZXRzLmV4cG9ydFN1Y2Nlc3MnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KENIQU5HRV9FVkVOVCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkRlc3Ryb3lQcmVzZXQoKSB7XHJcbiAgICAgICAgaWYgKCFjdXJyZW50UHJlc2V0KSByZXR1cm47XHJcblxyXG4gICAgICAgIHByZXNldHMgPSByZWR1Y2Vycy5yZW1vdmVQcmVzZXRCeU5hbWUoY3VycmVudFByZXNldCwgcHJlc2V0cyk7XHJcblxyXG4gICAgICAgICh7IHZhbHVlcywgY3VycmVudFByZXNldCB9ID0gcHJpbnRTdG9yZVV0aWxzLnJlc2V0QWxsVG9EZWZhdWx0KHRoaXMuZmx1eCwgdmFsdWVzKSk7XHJcbiAgICAgICAgdGhpcy5fc2F2ZVByZXNldHMocHJlc2V0cyk7XHJcbiAgICAgICAgdGhpcy5lbWl0KENIQU5HRV9FVkVOVCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uUmVhZFByZXNldHMoKSB7XHJcbiAgICAgICAgY29uc3QgeyBkaWFsb2cgfSA9IHJlcXVpcmUoJ2VsZWN0cm9uJykucmVtb3RlO1xyXG4gICAgICAgIGNvbnN0IGkxOG4gPSBnZXRJMThuKHRoaXMuZmx1eCk7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZVN0b3JlID0gdGhpcy5mbHV4LnN0b3JlKCdNZXNzYWdlU3RvcmUnKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVhZEpTT04gPSBwYXRoID0+XHJcbiAgICAgICAgICAgIGZzLnJlYWRKc29uKHBhdGgsIChlcnIsIG9iaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VTdG9yZS5vbk1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBpMThuLnQoJ21iOnByaW50U2V0dGluZ3MucHJlc2V0cy5pbXBvcnRGYWlsdXJlJyksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXNldCA9IHNhbml0aXplUHJlc2V0KG9iaiwgcHJlc2V0cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcHJlc2V0cyA9IFIuYXBwZW5kKHByZXNldCwgcHJlc2V0cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZVN0b3JlLm9uTWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2luZm9ybWF0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBpMThuLnQoJ21iOnByaW50U2V0dGluZ3MucHJlc2V0cy5pbXBvcnRTdWNjZXNzJyksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zYXZlUHJlc2V0cygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KENIQU5HRV9FVkVOVCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkaWFsb2cuc2hvd09wZW5EaWFsb2coXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBpMThuLnQoJ21iOnByaW50U2V0dGluZ3MucHJlc2V0cy5pbXBvcnQnKSxcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFsnb3BlbkZpbGUnLCAnbXVsdGlTZWxlY3Rpb25zJ10sXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWFrZXJib3QgUHJpbnQgUHJlc2V0cycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IFtQUkVTRVRfRVhUXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgUi5waXBlKFIuZGVmYXVsdFRvKFtdKSwgUi5zb3J0QnkoUi5wcm9wKCduYW1lJykpLCBSLndoZW4oUi5jb21wb3NlKFIubm90LCBSLmlzRW1wdHkpLCBSLm1hcChyZWFkSlNPTikpKVxyXG4gICAgICAgICk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uQXBwbHlQcmVzZXQoeyBuYW1lIH0pIHtcclxuICAgICAgICBpZiAoY3VycmVudFByZXNldCAmJiBjdXJyZW50UHJlc2V0ID09PSBuYW1lKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IHByZXNldCA9IHJlZHVjZXJzLmdldFByZXNldEJ5TmFtZShuYW1lLCBwcmVzZXRzKTtcclxuICAgICAgICBpZiAoIXByZXNldCkgY29uc29sZS5lcnJvcignTm8gcHJlc2V0IGJ5IHRoYXQgbmFtZScpO1xyXG5cclxuICAgICAgICBjb25zdCBmaWx0ZXJlZFNldHRpbmdzID0ge307XHJcblxyXG4gICAgICAgIE9iamVjdC5rZXlzKHByZXNldC5zZXR0aW5ncykubWFwKHNldHRpbmcgPT4ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUHJlc2V0IHNldHRpbmdzIG5lZWQgdG8gYmUgZmlsdGVyZWQgYmFzZWQgb24gdGhlXHJcbiAgICAgICAgICAgICAqIGF2YWlsYWJsZVNldHRpbmdzLCB3aGljaCBnZXRzIHVwZGF0ZWQgdXBvbiBsb2FkU2NoZW1hLFxyXG4gICAgICAgICAgICAgKiBkZXBlbmRpbmcgb24gd2hhdCBleHRydWRlciBpcyBhdHRhY2hlZC4gKFRoaXMgaXMgbWFpbmx5IGZvclxyXG4gICAgICAgICAgICAgKiBmaWx0ZXJpbmcgb3V0IEVFIHNldHRpbmdzIG9uIG5vbi1FRS1hdHRhY2hlZCBwcmludGVyKVxyXG4gICAgICAgICAgICAgKiovXHJcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdmFpbGFibGVTZXR0aW5ncykuaW5jbHVkZXMoc2V0dGluZykpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkU2V0dGluZ3Nbc2V0dGluZ10gPSBwcmVzZXQuc2V0dGluZ3Nbc2V0dGluZ107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBzZXR0aW5nIHdlJ3JlIGxvb2tpbmcgYXQgaXMgYSBwcmludCBtb2RlLFxyXG4gICAgICAgICAgICAvLyB3ZSBjaGVjayBpZiBpdCdzIHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBwcmludGVyXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHNldHRpbmcgPT09IENvbnN0YW50cy5TZXR0aW5nc0tleXMuUHJpbnRNb2RlcyAmJlxyXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkUHJpbnRNb2Rlcy5pbmNsdWRlcyhwcmVzZXQuc2V0dGluZ3Nbc2V0dGluZ10pXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcHJpbnRNb2RlID0gcHJlc2V0LnNldHRpbmdzW3NldHRpbmddO1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRTZXR0aW5nc1tzZXR0aW5nXSA9IHByZXNldC5zZXR0aW5nc1tzZXR0aW5nXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0U3RvcmVTZXR0aW5ncyA9IFIubWVyZ2UoXHJcbiAgICAgICAgICAgIFIubWFwT2JqSW5kZXhlZCgodiwgaykgPT4gKFIuY29udGFpbnMoaywgUHJlc2V0S2V5QmxhY2tsaXN0KSA/IHYgOiB1bmRlZmluZWQpLCB2YWx1ZXMpLFxyXG4gICAgICAgICAgICBmaWx0ZXJlZFNldHRpbmdzXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gdGFraW5nIHRoaXMgYXN5bmMgc28gYXMgbm90IHRvIGJsb2NrIHdpdGggdGhlc2Ugc2xvdyBvcGVyYXRpb25zXHJcbiAgICAgICAgcSgpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogJ3ByaW50U3RvcmVVdGlscy5yZXNldEFsbFRvRGVmYXVsdCcgaGFuZGxlcyB0aGUgdmFsdWVzIGluIHByb2plY3RTZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgICogJ19sb2FkU2NoZW1hSW5pdGlhbFZhbHVlJyB3aWxsIGhhbmRsZSB0aGVcclxuICAgICAgICAgICAgICAgICAqIHByaW50U2V0dGluZ3NTdG9yZSdzIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgKiovXHJcbiAgICAgICAgICAgICAgICAoeyB2YWx1ZXMsIGN1cnJlbnRQcmVzZXQgfSA9IHByaW50U3RvcmVVdGlscy5yZXNldEFsbFRvRGVmYXVsdCh0aGlzLmZsdXgsIHZhbHVlcykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFNjaGVtYUluaXRpYWxWYWx1ZSgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBSLm1lcmdlKGZpbHRlcmVkU2V0dGluZ3MsIFIucGljayhQcmVzZXRLZXlCbGFja2xpc3QsIHZhbHVlcykpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFByZXNldCA9IG5hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KENIQU5HRV9FVkVOVCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHByaW50U3RvcmVVdGlscy5zYXZlVG9Vc2VyQ29uZmlnKCdwcmludFNldHRpbmdzJywgdmFsdWVzLCB0aGlzLmZsdXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIFIubWFwT2JqSW5kZXhlZChcclxuICAgICAgICAgICAgICAgICAgICAodiwgaykgPT4gcHJpbnRTdG9yZVV0aWxzLnVwZGF0ZVByb2plY3RTdG9yZVByb3AoaywgdiwgZmFsc2UsIHRoaXMuZmx1eCksXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdFN0b3JlU2V0dGluZ3NcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKVxyXG4gICAgICAgICAgICAuZG9uZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblJlbmFtZVByZXNldCh7IG5hbWUgfSkge1xyXG4gICAgICAgIHRoaXMub25EZXN0cm95UHJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5vbkNyZWF0ZVByZXNldCh7IG5hbWUgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uVW5hcHBseVByZXNldCgpIHtcclxuICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZXQpIHJldHVybjtcclxuXHJcbiAgICAgICAgKHsgdmFsdWVzLCBjdXJyZW50UHJlc2V0IH0gPSBwcmludFN0b3JlVXRpbHMucmVzZXRBbGxUb0RlZmF1bHQodGhpcy5mbHV4LCB2YWx1ZXMpKTtcclxuICAgICAgICB0aGlzLmVtaXQoQ0hBTkdFX0VWRU5UKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25QcmVzZXRFcnJvcih7IGVycm9yIH0pIHtcclxuICAgICAgICBwcmVzZXRFcnJvciA9IGp1c3QoZXJyb3IpO1xyXG4gICAgICAgIHRoaXMuZW1pdChDSEFOR0VfRVZFTlQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkNsb3NlTW9kYWwoKSB7XHJcbiAgICAgICAgcHJlc2V0RXJyb3IgPSBub3RoaW5nKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KENIQU5HRV9FVkVOVCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc2V0TWF0ZXJpYWxTcGVjaWZpY1NldHRpbmdzKHNlbGVjdGVkTWF0ZXJpYWxzKSB7XHJcbiAgICAgICAgLy9TaW5jZSB0aGVzZSBzZXR0aW5ncyBhcmUgbWF0ZXJpYWwtc3BlY2lmaWMsIHRoZXkgbmVlZCB0byBiZVxyXG4gICAgICAgIC8vcmVzZXQgZWFjaCB0aW1lIHRoZSBtYXRlcmlhbCBjaGFuZ2VzLiAoVGhpcyBpbmNsdWRlcyB3aGVuIHRoZVxyXG4gICAgICAgIC8vZXh0cnVkZXIgY2hhbmdlcylcclxuICAgICAgICBwdXJnZVdhbGxDZW50ZXIgPSBbXTtcclxuICAgICAgICB0aGlzLl9wZXJzaXN0VmFsdWVzKCdtYXRlcmlhbHMnLCBzZWxlY3RlZE1hdGVyaWFscywgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5fcGVyc2lzdFZhbHVlcyhTZXR0aW5nc0tleXMuQ2hhbWJlclRlbXAsIG51bGwsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX3BlcnNpc3RWYWx1ZXMoU2V0dGluZ3NLZXlzLlN1cHBvcnRzLCBudWxsLCB0cnVlKTtcclxuICAgICAgICAvLyB0aGlzLl9wZXJzaXN0VmFsdWVzKFNldHRpbmdzS2V5cy5CdWlsZFBsYW5lVGVtcCwgbnVsbCwgdHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uVXBkYXRlRXh0cnVkZXIoKSB7XHJcbiAgICAgICAgLy8gQSBjaGFuZ2UgaW4gZXh0cnVkZXJzIGltcGxpZXMgYSBjaGFuZ2UgaW4gbWF0ZXJpYWxzXHJcbiAgICAgICAgc2VsZWN0ZWRNYXRlcmlhbHMgPSBbXTtcclxuICAgICAgICB0aGlzLnJlc2V0TWF0ZXJpYWxTcGVjaWZpY1NldHRpbmdzKHNlbGVjdGVkTWF0ZXJpYWxzKTtcclxuICAgICAgICB0aGlzLl9sb2FkU2NoZW1hSW5pdGlhbFZhbHVlKClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5lbWl0KENIQU5HRV9FVkVOVCkpXHJcbiAgICAgICAgICAgIC8vIGVtaXQgZXZlbnQgZm9yIGRpYWdub3N0aWNzIHB1cnBvc2VzXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuZW1pdChPTlVQREFURV9FWFRSVURFUlNfQ09NUExFVEVEX0VWRU5UKSlcclxuICAgICAgICAgICAgLmRvbmUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25VcGRhdGVFeHRydWRlclBhaXIoKSB7XHJcbiAgICAgICAgLy8gQSBjaGFuZ2UgaW4gZXh0cnVkZXJzIGltcGxpZXMgYSBjaGFuZ2UgaW4gbWF0ZXJpYWxzXHJcbiAgICAgICAgc2VsZWN0ZWRNYXRlcmlhbHMgPSBbXTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2luY2Ugd2UncmUgZXNzZW50aWFsbHkgYWxsb3dpbmcgc2xpY2VvY25maWcgZ2V0X3NjaGVtYSB0byByZXR1cm5cclxuICAgICAgICAgKiBkZWZhdWx0IG1hdGVyaWFscywgYnV0IEFUTSBzbGljZWNvbmZpZyBoYXMgYW4gaXNzdWUgd2hlcmUgaXQgZG9lc24ndFxyXG4gICAgICAgICAqIHJldHVybiBwcm9wZXIgaW5pdGlhbCB2YWx1ZXMgZm9yIGNlcnRhaW4gc2V0dGluZ3MuXHJcbiAgICAgICAgICogSW5zdGVhZCwgd2UnbGwgdXBkYXRlIHRoZSBgc2VsZWN0ZWRNYXRlcmlhbHNgIGJhc2VkIG9uIGRlZmF1bHRcclxuICAgICAgICAgKiBtYXRlcmlhbCBwZXIgZXh0cnVkZXIgdHlwZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC0tIFJheVxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBzZWxlY3RlZE1hdGVyaWFscyA9IHRoaXMuX2dldERlZmF1bHRNYXRlcmlhbHNCYXNlZE9uRXh0cnVkZXJzKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldE1hdGVyaWFsU3BlY2lmaWNTZXR0aW5ncyhzZWxlY3RlZE1hdGVyaWFscyk7XHJcbiAgICAgICAgdGhpcy5fbG9hZFNjaGVtYUluaXRpYWxWYWx1ZSgpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuZW1pdChDSEFOR0VfRVZFTlQpKVxyXG4gICAgICAgICAgICAvLyBlbWl0IGV2ZW50IGZvciBkaWFnbm9zdGljcyBwdXJwb3Nlc1xyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLmVtaXQoT05VUERBVEVfRVhUUlVERVJTX0NPTVBMRVRFRF9FVkVOVCkpXHJcbiAgICAgICAgICAgIC5kb25lKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uVXBkYXRlTWF0ZXJpYWwoeyBpbmRleCwgdmFsIH0pIHtcclxuICAgICAgICBpZiAoaW5kZXggPiAxIHx8IGluZGV4IDwgMCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBzZWxlY3RlZE1hdGVyaWFsc1tpbmRleF0gPSB2YWw7XHJcbiAgICAgICAgdGhpcy5yZXNldE1hdGVyaWFsU3BlY2lmaWNTZXR0aW5ncyhzZWxlY3RlZE1hdGVyaWFscyk7XHJcbiAgICAgICAgdGhpcy5fbG9hZFNjaGVtYUluaXRpYWxWYWx1ZSgpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuZW1pdChDSEFOR0VfRVZFTlQpKVxyXG4gICAgICAgICAgICAuZG9uZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblVwZGF0ZU1hdGVyaWFscyh7IGlkLCBzcG9vbHNJbmZvIH0pIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50UHJpbnRlciA9IHRoaXMuZmx1eC5zdG9yZSgnUHJpbnRlclN0b3JlJykuZ2V0U2VsZWN0ZWRQcmludGVyKCk7XHJcbiAgICAgICAgaWYgKCEoaWQgPT09IGN1cnJlbnRQcmludGVyLmdldElkKCkpKSByZXR1cm47XHJcblxyXG4gICAgICAgIHEodGhpcy51cGRhdGVQcmludGVyU3Bvb2xJbmZvKGN1cnJlbnRQcmludGVyLCB7IHNwb29sc0luZm8gfSkpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkTWF0ZXJpYWxzID0gc3Bvb2xNYXRlcmlhbHM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0TWF0ZXJpYWxTcGVjaWZpY1NldHRpbmdzKHNlbGVjdGVkTWF0ZXJpYWxzKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFNjaGVtYUluaXRpYWxWYWx1ZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5lbWl0KENIQU5HRV9FVkVOVCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRvbmUoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmRvbmUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25VcGRhdGVTdXBwb3J0cyh7IHN1cHBvcnRFeHRydWRlciwgc3VwcG9ydFR5cGUgfSkge1xyXG4gICAgICAgIHRoaXMuX3BlcnNpc3RWYWx1ZXMoU2V0dGluZ3NLZXlzLlN1cHBvcnRzLCBzdXBwb3J0VHlwZSk7XHJcbiAgICAgICAgdGhpcy5lbWl0KENIQU5HRV9FVkVOVCk7XHJcbiAgICAgICAgcHJpbnRTdG9yZVV0aWxzLmNsZWFyQnVpbGRzKHRoaXMuZmx1eCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uVXBkYXRlUHJpbnRNb2RlKG5ld1ByaW50TW9kZSkge1xyXG4gICAgICAgIGNvbnN0IHByaW50ZXIgPSB0aGlzLmZsdXguc3RvcmUoJ1ByaW50ZXJTdG9yZScpLmdldFNlbGVjdGVkUHJpbnRlcigpO1xyXG4gICAgICAgIHByaW50TW9kZSA9IG5ld1ByaW50TW9kZTtcclxuICAgICAgICB0aGlzLl9wZXJzaXN0VmFsdWVzKFNldHRpbmdzS2V5cy5QcmludE1vZGVzLCBwcmludE1vZGUsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX2xvYWRTY2hlbWFJbml0aWFsVmFsdWUoKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLmVtaXQoQ0hBTkdFX0VWRU5UKSlcclxuICAgICAgICAgICAgLmRvbmUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25VcGRhdGVQdXJnZVdhbGxDZW50ZXIobmV3UHVyZ2VXYWxsY2VudGVyKSB7XHJcbiAgICAgICAgcHVyZ2VXYWxsQ2VudGVyID0gbmV3UHVyZ2VXYWxsY2VudGVyO1xyXG4gICAgICAgIHRoaXMuX2xvYWRTY2hlbWFJbml0aWFsVmFsdWUoKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLmVtaXQoQ0hBTkdFX0VWRU5UKSlcclxuICAgICAgICAgICAgLmRvbmUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIC8qICAgICAgICAgICAgICAgICAgICAgICAgICBVVElMSVRZIE1FVEhPRFMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVE9ETzogUG90ZW50aWFsIGZvciByZWZhY3RvciwgbWF5YmUgbm90IG1hbmFnZSAzIGluZGVwZW5kZW50bHkuLi5cclxuICAgICAqXHJcbiAgICAgKiBTYXZlcyB2YWx1ZXMgYWNyb3NzIDMgb2JqZWN0cyB0aGF0IG5lZWQgdG8gYmUgaW4gc3luYzpcclxuICAgICAqICgxKSB0cmF5LmJvZHlQcm9wZXJ0aWVzIHRocm91Z2ggUHJvamVjdCBTdG9yZSAtIG5lY2Vzc2FyeSBmb3Igc2xpY2luZ1xyXG4gICAgICogKDIpIHZhbHVlcyBvYmplY3QgZnJvbSBjdXJyZW50IHN0b3JlIC0gcmVwcmVzZW50YXRpb24gb2Ygb3ZlcnJpZGVzXHJcbiAgICAgKiAoMykgdXNlcl9jb25maWcuanNvbiAtIGFwcC13aWRlIHNhdmVkIHNldHRpbmdzIHVuZGVyIGBwcmludFNldHRpbmdzYFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNldHRpbmcgLSBzZXR0aW5nIGtleVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdmFsdWUgdG8gcGVyc2lzdCBvbiBrZXlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9wZXJzaXN0VmFsdWVzKHNldHRpbmcsIHZhbHVlLCBza2lwVW5kb1N0YWNrID0gZmFsc2UpIHtcclxuICAgICAgICAvLyBTYXZlIHRvIHRyYXkuYm9keVByb3BlcnRpZXMgZm9yIHNsaWNpbmdcclxuICAgICAgICBwcmludFN0b3JlVXRpbHMudXBkYXRlUHJvamVjdFN0b3JlUHJvcChzZXR0aW5nLCB2YWx1ZSwgc2tpcFVuZG9TdGFjaywgdGhpcy5mbHV4KTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHZhbHVlcyA9IFIuYXNzb2Moc2V0dGluZywgdmFsdWUsIHZhbHVlcyk7XHJcbiAgICAgICAgZWxzZSB2YWx1ZXMgPSBSLmRpc3NvYyhzZXR0aW5nLCB2YWx1ZXMpO1xyXG5cclxuICAgICAgICAvLyBTYXZlIHRvIHVzZXJfY29uZmlnIGFzIEFQUC1XSURFIHNldHRpbmdzLlxyXG4gICAgICAgIHByaW50U3RvcmVVdGlscy5zYXZlVG9Vc2VyQ29uZmlnKCdwcmludFNldHRpbmdzJywgdmFsdWVzLCB0aGlzLmZsdXgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIHNsaWNlQ29uZmlnIGdldF9zY2hlbWEgd2l0aCBvdmVycmlkZXMgYW5kIHByaW50X21vZGVcclxuICAgICAqIHRvIGdldCBuZXcgaW5pdGlhbF92YWx1ZSBmb3IgYSBzZXR0aW5nLCBzYXZlcyB0byBvdmVycmlkZSBvYmplY3QsXHJcbiAgICAgKiBhbmQgc2V0cyBhcyBuZXcgYGluaXRpYWxfdmFsdWVgIHdpdGhpbiBhdmFpbGFibGVTZXR0aW5ncyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0dGluZyAtIHRoZSBhZHZhbmNlZCBzZXR0aW5nIGtleVxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSBuZXcgZXZhbHVhdGVkIGluaXRpYWxfdmFsdWVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9sb2FkU2NoZW1hSW5pdGlhbFZhbHVlKCkge1xyXG4gICAgICAgIGNvbnN0IHByaW50ZXIgPSB0aGlzLmZsdXguc3RvcmUoJ1ByaW50ZXJTdG9yZScpLmdldFNlbGVjdGVkUHJpbnRlcigpO1xyXG4gICAgICAgIGlmIChwcmludGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVRyYXkgPSB0aGlzLmZsdXhcclxuICAgICAgICAgICAgICAgIC5zdG9yZSgnUHJvamVjdFN0b3JlJylcclxuICAgICAgICAgICAgICAgIC5nZXRQcm9qZWN0KClcclxuICAgICAgICAgICAgICAgIC5nZXRBY3RpdmVUcmF5KCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0cmF5ID0gYWN0aXZlVHJheS5nZXRCdWlsZEluZm8ocHJpbnRlcik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbWFrZXJib3QuZ2V0U2NoZW1hKHRyYXksIHByaW50ZXIsIG51bGwsIHRoaXMuZmx1eCkudGhlbihzY2hlbWEgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gSW4gcmFyZSBjYXNlcywgaWYgZ2V0U2NoZW1hIGdldHMgY2FsbGVkIHRvbyBxdWlja2x5LCBpdFxyXG4gICAgICAgICAgICAgICAgLy8gd2lsbCByZXR1cm4gZW1wdHkgc3RyaW5nIGFzIGEgcmVzdWx0LiBMZXQncyBleGl0IGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpbmdzIGVycm9yIG91dC5cclxuICAgICAgICAgICAgICAgIC8vIC0tIFJheVxyXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNFbXB0eShzY2hlbWEpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbFNjaGVtYSA9IHNjaGVtYS5nZXRGdWxsU2NoZW1hKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVNjaGVtYShmdWxsU2NoZW1hKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBlbWl0dGluZyBhZ2FpbiBiZWNhdXNlIHRoZSBzZXR0aW5nIG1pZ2h0IGhhdmUgY2hhbmdlZCBpdHNcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWwgdmFsdWUsIHNvIHdlIHdhbnQgdGhlIFVJIHRvIHJlZmxlY3QgdGhpcyBjaGFuZ2UuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgYSBzbGlnaHQgZGVsYXksIGJ1dCBhcyBsb25nIGFzIHRoZSByZXN0IG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gVUkgY2hhbmdlcyBxdWlja2x5LCB0aGlzIHNsaWdodCBsYWcgaGVyZSBzaG91bGRuJ3QgYmUgYW5cclxuICAgICAgICAgICAgICAgIC8vIGlzc3VlIGZvciB0aGUgdXNlci5cclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChDSEFOR0VfRVZFTlQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSB0aGUgSlNPTiB0aGF0IGNvbWVzIGZyb21cclxuICAgICAqIFNsaWNlIENvbmZpZyBpbnRvIGEgdXNlYWJsZSBmb3JtYXQgZm9yIGF2YWlsYWJsZVNldHRpbmdzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWEgLSB0aGUgb2JqZWN0IHRoYXQgY29tZXMgZnJvbSBTbGljZSBDb25maWdcclxuICAgICAqL1xyXG4gICAgX3BhcnNlU2NoZW1hKHNjaGVtYSwgcmVzZXRUb0RlZmF1bHRFeHRydWRlcnMgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICghc2NoZW1hIHx8ICFzY2hlbWEudXNlcl9zZXR0aW5ncykgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHVzZXJfc2V0dGluZ3MsXHJcbiAgICAgICAgICAgIGV4dHJ1ZGVyczogc2NoZW1hRXh0cnVkZXJzLFxyXG4gICAgICAgICAgICBtYXRlcmlhbHM6IHNjaGVtYU1hdGVyaWFscyxcclxuICAgICAgICAgICAgbWF0ZXJpYWxzX3RyYW5zbGF0aW9uczogc2NoZW1hTWF0ZXJpYWxUcmFuc2xhdGlvbnMsXHJcbiAgICAgICAgICAgIHByaW50X21vZGVzOiBzY2hlbWFQcmludE1vZGVzLFxyXG4gICAgICAgIH0gPSBzY2hlbWE7XHJcblxyXG4gICAgICAgIGlmICghdXNlcl9zZXR0aW5ncyB8fCAhc2NoZW1hRXh0cnVkZXJzKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IHByaW50ZXIgPSB0aGlzLmZsdXguc3RvcmUoJ1ByaW50ZXJTdG9yZScpLmdldFNlbGVjdGVkUHJpbnRlcigpO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRCb3RUeXBlID0gcHJpbnRlci5nZXRHZW5kZXIoKS5ib3RUeXBlO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkU2V0dGluZ3MgPSBwcmludFN0b3JlVXRpbHMuZmlsdGVySW5jb21wYXRpYmxlT3ZlcnJpZGVzKHVzZXJfc2V0dGluZ3MsIGN1cnJlbnRCb3RUeXBlKTtcclxuXHJcbiAgICAgICAgLy8gbGlzdCBvZiB0aGUgc2V0dGluZ3Mgbm8gbG9uZ2VyIGF2YWlsYWJsZSAoaWYgYW55KSBmcm9tIHRoZSBsYXN0IHRpbWUgd2UgcGFyc2VkIHRoZSBzY2hlbWFcclxuICAgICAgICBjb25zdCBzY2hlbWFLZXlEaWZmID0gUi5waXBlKFxyXG4gICAgICAgICAgICBSLmtleXMsXHJcbiAgICAgICAgICAgIFIud2l0aG91dChSLmtleXMoZmlsdGVyZWRTZXR0aW5ncykpLFxyXG4gICAgICAgICAgICBSLndpdGhvdXQoW1NldHRpbmdzS2V5cy5QcmludE1vZGVzLCBTZXR0aW5nc0tleXMuRXh0cnVkZXJzLCBTZXR0aW5nc0tleXMuTWF0ZXJpYWxzXSlcclxuICAgICAgICApKGF2YWlsYWJsZVNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgYXZhaWxhYmxlU2V0dGluZ3MgPSByZWR1Y2Vycy5hdmFpbGFibGVTZXR0aW5ncyhmaWx0ZXJlZFNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgLy8gaWYgYSBzZXR0aW5nIGlzIG5vIGxvbmdlciBhdmFpbGFibGUgcmVtb3ZlIGl0XHJcbiAgICAgICAgUi5tYXAoayA9PiAodmFsdWVzID0gcHJpbnRTdG9yZVV0aWxzLnBlcnNpc3RWYWx1ZXMoaywgdW5kZWZpbmVkLCBmYWxzZSwgdmFsdWVzLCB0aGlzLmZsdXgpKSwgc2NoZW1hS2V5RGlmZik7XHJcblxyXG4gICAgICAgIHN1cHBvcnRlZEV4dHJ1ZGVycyA9IHNjaGVtYUV4dHJ1ZGVycy5zdXBwb3J0ZWQ7XHJcbiAgICAgICAgKHsgc3VwcG9ydGVkRXh0cnVkZXJQYWlyQ29uZmlncywgc3VwcG9ydGVkRXh0cnVkZXJzUGVySW5kZXggfSA9IHRoaXMuZ2VuZXJhdGVTdXBwb3J0ZWRFeHRydWRlcnNJbmZvKHtcclxuICAgICAgICAgICAgc3VwcG9ydGVkQ29uZmlndXJhdGlvbnMsXHJcbiAgICAgICAgICAgIHByaW50ZXIsXHJcbiAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICBzdXBwb3J0ZWRQcmludE1vZGVzID0gc2NoZW1hUHJpbnRNb2Rlcy5zdXBwb3J0ZWQ7XHJcblxyXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZE1hdGVyaWFsc0J5RXh0cnVkZXIgPSB0aGlzLl9nZXRTdXBwb3J0ZWRNYXRlcmlhbHNCeUV4dHJ1ZGVyKFxyXG4gICAgICAgICAgICBwcmludGVyLmdldEF0dGFjaGVkRXh0cnVkZXJzKCksXHJcbiAgICAgICAgICAgIHByaW50ZXIsXHJcbiAgICAgICAgICAgIHNjaGVtYU1hdGVyaWFscyxcclxuICAgICAgICAgICAgc3VwcG9ydGVkQ29uZmlndXJhdGlvbnNcclxuICAgICAgICApO1xyXG4gICAgICAgIHN1cHBvcnRlZE1hdGVyaWFscyA9IHN1cHBvcnRlZE1hdGVyaWFsc0J5RXh0cnVkZXI7XHJcblxyXG4gICAgICAgIG1hdGVyaWFsVHJhbnNsYXRpb25zID0gc2NoZW1hTWF0ZXJpYWxUcmFuc2xhdGlvbnM7XHJcblxyXG4gICAgICAgIC8vIEFzc2lnbiBtYXRlcmlhbHMgdG8gc2VsZWN0ZWRNYXRlcmlhbHMgZnJvbSBlaXRoZXIgc3Bvb2xNYXRlcmlhbHMgb3IgdGhyb3VnaCBzY2hlbWEncyBkZWZhdWx0IG1hdGVyaWFsc1xyXG4gICAgICAgIHNlbGVjdGVkTWF0ZXJpYWxzID0gdGhpcy5fZ2V0U2VsZWN0ZWRNYXRlcmlhbHMoe1xyXG4gICAgICAgICAgICBzcG9vbE1hdGVyaWFscyxcclxuICAgICAgICAgICAgc2VsZWN0ZWRNYXRlcmlhbHMsXHJcbiAgICAgICAgICAgIHN1cHBvcnRlZE1hdGVyaWFsc0J5RXh0cnVkZXIsXHJcbiAgICAgICAgICAgIGV4dHJ1ZGVyczogcHJpbnRlci5nZXRBdHRhY2hlZEV4dHJ1ZGVycygpLFxyXG4gICAgICAgICAgICBwcmludGVySXNDb25uZWN0ZWQ6IHByaW50ZXIuaXNDb25uZWN0ZWQoKSxcclxuICAgICAgICAgICAgcHJpbnRNb2RlLFxyXG4gICAgICAgICAgICBpc1NrZXRjaFByaW50ZXI6IHByaW50ZXIuaXNTa2V0Y2hQcmludGVyKCksXHJcbiAgICAgICAgICAgIGlzRmlmdGhHZW46IHByaW50ZXIuaXNGaWZ0aEdlbigpLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhIG5ld2x5IHNlbGVjdGVkIHByaW50ZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcHJpbnQgbW9kZSwgcmVzZXQgdG8gZGVmYXVsdFxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgcGVyc2lzdCB0aGUgcHJldmlvdXNseS1zZWxlY3RlZCBwcmludCBtb2RlLlxyXG4gICAgICAgIGlmIChwcmludE1vZGUgPT09IG51bGwgfHwgIXN1cHBvcnRlZFByaW50TW9kZXMuaW5jbHVkZXMocHJpbnRNb2RlKSkge1xyXG4gICAgICAgICAgICBwcmludE1vZGUgPSBzY2hlbWFQcmludE1vZGVzLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IFIuYXNzb2MoJ3ByaW50TW9kZScsIHByaW50TW9kZSwgdmFsdWVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5PVEU6XHJcbiAgICAgICAgICogUmVnYXJkbGVzcyBpZiBhIGBzdXBwb3JUeXBlYCBzZWxlY3Rpb24gdHJpZ2dlcnMgYW4gaW5pdGlhbCB2YWx1ZSBvZiBmYWxzZVxyXG4gICAgICAgICAqIHdpdGggYGRvUHVyZ2VXYWxsYCwgYHB1cmdlV2FsbENlbnRlcmAgd2lsbCByZXBvcnQgYW4gaW5pdGlhbCB2YWx1ZS4gTm8gbG9uZ2VyXHJcbiAgICAgICAgICogd2UgY2FuIHVzZSBgdXNlcl9zZXR0aW5ncy5wdXJnZVdhbGxDZW50ZXJgIHRvIHJlc2V0IGBwdXJnZVdhbGxDZW50ZXJgIGJhY2sgdG8gYW5cclxuICAgICAgICAgKiBlbXB0eSBhcnJheS4gOjplZWxyb2xsOjpcclxuICAgICAgICAgKiAtLSBSYXlcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgaWYgKCh1c2VyX3NldHRpbmdzLmRvUHVyZ2VXYWxsICYmIHVzZXJfc2V0dGluZ3MuZG9QdXJnZVdhbGwuaW5pdGlhbF92YWx1ZSkgfHwgdmFsdWVzLmRvUHVyZ2VXYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzRW1wdHkocHVyZ2VXYWxsQ2VudGVyKSkge1xyXG4gICAgICAgICAgICAgICAgcHVyZ2VXYWxsQ2VudGVyID0gKHVzZXJfc2V0dGluZ3MucHVyZ2VXYWxsQ2VudGVyICYmIHVzZXJfc2V0dGluZ3MucHVyZ2VXYWxsQ2VudGVyLmluaXRpYWxfdmFsdWUpIHx8IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcHVyZ2VXYWxsQ2VudGVyID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfZ2V0U2VsZWN0ZWRNYXRlcmlhbHMocGF5bG9hZCkge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgc3Bvb2xNYXRlcmlhbHMsXHJcbiAgICAgICAgICAgIHN1cHBvcnRlZE1hdGVyaWFsc0J5RXh0cnVkZXIsXHJcbiAgICAgICAgICAgIGV4dHJ1ZGVycyxcclxuICAgICAgICAgICAgcHJpbnRlcklzQ29ubmVjdGVkLFxyXG4gICAgICAgICAgICBwcmludE1vZGUsXHJcbiAgICAgICAgICAgIGlzU2tldGNoUHJpbnRlcixcclxuICAgICAgICAgICAgaXNGaWZ0aEdlbixcclxuICAgICAgICB9ID0gcGF5bG9hZDtcclxuICAgICAgICBsZXQgc2VsZWN0ZWRNYXRlcmlhbHMgPSBwYXlsb2FkLnNlbGVjdGVkTWF0ZXJpYWxzO1xyXG4gICAgICAgIGNvbnN0IGhhc0xhYnNFeHRydWRlciA9IGV4dHJ1ZGVyc1swXSA9PT0gRXh0cnVkZXJUeXBlRW51bS5tazE0X2U7XHJcblxyXG4gICAgICAgIGlmIChwcmludGVySXNDb25uZWN0ZWQgJiYgIWlzRmlmdGhHZW4gJiYgc3Bvb2xNYXRlcmlhbHMgIT09IG51bGwgJiYgIWhhc0xhYnNFeHRydWRlcikge1xyXG4gICAgICAgICAgICAvLyBMaXZlIGJvdCB3aXRoIHNtYXJ0IHNwb29sIGNhcGFiaWxpdGllcyAoc28sIGxpdmUgNnRoIGdlbiBib3RzKVxyXG4gICAgICAgICAgICAvLyBidXQgd2l0aG91dCBhIExBQlMgRXh0cnVkZXIuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaW5jbHVkZXMgNnRoIGdlbiBib3RzIHdpdGggZW1wdHkgc3Bvb2wgYmF5cy5cclxuICAgICAgICAgICAgLy8geG94byBMZW9yXHJcbiAgICAgICAgICAgIHNwb29sTWF0ZXJpYWxzLmZvckVhY2goKG1hdGVyaWFsLCBiYXlJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGVyaWFsICYmIHNlbGVjdGVkTWF0ZXJpYWxzW2JheUluZGV4XSAhPT0gbWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE1hdGVyaWFsc1tiYXlJbmRleF0gPSBtYXRlcmlhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQW55IGFyY2hldHlwZSBib3QsIG9yIGEgbGl2ZSBib3Qgd2l0aG91dCBzbWFydCBzcG9vbCBjYXBhYmlsaXRpZXNcclxuICAgICAgICAgICAgLy8gKHNvLCBhbGwgNXRoIGdlbnMpLCBvciBhbnkgNnRoIGdlbiB3aXRoIGFuIGV4cGVyaW1lbnRhbCBMQUJTIGV4dHJ1ZGVyXHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZE1hdGVyaWFsQ2hhbmdlID1cclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkTWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRNYXRlcmlhbHNbMF0gPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgIXN1cHBvcnRlZE1hdGVyaWFsc0J5RXh0cnVkZXJbMF0uaW5jbHVkZXMoc2VsZWN0ZWRNYXRlcmlhbHNbMF0gfHwgaGFzTGFic0V4dHJ1ZGVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzaG91bGRNYXRlcmlhbENoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dHJ1ZGVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRNYXRlcmlhbHNbMF0gPSBzdXBwb3J0ZWRNYXRlcmlhbHNCeUV4dHJ1ZGVyWzBdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTWF0ZXJpYWxzWzFdID0gc3VwcG9ydGVkTWF0ZXJpYWxzQnlFeHRydWRlclsxXVswXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTa2V0Y2hQcmludGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBbIFBMQSBdXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRNYXRlcmlhbHNbMF0gPSBzdXBwb3J0ZWRNYXRlcmlhbHNCeUV4dHJ1ZGVyWzBdWzFdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE1hdGVyaWFscyA9IHN1cHBvcnRlZE1hdGVyaWFsc0J5RXh0cnVkZXJbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkTWF0ZXJpYWxzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXREZWZhdWx0TWF0ZXJpYWxzKHN1cHBvcnRlZENvbmZpZ3VyYXRpb25zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gcmV0dXJucyBuZXN0ZWQgYXJyYXkgb2YgbWF0ZXJpYWxzIHBlciBleHRydWRlciBieSB3YXlcclxuICAgICAgICAvLyBvZiBzbGljZSBjb25maWcncyBzdXBwb3J0ZWRDb25maWd1cmF0aW9ucycgZS5nLiBbWydhYnMnXSxbJ3NyMzAnXV1cclxuICAgICAgICBjb25zdCB7IHByaW50ZXIsIHByaW50TW9kZSwgZXh0cnVkZXJzIH0gPSBvcHRpb25zO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydGVkQ29uZmlndXJhdGlvbnNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoY29uZmlnID0+IGNvbmZpZy5tYWNoaW5lX2lkID09PSBwcmludGVyLmdldEdlbmRlcigpLmJvdFR5cGUpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGNvbmZpZyA9PiAocHJpbnRNb2RlID8gY29uZmlnLnByaW50X21vZGUgPT09IHByaW50TW9kZSA6IHRydWUpKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihjb25maWcgPT4gXy5pc0VxdWFsKGNvbmZpZy5leHRydWRlcl9pZHMsIGV4dHJ1ZGVycykpXHJcbiAgICAgICAgICAgICAgICAubWFwKGNvbmZpZyA9PiBjb25maWcubWF0ZXJpYWxfaWRzKVxyXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjQXJyLCBtYXRlcmlhbHMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbHMubWFwKChtYXRlcmlhbCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIWFjY0FycltpbmRleF0gPyAoYWNjQXJyW2luZGV4XSA9IFttYXRlcmlhbF0pIDogYWNjQXJyW2luZGV4XS5wdXNoKG1hdGVyaWFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjQXJyO1xyXG4gICAgICAgICAgICAgICAgfSwgW10pXHJcbiAgICAgICAgICAgICAgICAubWFwKGJheU1hdGVyaWFscyA9PiBfLnVuaXEoYmF5TWF0ZXJpYWxzKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdlbmVyYXRlU3VwcG9ydGVkRXh0cnVkZXJzSW5mbyhwYXlsb2FkKSB7XHJcbiAgICAgICAgY29uc3QgeyBwcmludGVyLCBzdXBwb3J0ZWRDb25maWd1cmF0aW9ucyB9ID0gcGF5bG9hZDtcclxuICAgICAgICBjb25zdCB7IGJvdFR5cGUgfSA9IHByaW50ZXIuZ2V0R2VuZGVyKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkUmVzdWx0cyA9IHN1cHBvcnRlZENvbmZpZ3VyYXRpb25zXHJcbiAgICAgICAgICAgIC5maWx0ZXIoY29uZmlnID0+IGNvbmZpZy5tYWNoaW5lX2lkID09PSBib3RUeXBlKVxyXG4gICAgICAgICAgICAvLyBEb24ndCB3YW50IHRvIGZpbHRlciBieSBwcmludE1vZGUgb3IgZWxzZSB3ZSdsbCBsaW1pdFxyXG4gICAgICAgICAgICAvLyB0aGUgZXh0cnVkZXJzIGxpc3RzLiBFeHRydWRlciBkcm9wZG93biBzaG91bGQgZGljdGF0ZVxyXG4gICAgICAgICAgICAvLyBzdXBwb3J0ZWQgcHJpbnQgbW9kZXMuLi5cclxuICAgICAgICAgICAgLm1hcChjb25maWcgPT4gY29uZmlnLmV4dHJ1ZGVyX2lkcyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEV4dHJ1ZGVyUGFpckNvbmZpZ3MgPSBmaWx0ZXJlZFJlc3VsdHMucmVkdWNlKChhY2NBcnIsIGV4dHJ1ZGVySWRzKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGlmIFttazE0LCBtazE0X3NdIG5vdCBjb250YWluIGluIFtbbWsxNF9ob3QsIG1rMTRfaG90c10sIFsuLi5dXVxyXG4gICAgICAgICAgICAhUi5jb250YWlucyhleHRydWRlcklkcywgYWNjQXJyKSAvLyBVcGRhdGUgUi5jb250YWlucyAoRGVwcmVjYXRlZCkgdG8gUi5pbmNsdWRlc1xyXG4gICAgICAgICAgICAgICAgPyBhY2NBcnIucHVzaChleHRydWRlcklkcylcclxuICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY0FycjtcclxuICAgICAgICB9LCBbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEV4dHJ1ZGVyc1BlckluZGV4ID0gZmlsdGVyZWRSZXN1bHRzLnJlZHVjZSgoYWNjQXJyLCBleHRydWRlcklkcykgPT4ge1xyXG4gICAgICAgICAgICBleHRydWRlcklkcy5tYXAoKGV4dHJ1ZGVySWQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZS4gaWYgYWNjQXJyID09IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cclxuICAgICAgICAgICAgICAgIGlmICghYWNjQXJyW2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjY0FycltpbmRleF0gPSBbZXh0cnVkZXJJZF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGllLiBpZiBtazEzX2ltcGxhIG5vdCBpbiBbW21rMTIsIG1rMTMsIC4uLl1dXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIFIuY29udGFpbnMgKERlcHJlY2F0ZWQpIHRvIFIuaW5jbHVkZXNcclxuICAgICAgICAgICAgICAgICAgICAvLyB3LyBSYW1kYSBeMC4yNlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghUi5jb250YWlucyhleHRydWRlcklkLCBhY2NBcnJbaW5kZXhdKSAmJiBleHRydWRlcklkICE9PSBFeHRydWRlclR5cGVFbnVtLm1rMTNfZXhwZXJpbWVudGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY0FycltpbmRleF0ucHVzaChleHRydWRlcklkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjQXJyO1xyXG4gICAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgc3VwcG9ydGVkRXh0cnVkZXJQYWlyQ29uZmlncywgc3VwcG9ydGVkRXh0cnVkZXJzUGVySW5kZXggfTtcclxuICAgIH0sXHJcblxyXG4gICAgX2dldFN1cHBvcnRlZE1hdGVyaWFsc0J5RXh0cnVkZXIoZXh0cnVkZXJzLCBwcmludGVyKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEJvdFR5cGUgPSBwcmludGVyLmdldEdlbmRlcigpLmJvdFR5cGU7XHJcbiAgICAgICAgLy9tYXRlcmlhbHMgc3VwcG9ydGVkIGJ5IGVhY2ggZXh0cnVkZXIgb24gdGhlIGJvdFxyXG4gICAgICAgIGNvbnN0IG1hdGVyaWFscyA9IGV4dHJ1ZGVycy5tYXAoKGV4dHJ1ZGVyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydGVkQ29uZmlndXJhdGlvbnMucmVkdWNlKGZ1bmN0aW9uKG1hdGVyaWFsc0ZvclRoaXNFeHRydWRlciwgY29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLm1hY2hpbmVfaWQgPT09IGN1cnJlbnRCb3RUeXBlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgXy5pc0VxdWFsKGNvbmZpZy5leHRydWRlcl9pZHMsIGV4dHJ1ZGVycykgJiZcclxuICAgICAgICAgICAgICAgICAgICAhbWF0ZXJpYWxzRm9yVGhpc0V4dHJ1ZGVyLmluY2x1ZGVzKGNvbmZpZy5tYXRlcmlhbF9pZHNbaW5kZXhdKVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxzRm9yVGhpc0V4dHJ1ZGVyLnB1c2goY29uZmlnLm1hdGVyaWFsX2lkc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGVyaWFsc0ZvclRoaXNFeHRydWRlcjtcclxuICAgICAgICAgICAgfSwgW10pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtYXRlcmlhbHM7XHJcbiAgICB9LFxyXG5cclxuICAgIF9zYXZlUHJlc2V0cygpIHtcclxuICAgICAgICBwcmludFN0b3JlVXRpbHMuc2F2ZVRvVXNlckNvbmZpZygncHJlc2V0cycsIHByZXNldHMsIHRoaXMuZmx1eCk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9nZXREZWZhdWx0TWF0ZXJpYWxzQmFzZWRPbkV4dHJ1ZGVycygpIHtcclxuICAgICAgICBjb25zdCBlbnVtRXh0cnVkZXJUb0RlZmF1bHRNYXRlcmlhbHMgPSB7IC4uLkV4dHJ1ZGVyVG9EZWZhdWx0TWF0ZXJpYWwgfTtcclxuICAgICAgICBjb25zdCBwcmludGVyID0gdGhpcy5mbHV4LnN0b3JlKCdQcmludGVyU3RvcmUnKS5nZXRTZWxlY3RlZFByaW50ZXIoKTtcclxuICAgICAgICBjb25zdCBleHRydWRlcnMgPSBwcmludGVyICYmIHByaW50ZXIuZ2V0QXR0YWNoZWRFeHRydWRlcnMoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGV4dHJ1ZGVycy5tYXAoZXh0cnVkZXIgPT4gZW51bUV4dHJ1ZGVyVG9EZWZhdWx0TWF0ZXJpYWxzW2V4dHJ1ZGVyXSk7XHJcbiAgICB9LFxyXG59KTtcclxuIl19
