'use strict';

const R = require('ramda');

const reducers = require('./reducers');

const format = require('./format');

const removeAllSettings = flux => {
  const ConfigService = flux.getService('ConfigService');
  const newVisibleSettings = reducers.visibleSettings();
  ConfigService.delete('activeAdvSettings');
  return newVisibleSettings;
};

const resetAllToDefault = (flux, values) => {
  const ConfigService = flux.getService('ConfigService');
  R.mapObjIndexed((v, k) => updateProjectStoreProp(k, undefined, false, flux), values);
  const newValues = {};
  const newCurrentPreset = null;
  ConfigService.delete('printSettings');
  clearBuilds(flux);
  return {
    values: newValues,
    currentPreset: newCurrentPreset
  };
};
/**
 * Invalidates any existing slice. When changing settings, this happens
 * automatically, but apparently when removing them, it doesn't... no idea
 * why... but yeah, this fixes that problem
 */


const clearBuilds = flux => {
  const buildStore = flux.store('BuildStore');
  buildStore.onClearBuilds();
};
/**
 * TODO: Potential for refactor, maybe not manage 3 independently...
 *
 * Saves values across 3 objects that need to be in sync:
 * (1) tray.bodyProperties through Project Store - necessary for slicing
 * (2) values object from current store - representation of overrides
 * (3) user_config.json - app-wide saved settings under `printSettings`
 * @param {string} setting - setting key
 * @param {string} value - value to persist on key
 * @private
 */


const persistValues = (setting, value, skipUndoStack = false, values, flux) => {
  // Save to tray.bodyProperties for slicing
  updateProjectStoreProp(setting, value, skipUndoStack, flux);
  let newValues;
  if (value != null) newValues = R.assoc(setting, value, values);else newValues = R.dissoc(setting, values); // Save to user_config as APP-WIDE settings.

  saveToUserConfig('printSettings', newValues, flux);
  return newValues;
}; // Save to user_config as app settings.


const saveToUserConfig = (key, settings, flux) => {
  const ConfigService = flux.getService('ConfigService');
  ConfigService.set(key, settings);
}; // For setting props directly through project store


const updateProjectStoreProp = (pathKey, value, skipUndoStack = false, flux) => {
  // NOTE:  this will change as right now with per model settings.
  // currently, this APPLIES SETTINGS TO ALL MODEL OCCURRENCES
  const selections = flux.store('ProjectStore').getProject().getCurrentState().getOccurrences().toArray().map(occ => occ.getId());
  /* do not update project store if there's nothing to update.
   * It just unnecessarily makes the project dirty.
   */

  if (selections.length) {
    flux.store('ProjectStore').onUpdateProperty({
      path: format.path(pathKey),
      value,
      selections,
      skipUndoStack
    });
  }
};

const filterIncompatibleOverrides = (values, botType) => {
  const botSpecificSettings = {
    doPurgeWall: ['lava_f', 'fire_e'],
    chamberTemp: ['lava_f', 'fire_e', 'z18_6']
  };
  const filteredValues = {};
  Object.keys(values).map(value => {
    if (!Object.keys(botSpecificSettings).includes(value) || botSpecificSettings[value].includes(botType)) {
      filteredValues[value] = values[value];
    }
  });
  return filteredValues;
};

module.exports = {
  removeAllSettings,
  resetAllToDefault,
  clearBuilds,
  persistValues,
  saveToUserConfig,
  updateProjectStoreProp,
  filterIncompatibleOverrides
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByaW50U2V0dGluZ3NTdG9yZVV0aWxzLmpzIl0sIm5hbWVzIjpbIlIiLCJyZXF1aXJlIiwicmVkdWNlcnMiLCJmb3JtYXQiLCJyZW1vdmVBbGxTZXR0aW5ncyIsImZsdXgiLCJDb25maWdTZXJ2aWNlIiwiZ2V0U2VydmljZSIsIm5ld1Zpc2libGVTZXR0aW5ncyIsInZpc2libGVTZXR0aW5ncyIsImRlbGV0ZSIsInJlc2V0QWxsVG9EZWZhdWx0IiwidmFsdWVzIiwibWFwT2JqSW5kZXhlZCIsInYiLCJrIiwidXBkYXRlUHJvamVjdFN0b3JlUHJvcCIsInVuZGVmaW5lZCIsIm5ld1ZhbHVlcyIsIm5ld0N1cnJlbnRQcmVzZXQiLCJjbGVhckJ1aWxkcyIsImN1cnJlbnRQcmVzZXQiLCJidWlsZFN0b3JlIiwic3RvcmUiLCJvbkNsZWFyQnVpbGRzIiwicGVyc2lzdFZhbHVlcyIsInNldHRpbmciLCJ2YWx1ZSIsInNraXBVbmRvU3RhY2siLCJhc3NvYyIsImRpc3NvYyIsInNhdmVUb1VzZXJDb25maWciLCJrZXkiLCJzZXR0aW5ncyIsInNldCIsInBhdGhLZXkiLCJzZWxlY3Rpb25zIiwiZ2V0UHJvamVjdCIsImdldEN1cnJlbnRTdGF0ZSIsImdldE9jY3VycmVuY2VzIiwidG9BcnJheSIsIm1hcCIsIm9jYyIsImdldElkIiwibGVuZ3RoIiwib25VcGRhdGVQcm9wZXJ0eSIsInBhdGgiLCJmaWx0ZXJJbmNvbXBhdGlibGVPdmVycmlkZXMiLCJib3RUeXBlIiwiYm90U3BlY2lmaWNTZXR0aW5ncyIsImRvUHVyZ2VXYWxsIiwiY2hhbWJlclRlbXAiLCJmaWx0ZXJlZFZhbHVlcyIsIk9iamVjdCIsImtleXMiLCJpbmNsdWRlcyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLE1BQU1BLENBQUMsR0FBR0MsT0FBTyxDQUFDLE9BQUQsQ0FBakI7O0FBRUEsTUFBTUMsUUFBUSxHQUFHRCxPQUFPLENBQUMsWUFBRCxDQUF4Qjs7QUFDQSxN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QUFHYlMsRUFBQUEsV0FIYTtBQUliSyxFQUFBQSxhQUphO0FBS2JNLEVBQUFBLGdCQUxhO0FBTWJmLEVBQUFBLHNCQU5hO0FBT2IrQixFQUFBQTtBQVBhLENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgUiA9IHJlcXVpcmUoJ3JhbWRhJyk7XHJcblxyXG5jb25zdCByZWR1Y2VycyA9IHJlcXVpcmUoJy4vcmVkdWNlcnMnKTtcclxuY29uc3QgZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcclxuXHJcbmNvbnN0IHJlbW92ZUFsbFNldHRpbmdzID0gZmx1eCA9PiB7XHJcbiAgICBjb25zdCBDb25maWdTZXJ2aWNlID0gZmx1eC5nZXRTZXJ2aWNlKCdDb25maWdTZXJ2aWNlJyk7XHJcbiAgICBjb25zdCBuZXdWaXNpYmxlU2V0dGluZ3MgPSByZWR1Y2Vycy52aXNpYmxlU2V0dGluZ3MoKTtcclxuXHJcbiAgICBDb25maWdTZXJ2aWNlLmRlbGV0ZSgnYWN0aXZlQWR2U2V0dGluZ3MnKTtcclxuXHJcbiAgICByZXR1cm4gbmV3VmlzaWJsZVNldHRpbmdzO1xyXG59O1xyXG5cclxuY29uc3QgcmVzZXRBbGxUb0RlZmF1bHQgPSAoZmx1eCwgdmFsdWVzKSA9PiB7XHJcbiAgICBjb25zdCBDb25maWdTZXJ2aWNlID0gZmx1eC5nZXRTZXJ2aWNlKCdDb25maWdTZXJ2aWNlJyk7XHJcblxyXG4gICAgUi5tYXBPYmpJbmRleGVkKCh2LCBrKSA9PiB1cGRhdGVQcm9qZWN0U3RvcmVQcm9wKGssIHVuZGVmaW5lZCwgZmFsc2UsIGZsdXgpLCB2YWx1ZXMpO1xyXG5cclxuICAgIGNvbnN0IG5ld1ZhbHVlcyA9IHt9O1xyXG4gICAgY29uc3QgbmV3Q3VycmVudFByZXNldCA9IG51bGw7XHJcblxyXG4gICAgQ29uZmlnU2VydmljZS5kZWxldGUoJ3ByaW50U2V0dGluZ3MnKTtcclxuXHJcbiAgICBjbGVhckJ1aWxkcyhmbHV4KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlczogbmV3VmFsdWVzLFxyXG4gICAgICAgIGN1cnJlbnRQcmVzZXQ6IG5ld0N1cnJlbnRQcmVzZXQsXHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludmFsaWRhdGVzIGFueSBleGlzdGluZyBzbGljZS4gV2hlbiBjaGFuZ2luZyBzZXR0aW5ncywgdGhpcyBoYXBwZW5zXHJcbiAqIGF1dG9tYXRpY2FsbHksIGJ1dCBhcHBhcmVudGx5IHdoZW4gcmVtb3ZpbmcgdGhlbSwgaXQgZG9lc24ndC4uLiBubyBpZGVhXHJcbiAqIHdoeS4uLiBidXQgeWVhaCwgdGhpcyBmaXhlcyB0aGF0IHByb2JsZW1cclxuICovXHJcbmNvbnN0IGNsZWFyQnVpbGRzID0gZmx1eCA9PiB7XHJcbiAgICBjb25zdCBidWlsZFN0b3JlID0gZmx1eC5zdG9yZSgnQnVpbGRTdG9yZScpO1xyXG4gICAgYnVpbGRTdG9yZS5vbkNsZWFyQnVpbGRzKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogVE9ETzogUG90ZW50aWFsIGZvciByZWZhY3RvciwgbWF5YmUgbm90IG1hbmFnZSAzIGluZGVwZW5kZW50bHkuLi5cclxuICpcclxuICogU2F2ZXMgdmFsdWVzIGFjcm9zcyAzIG9iamVjdHMgdGhhdCBuZWVkIHRvIGJlIGluIHN5bmM6XHJcbiAqICgxKSB0cmF5LmJvZHlQcm9wZXJ0aWVzIHRocm91Z2ggUHJvamVjdCBTdG9yZSAtIG5lY2Vzc2FyeSBmb3Igc2xpY2luZ1xyXG4gKiAoMikgdmFsdWVzIG9iamVjdCBmcm9tIGN1cnJlbnQgc3RvcmUgLSByZXByZXNlbnRhdGlvbiBvZiBvdmVycmlkZXNcclxuICogKDMpIHVzZXJfY29uZmlnLmpzb24gLSBhcHAtd2lkZSBzYXZlZCBzZXR0aW5ncyB1bmRlciBgcHJpbnRTZXR0aW5nc2BcclxuICogQHBhcmFtIHtzdHJpbmd9IHNldHRpbmcgLSBzZXR0aW5nIGtleVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB2YWx1ZSB0byBwZXJzaXN0IG9uIGtleVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgcGVyc2lzdFZhbHVlcyA9IChzZXR0aW5nLCB2YWx1ZSwgc2tpcFVuZG9TdGFjayA9IGZhbHNlLCB2YWx1ZXMsIGZsdXgpID0+IHtcclxuICAgIC8vIFNhdmUgdG8gdHJheS5ib2R5UHJvcGVydGllcyBmb3Igc2xpY2luZ1xyXG4gICAgdXBkYXRlUHJvamVjdFN0b3JlUHJvcChzZXR0aW5nLCB2YWx1ZSwgc2tpcFVuZG9TdGFjaywgZmx1eCk7XHJcblxyXG4gICAgbGV0IG5ld1ZhbHVlcztcclxuXHJcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgbmV3VmFsdWVzID0gUi5hc3NvYyhzZXR0aW5nLCB2YWx1ZSwgdmFsdWVzKTtcclxuICAgIGVsc2UgbmV3VmFsdWVzID0gUi5kaXNzb2Moc2V0dGluZywgdmFsdWVzKTtcclxuXHJcbiAgICAvLyBTYXZlIHRvIHVzZXJfY29uZmlnIGFzIEFQUC1XSURFIHNldHRpbmdzLlxyXG4gICAgc2F2ZVRvVXNlckNvbmZpZygncHJpbnRTZXR0aW5ncycsIG5ld1ZhbHVlcywgZmx1eCk7XHJcblxyXG4gICAgcmV0dXJuIG5ld1ZhbHVlcztcclxufTtcclxuXHJcbi8vIFNhdmUgdG8gdXNlcl9jb25maWcgYXMgYXBwIHNldHRpbmdzLlxyXG5jb25zdCBzYXZlVG9Vc2VyQ29uZmlnID0gKGtleSwgc2V0dGluZ3MsIGZsdXgpID0+IHtcclxuICAgIGNvbnN0IENvbmZpZ1NlcnZpY2UgPSBmbHV4LmdldFNlcnZpY2UoJ0NvbmZpZ1NlcnZpY2UnKTtcclxuICAgIENvbmZpZ1NlcnZpY2Uuc2V0KGtleSwgc2V0dGluZ3MpO1xyXG59O1xyXG5cclxuLy8gRm9yIHNldHRpbmcgcHJvcHMgZGlyZWN0bHkgdGhyb3VnaCBwcm9qZWN0IHN0b3JlXHJcbmNvbnN0IHVwZGF0ZVByb2plY3RTdG9yZVByb3AgPSAocGF0aEtleSwgdmFsdWUsIHNraXBVbmRvU3RhY2sgPSBmYWxzZSwgZmx1eCkgPT4ge1xyXG4gICAgLy8gTk9URTogIHRoaXMgd2lsbCBjaGFuZ2UgYXMgcmlnaHQgbm93IHdpdGggcGVyIG1vZGVsIHNldHRpbmdzLlxyXG4gICAgLy8gY3VycmVudGx5LCB0aGlzIEFQUExJRVMgU0VUVElOR1MgVE8gQUxMIE1PREVMIE9DQ1VSUkVOQ0VTXHJcbiAgICBjb25zdCBzZWxlY3Rpb25zID0gZmx1eFxyXG4gICAgICAgIC5zdG9yZSgnUHJvamVjdFN0b3JlJylcclxuICAgICAgICAuZ2V0UHJvamVjdCgpXHJcbiAgICAgICAgLmdldEN1cnJlbnRTdGF0ZSgpXHJcbiAgICAgICAgLmdldE9jY3VycmVuY2VzKClcclxuICAgICAgICAudG9BcnJheSgpXHJcbiAgICAgICAgLm1hcChvY2MgPT4gb2NjLmdldElkKCkpO1xyXG5cclxuICAgIC8qIGRvIG5vdCB1cGRhdGUgcHJvamVjdCBzdG9yZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gdXBkYXRlLlxyXG4gICAgICogSXQganVzdCB1bm5lY2Vzc2FyaWx5IG1ha2VzIHRoZSBwcm9qZWN0IGRpcnR5LlxyXG4gICAgICovXHJcbiAgICBpZiAoc2VsZWN0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICBmbHV4LnN0b3JlKCdQcm9qZWN0U3RvcmUnKS5vblVwZGF0ZVByb3BlcnR5KHtcclxuICAgICAgICAgICAgcGF0aDogZm9ybWF0LnBhdGgocGF0aEtleSksXHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICBzZWxlY3Rpb25zLFxyXG4gICAgICAgICAgICBza2lwVW5kb1N0YWNrLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuY29uc3QgZmlsdGVySW5jb21wYXRpYmxlT3ZlcnJpZGVzID0gKHZhbHVlcywgYm90VHlwZSkgPT4ge1xyXG4gICAgY29uc3QgYm90U3BlY2lmaWNTZXR0aW5ncyA9IHtcclxuICAgICAgICBkb1B1cmdlV2FsbDogWydsYXZhX2YnLCAnZmlyZV9lJ10sXHJcbiAgICAgICAgY2hhbWJlclRlbXA6IFsnbGF2YV9mJywgJ2ZpcmVfZScsICd6MThfNiddLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBmaWx0ZXJlZFZhbHVlcyA9IHt9O1xyXG5cclxuICAgIE9iamVjdC5rZXlzKHZhbHVlcykubWFwKHZhbHVlID0+IHtcclxuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGJvdFNwZWNpZmljU2V0dGluZ3MpLmluY2x1ZGVzKHZhbHVlKSB8fCBib3RTcGVjaWZpY1NldHRpbmdzW3ZhbHVlXS5pbmNsdWRlcyhib3RUeXBlKSkge1xyXG4gICAgICAgICAgICBmaWx0ZXJlZFZhbHVlc1t2YWx1ZV0gPSB2YWx1ZXNbdmFsdWVdO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBmaWx0ZXJlZFZhbHVlcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgcmVtb3ZlQWxsU2V0dGluZ3MsXHJcbiAgICByZXNldEFsbFRvRGVmYXVsdCxcclxuICAgIGNsZWFyQnVpbGRzLFxyXG4gICAgcGVyc2lzdFZhbHVlcyxcclxuICAgIHNhdmVUb1VzZXJDb25maWcsXHJcbiAgICB1cGRhdGVQcm9qZWN0U3RvcmVQcm9wLFxyXG4gICAgZmlsdGVySW5jb21wYXRpYmxlT3ZlcnJpZGVzLFxyXG59O1xyXG4iXX0=
