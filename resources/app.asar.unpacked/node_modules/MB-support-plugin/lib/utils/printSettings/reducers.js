"use strict";

const R = require('ramda');

const {
  roundPrec,
  escapeRegExp
} = require('../../util');

const {
  path
} = require('./format');

const L = require('./lenses');

const {
  SettingsKeys,
  EESettingsKeys,
  PresetKeyBlacklist
} = require('../../constants/print_settings'); // getGrouping :: String -> {k: v} -> [k]


const getGrouping = R.uncurryN(2, k => R.pipe(R.pickBy(R.contains(k)), R.keys)); // getOptions :: String -> {k: v} -> (Num -> Num -> Num -> [Num])

const getOptions = (k, options, setting) => {
  return R.propOr(() => R.propOr([], 'validStrings', setting), k, options);
};
/**
 * This formats a schema to add extra properties to make using the values
 * easier to use in the UI. It adds whether an element is visible, what its value is,
 * and what group it belongs to.
 * It's written out like this to make the formatting easier to test.
 *
 * @param {object<string, any>} settings - all of the settings that came from Slice Config.
 * @param {object<string, boolean>} visible - which keys in `settings` should be considered visible.
 * @param {object<string, any>} vals - the value of each item in `settings`.
 * @param {object<string, string[]>} grouping - a dictionary of the grouping for each item
 * @param {PrintSettingsConstants.Options} options - a dictionary for converting ranges to lists for dropdowns
 * @param {PrintSettingsConstants.Format} formatting - a dictionary for formatting values of settings
 * @param {PrintSettingsConstants.Sanitization} sanitization - a dictionary for validation of settings
 * @param {PrintSettingsConstants.SettingsTypes} typeOverrides - a dictionary for overriding setting type
 *
 * @returns {object<string, any>}
 */


const state = (settings, visible, vals, grouping, options, formatting, sanitization, typeOverrides) => {
  return R.mapObjIndexed((v, k) => R.merge(v, {
    path: path(k),
    visible: R.propOr(false, k, visible),
    value: R.propOr(v.initial_value, k, vals),
    groups: getGrouping(k, grouping),
    options: getOptions(k, options, v)(v.min, v.max + v.step, v.step),
    format: R.propOr(() => R.identity, k, formatting),
    sanitize: R.propOr(R.identity, k, sanitization),
    type: R.propOr(v.type, k, typeOverrides)
  }), settings);
};
/**
 * This function was made in frustration. There are a few settings from slice config whose default settings
 * (initial_value) don't match what Product wants them to be, and apparently that's the UI's problem.
 * So, instead of trying to get clever, I said "screw it" and just overrode them, since they're always
 * the same and never change.
 * @param {object} settings - the settings as they came in from slice config
 * @returns {object} - New and improved with defaults that match Product's specs
 */


const initialValueOverrides = R.over(R.compose(L.layerHeight, L.initialValue), roundPrec(1));
/**
 * Parses the available settings coming from `schema`. Most of it is just a pretty straight forward
 * list concatenation.
 * Note that extruders and print modes come in from the schema seperately from these settings.
 * @param {object} schema - the schema that comes back from the printer
 * @returns {object} - the schema parsed into the proper format for availableSettings
 */

const availableSettings = settings => {
  const s = R.omit(['basic_parameters', 'custom_parameters'], settings);
  if (R.keys(s).length === 0) return {};
  return R.pipe(initialValueOverrides)(s);
};
/**
 * Overall this a pretty mundane function, but we needed to handle some
 * special cases regarding what settings can and cannot be made visible
 * @returns {object<string, bool>} - a map of visible settings
 */


const visibleSettings = () => ({
  // Supports are a special case since it's the only advanced setting
  // that always appears in the panel by default
  [SettingsKeys.Supports]: false
});

const cleanValues = (vals, visible) => R.pipe(R.pickBy((v, k) => R.propOr(false, k, visible) === true), R.assoc('applyToAll', true))(vals);
/**
 * A fairly straight-forward helper function to determine whether the current
 * value is valid. If so, use it, if not, use the default.
 * @param {any} currentVal - the current value
 * @param {any} defaultVal - the default value
 * @param {any[]} validList - the list of valid values
 * @returns {any} - either the current value or the default
 */


const normalizeValue = (currentVal, defaultVal, validList) => currentVal && R.contains(currentVal, validList) ? currentVal : defaultVal; // getPresetByName :: String -> [Preset] -> Preset


const getPresetByName = R.curry((name, presets) => R.pipe(R.filter(R.propEq('name', name)), R.head)(presets)); // removePresetByName :: String -> [Preset] -> Preset

const removePresetByName = R.curry((name, presets) => R.reject(R.propEq('name', name), presets)); // updatePresetByName :: String -> Preset -> [Preset] -> [Preset]

const updatePresetByName = R.curry((name, update, presets) => R.pipe(R.reject(R.propEq('name', name)), R.append(update))(presets)); // valuesToPreset :: String -> String -> {k: v} -> Preset

const valuesToPreset = R.curry((name, values) => {
  return {
    name,
    settings: R.omit(PresetKeyBlacklist, values)
  };
}); // make sure it has a version number
// presetToJSON :: String -> { k: v } -> { k: v }

const presetToJSON = R.curry((scVersion, preset) => R.merge({
  version: scVersion
}, preset)); // sanitizePreset :: Preset -> Preset

const sanitizePreset = R.curry((scVersion, preset, presets) => R.pipe(R.merge({
  version: scVersion
}), // make sure it has a version number, we may use this later
R.evolve({
  version: R.identity,
  settings: R.pipe(R.omit(PresetKeyBlacklist), R.pick(R.values(SettingsKeys))),
  name: incrementPresetName(presets)
}), R.pick(['name', 'settings']))(preset));
const incrementPresetName = R.curry((presets, search) => R.pipe(R.map(R.pipe(R.prop('name'), R.match(new RegExp(`${escapeRegExp(search)}(\\s\\((\\d+)\\))*$`)))), R.filter(R.length), // remove everything that didn't match
R.map(R.pipe(R.nth(2), // grab the number as a string out of the name
R.defaultTo('0'), // if there wasn't a number, make it '0'
parseInt)), R.reduce(R.max, -1), // Find the biggest number
n => n >= 0 ? `${search} (${n + 1})` : search)(presets));
const presetHasSettings = R.curry((keys, preset) => R.reduce((acc, k) => acc || R.has(k, preset.settings), false, keys));
const presetIsExperimental = presetHasSettings(EESettingsKeys);
module.exports = {
  state,
  availableSettings,
  visibleSettings,
  cleanValues,
  normalizeValue,
  initialValueOverrides,
  getGrouping,
  getOptions,
  getPresetByName,
  updatePresetByName,
  removePresetByName,
  valuesToPreset,
  presetToJSON,
  sanitizePreset,
  incrementPresetName,
  presetIsExperimental
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlZHVjZXJzLmpzIl0sIm5hbWVzIjpbIlIiLCJyZXF1aXJlIiwicm91bmRQcmVjIiwiZXNjYXBlUmVnRXhwIiwicGF0aCIsIkwiLCJTZXR0aW5nc0tleXMiLCJFRVNldHRpbmdzS2V5cyIsIlByZXNldEtleUJsYWNrbGlzdCIsImdldEdyb3VwaW5nIiwidW5jdXJyeU4iLCJrIiwicGlwZSIsInBpY2tCeSIsImNvbnRhaW5zIiwia2V5cyIsImdldE9wdGlvbnMiLCJvcHRpb25zIiwic2V0dGluZyIsInByb3BPciIsInN0YXRlIiwic2V0dGluZ3MiLCJ2aXNpYmxlIiwidmFscyIsImdyb3VwaW5nIiwiZm9ybWF0dGluZyIsInNhbml0aXphdGlvbiIsInR5cGVPdmVycmlkZXMiLCJtYXBPYmpJbmRleGVkIiwidiIsIm1lcmdlIiwidmFsdWUiLCJpbml0aWFsX3ZhbHVlIiwiZ3JvdXBzIiwibWluIiwibWF4Iiwic3RlcCIsImZvcm1hdCIsImlkZW50aXR5Iiwic2FuaXRpemUiLCJ0eXBlIiwiaW5pdGlhbFZhbHVlT3ZlcnJpZGVzIiwib3ZlciIsImNvbXBvc2UiLCJsYXllckhlaWdodCIsImluaXRpYWxWYWx1ZSIsImF2YWlsYWJsZVNldHRpbmdzIiwicyIsIm9taXQiLCJsZW5ndGgiLCJ2aXNpYmxlU2V0dGluZ3MiLCJTdXBwb3J0cyIsImNsZWFuVmFsdWVzIiwiYXNzb2MiLCJub3JtYWxpemVWYWx1ZSIsImN1cnJlbnRWYWwiLCJkZWZhdWx0VmFsIiwidmFsaWRMaXN0IiwiZ2V0UHJlc2V0QnlOYW1lIiwiY3VycnkiLCJuYW1lIiwicHJlc2V0cyIsImZpbHRlciIsInByb3BFcSIsImhlYWQiLCJyZW1vdmVQcmVzZXRCeU5hbWUiLCJyZWplY3QiLCJ1cGRhdGVQcmVzZXRCeU5hbWUiLCJ1cGRhdGUiLCJhcHBlbmQiLCJ2YWx1ZXNUb1ByZXNldCIsInZhbHVlcyIsInByZXNldFRvSlNPTiIsInNjVmVyc2lvbiIsInByZXNldCIsInZlcnNpb24iLCJzYW5pdGl6ZVByZXNldCIsImV2b2x2ZSIsInBpY2siLCJpbmNyZW1lbnRQcmVzZXROYW1lIiwic2VhcmNoIiwibWFwIiwicHJvcCIsIm1hdGNoIiwiUmVnRXhwIiwibnRoIiwiZGVmYXVsdFRvIiwicGFyc2VJbnQiLCJyZWR1Y2UiLCJuIiwicHJlc2V0SGFzU2V0dGluZ3MiLCJhY2MiLCJoYXMiLCJwcmVzZXRJc0V4cGVyaW1lbnRhbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTUEsQ0FBQyxHQUFHQyxPQUFPLENBQUMsT0FBRCxDQUFqQjs7QUFFQSxNQUFNO0FBQUVDLEVBQUFBLFNBQUY7QUFBYUMsRUFBQUE7QUFBYixJQUE4QkYsT0FBTyxDQUFDLFlBQUQsQ0FBM0M7O0FBQ0EsTUFBTTtBQUFFRyxFQUFBQTtBQUFGLElBQVdILE9BQU8sQ0FBQyxVQUFELENBQXhCOztBQUNBLE1BQU1JLENBQUMsR0FBR0osT0FBTyxDQUFDLFVBQUQsQ0FBakI7O0FBQ0EsTUFBTTtBQUFFSyxFQUFBQSxZQUFGO0FBQWdCQyxFQUFBQSxjQUFoQjtBQUFnQ0MsRUFBQUE7QUFBaEMsSUFBdURQLE9BQU8sQ0FBQyxnQ0FBRCxDQUFwRSxDLENBRUE7OztBQUNBLE1BQU1RLFdBQVcsR0FBR1QsQ0FBQyxDQUFDVSxRQUFGLENBQVcsQ0FBWCxFQUFjQyxDQUFDLElBQUlYLENBQUMsQ0FBQ1ksSUFBRixDQUFPWixDQUFDLENBQUNhLE1BQUYsQ0FBU2IsQ0FBQyxDQUFDYyxRQUFGLENBQVdILENBQVgsQ0FBVCxDQUFQLEVBQWdDWCxDQUFDLENBQUNlLElBQWxDLENBQW5CLENBQXBCLEMsQ0FFQTs7QUFDQSxNQUFNQyxVQUFVLEdBQUcsQ0FBQ0wsQ0FBRCxFQUFJTSxPQUFKLEVBQWFDLE9BQWIsS0FBeUI7QUFDeEMsU0FBT2xCLENBQUMsQ0FBQ21CLE1BQUYsQ0FBUyxNQUFNbkIsQ0FBQyxDQUFDbUIsTUFBRixDQUFTLEVBQVQsRUFBYSxjQUFiLEVBQTZCRCxPQUE3QixDQUFmLEVBQXNEUCxDQUF0RCxFQUF5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QixHQUFHMUYsQ0FBQyxDQUFDMkQsS0FBRixDQUFRLENBQUM1QyxJQUFELEVBQU8yRCxNQUFQLEtBQzlCMUUsQ0FBQyxDQUFDd0YsTUFBRixDQUFTLENBQUNHLEdBQUQsRUFBTWhGLENBQU4sS0FBWWdGLEdBQUcsSUFBSTNGLENBQUMsQ0FBQzRGLEdBQUYsQ0FBTWpGLENBQU4sRUFBUytELE1BQU0sQ0FBQ3JELFFBQWhCLENBQTVCLEVBQXVELEtBQXZELEVBQThETixJQUE5RCxDQURzQixDQUExQjtBQUlBLE1BQU04RSxvQkFBb0IsR0FBR0gsaUJBQWlCLENBQUNuRixjQUFELENBQTlDO0FBRUF1RixNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFDYjNFLEVBQUFBLEtBRGE7QUFFYjBCLEVBQUFBLGlCQUZhO0FBR2JJLEVBQUFBLGVBSGE7QUFJYkUsRUFBQUEsV0FKYTtBQUtiRSxFQUFBQSxjQUxhO0FBTWJiLEVBQUFBLHFCQU5hO0FBT2JoQyxFQUFBQSxXQVBhO0FBUWJPLEVBQUFBLFVBUmE7QUFTYjBDLEVBQUFBLGVBVGE7QUFVYlMsRUFBQUEsa0JBVmE7QUFXYkYsRUFBQUEsa0JBWGE7QUFZYkssRUFBQUEsY0FaYTtBQWFiRSxFQUFBQSxZQWJhO0FBY2JJLEVBQUFBLGNBZGE7QUFlYkcsRUFBQUEsbUJBZmE7QUFnQmJjLEVBQUFBO0FBaEJhLENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUiA9IHJlcXVpcmUoJ3JhbWRhJyk7XHJcblxyXG5jb25zdCB7IHJvdW5kUHJlYywgZXNjYXBlUmVnRXhwIH0gPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XHJcbmNvbnN0IHsgcGF0aCB9ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcclxuY29uc3QgTCA9IHJlcXVpcmUoJy4vbGVuc2VzJyk7XHJcbmNvbnN0IHsgU2V0dGluZ3NLZXlzLCBFRVNldHRpbmdzS2V5cywgUHJlc2V0S2V5QmxhY2tsaXN0IH0gPSByZXF1aXJlKCcuLi8uLi9jb25zdGFudHMvcHJpbnRfc2V0dGluZ3MnKTtcclxuXHJcbi8vIGdldEdyb3VwaW5nIDo6IFN0cmluZyAtPiB7azogdn0gLT4gW2tdXHJcbmNvbnN0IGdldEdyb3VwaW5nID0gUi51bmN1cnJ5TigyLCBrID0+IFIucGlwZShSLnBpY2tCeShSLmNvbnRhaW5zKGspKSwgUi5rZXlzKSk7XHJcblxyXG4vLyBnZXRPcHRpb25zIDo6IFN0cmluZyAtPiB7azogdn0gLT4gKE51bSAtPiBOdW0gLT4gTnVtIC0+IFtOdW1dKVxyXG5jb25zdCBnZXRPcHRpb25zID0gKGssIG9wdGlvbnMsIHNldHRpbmcpID0+IHtcclxuICAgIHJldHVybiBSLnByb3BPcigoKSA9PiBSLnByb3BPcihbXSwgJ3ZhbGlkU3RyaW5ncycsIHNldHRpbmcpLCBrLCBvcHRpb25zKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZvcm1hdHMgYSBzY2hlbWEgdG8gYWRkIGV4dHJhIHByb3BlcnRpZXMgdG8gbWFrZSB1c2luZyB0aGUgdmFsdWVzXHJcbiAqIGVhc2llciB0byB1c2UgaW4gdGhlIFVJLiBJdCBhZGRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyB2aXNpYmxlLCB3aGF0IGl0cyB2YWx1ZSBpcyxcclxuICogYW5kIHdoYXQgZ3JvdXAgaXQgYmVsb25ncyB0by5cclxuICogSXQncyB3cml0dGVuIG91dCBsaWtlIHRoaXMgdG8gbWFrZSB0aGUgZm9ybWF0dGluZyBlYXNpZXIgdG8gdGVzdC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3Q8c3RyaW5nLCBhbnk+fSBzZXR0aW5ncyAtIGFsbCBvZiB0aGUgc2V0dGluZ3MgdGhhdCBjYW1lIGZyb20gU2xpY2UgQ29uZmlnLlxyXG4gKiBAcGFyYW0ge29iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSB2aXNpYmxlIC0gd2hpY2gga2V5cyBpbiBgc2V0dGluZ3NgIHNob3VsZCBiZSBjb25zaWRlcmVkIHZpc2libGUuXHJcbiAqIEBwYXJhbSB7b2JqZWN0PHN0cmluZywgYW55Pn0gdmFscyAtIHRoZSB2YWx1ZSBvZiBlYWNoIGl0ZW0gaW4gYHNldHRpbmdzYC5cclxuICogQHBhcmFtIHtvYmplY3Q8c3RyaW5nLCBzdHJpbmdbXT59IGdyb3VwaW5nIC0gYSBkaWN0aW9uYXJ5IG9mIHRoZSBncm91cGluZyBmb3IgZWFjaCBpdGVtXHJcbiAqIEBwYXJhbSB7UHJpbnRTZXR0aW5nc0NvbnN0YW50cy5PcHRpb25zfSBvcHRpb25zIC0gYSBkaWN0aW9uYXJ5IGZvciBjb252ZXJ0aW5nIHJhbmdlcyB0byBsaXN0cyBmb3IgZHJvcGRvd25zXHJcbiAqIEBwYXJhbSB7UHJpbnRTZXR0aW5nc0NvbnN0YW50cy5Gb3JtYXR9IGZvcm1hdHRpbmcgLSBhIGRpY3Rpb25hcnkgZm9yIGZvcm1hdHRpbmcgdmFsdWVzIG9mIHNldHRpbmdzXHJcbiAqIEBwYXJhbSB7UHJpbnRTZXR0aW5nc0NvbnN0YW50cy5TYW5pdGl6YXRpb259IHNhbml0aXphdGlvbiAtIGEgZGljdGlvbmFyeSBmb3IgdmFsaWRhdGlvbiBvZiBzZXR0aW5nc1xyXG4gKiBAcGFyYW0ge1ByaW50U2V0dGluZ3NDb25zdGFudHMuU2V0dGluZ3NUeXBlc30gdHlwZU92ZXJyaWRlcyAtIGEgZGljdGlvbmFyeSBmb3Igb3ZlcnJpZGluZyBzZXR0aW5nIHR5cGVcclxuICpcclxuICogQHJldHVybnMge29iamVjdDxzdHJpbmcsIGFueT59XHJcbiAqL1xyXG5jb25zdCBzdGF0ZSA9IChzZXR0aW5ncywgdmlzaWJsZSwgdmFscywgZ3JvdXBpbmcsIG9wdGlvbnMsIGZvcm1hdHRpbmcsIHNhbml0aXphdGlvbiwgdHlwZU92ZXJyaWRlcykgPT4ge1xyXG4gICAgcmV0dXJuIFIubWFwT2JqSW5kZXhlZChcclxuICAgICAgICAodiwgaykgPT5cclxuICAgICAgICAgICAgUi5tZXJnZSh2LCB7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoKGspLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogUi5wcm9wT3IoZmFsc2UsIGssIHZpc2libGUpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFIucHJvcE9yKHYuaW5pdGlhbF92YWx1ZSwgaywgdmFscyksXHJcbiAgICAgICAgICAgICAgICBncm91cHM6IGdldEdyb3VwaW5nKGssIGdyb3VwaW5nKSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGdldE9wdGlvbnMoaywgb3B0aW9ucywgdikodi5taW4sIHYubWF4ICsgdi5zdGVwLCB2LnN0ZXApLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBSLnByb3BPcigoKSA9PiBSLmlkZW50aXR5LCBrLCBmb3JtYXR0aW5nKSxcclxuICAgICAgICAgICAgICAgIHNhbml0aXplOiBSLnByb3BPcihSLmlkZW50aXR5LCBrLCBzYW5pdGl6YXRpb24pLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogUi5wcm9wT3Iodi50eXBlLCBrLCB0eXBlT3ZlcnJpZGVzKSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgc2V0dGluZ3NcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiB3YXMgbWFkZSBpbiBmcnVzdHJhdGlvbi4gVGhlcmUgYXJlIGEgZmV3IHNldHRpbmdzIGZyb20gc2xpY2UgY29uZmlnIHdob3NlIGRlZmF1bHQgc2V0dGluZ3NcclxuICogKGluaXRpYWxfdmFsdWUpIGRvbid0IG1hdGNoIHdoYXQgUHJvZHVjdCB3YW50cyB0aGVtIHRvIGJlLCBhbmQgYXBwYXJlbnRseSB0aGF0J3MgdGhlIFVJJ3MgcHJvYmxlbS5cclxuICogU28sIGluc3RlYWQgb2YgdHJ5aW5nIHRvIGdldCBjbGV2ZXIsIEkgc2FpZCBcInNjcmV3IGl0XCIgYW5kIGp1c3Qgb3ZlcnJvZGUgdGhlbSwgc2luY2UgdGhleSdyZSBhbHdheXNcclxuICogdGhlIHNhbWUgYW5kIG5ldmVyIGNoYW5nZS5cclxuICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIC0gdGhlIHNldHRpbmdzIGFzIHRoZXkgY2FtZSBpbiBmcm9tIHNsaWNlIGNvbmZpZ1xyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIE5ldyBhbmQgaW1wcm92ZWQgd2l0aCBkZWZhdWx0cyB0aGF0IG1hdGNoIFByb2R1Y3QncyBzcGVjc1xyXG4gKi9cclxuY29uc3QgaW5pdGlhbFZhbHVlT3ZlcnJpZGVzID0gUi5vdmVyKFIuY29tcG9zZShMLmxheWVySGVpZ2h0LCBMLmluaXRpYWxWYWx1ZSksIHJvdW5kUHJlYygxKSk7XHJcblxyXG4vKipcclxuICogUGFyc2VzIHRoZSBhdmFpbGFibGUgc2V0dGluZ3MgY29taW5nIGZyb20gYHNjaGVtYWAuIE1vc3Qgb2YgaXQgaXMganVzdCBhIHByZXR0eSBzdHJhaWdodCBmb3J3YXJkXHJcbiAqIGxpc3QgY29uY2F0ZW5hdGlvbi5cclxuICogTm90ZSB0aGF0IGV4dHJ1ZGVycyBhbmQgcHJpbnQgbW9kZXMgY29tZSBpbiBmcm9tIHRoZSBzY2hlbWEgc2VwZXJhdGVseSBmcm9tIHRoZXNlIHNldHRpbmdzLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hIC0gdGhlIHNjaGVtYSB0aGF0IGNvbWVzIGJhY2sgZnJvbSB0aGUgcHJpbnRlclxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIHRoZSBzY2hlbWEgcGFyc2VkIGludG8gdGhlIHByb3BlciBmb3JtYXQgZm9yIGF2YWlsYWJsZVNldHRpbmdzXHJcbiAqL1xyXG5jb25zdCBhdmFpbGFibGVTZXR0aW5ncyA9IHNldHRpbmdzID0+IHtcclxuICAgIGNvbnN0IHMgPSBSLm9taXQoWydiYXNpY19wYXJhbWV0ZXJzJywgJ2N1c3RvbV9wYXJhbWV0ZXJzJ10sIHNldHRpbmdzKTtcclxuXHJcbiAgICBpZiAoUi5rZXlzKHMpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHt9O1xyXG5cclxuICAgIHJldHVybiBSLnBpcGUoaW5pdGlhbFZhbHVlT3ZlcnJpZGVzKShzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBPdmVyYWxsIHRoaXMgYSBwcmV0dHkgbXVuZGFuZSBmdW5jdGlvbiwgYnV0IHdlIG5lZWRlZCB0byBoYW5kbGUgc29tZVxyXG4gKiBzcGVjaWFsIGNhc2VzIHJlZ2FyZGluZyB3aGF0IHNldHRpbmdzIGNhbiBhbmQgY2Fubm90IGJlIG1hZGUgdmlzaWJsZVxyXG4gKiBAcmV0dXJucyB7b2JqZWN0PHN0cmluZywgYm9vbD59IC0gYSBtYXAgb2YgdmlzaWJsZSBzZXR0aW5nc1xyXG4gKi9cclxuY29uc3QgdmlzaWJsZVNldHRpbmdzID0gKCkgPT4gKHtcclxuICAgIC8vIFN1cHBvcnRzIGFyZSBhIHNwZWNpYWwgY2FzZSBzaW5jZSBpdCdzIHRoZSBvbmx5IGFkdmFuY2VkIHNldHRpbmdcclxuICAgIC8vIHRoYXQgYWx3YXlzIGFwcGVhcnMgaW4gdGhlIHBhbmVsIGJ5IGRlZmF1bHRcclxuICAgIFtTZXR0aW5nc0tleXMuU3VwcG9ydHNdOiBmYWxzZSxcclxufSk7XHJcblxyXG5jb25zdCBjbGVhblZhbHVlcyA9ICh2YWxzLCB2aXNpYmxlKSA9PlxyXG4gICAgUi5waXBlKFxyXG4gICAgICAgIFIucGlja0J5KCh2LCBrKSA9PiBSLnByb3BPcihmYWxzZSwgaywgdmlzaWJsZSkgPT09IHRydWUpLFxyXG4gICAgICAgIFIuYXNzb2MoJ2FwcGx5VG9BbGwnLCB0cnVlKVxyXG4gICAgKSh2YWxzKTtcclxuXHJcbi8qKlxyXG4gKiBBIGZhaXJseSBzdHJhaWdodC1mb3J3YXJkIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudFxyXG4gKiB2YWx1ZSBpcyB2YWxpZC4gSWYgc28sIHVzZSBpdCwgaWYgbm90LCB1c2UgdGhlIGRlZmF1bHQuXHJcbiAqIEBwYXJhbSB7YW55fSBjdXJyZW50VmFsIC0gdGhlIGN1cnJlbnQgdmFsdWVcclxuICogQHBhcmFtIHthbnl9IGRlZmF1bHRWYWwgLSB0aGUgZGVmYXVsdCB2YWx1ZVxyXG4gKiBAcGFyYW0ge2FueVtdfSB2YWxpZExpc3QgLSB0aGUgbGlzdCBvZiB2YWxpZCB2YWx1ZXNcclxuICogQHJldHVybnMge2FueX0gLSBlaXRoZXIgdGhlIGN1cnJlbnQgdmFsdWUgb3IgdGhlIGRlZmF1bHRcclxuICovXHJcbmNvbnN0IG5vcm1hbGl6ZVZhbHVlID0gKGN1cnJlbnRWYWwsIGRlZmF1bHRWYWwsIHZhbGlkTGlzdCkgPT5cclxuICAgIGN1cnJlbnRWYWwgJiYgUi5jb250YWlucyhjdXJyZW50VmFsLCB2YWxpZExpc3QpID8gY3VycmVudFZhbCA6IGRlZmF1bHRWYWw7XHJcblxyXG4vLyBnZXRQcmVzZXRCeU5hbWUgOjogU3RyaW5nIC0+IFtQcmVzZXRdIC0+IFByZXNldFxyXG5jb25zdCBnZXRQcmVzZXRCeU5hbWUgPSBSLmN1cnJ5KChuYW1lLCBwcmVzZXRzKSA9PiBSLnBpcGUoUi5maWx0ZXIoUi5wcm9wRXEoJ25hbWUnLCBuYW1lKSksIFIuaGVhZCkocHJlc2V0cykpO1xyXG5cclxuLy8gcmVtb3ZlUHJlc2V0QnlOYW1lIDo6IFN0cmluZyAtPiBbUHJlc2V0XSAtPiBQcmVzZXRcclxuY29uc3QgcmVtb3ZlUHJlc2V0QnlOYW1lID0gUi5jdXJyeSgobmFtZSwgcHJlc2V0cykgPT4gUi5yZWplY3QoUi5wcm9wRXEoJ25hbWUnLCBuYW1lKSwgcHJlc2V0cykpO1xyXG5cclxuLy8gdXBkYXRlUHJlc2V0QnlOYW1lIDo6IFN0cmluZyAtPiBQcmVzZXQgLT4gW1ByZXNldF0gLT4gW1ByZXNldF1cclxuY29uc3QgdXBkYXRlUHJlc2V0QnlOYW1lID0gUi5jdXJyeSgobmFtZSwgdXBkYXRlLCBwcmVzZXRzKSA9PlxyXG4gICAgUi5waXBlKFIucmVqZWN0KFIucHJvcEVxKCduYW1lJywgbmFtZSkpLCBSLmFwcGVuZCh1cGRhdGUpKShwcmVzZXRzKVxyXG4pO1xyXG5cclxuLy8gdmFsdWVzVG9QcmVzZXQgOjogU3RyaW5nIC0+IFN0cmluZyAtPiB7azogdn0gLT4gUHJlc2V0XHJcbmNvbnN0IHZhbHVlc1RvUHJlc2V0ID0gUi5jdXJyeSgobmFtZSwgdmFsdWVzKSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgc2V0dGluZ3M6IFIub21pdChQcmVzZXRLZXlCbGFja2xpc3QsIHZhbHVlcyksXHJcbiAgICB9O1xyXG59KTtcclxuXHJcbi8vIG1ha2Ugc3VyZSBpdCBoYXMgYSB2ZXJzaW9uIG51bWJlclxyXG4vLyBwcmVzZXRUb0pTT04gOjogU3RyaW5nIC0+IHsgazogdiB9IC0+IHsgazogdiB9XHJcbmNvbnN0IHByZXNldFRvSlNPTiA9IFIuY3VycnkoKHNjVmVyc2lvbiwgcHJlc2V0KSA9PiBSLm1lcmdlKHsgdmVyc2lvbjogc2NWZXJzaW9uIH0sIHByZXNldCkpO1xyXG5cclxuLy8gc2FuaXRpemVQcmVzZXQgOjogUHJlc2V0IC0+IFByZXNldFxyXG5jb25zdCBzYW5pdGl6ZVByZXNldCA9IFIuY3VycnkoKHNjVmVyc2lvbiwgcHJlc2V0LCBwcmVzZXRzKSA9PlxyXG4gICAgUi5waXBlKFxyXG4gICAgICAgIFIubWVyZ2UoeyB2ZXJzaW9uOiBzY1ZlcnNpb24gfSksIC8vIG1ha2Ugc3VyZSBpdCBoYXMgYSB2ZXJzaW9uIG51bWJlciwgd2UgbWF5IHVzZSB0aGlzIGxhdGVyXHJcbiAgICAgICAgUi5ldm9sdmUoe1xyXG4gICAgICAgICAgICB2ZXJzaW9uOiBSLmlkZW50aXR5LFxyXG4gICAgICAgICAgICBzZXR0aW5nczogUi5waXBlKFIub21pdChQcmVzZXRLZXlCbGFja2xpc3QpLCBSLnBpY2soUi52YWx1ZXMoU2V0dGluZ3NLZXlzKSkpLFxyXG4gICAgICAgICAgICBuYW1lOiBpbmNyZW1lbnRQcmVzZXROYW1lKHByZXNldHMpLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIFIucGljayhbJ25hbWUnLCAnc2V0dGluZ3MnXSlcclxuICAgICkocHJlc2V0KVxyXG4pO1xyXG5cclxuY29uc3QgaW5jcmVtZW50UHJlc2V0TmFtZSA9IFIuY3VycnkoKHByZXNldHMsIHNlYXJjaCkgPT5cclxuICAgIFIucGlwZShcclxuICAgICAgICBSLm1hcChSLnBpcGUoUi5wcm9wKCduYW1lJyksIFIubWF0Y2gobmV3IFJlZ0V4cChgJHtlc2NhcGVSZWdFeHAoc2VhcmNoKX0oXFxcXHNcXFxcKChcXFxcZCspXFxcXCkpKiRgKSkpKSxcclxuICAgICAgICBSLmZpbHRlcihSLmxlbmd0aCksIC8vIHJlbW92ZSBldmVyeXRoaW5nIHRoYXQgZGlkbid0IG1hdGNoXHJcbiAgICAgICAgUi5tYXAoXHJcbiAgICAgICAgICAgIFIucGlwZShcclxuICAgICAgICAgICAgICAgIFIubnRoKDIpLCAvLyBncmFiIHRoZSBudW1iZXIgYXMgYSBzdHJpbmcgb3V0IG9mIHRoZSBuYW1lXHJcbiAgICAgICAgICAgICAgICBSLmRlZmF1bHRUbygnMCcpLCAvLyBpZiB0aGVyZSB3YXNuJ3QgYSBudW1iZXIsIG1ha2UgaXQgJzAnXHJcbiAgICAgICAgICAgICAgICBwYXJzZUludFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKSxcclxuICAgICAgICBSLnJlZHVjZShSLm1heCwgLTEpLCAvLyBGaW5kIHRoZSBiaWdnZXN0IG51bWJlclxyXG4gICAgICAgIG4gPT4gKG4gPj0gMCA/IGAke3NlYXJjaH0gKCR7biArIDF9KWAgOiBzZWFyY2gpXHJcbiAgICApKHByZXNldHMpXHJcbik7XHJcblxyXG5jb25zdCBwcmVzZXRIYXNTZXR0aW5ncyA9IFIuY3VycnkoKGtleXMsIHByZXNldCkgPT5cclxuICAgIFIucmVkdWNlKChhY2MsIGspID0+IGFjYyB8fCBSLmhhcyhrLCBwcmVzZXQuc2V0dGluZ3MpLCBmYWxzZSwga2V5cylcclxuKTtcclxuXHJcbmNvbnN0IHByZXNldElzRXhwZXJpbWVudGFsID0gcHJlc2V0SGFzU2V0dGluZ3MoRUVTZXR0aW5nc0tleXMpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBzdGF0ZSxcclxuICAgIGF2YWlsYWJsZVNldHRpbmdzLFxyXG4gICAgdmlzaWJsZVNldHRpbmdzLFxyXG4gICAgY2xlYW5WYWx1ZXMsXHJcbiAgICBub3JtYWxpemVWYWx1ZSxcclxuICAgIGluaXRpYWxWYWx1ZU92ZXJyaWRlcyxcclxuICAgIGdldEdyb3VwaW5nLFxyXG4gICAgZ2V0T3B0aW9ucyxcclxuICAgIGdldFByZXNldEJ5TmFtZSxcclxuICAgIHVwZGF0ZVByZXNldEJ5TmFtZSxcclxuICAgIHJlbW92ZVByZXNldEJ5TmFtZSxcclxuICAgIHZhbHVlc1RvUHJlc2V0LFxyXG4gICAgcHJlc2V0VG9KU09OLFxyXG4gICAgc2FuaXRpemVQcmVzZXQsXHJcbiAgICBpbmNyZW1lbnRQcmVzZXROYW1lLFxyXG4gICAgcHJlc2V0SXNFeHBlcmltZW50YWwsXHJcbn07XHJcbiJdfQ==
