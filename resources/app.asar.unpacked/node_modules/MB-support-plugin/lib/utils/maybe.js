'use strict';

const _ = require('lodash');
/**
 * Are you sick of being burned by unexpected nulls or `undefined is not a
 * function'? Are you sick of null checking everytime you want to do anything
 * of any significance? Are you sick of the uncertainty? Well do I have the
 * thing for you! Hi, I'm Billy Mays, here to introduce you to Maybe.js!
 *
 * The justification for these helper functions is to abstract away
 * null-checking. It's important to deal with errors, but it rather than
 * deal with them interspersed throughout business logic (and likely forget)
 * it's better to deal with them all at once at the end, allowing you to
 * write more natural code.
 *
 * These helpers are based on Haskell monads and functors. The vocabulary
 * isn't really important. I'm just pointing it out in case you want to
 * google more information about the patterns.
 *
 * @example
 * if(printer) {
 *   const status = printer.getStatus();
 *   if(status) {
 *     const currentProcess = status.current_process;
 *     if(currentProcess) {
 *       if(currentProcess.percent_done) {
 *         // do something with the percent done
 *       }
 *     }
 *   }
 * }
 *
 * // You can probably see how this would (and does) quickly get out of hand.
 * // THERE'S GOT TO BE A BETTER WAY!
 *
 * // THERE IS!
 * maybe(this.props.printer.getStatus())
 *   .flatMap(s => maybe(s.current_process))
 *   .flatMap(cp => maybe(cp.percent_done))
 *   .map(percent => {
 *     // do something with percent done
 *   });
 *
 * // OR HOW ABOUT THIS?!
 * either(status.state, status.current_process)
 *   .left(state => i18n.t(`${state}`))
 *   .right(cp => i18n.t(`${cp.name}.${cp.step}`))
 *   .lift()
 *
 * @author Jon Laing
 */

/**
 * Maybe represents a value that might exist, or might not. This is helpful
 * for dealing with values coming from the printer, which may or may not
 * be set. Using this interface, you can write your code naturally, without
 * having to null-check on every operation.
 *
 * @interface Maybe
 */

/**
 * Apply a function to the contained value. If the value doesn't exist
 * (nothing), then this is a noop.
 *
 * @function
 * @name Maybe#map
 * @param {function} f - a function to apply to the inner value. It should
 * return anything except a Maybe. If your `f` returns a Maybe, use `flatMap`
 * instead. It takes one parameter, which is the contained value, if one
 * exists. If no value exists, then the function is not called. You don't
 * have to null-check within `f`.
 * @returns {Maybe}
 */

/**
 * Apply a function that can return a maybe to a contained value. Use this
 * instead of `map` if the closure will also return a maybe. Otherwise,
 * you will have a Maybe nested inside a Maybe, and that kind of defeats
 * the purpose.
 *
 * @function
 * @name Maybe#flatMap
 * @param {function} f - a function to apply to the inner value. `f` should
 * return a Maybe to allow the chain to continue.
 * @returns {Maybe}
 */

/**
 * Lift the value out of the Maybe. If the value exists, then this will
 * return the value. If not, this will return `null`.
 *
 * @function
 * @name Maybe#lift
 * @returns {any}
 */

/**
 * A value exists
 * @implements {Maybe}
 */


const just = val => ({
  map: f => just(f(val)),
  flatMap: f => f(val),
  lift: () => val
});
/**
 * A value doesn't exist
 * @implements {Maybe}
 */


const nothing = () => ({
  map: nothing,
  flatMap: nothing,
  lift: () => null
});
/**
 * A helper function that will abstract out null-checking.
 * If `val` is not `null` or `undefined` it will return `just(val)`
 * otherwise it will return `nothing`.
 *
 * @param {any} val - any value
 * @returns {Maybe}
 */


const maybe = val => val != null ? just(val) : nothing();

const isNothing = maybeVal => !maybeVal.map(() => true).lift();
/**
 * Either abstracts null-checking in a slightly different way from Maybe.
 * Instead of returning an empty `nothing` when its primary value is null,
 * it returns a fallback value.
 *
 * You'll notice that the interface has `left` and `right`. Use the
 * mneumonic "right" = "correct" to determine which is the primary
 * value, and which is the fallback. ie: `right` is the primary value, and
 * `left` is the fallback.
 *
 * @interface Either
 */

/**
 * Left allows you to apply transformations to the left side (fallback or
 * error side) of the Either switch. This is a no-op on the right
 * side.
 *
 * @function
 * @name Either#left
 * @param {function} f - a function to apply to the contained value
 * on the left side.
 * @returns {Either}
 */

/**
 * Right allows you to apply transformations to the right side (primary or
 * correct side) of the Either switch. This is a no-op on the left side.
 *
 * @function
 * @name Either#right
 * @param {function} f - a function to apply to the contained value
 * on the right side.
 * @returns {Either}
 */

/**
 * Lifts the contained value, be it left or right, out of the Either.
 *
 * @function
 * @name Either#lift
 * @returns {any}
 */

/** @implements {Either} */


const left = val => ({
  left: f => left(f(val)),
  map: f => left(f(val)),
  right: () => left(val),
  lift: () => val
});
/** @implements {Either} */


const right = val => ({
  left: () => right(val),
  map: f => right(f(val)),
  right: f => right(f(val)),
  lift: () => val
});
/**
 * A helper function that will abstract null-checking and create the
 * Either. If `val` is not `null` or `undefined`, this will return a `right`
 * containing `val`. Otherwise, it will return a `left` containing `fallback`.
 *
 * @param {any} fallback - A default, error, or fallback value
 * @param {any} val - the primary value
 * @returns {Either}
 */


const either = (fallback, val) => val == null ? left(fallback) : right(val);

const getProp = _.curry((propName, monad) => monad.map(val => val[propName]));

const getPropLift = _.curry((propName, monad) => monad.map(val => val[propName]).lift()); //TODO add nested property checking capability to maybe.js


module.exports = {
  just,
  nothing,
  maybe,
  isNothing,
  left,
  right,
  either,
  getProp,
  getPropLift
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1heWJlLmpzIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwianVzdCIsInZhbCIsIm1hcCIsImYiLCJmbGF0TWFwIiwibGlmdCIsIm5vdGhpbmciLCJtYXliZSIsImlzTm90aGluZyIsIm1heWJlVmFsIiwibGVmdCIsInJpZ2h0IiwiZWl0aGVyIiwiZmFsbGJhY2siLCJnZXRQcm9wIiwiY3VycnkiLCJwcm9wTmFtZSIsIm1vbmFkIiwiZ2V0UHJvcExpZnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxNQUFNQSxDQUFDLEdBQUdDLE9BQU8sQ0FBQyxRQUFELENBQWpCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1DLElBQUksR0FBR0MsR0FBRyxLQUFLO0FBQ2pCQyxFQUFBQSxHQUFHLEVBQUVDLENBQUMsSUFBSUgsSUFBSSxDQUFDRyxDQUFDLENBQUNGLEdBQUQsQ0FBRixDQURHO0FBRWpCRyxFQUFBQSxPQUFP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QUFBLElBTGE7QUFNYkMsRUFBQUEsS0FOYTtBQU9iQyxFQUFBQSxNQVBhO0FBUWJFLEVBQUFBLE9BUmE7QUFTYkksRUFBQUE7QUFUYSxDQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuXHJcbi8qKlxyXG4gKiBBcmUgeW91IHNpY2sgb2YgYmVpbmcgYnVybmVkIGJ5IHVuZXhwZWN0ZWQgbnVsbHMgb3IgYHVuZGVmaW5lZCBpcyBub3QgYVxyXG4gKiBmdW5jdGlvbic/IEFyZSB5b3Ugc2ljayBvZiBudWxsIGNoZWNraW5nIGV2ZXJ5dGltZSB5b3Ugd2FudCB0byBkbyBhbnl0aGluZ1xyXG4gKiBvZiBhbnkgc2lnbmlmaWNhbmNlPyBBcmUgeW91IHNpY2sgb2YgdGhlIHVuY2VydGFpbnR5PyBXZWxsIGRvIEkgaGF2ZSB0aGVcclxuICogdGhpbmcgZm9yIHlvdSEgSGksIEknbSBCaWxseSBNYXlzLCBoZXJlIHRvIGludHJvZHVjZSB5b3UgdG8gTWF5YmUuanMhXHJcbiAqXHJcbiAqIFRoZSBqdXN0aWZpY2F0aW9uIGZvciB0aGVzZSBoZWxwZXIgZnVuY3Rpb25zIGlzIHRvIGFic3RyYWN0IGF3YXlcclxuICogbnVsbC1jaGVja2luZy4gSXQncyBpbXBvcnRhbnQgdG8gZGVhbCB3aXRoIGVycm9ycywgYnV0IGl0IHJhdGhlciB0aGFuXHJcbiAqIGRlYWwgd2l0aCB0aGVtIGludGVyc3BlcnNlZCB0aHJvdWdob3V0IGJ1c2luZXNzIGxvZ2ljIChhbmQgbGlrZWx5IGZvcmdldClcclxuICogaXQncyBiZXR0ZXIgdG8gZGVhbCB3aXRoIHRoZW0gYWxsIGF0IG9uY2UgYXQgdGhlIGVuZCwgYWxsb3dpbmcgeW91IHRvXHJcbiAqIHdyaXRlIG1vcmUgbmF0dXJhbCBjb2RlLlxyXG4gKlxyXG4gKiBUaGVzZSBoZWxwZXJzIGFyZSBiYXNlZCBvbiBIYXNrZWxsIG1vbmFkcyBhbmQgZnVuY3RvcnMuIFRoZSB2b2NhYnVsYXJ5XHJcbiAqIGlzbid0IHJlYWxseSBpbXBvcnRhbnQuIEknbSBqdXN0IHBvaW50aW5nIGl0IG91dCBpbiBjYXNlIHlvdSB3YW50IHRvXHJcbiAqIGdvb2dsZSBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwYXR0ZXJucy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogaWYocHJpbnRlcikge1xyXG4gKiAgIGNvbnN0IHN0YXR1cyA9IHByaW50ZXIuZ2V0U3RhdHVzKCk7XHJcbiAqICAgaWYoc3RhdHVzKSB7XHJcbiAqICAgICBjb25zdCBjdXJyZW50UHJvY2VzcyA9IHN0YXR1cy5jdXJyZW50X3Byb2Nlc3M7XHJcbiAqICAgICBpZihjdXJyZW50UHJvY2Vzcykge1xyXG4gKiAgICAgICBpZihjdXJyZW50UHJvY2Vzcy5wZXJjZW50X2RvbmUpIHtcclxuICogICAgICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcGVyY2VudCBkb25lXHJcbiAqICAgICAgIH1cclxuICogICAgIH1cclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogLy8gWW91IGNhbiBwcm9iYWJseSBzZWUgaG93IHRoaXMgd291bGQgKGFuZCBkb2VzKSBxdWlja2x5IGdldCBvdXQgb2YgaGFuZC5cclxuICogLy8gVEhFUkUnUyBHT1QgVE8gQkUgQSBCRVRURVIgV0FZIVxyXG4gKlxyXG4gKiAvLyBUSEVSRSBJUyFcclxuICogbWF5YmUodGhpcy5wcm9wcy5wcmludGVyLmdldFN0YXR1cygpKVxyXG4gKiAgIC5mbGF0TWFwKHMgPT4gbWF5YmUocy5jdXJyZW50X3Byb2Nlc3MpKVxyXG4gKiAgIC5mbGF0TWFwKGNwID0+IG1heWJlKGNwLnBlcmNlbnRfZG9uZSkpXHJcbiAqICAgLm1hcChwZXJjZW50ID0+IHtcclxuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHBlcmNlbnQgZG9uZVxyXG4gKiAgIH0pO1xyXG4gKlxyXG4gKiAvLyBPUiBIT1cgQUJPVVQgVEhJUz8hXHJcbiAqIGVpdGhlcihzdGF0dXMuc3RhdGUsIHN0YXR1cy5jdXJyZW50X3Byb2Nlc3MpXHJcbiAqICAgLmxlZnQoc3RhdGUgPT4gaTE4bi50KGAke3N0YXRlfWApKVxyXG4gKiAgIC5yaWdodChjcCA9PiBpMThuLnQoYCR7Y3AubmFtZX0uJHtjcC5zdGVwfWApKVxyXG4gKiAgIC5saWZ0KClcclxuICpcclxuICogQGF1dGhvciBKb24gTGFpbmdcclxuICovXHJcblxyXG4vKipcclxuICogTWF5YmUgcmVwcmVzZW50cyBhIHZhbHVlIHRoYXQgbWlnaHQgZXhpc3QsIG9yIG1pZ2h0IG5vdC4gVGhpcyBpcyBoZWxwZnVsXHJcbiAqIGZvciBkZWFsaW5nIHdpdGggdmFsdWVzIGNvbWluZyBmcm9tIHRoZSBwcmludGVyLCB3aGljaCBtYXkgb3IgbWF5IG5vdFxyXG4gKiBiZSBzZXQuIFVzaW5nIHRoaXMgaW50ZXJmYWNlLCB5b3UgY2FuIHdyaXRlIHlvdXIgY29kZSBuYXR1cmFsbHksIHdpdGhvdXRcclxuICogaGF2aW5nIHRvIG51bGwtY2hlY2sgb24gZXZlcnkgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBAaW50ZXJmYWNlIE1heWJlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEFwcGx5IGEgZnVuY3Rpb24gdG8gdGhlIGNvbnRhaW5lZCB2YWx1ZS4gSWYgdGhlIHZhbHVlIGRvZXNuJ3QgZXhpc3RcclxuICogKG5vdGhpbmcpLCB0aGVuIHRoaXMgaXMgYSBub29wLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQG5hbWUgTWF5YmUjbWFwXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGYgLSBhIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSBpbm5lciB2YWx1ZS4gSXQgc2hvdWxkXHJcbiAqIHJldHVybiBhbnl0aGluZyBleGNlcHQgYSBNYXliZS4gSWYgeW91ciBgZmAgcmV0dXJucyBhIE1heWJlLCB1c2UgYGZsYXRNYXBgXHJcbiAqIGluc3RlYWQuIEl0IHRha2VzIG9uZSBwYXJhbWV0ZXIsIHdoaWNoIGlzIHRoZSBjb250YWluZWQgdmFsdWUsIGlmIG9uZVxyXG4gKiBleGlzdHMuIElmIG5vIHZhbHVlIGV4aXN0cywgdGhlbiB0aGUgZnVuY3Rpb24gaXMgbm90IGNhbGxlZC4gWW91IGRvbid0XHJcbiAqIGhhdmUgdG8gbnVsbC1jaGVjayB3aXRoaW4gYGZgLlxyXG4gKiBAcmV0dXJucyB7TWF5YmV9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEFwcGx5IGEgZnVuY3Rpb24gdGhhdCBjYW4gcmV0dXJuIGEgbWF5YmUgdG8gYSBjb250YWluZWQgdmFsdWUuIFVzZSB0aGlzXHJcbiAqIGluc3RlYWQgb2YgYG1hcGAgaWYgdGhlIGNsb3N1cmUgd2lsbCBhbHNvIHJldHVybiBhIG1heWJlLiBPdGhlcndpc2UsXHJcbiAqIHlvdSB3aWxsIGhhdmUgYSBNYXliZSBuZXN0ZWQgaW5zaWRlIGEgTWF5YmUsIGFuZCB0aGF0IGtpbmQgb2YgZGVmZWF0c1xyXG4gKiB0aGUgcHVycG9zZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBuYW1lIE1heWJlI2ZsYXRNYXBcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZiAtIGEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIGlubmVyIHZhbHVlLiBgZmAgc2hvdWxkXHJcbiAqIHJldHVybiBhIE1heWJlIHRvIGFsbG93IHRoZSBjaGFpbiB0byBjb250aW51ZS5cclxuICogQHJldHVybnMge01heWJlfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBMaWZ0IHRoZSB2YWx1ZSBvdXQgb2YgdGhlIE1heWJlLiBJZiB0aGUgdmFsdWUgZXhpc3RzLCB0aGVuIHRoaXMgd2lsbFxyXG4gKiByZXR1cm4gdGhlIHZhbHVlLiBJZiBub3QsIHRoaXMgd2lsbCByZXR1cm4gYG51bGxgLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQG5hbWUgTWF5YmUjbGlmdFxyXG4gKiBAcmV0dXJucyB7YW55fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHZhbHVlIGV4aXN0c1xyXG4gKiBAaW1wbGVtZW50cyB7TWF5YmV9XHJcbiAqL1xyXG5jb25zdCBqdXN0ID0gdmFsID0+ICh7XHJcbiAgICBtYXA6IGYgPT4ganVzdChmKHZhbCkpLFxyXG4gICAgZmxhdE1hcDogZiA9PiBmKHZhbCksXHJcbiAgICBsaWZ0OiAoKSA9PiB2YWwsXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEEgdmFsdWUgZG9lc24ndCBleGlzdFxyXG4gKiBAaW1wbGVtZW50cyB7TWF5YmV9XHJcbiAqL1xyXG5jb25zdCBub3RoaW5nID0gKCkgPT4gKHtcclxuICAgIG1hcDogbm90aGluZyxcclxuICAgIGZsYXRNYXA6IG5vdGhpbmcsXHJcbiAgICBsaWZ0OiAoKSA9PiBudWxsLFxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHdpbGwgYWJzdHJhY3Qgb3V0IG51bGwtY2hlY2tpbmcuXHJcbiAqIElmIGB2YWxgIGlzIG5vdCBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgaXQgd2lsbCByZXR1cm4gYGp1c3QodmFsKWBcclxuICogb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGBub3RoaW5nYC5cclxuICpcclxuICogQHBhcmFtIHthbnl9IHZhbCAtIGFueSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7TWF5YmV9XHJcbiAqL1xyXG5jb25zdCBtYXliZSA9IHZhbCA9PiAodmFsICE9IG51bGwgPyBqdXN0KHZhbCkgOiBub3RoaW5nKCkpO1xyXG5cclxuY29uc3QgaXNOb3RoaW5nID0gbWF5YmVWYWwgPT4gIW1heWJlVmFsLm1hcCgoKSA9PiB0cnVlKS5saWZ0KCk7XHJcblxyXG4vKipcclxuICogRWl0aGVyIGFic3RyYWN0cyBudWxsLWNoZWNraW5nIGluIGEgc2xpZ2h0bHkgZGlmZmVyZW50IHdheSBmcm9tIE1heWJlLlxyXG4gKiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlbXB0eSBgbm90aGluZ2Agd2hlbiBpdHMgcHJpbWFyeSB2YWx1ZSBpcyBudWxsLFxyXG4gKiBpdCByZXR1cm5zIGEgZmFsbGJhY2sgdmFsdWUuXHJcbiAqXHJcbiAqIFlvdSdsbCBub3RpY2UgdGhhdCB0aGUgaW50ZXJmYWNlIGhhcyBgbGVmdGAgYW5kIGByaWdodGAuIFVzZSB0aGVcclxuICogbW5ldW1vbmljIFwicmlnaHRcIiA9IFwiY29ycmVjdFwiIHRvIGRldGVybWluZSB3aGljaCBpcyB0aGUgcHJpbWFyeVxyXG4gKiB2YWx1ZSwgYW5kIHdoaWNoIGlzIHRoZSBmYWxsYmFjay4gaWU6IGByaWdodGAgaXMgdGhlIHByaW1hcnkgdmFsdWUsIGFuZFxyXG4gKiBgbGVmdGAgaXMgdGhlIGZhbGxiYWNrLlxyXG4gKlxyXG4gKiBAaW50ZXJmYWNlIEVpdGhlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBMZWZ0IGFsbG93cyB5b3UgdG8gYXBwbHkgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBsZWZ0IHNpZGUgKGZhbGxiYWNrIG9yXHJcbiAqIGVycm9yIHNpZGUpIG9mIHRoZSBFaXRoZXIgc3dpdGNoLiBUaGlzIGlzIGEgbm8tb3Agb24gdGhlIHJpZ2h0XHJcbiAqIHNpZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAbmFtZSBFaXRoZXIjbGVmdFxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmIC0gYSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgY29udGFpbmVkIHZhbHVlXHJcbiAqIG9uIHRoZSBsZWZ0IHNpZGUuXHJcbiAqIEByZXR1cm5zIHtFaXRoZXJ9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJpZ2h0IGFsbG93cyB5b3UgdG8gYXBwbHkgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSByaWdodCBzaWRlIChwcmltYXJ5IG9yXHJcbiAqIGNvcnJlY3Qgc2lkZSkgb2YgdGhlIEVpdGhlciBzd2l0Y2guIFRoaXMgaXMgYSBuby1vcCBvbiB0aGUgbGVmdCBzaWRlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQG5hbWUgRWl0aGVyI3JpZ2h0XHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGYgLSBhIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSBjb250YWluZWQgdmFsdWVcclxuICogb24gdGhlIHJpZ2h0IHNpZGUuXHJcbiAqIEByZXR1cm5zIHtFaXRoZXJ9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIExpZnRzIHRoZSBjb250YWluZWQgdmFsdWUsIGJlIGl0IGxlZnQgb3IgcmlnaHQsIG91dCBvZiB0aGUgRWl0aGVyLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQG5hbWUgRWl0aGVyI2xpZnRcclxuICogQHJldHVybnMge2FueX1cclxuICovXHJcblxyXG4vKiogQGltcGxlbWVudHMge0VpdGhlcn0gKi9cclxuY29uc3QgbGVmdCA9IHZhbCA9PiAoe1xyXG4gICAgbGVmdDogZiA9PiBsZWZ0KGYodmFsKSksXHJcbiAgICBtYXA6IGYgPT4gbGVmdChmKHZhbCkpLFxyXG4gICAgcmlnaHQ6ICgpID0+IGxlZnQodmFsKSxcclxuICAgIGxpZnQ6ICgpID0+IHZhbCxcclxufSk7XHJcblxyXG4vKiogQGltcGxlbWVudHMge0VpdGhlcn0gKi9cclxuY29uc3QgcmlnaHQgPSB2YWwgPT4gKHtcclxuICAgIGxlZnQ6ICgpID0+IHJpZ2h0KHZhbCksXHJcbiAgICBtYXA6IGYgPT4gcmlnaHQoZih2YWwpKSxcclxuICAgIHJpZ2h0OiBmID0+IHJpZ2h0KGYodmFsKSksXHJcbiAgICBsaWZ0OiAoKSA9PiB2YWwsXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBhYnN0cmFjdCBudWxsLWNoZWNraW5nIGFuZCBjcmVhdGUgdGhlXHJcbiAqIEVpdGhlci4gSWYgYHZhbGAgaXMgbm90IGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhpcyB3aWxsIHJldHVybiBhIGByaWdodGBcclxuICogY29udGFpbmluZyBgdmFsYC4gT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiBhIGBsZWZ0YCBjb250YWluaW5nIGBmYWxsYmFja2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7YW55fSBmYWxsYmFjayAtIEEgZGVmYXVsdCwgZXJyb3IsIG9yIGZhbGxiYWNrIHZhbHVlXHJcbiAqIEBwYXJhbSB7YW55fSB2YWwgLSB0aGUgcHJpbWFyeSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7RWl0aGVyfVxyXG4gKi9cclxuY29uc3QgZWl0aGVyID0gKGZhbGxiYWNrLCB2YWwpID0+ICh2YWwgPT0gbnVsbCA/IGxlZnQoZmFsbGJhY2spIDogcmlnaHQodmFsKSk7XHJcblxyXG5jb25zdCBnZXRQcm9wID0gXy5jdXJyeSgocHJvcE5hbWUsIG1vbmFkKSA9PiBtb25hZC5tYXAodmFsID0+IHZhbFtwcm9wTmFtZV0pKTtcclxuXHJcbmNvbnN0IGdldFByb3BMaWZ0ID0gXy5jdXJyeSgocHJvcE5hbWUsIG1vbmFkKSA9PiBtb25hZC5tYXAodmFsID0+IHZhbFtwcm9wTmFtZV0pLmxpZnQoKSk7XHJcblxyXG4vL1RPRE8gYWRkIG5lc3RlZCBwcm9wZXJ0eSBjaGVja2luZyBjYXBhYmlsaXR5IHRvIG1heWJlLmpzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGp1c3QsXHJcbiAgICBub3RoaW5nLFxyXG4gICAgbWF5YmUsXHJcbiAgICBpc05vdGhpbmcsXHJcbiAgICBsZWZ0LFxyXG4gICAgcmlnaHQsXHJcbiAgICBlaXRoZXIsXHJcbiAgICBnZXRQcm9wLFxyXG4gICAgZ2V0UHJvcExpZnQsXHJcbn07XHJcbiJdfQ==
