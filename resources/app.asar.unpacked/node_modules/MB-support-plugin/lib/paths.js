'use strict';

const path = require('path'); // TODO: These paths are duplicated from the makerbot build system...


const os_type = require('os').type(); // Where the grunt task unpacks our artifacts


const installRoot = `${__dirname}/../mb_ir`;

function getInstallArtifactsRootDir() {
  return installRoot;
}

function getBinDir() {
  switch (os_type) {
    case 'Linux':
      return path.join(installRoot, 'usr/bin');

    case 'Darwin':
      return path.join(installRoot, 'Library/MakerBot');

    case 'Windows_NT':
      return path.join(installRoot, 'MakerWare');

    default:
      throw `Unsupported OS type: ${os_type}`;
  }
}

function getConfigDir() {
  let remote, app;

  try {
    remote = require('electron').remote;
    app = remote.app;
  } catch (err) {
    // if this is being run from the main process, then 'remote' doesn't exist and will throw an error
    // in that case, simply require app
    try {
      app = require('electron').app;
    } catch (err) {// this can happen if running in unit test environment
    }
  }

  return app ? app.getPath('userData') : '';
}

function getWinUsbMonitor() {
  if (os_type !== 'Windows_NT') throw `Unsupported OS type: ${os_type}`; // this needs to be changed if we ever decide to support 32bit (lol)

  const programfiles = process.env.programfiles;
  return {
    path: path.join(programfiles, 'MakerBot Usb Support', 'MakerWare', 'UsbMonitor'),
    bin: 'UsbMonitor.exe'
  };
}

function requireNativeCroissant() {
  let Croissant;
  const platform = process.platform;
  const binary = path.basename(process.argv[0]);

  switch (os_type) {
    case 'Linux':
      Croissant = require('../mb_ir/usr/bin/croissantjs');
      break;

    case 'Darwin':
      if (binary === 'Electron Helper') Croissant = require('../mb_ir/Library/MakerBot/croissantjs_electron');else Croissant = require('../mb_ir/Library/MakerBot/croissantjs');
      break;

    case 'Windows_NT':
      // On windows the library loading mechanism prevents us from using the
      // same native module with both the node and electron binaries.  We try
      // to only use the electron specific module when we have to because we
      // don't ever test the electron module.
      if (platform == 'win32' && (binary == 'electron.exe' || binary == 'GrabCADPrint.exe' || binary == 'makerbot-print.exe')) {
        Croissant = require('../mb_ir/MakerWare/croissantjs_electron');
      } else {
        Croissant = require('../mb_ir/MakerWare/croissantjs');
      }

      break;

    default:
      throw `Unsupported OS type: ${os_type}`;
  }

  return Croissant;
}

function requireSliceConfig() {
  let SliceConfig; // Note: .js suffix needed for require() to disambiguate from sliceconfig Python script that exists in same directory

  switch (os_type) {
    case 'Linux':
      SliceConfig = require('../mb_ir/usr/bin/sliceconfig.js');
      break;

    case 'Darwin':
      SliceConfig = require('../mb_ir/Library/MakerBot/sliceconfig.js');
      break;

    case 'Windows_NT':
      // On windows the library loading mechanism prevents us from using the
      // same native module with both the node and electron binaries.  We try
      // to only use the electron specific module when we have to because we
      // don't ever test the electron module.
      SliceConfig = require('../mb_ir/MakerWare/sliceconfig.js');
      break;

    default:
      throw `Unsupported OS type: ${os_type}`;
  }

  return SliceConfig;
}

function requireNodeGrue() {
  let NodeGrue;
  const platform = process.platform;
  const binary = path.basename(process.argv[0]);

  switch (os_type) {
    case 'Linux':
      // NOTE: untested but it's not like we build mb print for linux anyways
      NodeGrue = require('../mb_ir/usr/share/makerbot/node_modules/nodegrue_addon');
      break;

    case 'Darwin':
      if (binary === 'Electron Helper') {
        NodeGrue = require('../mb_ir/Library/MakerBot/nodegrue_addon_electron');
      } else {
        NodeGrue = require('../mb_ir/Library/MakerBot/nodegrue_addon');
      }

      break;

    case 'Windows_NT':
      // On windows the library loading mechanism prevents us from using the
      // same native module with both the node and electron binaries.  We try
      // to only use the electron specific module when we have to because we
      // don't ever test the electron module.
      if (platform == 'win32' && (binary == 'electron.exe' || binary == 'GrabCADPrint.exe' || binary == 'makerbot-print.exe')) {
        NodeGrue = require('../mb_ir/MakerWare/nodegrue_addon_electron');
      } else {
        NodeGrue = require('../mb_ir/MakerWare/nodegrue_addon');
      }

      break;

    default:
      throw `Unsupported OS type: ${os_type}`;
  }

  return NodeGrue;
}

module.exports = {
  getInstallArtifactsRootDir,
  getBinDir,
  getConfigDir,
  getWinUsbMonitor,
  requireNativeCroissant,
  requireSliceConfig,
  requireNodeGrue
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhdGhzLmpzIl0sIm5hbWVzIjpbInBhdGgiLCJyZXF1aXJlIiwib3NfdHlwZSIsInR5cGUiLCJpbnN0YWxsUm9vdCIsIl9fZGlybmFtZSIsImdldEluc3RhbGxBcnRpZmFjdHNSb290RGlyIiwiZ2V0QmluRGlyIiwiam9pbiIsImdldENvbmZpZ0RpciIsInJlbW90ZSIsImFwcCIsImVyciIsImdldFBhdGgiLCJnZXRXaW5Vc2JNb25pdG9yIiwicHJvZ3JhbWZpbGVzIiwicHJvY2VzcyIsImVudiIsImJpbiIsInJlcXVpcmVOYXRpdmVDcm9pc3NhbnQiLCJDcm9pc3NhbnQiLCJwbGF0Zm9ybSIsImJpbmFyeSIsImJhc2VuYW1lIiwiYXJndiIsInJlcXVpcmVTbGljZUNvbmZpZyIsIlNsaWNlQ29uZmlnIiwicmVxdWlyZU5vZGVHcnVlIiwiTm9kZUdydWUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxNQUFNQSxJQUFJLEdBQUdDLE9BQU8sQ0FBQyxNQUFELENBQXBCLEMsQ0FDQTs7O0FBQ0EsTUFBTUMsT0FBTyxHQUFHRCxPQUFPLENBQUMsSUFBRCxDQUFQLENBQWNFLElBQWQsRUFBaEIsQyxDQUVBOzs7QUFDQSxNQUFNQyxXQUFXLEdBQUksR0FBRUMsU0FBVSxXQUFqQzs7QUFFQSxTQUFTQywwQkFBVCxHQUFzQztBQUNsQyxTQUFPRixXQUFQO0FBQ0g7O0FBRUQsU0FBU0csU0FBVCxHQUFxQjtBQUNqQixVQUFRTCxPQUFSO0FBQ0ksU0FBSyxPQUFMO0FBQ0ksYUFBT0YsSUFBSSxDQUFDUSxJQUFMLENBQVVKLFdBQVYsRUFBdUIsU0FBdkIsQ0FBUDs7QUFDSixTQUFLLFFBQUw7QUFDSSxhQUFPSixJQUFJLENBQUNRLElBQUwsQ0FBVUosV0FBVixFQUF1QixrQkFBdkIsQ0FBUDs7QUFDSixTQUFLLFlBQUw7QUFDSSxhQUFPSixJQUFJLENBQUNRLElBQUwsQ0FBVUosV0FBVixFQUF1QixXQUF2QixDQUFQOztBQUNKO0FBQ0ks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aWN0JztcclxuXHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcbi8vIFRPRE86IFRoZXNlIHBhdGhzIGFyZSBkdXBsaWNhdGVkIGZyb20gdGhlIG1ha2VyYm90IGJ1aWxkIHN5c3RlbS4uLlxyXG5jb25zdCBvc190eXBlID0gcmVxdWlyZSgnb3MnKS50eXBlKCk7XHJcblxyXG4vLyBXaGVyZSB0aGUgZ3J1bnQgdGFzayB1bnBhY2tzIG91ciBhcnRpZmFjdHNcclxuY29uc3QgaW5zdGFsbFJvb3QgPSBgJHtfX2Rpcm5hbWV9Ly4uL21iX2lyYDtcclxuXHJcbmZ1bmN0aW9uIGdldEluc3RhbGxBcnRpZmFjdHNSb290RGlyKCkge1xyXG4gICAgcmV0dXJuIGluc3RhbGxSb290O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRCaW5EaXIoKSB7XHJcbiAgICBzd2l0Y2ggKG9zX3R5cGUpIHtcclxuICAgICAgICBjYXNlICdMaW51eCc6XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoLmpvaW4oaW5zdGFsbFJvb3QsICd1c3IvYmluJyk7XHJcbiAgICAgICAgY2FzZSAnRGFyd2luJzpcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGguam9pbihpbnN0YWxsUm9vdCwgJ0xpYnJhcnkvTWFrZXJCb3QnKTtcclxuICAgICAgICBjYXNlICdXaW5kb3dzX05UJzpcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGguam9pbihpbnN0YWxsUm9vdCwgJ01ha2VyV2FyZScpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IGBVbnN1cHBvcnRlZCBPUyB0eXBlOiAke29zX3R5cGV9YDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q29uZmlnRGlyKCkge1xyXG4gICAgbGV0IHJlbW90ZSwgYXBwO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZW1vdGUgPSByZXF1aXJlKCdlbGVjdHJvbicpLnJlbW90ZTtcclxuICAgICAgICBhcHAgPSByZW1vdGUuYXBwO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBiZWluZyBydW4gZnJvbSB0aGUgbWFpbiBwcm9jZXNzLCB0aGVuICdyZW1vdGUnIGRvZXNuJ3QgZXhpc3QgYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3JcclxuICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIHNpbXBseSByZXF1aXJlIGFwcFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGFwcCA9IHJlcXVpcmUoJ2VsZWN0cm9uJykuYXBwO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGNhbiBoYXBwZW4gaWYgcnVubmluZyBpbiB1bml0IHRlc3QgZW52aXJvbm1lbnRcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwID8gYXBwLmdldFBhdGgoJ3VzZXJEYXRhJykgOiAnJztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0V2luVXNiTW9uaXRvcigpIHtcclxuICAgIGlmIChvc190eXBlICE9PSAnV2luZG93c19OVCcpIHRocm93IGBVbnN1cHBvcnRlZCBPUyB0eXBlOiAke29zX3R5cGV9YDtcclxuXHJcbiAgICAvLyB0aGlzIG5lZWRzIHRvIGJlIGNoYW5nZWQgaWYgd2UgZXZlciBkZWNpZGUgdG8gc3VwcG9ydCAzMmJpdCAobG9sKVxyXG4gICAgY29uc3QgcHJvZ3JhbWZpbGVzID0gcHJvY2Vzcy5lbnYucHJvZ3JhbWZpbGVzO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXRoOiBwYXRoLmpvaW4ocHJvZ3JhbWZpbGVzLCAnTWFrZXJCb3QgVXNiIFN1cHBvcnQnLCAnTWFrZXJXYXJlJywgJ1VzYk1vbml0b3InKSxcclxuICAgICAgICBiaW46ICdVc2JNb25pdG9yLmV4ZScsXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlTmF0aXZlQ3JvaXNzYW50KCkge1xyXG4gICAgbGV0IENyb2lzc2FudDtcclxuICAgIGNvbnN0IHBsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcclxuICAgIGNvbnN0IGJpbmFyeSA9IHBhdGguYmFzZW5hbWUocHJvY2Vzcy5hcmd2WzBdKTtcclxuXHJcbiAgICBzd2l0Y2ggKG9zX3R5cGUpIHtcclxuICAgICAgICBjYXNlICdMaW51eCc6XHJcbiAgICAgICAgICAgIENyb2lzc2FudCA9IHJlcXVpcmUoJy4uL21iX2lyL3Vzci9iaW4vY3JvaXNzYW50anMnKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnRGFyd2luJzpcclxuICAgICAgICAgICAgaWYgKGJpbmFyeSA9PT0gJ0VsZWN0cm9uIEhlbHBlcicpIENyb2lzc2FudCA9IHJlcXVpcmUoJy4uL21iX2lyL0xpYnJhcnkvTWFrZXJCb3QvY3JvaXNzYW50anNfZWxlY3Ryb24nKTtcclxuICAgICAgICAgICAgZWxzZSBDcm9pc3NhbnQgPSByZXF1aXJlKCcuLi9tYl9pci9MaWJyYXJ5L01ha2VyQm90L2Nyb2lzc2FudGpzJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1dpbmRvd3NfTlQnOlxyXG4gICAgICAgICAgICAvLyBPbiB3aW5kb3dzIHRoZSBsaWJyYXJ5IGxvYWRpbmcgbWVjaGFuaXNtIHByZXZlbnRzIHVzIGZyb20gdXNpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIHNhbWUgbmF0aXZlIG1vZHVsZSB3aXRoIGJvdGggdGhlIG5vZGUgYW5kIGVsZWN0cm9uIGJpbmFyaWVzLiAgV2UgdHJ5XHJcbiAgICAgICAgICAgIC8vIHRvIG9ubHkgdXNlIHRoZSBlbGVjdHJvbiBzcGVjaWZpYyBtb2R1bGUgd2hlbiB3ZSBoYXZlIHRvIGJlY2F1c2Ugd2VcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZXZlciB0ZXN0IHRoZSBlbGVjdHJvbiBtb2R1bGUuXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHBsYXRmb3JtID09ICd3aW4zMicgJiZcclxuICAgICAgICAgICAgICAgIChiaW5hcnkgPT0gJ2VsZWN0cm9uLmV4ZScgfHwgYmluYXJ5ID09ICdHcmFiQ0FEUHJpbnQuZXhlJyB8fCBiaW5hcnkgPT0gJ21ha2VyYm90LXByaW50LmV4ZScpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgQ3JvaXNzYW50ID0gcmVxdWlyZSgnLi4vbWJfaXIvTWFrZXJXYXJlL2Nyb2lzc2FudGpzX2VsZWN0cm9uJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDcm9pc3NhbnQgPSByZXF1aXJlKCcuLi9tYl9pci9NYWtlcldhcmUvY3JvaXNzYW50anMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBgVW5zdXBwb3J0ZWQgT1MgdHlwZTogJHtvc190eXBlfWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ3JvaXNzYW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlU2xpY2VDb25maWcoKSB7XHJcbiAgICBsZXQgU2xpY2VDb25maWc7XHJcbiAgICAvLyBOb3RlOiAuanMgc3VmZml4IG5lZWRlZCBmb3IgcmVxdWlyZSgpIHRvIGRpc2FtYmlndWF0ZSBmcm9tIHNsaWNlY29uZmlnIFB5dGhvbiBzY3JpcHQgdGhhdCBleGlzdHMgaW4gc2FtZSBkaXJlY3RvcnlcclxuICAgIHN3aXRjaCAob3NfdHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ0xpbnV4JzpcclxuICAgICAgICAgICAgU2xpY2VDb25maWcgPSByZXF1aXJlKCcuLi9tYl9pci91c3IvYmluL3NsaWNlY29uZmlnLmpzJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0Rhcndpbic6XHJcbiAgICAgICAgICAgIFNsaWNlQ29uZmlnID0gcmVxdWlyZSgnLi4vbWJfaXIvTGlicmFyeS9NYWtlckJvdC9zbGljZWNvbmZpZy5qcycpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdXaW5kb3dzX05UJzpcclxuICAgICAgICAgICAgLy8gT24gd2luZG93cyB0aGUgbGlicmFyeSBsb2FkaW5nIG1lY2hhbmlzbSBwcmV2ZW50cyB1cyBmcm9tIHVzaW5nIHRoZVxyXG4gICAgICAgICAgICAvLyBzYW1lIG5hdGl2ZSBtb2R1bGUgd2l0aCBib3RoIHRoZSBub2RlIGFuZCBlbGVjdHJvbiBiaW5hcmllcy4gIFdlIHRyeVxyXG4gICAgICAgICAgICAvLyB0byBvbmx5IHVzZSB0aGUgZWxlY3Ryb24gc3BlY2lmaWMgbW9kdWxlIHdoZW4gd2UgaGF2ZSB0byBiZWNhdXNlIHdlXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGV2ZXIgdGVzdCB0aGUgZWxlY3Ryb24gbW9kdWxlLlxyXG4gICAgICAgICAgICBTbGljZUNvbmZpZyA9IHJlcXVpcmUoJy4uL21iX2lyL01ha2VyV2FyZS9zbGljZWNvbmZpZy5qcycpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBgVW5zdXBwb3J0ZWQgT1MgdHlwZTogJHtvc190eXBlfWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU2xpY2VDb25maWc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcXVpcmVOb2RlR3J1ZSgpIHtcclxuICAgIGxldCBOb2RlR3J1ZTtcclxuICAgIGNvbnN0IHBsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcclxuICAgIGNvbnN0IGJpbmFyeSA9IHBhdGguYmFzZW5hbWUocHJvY2Vzcy5hcmd2WzBdKTtcclxuXHJcbiAgICBzd2l0Y2ggKG9zX3R5cGUpIHtcclxuICAgICAgICBjYXNlICdMaW51eCc6XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IHVudGVzdGVkIGJ1dCBpdCdzIG5vdCBsaWtlIHdlIGJ1aWxkIG1iIHByaW50IGZvciBsaW51eCBhbnl3YXlzXHJcbiAgICAgICAgICAgIE5vZGVHcnVlID0gcmVxdWlyZSgnLi4vbWJfaXIvdXNyL3NoYXJlL21ha2VyYm90L25vZGVfbW9kdWxlcy9ub2RlZ3J1ZV9hZGRvbicpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdEYXJ3aW4nOlxyXG4gICAgICAgICAgICBpZiAoYmluYXJ5ID09PSAnRWxlY3Ryb24gSGVscGVyJykge1xyXG4gICAgICAgICAgICAgICAgTm9kZUdydWUgPSByZXF1aXJlKCcuLi9tYl9pci9MaWJyYXJ5L01ha2VyQm90L25vZGVncnVlX2FkZG9uX2VsZWN0cm9uJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBOb2RlR3J1ZSA9IHJlcXVpcmUoJy4uL21iX2lyL0xpYnJhcnkvTWFrZXJCb3Qvbm9kZWdydWVfYWRkb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdXaW5kb3dzX05UJzpcclxuICAgICAgICAgICAgLy8gT24gd2luZG93cyB0aGUgbGlicmFyeSBsb2FkaW5nIG1lY2hhbmlzbSBwcmV2ZW50cyB1cyBmcm9tIHVzaW5nIHRoZVxyXG4gICAgICAgICAgICAvLyBzYW1lIG5hdGl2ZSBtb2R1bGUgd2l0aCBib3RoIHRoZSBub2RlIGFuZCBlbGVjdHJvbiBiaW5hcmllcy4gIFdlIHRyeVxyXG4gICAgICAgICAgICAvLyB0byBvbmx5IHVzZSB0aGUgZWxlY3Ryb24gc3BlY2lmaWMgbW9kdWxlIHdoZW4gd2UgaGF2ZSB0byBiZWNhdXNlIHdlXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGV2ZXIgdGVzdCB0aGUgZWxlY3Ryb24gbW9kdWxlLlxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybSA9PSAnd2luMzInICYmXHJcbiAgICAgICAgICAgICAgICAoYmluYXJ5ID09ICdlbGVjdHJvbi5leGUnIHx8IGJpbmFyeSA9PSAnR3JhYkNBRFByaW50LmV4ZScgfHwgYmluYXJ5ID09ICdtYWtlcmJvdC1wcmludC5leGUnKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIE5vZGVHcnVlID0gcmVxdWlyZSgnLi4vbWJfaXIvTWFrZXJXYXJlL25vZGVncnVlX2FkZG9uX2VsZWN0cm9uJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBOb2RlR3J1ZSA9IHJlcXVpcmUoJy4uL21iX2lyL01ha2VyV2FyZS9ub2RlZ3J1ZV9hZGRvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IGBVbnN1cHBvcnRlZCBPUyB0eXBlOiAke29zX3R5cGV9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBOb2RlR3J1ZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBnZXRJbnN0YWxsQXJ0aWZhY3RzUm9vdERpcixcclxuICAgIGdldEJpbkRpcixcclxuICAgIGdldENvbmZpZ0RpcixcclxuICAgIGdldFdpblVzYk1vbml0b3IsXHJcbiAgICByZXF1aXJlTmF0aXZlQ3JvaXNzYW50LFxyXG4gICAgcmVxdWlyZVNsaWNlQ29uZmlnLFxyXG4gICAgcmVxdWlyZU5vZGVHcnVlLFxyXG59O1xyXG4iXX0=
