'use strict';

const q = require('q');

const _ = require('lodash');

const ComposeProvider = require('eagle-print/services/providers/compose_provider');

const Transform = require('eagle-print/model/transform'); /// Rect object that will rep the bounding boxes of our objects to plate


const Rect = function (x, y, w, h) {
  this.x = _.round(x, 6);
  this.y = _.round(y, 6);
  this.width = _.round(w, 6);
  this.height = _.round(h, 6);
};

Rect.prototype = {
  constructor: Rect,

  /// does this rectangle fully contain the rectangle @rect
  /// @returns {bool}
  contains(rect) {
    return this.x <= rect.x && this.y <= rect.y && this.x + this.width >= rect.x + rect.width && this.y + this.height >= rect.y + rect.height;
  },

  /// does this rectangle overlap with the recatangle @rect
  /// @returns {bool}
  overlaps(rect) {
    // setup the left, right, bottom and top for this rect
    const thisLeft = this.x;
    const thisRight = this.x + this.width;
    const thisBottom = this.y;
    const thisTop = this.y + this.height; // setup the same for the rect

    const thatLeft = rect.x;
    const thatRight = rect.x + rect.width;
    const thatBottom = rect.y;
    const thatTop = rect.y + rect.height; // fun geometry trick - http://stackoverflow.com/a/306332

    return thisLeft < thatRight && thisRight > thatLeft && thisBottom < thatTop && thisTop > thatBottom;
  },

  /// union this rectangle with @rect and @return a new rect that is their
  /// overlap.
  union(rect) {
    const thisLeft = this.x;
    const thisRight = this.x + this.width;
    const thisBottom = this.y;
    const thisTop = this.y + this.height; // setup the same for the rect

    const thatLeft = rect.x;
    const thatRight = rect.x + rect.width;
    const thatBottom = rect.y;
    const thatTop = rect.y + rect.height;
    const left = thisLeft > thatLeft ? thisLeft : thatLeft;
    const width = thisRight < thatRight ? thisRight - left : thatRight - left;
    const bottom = thisBottom > thatBottom ? thisBottom : thatBottom;
    const height = thisTop < thatTop ? thisTop - bottom : thatTop - bottom;
    return new Rect(left, bottom, width, height);
  },

  /// break this rectange into an array of smaller ones, missing the area bound
  /// by @rect. the rectangles in that array may overlap.
  /// @returns {Array of Rect}
  getFreeRects(rect) {
    // if the rect doesn't overlap, just return this rectangle
    if (!this.overlaps(rect)) {
      return [this];
    }

    const freeRects = []; // setup the left, right, bottom and top for this rect

    const boundsLeft = this.x;
    const boundsRight = this.x + this.width;
    const boundsBottom = this.y;
    const boundsTop = this.y + this.height; // setup the same for the rect

    const cutoutLeft = rect.x;
    const cutoutRight = rect.x + rect.width;
    const cutoutBottom = rect.y;
    const cutoutTop = rect.y + rect.height; // bottom

    if (boundsBottom < cutoutBottom) {
      freeRects.push(new Rect(boundsLeft, boundsBottom, boundsRight - boundsLeft, cutoutBottom - boundsBottom));
    } // right


    if (boundsRight > cutoutRight) {
      freeRects.push(new Rect(cutoutRight, boundsBottom, boundsRight - cutoutRight, boundsTop - boundsBottom));
    } // top


    if (boundsTop > cutoutTop) {
      freeRects.push(new Rect(boundsLeft, cutoutTop, boundsRight - boundsLeft, boundsTop - cutoutTop));
    } // left


    if (boundsLeft < cutoutLeft) {
      freeRects.push(new Rect(boundsLeft, boundsBottom, cutoutLeft - boundsLeft, boundsTop - boundsBottom));
    }

    return freeRects;
  },

  /// can this rectangle fit @rect inside of it
  /// @returns {bool}
  canFit(rect) {
    return this.width >= rect.width && this.height >= rect.height;
  },

  /// get the distance from the orgin (0, 0) to the closest point of this
  /// rectangle.
  ///
  /// @returns {float?}
  distanceToOrigin() {
    const point = this.closestPointToOrigin();
    return Math.sqrt(point.x * point.x + point.y * point.y);
  },

  /// get the point closest to the origin (0, 0) on this rectangle
  /// @returns {x, y}
  closestPointToOrigin() {
    // http://stackoverflow.com/a/18157551
    return {
      x: Math.max(this.x, 0, -(this.x + this.width)),
      y: Math.max(this.y, 0, -(this.y + this.height))
    };
  }

}; /// On object representing a build area that we can place rectangles into

const Buildplate = function (buildArea, allowOutsideOfBounds) {
  this.allowOutsideOfBounds = allowOutsideOfBounds; // create spaces - an array of rectangles representing the build plate,
  // initialize with one in each quadrent

  const width = buildArea.x / 2;
  const height = buildArea.y / 2;
  this.buildRect = new Rect(-width, -height, 2 * width, 2 * height);

  if (this.allowOutsideOfBounds) {
    // a solid km x km build plate should be sufficiently large to avoid
    // problems
    const huge = 1000;
    this.spaces = [new Rect(-huge / 2, -huge / 2, huge, huge)];
  } else {
    this.spaces = [this.buildRect];
  }
};

Buildplate.prototype = {
  constructor: Buildplate,

  /// add a bounding box @rect to this buildplate.
  /// @return {bool} - was the rect able to be packed in this buildplate
  pack(rect) {
    // derp
    const self = this; // we'll store the first space outside the buildplate that can fit our rect
    // if we're allowed to place bodies there.

    let firstFitSpace = null;

    for (const i in self.spaces) {
      const space = self.spaces[i]; // check to see if this space can hold rect

      if (space.canFit(rect)) {
        if (self.allowOutsideOfBounds) {
          // if we're allowed to place things outside of the bounds, then some
          // the spaces extend beyond the build plate. check to see if the union
          // of the buildplate and this space can contain this rect. if it can
          // place it there, if it can't store the first space visited in case
          // none of our spaces can hold this rect.
          const spaceOnPlate = space.union(self.buildRect);

          if (spaceOnPlate.canFit(rect)) {
            self._placeRectInSpace(space, rect);

            return true;
          } else if (!firstFitSpace) {
            firstFitSpace = space;
          }
        } else {
          // if we aren't allowed to place things outside of the bounds, then
          // the rect fitting in this space is sufficient. place and exit.
          self._placeRectInSpace(space, rect);

          return true;
        }
      }
    }

    if (self._isEmpty()) {
      // if this buildplate is empty, and the model doesnt fit in the sole
      // space, then place it in the sole space anyway, since it won't fit on
      // any tray we create.
      self._placeRectInSpace(self.spaces[0], rect);

      return true;
    } else if (this.allowOutsideOfBounds) {
      if (!firstFitSpace) {
        throw new Error('Unable to find space for model on current tray.');
      } // if we' are allowed to place outside of the bounds, firstFitSpace is the
      // first space we visited that can contain rect. place the rect there.


      self._placeRectInSpace(firstFitSpace, rect);

      return true;
    } else {
      // if we aren't allowed to place outside of the bounds, return false since
      // we didn't place the rect.
      return false;
    }
  },

  /// @return {bool} - is this buildplate empty?
  _isEmpty() {
    const self = this;
    return self.spaces.length === 1 && self.spaces[0].contains(self.buildRect);
  },

  /// place the rectangle @rect inside of @space such that the center of @rect
  /// is as close to the origin as possible. then place @rect in this.spaces.
  _placeRectInSpace(space, rect) {
    // get the point in the space closest to the origin
    const point = space.closestPointToOrigin(); // set rect.x so that the center of the rect is is closest to point
    //
    // there are three places that we could want our bounding box to end up
    // on the x axis, the extreme right and left of the current space, or on
    // the y axis. we can determine which one based on the closest point of
    // our space to the origin. the same is going to be true for the y axis
    // in the next block of code.
    //
    // LEGEND
    // + - (0 , 0) origin
    // * - point in the current space closest to origin
    // # - right edge of a space
    // @ - left edge of a space
    // $ - x = 0
    //
    // EXAMPLE WHERE WE WANT X = 0 - rect.width / 2
    // point = (0, -2)
    // rect = { width:8, height:3 }
    // space = { x:-34 , y:-7, width:68, height:5 }
    //
    // ---------------------------------------------------------------------
    // |                                                                   |
    // |                                                                   |
    // |                                                                   |
    // |                           ------------                            |
    // |                           |          |                            |
    // |  object already here ->   |     +    |                            |
    // |                           |          |                            |
    // |---------------------------------*---------------------------------|
    // |                             ~~~~~~~~~                             |
    // |                             ~       ~                             |
    // #                             $~~~~~~~~                     @       |
    // |                                                                   |
    // ---------------------------------------------------------------------
    //        space we're going to fill ^
    // EXAMPLE WHERE WE WANT X = space.x
    // point = (5, 0)
    // rect = { width: 8, height: 3 }
    // space = { x:5, y:-7, width:30, height:14 }
    // ---------------------------------------------------------------------
    // |                                      |                            |
    // |        space we're going to fill ->  |                            |
    // |                                      |                            |
    // |                           ------------                            |
    // |                           |          |                            |
    // |  object already here ->   |     +    *                            |
    // |                           |          |                            |
    // |                           ------------                            |
    // |                                      |~~~~~~~                     |
    // |                                      |      ~                     |
    // |                             $        #~~~~~~~             @       |
    // |                                      |                            |
    // ---------------------------------------------------------------------
    // EXAMPLE WHERE WE WANT x = space.x + space.width - rect.width
    // point = (-5, 0)
    // rect = { width: 8, height: 3 }
    // space = { x:-34, y:-7, width:30, height:14 }
    // ---------------------------------------------------------------------
    // |                           |                                       |
    // |                           | <- space we're going to fill          |
    // |                           |                                       |
    // |                           ------------                            |
    // |                           |          |                            |
    // |                           *     +    | <- object already here     |
    // |                           |          |                            |
    // |                           ------------                            |
    // |                    ~~~~~~~|                                       |
    // |                    ~      |                                       |
    // #                    @~~~~~~| $                                     |
    // |                           |                                       |
    // ---------------------------------------------------------------------

    if (point.x === space.x) {
      rect.x = space.x;
    } else if (point.x === 0) {
      rect.x = point.x - rect.width / 2;
    } else {
      rect.x = space.x + space.width - rect.width;
    } // set rect.y so that the center of the rect is closest to the point


    if (point.y === space.y) {
      rect.y = point.y;
    } else if (point.y === 0) {
      rect.y = point.y - rect.height / 2;
    } else {
      rect.y = space.y + space.height - rect.height;
    }

    this.place(rect);
    return true;
  },

  /// update spaces by placing rectangle @rect and dividing up the space(s) it
  /// falls in
  place(rect) {
    // break up any spaces that rect falls into, concatting them into spaces
    const newSpaces = [];

    for (const i in this.spaces) {
      const newbies = this.spaces[i].getFreeRects(rect);

      for (const j in newbies) {
        newSpaces.push(newbies[j]);
      }
    } // consolidate spaces by omitting any space that is fully contained by
    // another space


    this.spaces = newSpaces.filter(function (rect, index) {
      for (let i = 0; i < newSpaces.length; i++) {
        const doesItContain = newSpaces[i].contains(rect); // compare against index to not compare rect against itself

        if (index !== i && doesItContain) {
          return false;
        }
      }

      return true;
    }); // sort the spaces by their distance to the origin. this is the order the
    // next object to be packed will visit the spaces

    this.spaces.sort(function (rectA, rectB) {
      return rectA.distanceToOrigin() - rectB.distanceToOrigin();
    });
  }

}; /// Packer object will take in recangles and assign them coordinates
/// @geometryService - service used to get bounding boxes on tray bodies
/// @tessellationMap - map of tessellations used in current tray
/// @buildArea - width and height of the build area
/// @innerGutter - how much padding each object gets when placed
/// @currentTray - the tray we're packing bodies into
/// @standIns - the objects we're adding to the build plate
/// @restrictToSingleTray - create additional trays as we need them
/// @getNextTray - function that returns the next tray we have to package
/// @projectState - the state of the current project

const Packer = function (geometryService, tessellationMap, buildArea, innerGutter, currentTray, standIns, restrictToSingleTray, getNextTray, projectState) {
  // save the geom service, tess map, inner gutter, and tray
  // TODO - inner gutter should come from tray settings?
  this.geometryService = geometryService;
  this.tessellationMap = tessellationMap;
  this.innerGutter = innerGutter; // store the build area argument and generate the first buildplate

  this.restrictToSingleTray = restrictToSingleTray;
  this.buildArea = buildArea;
  this.buildplate = new Buildplate(this.buildArea, this.restrictToSingleTray);
  this.tray = currentTray;
  this.getNextTray = getNextTray;
  this.projectState = projectState; // sort the stand ins and store that at this.standIns
  // TODO - think about different ways to sort

  this.standIns = standIns.sort(function (standInA, standInB) {
    const sizeA = standInA.getSize();
    const areaA = sizeA.x * sizeA.y;
    const sizeB = standInB.getSize();
    const areaB = sizeB.x * sizeB.y;

    if (areaA > areaB) {
      return -1;
    } else if (areaA === areaB) {
      return 0;
    } else {
      return 1;
    }
  });
};

Packer.prototype = {
  constructor: Packer,

  /// itterate through our tray, and place it into our "buildplate"
  _placeTrayBodies() {
    const self = this;
    self.tray.getTrayBodies().forEach(function (tb) {
      // get the tessellation for this object and grab its bounding box
      const tessellation = self.tessellationMap.get(tb.getOccurrence().getTessellationKey());
      const trayBodyBoundingBox = self.geometryService.getBounds(tb.getOccurrence(), tb.getTransform(), tessellation);
      const min = trayBodyBoundingBox.min;
      const max = trayBodyBoundingBox.max; // create a new rect with the same size as the bounding box, and place it

      self.buildplate.place(new Rect(min.x - self.innerGutter, min.y - self.innerGutter, max.x - min.x + 2 * self.innerGutter, max.y - min.y + 2 * self.innerGutter));
    });
  },

  /// Create a new (empty) buildplate object and store it in this.buildplate.
  /// Use the getNextTray function and reassign this.tray.
  _incrementTray() {
    const self = this;
    self.buildplate = new Buildplate(self.buildArea, self.restrictToSingleTray);
    const trayState = self.getNextTray(self.tray, self.projectState);
    self.tray = trayState.nextTray;
    self.projectState = trayState.newProjectState;
  },

  /// pack the stand ins and place them in spaces. once they are packed,
  /// translate the stand ins and add them to the tray.
  ///
  /// @returns {this.tray} - modified filled tray
  arrangeTray() {
    const self = this;
    return q.Promise(function (resolve, reject) {
      try {
        // create an object to store stand ins that won't fit onto the current tray
        let leftoverStandIns; // while we have stand ins that haven't been placed yet

        while (self.standIns.length > 0) {
          // reset leftoverStandIns to an empty array
          leftoverStandIns = []; // place all of the bodies in the current tray in the current
          // buildplate

          self._placeTrayBodies(); // try to place each stand in in the current buildplate


          for (const i in self.standIns) {
            // get the stand ins bounding box and create a Rect for it, adding in
            // the inner gutter to the height and width.
            const standIn = self.standIns[i];
            const size = standIn.getSize();
            const rect = new Rect(0, 0, size.x + self.innerGutter * 2, size.y + self.innerGutter * 2); // try to pack the bounding rect in the corresponding buildplate.
            // if successful, set the transformation for this standin, and add
            // it to the current tray

            if (self.buildplate.pack(rect)) {
              // extract the shift in (x, y) from the rect, apply it to the stand in
              // and add the stand in to the tray.
              standIn.setTransform(Transform.createTranslationXform(rect.x + self.innerGutter, rect.y + self.innerGutter, 0));
              self.tray = standIn.addBodiesToTray(self.tray).newTray;
            } else {
              // if the stand in doesn't fit on the current buildplate, store
              // it for the next one
              leftoverStandIns.push(standIn);
            }
          } // reset standins to the an array of only the ones that didnt fit


          self.standIns = leftoverStandIns;

          if (self.standIns.length > 0) {
            // if we still have stand ins, create another buildplate and tray to
            // add them to.
            self._incrementTray();
          }
        }

        resolve(self.projectState.setTray(self.tray));
      } catch (err) {
        reject(err);
      }
    });
  }

};

class MBComposer extends ComposeProvider {
  constructor(geometryService) {
    super(geometryService);
  }

  arrangeStandIns(standIns, projectState, tessellationMap, currentTray, restrictToSingleTray, getNextTray) {
    // get the envelope size and subtract the outer gutter from x and y,
    // resulting in the total build area
    const envelopeSize = projectState.getBuildEnvelope().getDimensions();
    const outerGutter = 0.00635;
    const buildArea = {
      x: envelopeSize.x - outerGutter * 2,
      y: envelopeSize.y - outerGutter * 2
    }; // set the inner gutter

    const innerGutter = 0.002; // create a promise with a resolve and reject (maybe an update soon?)

    const self = this; // create compose helper that we're using

    const packer = new Packer(self.geometryService, tessellationMap, buildArea, innerGutter, currentTray, standIns, restrictToSingleTray, getNextTray, projectState);
    return packer.arrangeTray();
  }

  accept(composeData) {
    return composeData.projectState.getGender().getVendor() === 'MakerBot';
  }

}

module.exports = MBComposer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1iX3F1aWNrX2NvbXBvc2VyLmpzIl0sIm5hbWVzIjpbInEiLCJyZXF1aXJlIiwiXyIsIkNvbXBvc2VQcm92aWRlciIsIlRyYW5zZm9ybSIsIlJlY3QiLCJ4IiwieSIsInciLCJoIiwicm91bmQiLCJ3aWR0aCIsImhlaWdodCIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIiwiY29udGFpbnMiLCJyZWN0Iiwib3ZlcmxhcHMiLCJ0aGlzTGVmdCIsInRoaXNSaWdodCIsInRoaXNCb3R0b20iLCJ0aGlzVG9wIiwidGhhdExlZnQiLCJ0aGF0UmlnaHQiLCJ0aGF0Qm90dG9tIiwidGhhdFRvcCIsInVuaW9uIiwibGVmdCIsImJvdHRvbSIsImdldEZyZWVSZWN0cyIsImZyZWVSZWN0cyIsImJvdW5kc0xlZnQiLCJib3VuZHNSaWdodCIsImJvdW5kc0JvdHRvbSIsImJvdW5kc1RvcCIsImN1dG91dExlZnQiLCJjdXRvdXRSaWdodCIsImN1dG91dEJvdHRvbSIsImN1dG91dFRvcCIsInB1c2giLCJjYW5GaXQiLCJkaXN0YW5jZVRvT3JpZ2luIiwicG9pbnQiLCJjbG9zZXN0UG9pbnRUb09yaWdpbiIsIk1hdGgiLCJzcXJ0IiwibWF4IiwiQnVpbGRwbGF0ZSIsImJ1aWxkQXJlYSIsImFsbG93T3V0c2lkZU9mQm91bmRzIiwiYnVpbGRSZWN0IiwiaHVnZSIsInNwYWNlcyIsInBhY2siLCJzZWxmIiwiZmlyc3RGaXRTcGFjZSIsImkiLCJzcGFjZSIsInNwYWNlT25QbGF0ZSIsIl9wbGFjZVJlY3RJblNwYWNlIiwiX2lzRW1wdHkiLCJFcnJvciIsImxlbmd0aCIsInBsYWNlIiwibmV3U3BhY2VzIiwibmV3YmllcyIsImoiLCJmaWx0ZXIiLCJpbmRleCIsImRvZXNJdENvbnRhaW4iLCJzb3J0IiwicmVjdEEiLCJyZWN0QiIsIlBhY2tlciIsImdlb21ldHJ5U2VydmljZSIsInRlc3NlbGxhdGlvbk1hcCIsImlubmVyR3V0dGVyIiwiY3VycmVudFRyYXkiLCJzdGFuZElucyIsInJlc3RyaWN0VG9TaW5nbGVUcmF5IiwiZ2V0TmV4dFRyYXkiLCJwcm9qZWN0U3RhdGUiLCJidWlsZHBsYXRlIiwidHJheSIsInN0YW5kSW5BIiwic3RhbmRJbkIiLCJzaXplQSIsImdldFNpemUiLCJhcmVhQSIsInNpemVCIiwiYXJlYUIiLCJfcGxhY2VUcmF5Qm9kaWVzIiwiZ2V0VHJheUJvZGllcyIsImZvckVhY2giLCJ0YiIsInRlc3NlbGxhdGlvbiIsImdldCIsImdldE9jY3VycmVuY2UiLCJnZXRUZXNzZWxsYXRpb25LZXkiLCJ0cmF5Qm9keUJvdW5kaW5nQm94IiwiZ2V0Qm91bmRzIiwiZ2V0VHJhbnNmb3JtIiwibWluIiwiX2luY3JlbWVudFRyYXkiLCJ0cmF5U3RhdGUiLCJuZXh0VHJheSIsIm5ld1Byb2plY3RTdGF0ZSIsImFycmFuZ2VUcmF5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJsZWZ0b3ZlclN0YW5kSW5zIiwic3RhbmRJbiIsInNpemUiLCJzZXRUcmFuc2Zvcm0iLCJjcmVhdGVUcmFuc2xhdGlvblhmb3JtIiwiYWRkQm9kaWVzVG9UcmF5IiwibmV3VHJheSIsInNldFRyYXkiLCJlcnIiLCJNQkNvbXBvc2VyIiwiYXJyYW5nZVN0YW5kSW5zIiwiZW52ZWxvcGVTaXplIiwiZ2V0QnVpbGRFbnZlbG9wZSIsImdldERpbWVuc2lvbnMiLCJvdXRlckd1dHRlciIsInBhY2tlciIsImFjY2VwdCIsImNvbXBvc2VEYXRhIiwiZ2V0R2VuZGVyIiwiZ2V0VmVuZG9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsTUFBTUEsQ0FBQyxHQUFHQyxPQUFPLENBQUMsR0FBRCxDQUFqQjs7QUFDQSxNQUFNQyxDQUFDLEdBQUdELE9BQU8sQ0FBQyxRQUFELENBQWpCOztBQUNBLE1BQU1FLGVBQWUsR0FBR0YsT0FBTyxDQUFDLGlEQUFELENBQS9COztBQUNBLE1BQU1HLFNBQVMsR0FBR0gsT0FBTyxDQUFDLDZCQUFELENBQXpCLEMsQ0FFQTs7O0FBQ0Es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QyxRQU5XLEVBT1hDLG9CQVBXLEVBUVhDLFdBUlcsRUFTWEMsWUFUVyxDQUFmO0FBWUEsV0FBTzZDLE1BQU0sQ0FBQ25CLFdBQVAsRUFBUDtBQUNIOztBQUVEb0IsRUFBQUEsTUFBTSxDQUFDQyxXQUFELEVBQWM7QUFDaEIsV0FBT0EsV0FBVyxDQUFDL0MsWUFBWixDQUF5QmdELFNBQXpCLEdBQXFDQyxTQUFyQyxPQUFxRCxVQUE1RDtBQUNIOztBQXZDb0M7O0FBMEN6Q0MsTUFBTSxDQUFDQyxPQUFQLEdBQWlCWixVQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IHEgPSByZXF1aXJlKCdxJyk7XHJcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuY29uc3QgQ29tcG9zZVByb3ZpZGVyID0gcmVxdWlyZSgnZWFnbGUtcHJpbnQvc2VydmljZXMvcHJvdmlkZXJzL2NvbXBvc2VfcHJvdmlkZXInKTtcclxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSgnZWFnbGUtcHJpbnQvbW9kZWwvdHJhbnNmb3JtJyk7XHJcblxyXG4vLy8gUmVjdCBvYmplY3QgdGhhdCB3aWxsIHJlcCB0aGUgYm91bmRpbmcgYm94ZXMgb2Ygb3VyIG9iamVjdHMgdG8gcGxhdGVcclxuY29uc3QgUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcclxuICAgIHRoaXMueCA9IF8ucm91bmQoeCwgNik7XHJcbiAgICB0aGlzLnkgPSBfLnJvdW5kKHksIDYpO1xyXG4gICAgdGhpcy53aWR0aCA9IF8ucm91bmQodywgNik7XHJcbiAgICB0aGlzLmhlaWdodCA9IF8ucm91bmQoaCwgNik7XHJcbn07XHJcblxyXG5SZWN0LnByb3RvdHlwZSA9IHtcclxuICAgIGNvbnN0cnVjdG9yOiBSZWN0LFxyXG5cclxuICAgIC8vLyBkb2VzIHRoaXMgcmVjdGFuZ2xlIGZ1bGx5IGNvbnRhaW4gdGhlIHJlY3RhbmdsZSBAcmVjdFxyXG4gICAgLy8vIEByZXR1cm5zIHtib29sfVxyXG4gICAgY29udGFpbnMocmVjdCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMueCA8PSByZWN0LnggJiZcclxuICAgICAgICAgICAgdGhpcy55IDw9IHJlY3QueSAmJlxyXG4gICAgICAgICAgICB0aGlzLnggKyB0aGlzLndpZHRoID49IHJlY3QueCArIHJlY3Qud2lkdGggJiZcclxuICAgICAgICAgICAgdGhpcy55ICsgdGhpcy5oZWlnaHQgPj0gcmVjdC55ICsgcmVjdC5oZWlnaHRcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLy8gZG9lcyB0aGlzIHJlY3RhbmdsZSBvdmVybGFwIHdpdGggdGhlIHJlY2F0YW5nbGUgQHJlY3RcclxuICAgIC8vLyBAcmV0dXJucyB7Ym9vbH1cclxuICAgIG92ZXJsYXBzKHJlY3QpIHtcclxuICAgICAgICAvLyBzZXR1cCB0aGUgbGVmdCwgcmlnaHQsIGJvdHRvbSBhbmQgdG9wIGZvciB0aGlzIHJlY3RcclxuICAgICAgICBjb25zdCB0aGlzTGVmdCA9IHRoaXMueDtcclxuICAgICAgICBjb25zdCB0aGlzUmlnaHQgPSB0aGlzLnggKyB0aGlzLndpZHRoO1xyXG4gICAgICAgIGNvbnN0IHRoaXNCb3R0b20gPSB0aGlzLnk7XHJcbiAgICAgICAgY29uc3QgdGhpc1RvcCA9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBzZXR1cCB0aGUgc2FtZSBmb3IgdGhlIHJlY3RcclxuICAgICAgICBjb25zdCB0aGF0TGVmdCA9IHJlY3QueDtcclxuICAgICAgICBjb25zdCB0aGF0UmlnaHQgPSByZWN0LnggKyByZWN0LndpZHRoO1xyXG4gICAgICAgIGNvbnN0IHRoYXRCb3R0b20gPSByZWN0Lnk7XHJcbiAgICAgICAgY29uc3QgdGhhdFRvcCA9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBmdW4gZ2VvbWV0cnkgdHJpY2sgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMDYzMzJcclxuICAgICAgICByZXR1cm4gdGhpc0xlZnQgPCB0aGF0UmlnaHQgJiYgdGhpc1JpZ2h0ID4gdGhhdExlZnQgJiYgdGhpc0JvdHRvbSA8IHRoYXRUb3AgJiYgdGhpc1RvcCA+IHRoYXRCb3R0b207XHJcbiAgICB9LFxyXG5cclxuICAgIC8vLyB1bmlvbiB0aGlzIHJlY3RhbmdsZSB3aXRoIEByZWN0IGFuZCBAcmV0dXJuIGEgbmV3IHJlY3QgdGhhdCBpcyB0aGVpclxyXG4gICAgLy8vIG92ZXJsYXAuXHJcbiAgICB1bmlvbihyZWN0KSB7XHJcbiAgICAgICAgY29uc3QgdGhpc0xlZnQgPSB0aGlzLng7XHJcbiAgICAgICAgY29uc3QgdGhpc1JpZ2h0ID0gdGhpcy54ICsgdGhpcy53aWR0aDtcclxuICAgICAgICBjb25zdCB0aGlzQm90dG9tID0gdGhpcy55O1xyXG4gICAgICAgIGNvbnN0IHRoaXNUb3AgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gc2V0dXAgdGhlIHNhbWUgZm9yIHRoZSByZWN0XHJcbiAgICAgICAgY29uc3QgdGhhdExlZnQgPSByZWN0Lng7XHJcbiAgICAgICAgY29uc3QgdGhhdFJpZ2h0ID0gcmVjdC54ICsgcmVjdC53aWR0aDtcclxuICAgICAgICBjb25zdCB0aGF0Qm90dG9tID0gcmVjdC55O1xyXG4gICAgICAgIGNvbnN0IHRoYXRUb3AgPSByZWN0LnkgKyByZWN0LmhlaWdodDtcclxuXHJcbiAgICAgICAgY29uc3QgbGVmdCA9IHRoaXNMZWZ0ID4gdGhhdExlZnQgPyB0aGlzTGVmdCA6IHRoYXRMZWZ0O1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpc1JpZ2h0IDwgdGhhdFJpZ2h0ID8gdGhpc1JpZ2h0IC0gbGVmdCA6IHRoYXRSaWdodCAtIGxlZnQ7XHJcbiAgICAgICAgY29uc3QgYm90dG9tID0gdGhpc0JvdHRvbSA+IHRoYXRCb3R0b20gPyB0aGlzQm90dG9tIDogdGhhdEJvdHRvbTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzVG9wIDwgdGhhdFRvcCA/IHRoaXNUb3AgLSBib3R0b20gOiB0aGF0VG9wIC0gYm90dG9tO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFJlY3QobGVmdCwgYm90dG9tLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8vIGJyZWFrIHRoaXMgcmVjdGFuZ2UgaW50byBhbiBhcnJheSBvZiBzbWFsbGVyIG9uZXMsIG1pc3NpbmcgdGhlIGFyZWEgYm91bmRcclxuICAgIC8vLyBieSBAcmVjdC4gdGhlIHJlY3RhbmdsZXMgaW4gdGhhdCBhcnJheSBtYXkgb3ZlcmxhcC5cclxuICAgIC8vLyBAcmV0dXJucyB7QXJyYXkgb2YgUmVjdH1cclxuICAgIGdldEZyZWVSZWN0cyhyZWN0KSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIHJlY3QgZG9lc24ndCBvdmVybGFwLCBqdXN0IHJldHVybiB0aGlzIHJlY3RhbmdsZVxyXG4gICAgICAgIGlmICghdGhpcy5vdmVybGFwcyhyZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZnJlZVJlY3RzID0gW107XHJcblxyXG4gICAgICAgIC8vIHNldHVwIHRoZSBsZWZ0LCByaWdodCwgYm90dG9tIGFuZCB0b3AgZm9yIHRoaXMgcmVjdFxyXG4gICAgICAgIGNvbnN0IGJvdW5kc0xlZnQgPSB0aGlzLng7XHJcbiAgICAgICAgY29uc3QgYm91bmRzUmlnaHQgPSB0aGlzLnggKyB0aGlzLndpZHRoO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kc0JvdHRvbSA9IHRoaXMueTtcclxuICAgICAgICBjb25zdCBib3VuZHNUb3AgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gc2V0dXAgdGhlIHNhbWUgZm9yIHRoZSByZWN0XHJcbiAgICAgICAgY29uc3QgY3V0b3V0TGVmdCA9IHJlY3QueDtcclxuICAgICAgICBjb25zdCBjdXRvdXRSaWdodCA9IHJlY3QueCArIHJlY3Qud2lkdGg7XHJcbiAgICAgICAgY29uc3QgY3V0b3V0Qm90dG9tID0gcmVjdC55O1xyXG4gICAgICAgIGNvbnN0IGN1dG91dFRvcCA9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBib3R0b21cclxuICAgICAgICBpZiAoYm91bmRzQm90dG9tIDwgY3V0b3V0Qm90dG9tKSB7XHJcbiAgICAgICAgICAgIGZyZWVSZWN0cy5wdXNoKG5ldyBSZWN0KGJvdW5kc0xlZnQsIGJvdW5kc0JvdHRvbSwgYm91bmRzUmlnaHQgLSBib3VuZHNMZWZ0LCBjdXRvdXRCb3R0b20gLSBib3VuZHNCb3R0b20pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJpZ2h0XHJcbiAgICAgICAgaWYgKGJvdW5kc1JpZ2h0ID4gY3V0b3V0UmlnaHQpIHtcclxuICAgICAgICAgICAgZnJlZVJlY3RzLnB1c2gobmV3IFJlY3QoY3V0b3V0UmlnaHQsIGJvdW5kc0JvdHRvbSwgYm91bmRzUmlnaHQgLSBjdXRvdXRSaWdodCwgYm91bmRzVG9wIC0gYm91bmRzQm90dG9tKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0b3BcclxuICAgICAgICBpZiAoYm91bmRzVG9wID4gY3V0b3V0VG9wKSB7XHJcbiAgICAgICAgICAgIGZyZWVSZWN0cy5wdXNoKG5ldyBSZWN0KGJvdW5kc0xlZnQsIGN1dG91dFRvcCwgYm91bmRzUmlnaHQgLSBib3VuZHNMZWZ0LCBib3VuZHNUb3AgLSBjdXRvdXRUb3ApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGxlZnRcclxuICAgICAgICBpZiAoYm91bmRzTGVmdCA8IGN1dG91dExlZnQpIHtcclxuICAgICAgICAgICAgZnJlZVJlY3RzLnB1c2gobmV3IFJlY3QoYm91bmRzTGVmdCwgYm91bmRzQm90dG9tLCBjdXRvdXRMZWZ0IC0gYm91bmRzTGVmdCwgYm91bmRzVG9wIC0gYm91bmRzQm90dG9tKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnJlZVJlY3RzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLy8gY2FuIHRoaXMgcmVjdGFuZ2xlIGZpdCBAcmVjdCBpbnNpZGUgb2YgaXRcclxuICAgIC8vLyBAcmV0dXJucyB7Ym9vbH1cclxuICAgIGNhbkZpdChyZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPj0gcmVjdC53aWR0aCAmJiB0aGlzLmhlaWdodCA+PSByZWN0LmhlaWdodDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8vIGdldCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgb3JnaW4gKDAsIDApIHRvIHRoZSBjbG9zZXN0IHBvaW50IG9mIHRoaXNcclxuICAgIC8vLyByZWN0YW5nbGUuXHJcbiAgICAvLy9cclxuICAgIC8vLyBAcmV0dXJucyB7ZmxvYXQ/fVxyXG4gICAgZGlzdGFuY2VUb09yaWdpbigpIHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuY2xvc2VzdFBvaW50VG9PcmlnaW4oKTtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHBvaW50LnggKiBwb2ludC54ICsgcG9pbnQueSAqIHBvaW50LnkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLy8gZ2V0IHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBvcmlnaW4gKDAsIDApIG9uIHRoaXMgcmVjdGFuZ2xlXHJcbiAgICAvLy8gQHJldHVybnMge3gsIHl9XHJcbiAgICBjbG9zZXN0UG9pbnRUb09yaWdpbigpIHtcclxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xODE1NzU1MVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IE1hdGgubWF4KHRoaXMueCwgMCwgLSh0aGlzLnggKyB0aGlzLndpZHRoKSksXHJcbiAgICAgICAgICAgIHk6IE1hdGgubWF4KHRoaXMueSwgMCwgLSh0aGlzLnkgKyB0aGlzLmhlaWdodCkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59O1xyXG5cclxuLy8vIE9uIG9iamVjdCByZXByZXNlbnRpbmcgYSBidWlsZCBhcmVhIHRoYXQgd2UgY2FuIHBsYWNlIHJlY3RhbmdsZXMgaW50b1xyXG5jb25zdCBCdWlsZHBsYXRlID0gZnVuY3Rpb24oYnVpbGRBcmVhLCBhbGxvd091dHNpZGVPZkJvdW5kcykge1xyXG4gICAgdGhpcy5hbGxvd091dHNpZGVPZkJvdW5kcyA9IGFsbG93T3V0c2lkZU9mQm91bmRzO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBzcGFjZXMgLSBhbiBhcnJheSBvZiByZWN0YW5nbGVzIHJlcHJlc2VudGluZyB0aGUgYnVpbGQgcGxhdGUsXHJcbiAgICAvLyBpbml0aWFsaXplIHdpdGggb25lIGluIGVhY2ggcXVhZHJlbnRcclxuICAgIGNvbnN0IHdpZHRoID0gYnVpbGRBcmVhLnggLyAyO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gYnVpbGRBcmVhLnkgLyAyO1xyXG4gICAgdGhpcy5idWlsZFJlY3QgPSBuZXcgUmVjdCgtd2lkdGgsIC1oZWlnaHQsIDIgKiB3aWR0aCwgMiAqIGhlaWdodCk7XHJcbiAgICBpZiAodGhpcy5hbGxvd091dHNpZGVPZkJvdW5kcykge1xyXG4gICAgICAgIC8vIGEgc29saWQga20geCBrbSBidWlsZCBwbGF0ZSBzaG91bGQgYmUgc3VmZmljaWVudGx5IGxhcmdlIHRvIGF2b2lkXHJcbiAgICAgICAgLy8gcHJvYmxlbXNcclxuICAgICAgICBjb25zdCBodWdlID0gMTAwMDtcclxuICAgICAgICB0aGlzLnNwYWNlcyA9IFtuZXcgUmVjdCgtaHVnZSAvIDIsIC1odWdlIC8gMiwgaHVnZSwgaHVnZSldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnNwYWNlcyA9IFt0aGlzLmJ1aWxkUmVjdF07XHJcbiAgICB9XHJcbn07XHJcblxyXG5CdWlsZHBsYXRlLnByb3RvdHlwZSA9IHtcclxuICAgIGNvbnN0cnVjdG9yOiBCdWlsZHBsYXRlLFxyXG5cclxuICAgIC8vLyBhZGQgYSBib3VuZGluZyBib3ggQHJlY3QgdG8gdGhpcyBidWlsZHBsYXRlLlxyXG4gICAgLy8vIEByZXR1cm4ge2Jvb2x9IC0gd2FzIHRoZSByZWN0IGFibGUgdG8gYmUgcGFja2VkIGluIHRoaXMgYnVpbGRwbGF0ZVxyXG4gICAgcGFjayhyZWN0KSB7XHJcbiAgICAgICAgLy8gZGVycFxyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAvLyB3ZSdsbCBzdG9yZSB0aGUgZmlyc3Qgc3BhY2Ugb3V0c2lkZSB0aGUgYnVpbGRwbGF0ZSB0aGF0IGNhbiBmaXQgb3VyIHJlY3RcclxuICAgICAgICAvLyBpZiB3ZSdyZSBhbGxvd2VkIHRvIHBsYWNlIGJvZGllcyB0aGVyZS5cclxuICAgICAgICBsZXQgZmlyc3RGaXRTcGFjZSA9IG51bGw7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgaSBpbiBzZWxmLnNwYWNlcykge1xyXG4gICAgICAgICAgICBjb25zdCBzcGFjZSA9IHNlbGYuc3BhY2VzW2ldO1xyXG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhpcyBzcGFjZSBjYW4gaG9sZCByZWN0XHJcbiAgICAgICAgICAgIGlmIChzcGFjZS5jYW5GaXQocmVjdCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFsbG93T3V0c2lkZU9mQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgYWxsb3dlZCB0byBwbGFjZSB0aGluZ3Mgb3V0c2lkZSBvZiB0aGUgYm91bmRzLCB0aGVuIHNvbWVcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3BhY2VzIGV4dGVuZCBiZXlvbmQgdGhlIGJ1aWxkIHBsYXRlLiBjaGVjayB0byBzZWUgaWYgdGhlIHVuaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIGJ1aWxkcGxhdGUgYW5kIHRoaXMgc3BhY2UgY2FuIGNvbnRhaW4gdGhpcyByZWN0LiBpZiBpdCBjYW5cclxuICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZSBpdCB0aGVyZSwgaWYgaXQgY2FuJ3Qgc3RvcmUgdGhlIGZpcnN0IHNwYWNlIHZpc2l0ZWQgaW4gY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbmUgb2Ygb3VyIHNwYWNlcyBjYW4gaG9sZCB0aGlzIHJlY3QuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhY2VPblBsYXRlID0gc3BhY2UudW5pb24oc2VsZi5idWlsZFJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFjZU9uUGxhdGUuY2FuRml0KHJlY3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3BsYWNlUmVjdEluU3BhY2Uoc3BhY2UsIHJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFmaXJzdEZpdFNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Rml0U3BhY2UgPSBzcGFjZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZW4ndCBhbGxvd2VkIHRvIHBsYWNlIHRoaW5ncyBvdXRzaWRlIG9mIHRoZSBib3VuZHMsIHRoZW5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVjdCBmaXR0aW5nIGluIHRoaXMgc3BhY2UgaXMgc3VmZmljaWVudC4gcGxhY2UgYW5kIGV4aXQuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGxhY2VSZWN0SW5TcGFjZShzcGFjZSwgcmVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZWxmLl9pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhpcyBidWlsZHBsYXRlIGlzIGVtcHR5LCBhbmQgdGhlIG1vZGVsIGRvZXNudCBmaXQgaW4gdGhlIHNvbGVcclxuICAgICAgICAgICAgLy8gc3BhY2UsIHRoZW4gcGxhY2UgaXQgaW4gdGhlIHNvbGUgc3BhY2UgYW55d2F5LCBzaW5jZSBpdCB3b24ndCBmaXQgb25cclxuICAgICAgICAgICAgLy8gYW55IHRyYXkgd2UgY3JlYXRlLlxyXG4gICAgICAgICAgICBzZWxmLl9wbGFjZVJlY3RJblNwYWNlKHNlbGYuc3BhY2VzWzBdLCByZWN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFsbG93T3V0c2lkZU9mQm91bmRzKSB7XHJcbiAgICAgICAgICAgIGlmICghZmlyc3RGaXRTcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzcGFjZSBmb3IgbW9kZWwgb24gY3VycmVudCB0cmF5LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHdlJyBhcmUgYWxsb3dlZCB0byBwbGFjZSBvdXRzaWRlIG9mIHRoZSBib3VuZHMsIGZpcnN0Rml0U3BhY2UgaXMgdGhlXHJcbiAgICAgICAgICAgIC8vIGZpcnN0IHNwYWNlIHdlIHZpc2l0ZWQgdGhhdCBjYW4gY29udGFpbiByZWN0LiBwbGFjZSB0aGUgcmVjdCB0aGVyZS5cclxuICAgICAgICAgICAgc2VsZi5fcGxhY2VSZWN0SW5TcGFjZShmaXJzdEZpdFNwYWNlLCByZWN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlbid0IGFsbG93ZWQgdG8gcGxhY2Ugb3V0c2lkZSBvZiB0aGUgYm91bmRzLCByZXR1cm4gZmFsc2Ugc2luY2VcclxuICAgICAgICAgICAgLy8gd2UgZGlkbid0IHBsYWNlIHRoZSByZWN0LlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLy8gQHJldHVybiB7Ym9vbH0gLSBpcyB0aGlzIGJ1aWxkcGxhdGUgZW1wdHk/XHJcbiAgICBfaXNFbXB0eSgpIHtcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gc2VsZi5zcGFjZXMubGVuZ3RoID09PSAxICYmIHNlbGYuc3BhY2VzWzBdLmNvbnRhaW5zKHNlbGYuYnVpbGRSZWN0KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8vIHBsYWNlIHRoZSByZWN0YW5nbGUgQHJlY3QgaW5zaWRlIG9mIEBzcGFjZSBzdWNoIHRoYXQgdGhlIGNlbnRlciBvZiBAcmVjdFxyXG4gICAgLy8vIGlzIGFzIGNsb3NlIHRvIHRoZSBvcmlnaW4gYXMgcG9zc2libGUuIHRoZW4gcGxhY2UgQHJlY3QgaW4gdGhpcy5zcGFjZXMuXHJcbiAgICBfcGxhY2VSZWN0SW5TcGFjZShzcGFjZSwgcmVjdCkge1xyXG4gICAgICAgIC8vIGdldCB0aGUgcG9pbnQgaW4gdGhlIHNwYWNlIGNsb3Nlc3QgdG8gdGhlIG9yaWdpblxyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gc3BhY2UuY2xvc2VzdFBvaW50VG9PcmlnaW4oKTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHJlY3QueCBzbyB0aGF0IHRoZSBjZW50ZXIgb2YgdGhlIHJlY3QgaXMgaXMgY2xvc2VzdCB0byBwb2ludFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gdGhlcmUgYXJlIHRocmVlIHBsYWNlcyB0aGF0IHdlIGNvdWxkIHdhbnQgb3VyIGJvdW5kaW5nIGJveCB0byBlbmQgdXBcclxuICAgICAgICAvLyBvbiB0aGUgeCBheGlzLCB0aGUgZXh0cmVtZSByaWdodCBhbmQgbGVmdCBvZiB0aGUgY3VycmVudCBzcGFjZSwgb3Igb25cclxuICAgICAgICAvLyB0aGUgeSBheGlzLiB3ZSBjYW4gZGV0ZXJtaW5lIHdoaWNoIG9uZSBiYXNlZCBvbiB0aGUgY2xvc2VzdCBwb2ludCBvZlxyXG4gICAgICAgIC8vIG91ciBzcGFjZSB0byB0aGUgb3JpZ2luLiB0aGUgc2FtZSBpcyBnb2luZyB0byBiZSB0cnVlIGZvciB0aGUgeSBheGlzXHJcbiAgICAgICAgLy8gaW4gdGhlIG5leHQgYmxvY2sgb2YgY29kZS5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIExFR0VORFxyXG4gICAgICAgIC8vICsgLSAoMCAsIDApIG9yaWdpblxyXG4gICAgICAgIC8vICogLSBwb2ludCBpbiB0aGUgY3VycmVudCBzcGFjZSBjbG9zZXN0IHRvIG9yaWdpblxyXG4gICAgICAgIC8vICMgLSByaWdodCBlZGdlIG9mIGEgc3BhY2VcclxuICAgICAgICAvLyBAIC0gbGVmdCBlZGdlIG9mIGEgc3BhY2VcclxuICAgICAgICAvLyAkIC0geCA9IDBcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIEVYQU1QTEUgV0hFUkUgV0UgV0FOVCBYID0gMCAtIHJlY3Qud2lkdGggLyAyXHJcbiAgICAgICAgLy8gcG9pbnQgPSAoMCwgLTIpXHJcbiAgICAgICAgLy8gcmVjdCA9IHsgd2lkdGg6OCwgaGVpZ2h0OjMgfVxyXG4gICAgICAgIC8vIHNwYWNlID0geyB4Oi0zNCAsIHk6LTcsIHdpZHRoOjY4LCBoZWlnaHQ6NSB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAvLyB8ICBvYmplY3QgYWxyZWFkeSBoZXJlIC0+ICAgfCAgICAgKyAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuICAgICAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+fn4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+ICAgICAgIH4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAvLyAjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkfn5+fn5+fn4gICAgICAgICAgICAgICAgICAgICBAICAgICAgIHxcclxuICAgICAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAvLyAgICAgICAgc3BhY2Ugd2UncmUgZ29pbmcgdG8gZmlsbCBeXHJcblxyXG4gICAgICAgIC8vIEVYQU1QTEUgV0hFUkUgV0UgV0FOVCBYID0gc3BhY2UueFxyXG4gICAgICAgIC8vIHBvaW50ID0gKDUsIDApXHJcbiAgICAgICAgLy8gcmVjdCA9IHsgd2lkdGg6IDgsIGhlaWdodDogMyB9XHJcbiAgICAgICAgLy8gc3BhY2UgPSB7IHg6NSwgeTotNywgd2lkdGg6MzAsIGhlaWdodDoxNCB9XHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgc3BhY2Ugd2UncmUgZ29pbmcgdG8gZmlsbCAtPiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgb2JqZWN0IGFscmVhZHkgaGVyZSAtPiAgIHwgICAgICsgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfH5+fn5+fn4gICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIH4gICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCAgICAgICAgI35+fn5+fn4gICAgICAgICAgICAgQCAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgICAgIC8vIEVYQU1QTEUgV0hFUkUgV0UgV0FOVCB4ID0gc3BhY2UueCArIHNwYWNlLndpZHRoIC0gcmVjdC53aWR0aFxyXG4gICAgICAgIC8vIHBvaW50ID0gKC01LCAwKVxyXG4gICAgICAgIC8vIHJlY3QgPSB7IHdpZHRoOiA4LCBoZWlnaHQ6IDMgfVxyXG4gICAgICAgIC8vIHNwYWNlID0geyB4Oi0zNCwgeTotNywgd2lkdGg6MzAsIGhlaWdodDoxNCB9XHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgPC0gc3BhY2Ugd2UncmUgZ29pbmcgdG8gZmlsbCAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICsgICAgfCA8LSBvYmplY3QgYWxyZWFkeSBoZXJlICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgfn5+fn5+fnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgfiAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gIyAgICAgICAgICAgICAgICAgICAgQH5+fn5+fnwgJCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgICAgIGlmIChwb2ludC54ID09PSBzcGFjZS54KSB7XHJcbiAgICAgICAgICAgIHJlY3QueCA9IHNwYWNlLng7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludC54ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJlY3QueCA9IHBvaW50LnggLSByZWN0LndpZHRoIC8gMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZWN0LnggPSBzcGFjZS54ICsgc3BhY2Uud2lkdGggLSByZWN0LndpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2V0IHJlY3QueSBzbyB0aGF0IHRoZSBjZW50ZXIgb2YgdGhlIHJlY3QgaXMgY2xvc2VzdCB0byB0aGUgcG9pbnRcclxuICAgICAgICBpZiAocG9pbnQueSA9PT0gc3BhY2UueSkge1xyXG4gICAgICAgICAgICByZWN0LnkgPSBwb2ludC55O1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnQueSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZWN0LnkgPSBwb2ludC55IC0gcmVjdC5oZWlnaHQgLyAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlY3QueSA9IHNwYWNlLnkgKyBzcGFjZS5oZWlnaHQgLSByZWN0LmhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucGxhY2UocmVjdCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vLyB1cGRhdGUgc3BhY2VzIGJ5IHBsYWNpbmcgcmVjdGFuZ2xlIEByZWN0IGFuZCBkaXZpZGluZyB1cCB0aGUgc3BhY2UocykgaXRcclxuICAgIC8vLyBmYWxscyBpblxyXG4gICAgcGxhY2UocmVjdCkge1xyXG4gICAgICAgIC8vIGJyZWFrIHVwIGFueSBzcGFjZXMgdGhhdCByZWN0IGZhbGxzIGludG8sIGNvbmNhdHRpbmcgdGhlbSBpbnRvIHNwYWNlc1xyXG4gICAgICAgIGNvbnN0IG5ld1NwYWNlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnNwYWNlcykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdiaWVzID0gdGhpcy5zcGFjZXNbaV0uZ2V0RnJlZVJlY3RzKHJlY3QpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGogaW4gbmV3Ymllcykge1xyXG4gICAgICAgICAgICAgICAgbmV3U3BhY2VzLnB1c2gobmV3Ymllc1tqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGlkYXRlIHNwYWNlcyBieSBvbWl0dGluZyBhbnkgc3BhY2UgdGhhdCBpcyBmdWxseSBjb250YWluZWQgYnlcclxuICAgICAgICAvLyBhbm90aGVyIHNwYWNlXHJcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBuZXdTcGFjZXMuZmlsdGVyKGZ1bmN0aW9uKHJlY3QsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3BhY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb2VzSXRDb250YWluID0gbmV3U3BhY2VzW2ldLmNvbnRhaW5zKHJlY3QpO1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcGFyZSBhZ2FpbnN0IGluZGV4IHRvIG5vdCBjb21wYXJlIHJlY3QgYWdhaW5zdCBpdHNlbGZcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gaSAmJiBkb2VzSXRDb250YWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBzb3J0IHRoZSBzcGFjZXMgYnkgdGhlaXIgZGlzdGFuY2UgdG8gdGhlIG9yaWdpbi4gdGhpcyBpcyB0aGUgb3JkZXIgdGhlXHJcbiAgICAgICAgLy8gbmV4dCBvYmplY3QgdG8gYmUgcGFja2VkIHdpbGwgdmlzaXQgdGhlIHNwYWNlc1xyXG4gICAgICAgIHRoaXMuc3BhY2VzLnNvcnQoZnVuY3Rpb24ocmVjdEEsIHJlY3RCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0QS5kaXN0YW5jZVRvT3JpZ2luKCkgLSByZWN0Qi5kaXN0YW5jZVRvT3JpZ2luKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG59O1xyXG5cclxuLy8vIFBhY2tlciBvYmplY3Qgd2lsbCB0YWtlIGluIHJlY2FuZ2xlcyBhbmQgYXNzaWduIHRoZW0gY29vcmRpbmF0ZXNcclxuLy8vIEBnZW9tZXRyeVNlcnZpY2UgLSBzZXJ2aWNlIHVzZWQgdG8gZ2V0IGJvdW5kaW5nIGJveGVzIG9uIHRyYXkgYm9kaWVzXHJcbi8vLyBAdGVzc2VsbGF0aW9uTWFwIC0gbWFwIG9mIHRlc3NlbGxhdGlvbnMgdXNlZCBpbiBjdXJyZW50IHRyYXlcclxuLy8vIEBidWlsZEFyZWEgLSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBidWlsZCBhcmVhXHJcbi8vLyBAaW5uZXJHdXR0ZXIgLSBob3cgbXVjaCBwYWRkaW5nIGVhY2ggb2JqZWN0IGdldHMgd2hlbiBwbGFjZWRcclxuLy8vIEBjdXJyZW50VHJheSAtIHRoZSB0cmF5IHdlJ3JlIHBhY2tpbmcgYm9kaWVzIGludG9cclxuLy8vIEBzdGFuZElucyAtIHRoZSBvYmplY3RzIHdlJ3JlIGFkZGluZyB0byB0aGUgYnVpbGQgcGxhdGVcclxuLy8vIEByZXN0cmljdFRvU2luZ2xlVHJheSAtIGNyZWF0ZSBhZGRpdGlvbmFsIHRyYXlzIGFzIHdlIG5lZWQgdGhlbVxyXG4vLy8gQGdldE5leHRUcmF5IC0gZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHRyYXkgd2UgaGF2ZSB0byBwYWNrYWdlXHJcbi8vLyBAcHJvamVjdFN0YXRlIC0gdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IHByb2plY3RcclxuY29uc3QgUGFja2VyID0gZnVuY3Rpb24oXHJcbiAgICBnZW9tZXRyeVNlcnZpY2UsXHJcbiAgICB0ZXNzZWxsYXRpb25NYXAsXHJcbiAgICBidWlsZEFyZWEsXHJcbiAgICBpbm5lckd1dHRlcixcclxuICAgIGN1cnJlbnRUcmF5LFxyXG4gICAgc3RhbmRJbnMsXHJcbiAgICByZXN0cmljdFRvU2luZ2xlVHJheSxcclxuICAgIGdldE5leHRUcmF5LFxyXG4gICAgcHJvamVjdFN0YXRlXHJcbikge1xyXG4gICAgLy8gc2F2ZSB0aGUgZ2VvbSBzZXJ2aWNlLCB0ZXNzIG1hcCwgaW5uZXIgZ3V0dGVyLCBhbmQgdHJheVxyXG4gICAgLy8gVE9ETyAtIGlubmVyIGd1dHRlciBzaG91bGQgY29tZSBmcm9tIHRyYXkgc2V0dGluZ3M/XHJcbiAgICB0aGlzLmdlb21ldHJ5U2VydmljZSA9IGdlb21ldHJ5U2VydmljZTtcclxuICAgIHRoaXMudGVzc2VsbGF0aW9uTWFwID0gdGVzc2VsbGF0aW9uTWFwO1xyXG4gICAgdGhpcy5pbm5lckd1dHRlciA9IGlubmVyR3V0dGVyO1xyXG5cclxuICAgIC8vIHN0b3JlIHRoZSBidWlsZCBhcmVhIGFyZ3VtZW50IGFuZCBnZW5lcmF0ZSB0aGUgZmlyc3QgYnVpbGRwbGF0ZVxyXG4gICAgdGhpcy5yZXN0cmljdFRvU2luZ2xlVHJheSA9IHJlc3RyaWN0VG9TaW5nbGVUcmF5O1xyXG4gICAgdGhpcy5idWlsZEFyZWEgPSBidWlsZEFyZWE7XHJcbiAgICB0aGlzLmJ1aWxkcGxhdGUgPSBuZXcgQnVpbGRwbGF0ZSh0aGlzLmJ1aWxkQXJlYSwgdGhpcy5yZXN0cmljdFRvU2luZ2xlVHJheSk7XHJcbiAgICB0aGlzLnRyYXkgPSBjdXJyZW50VHJheTtcclxuICAgIHRoaXMuZ2V0TmV4dFRyYXkgPSBnZXROZXh0VHJheTtcclxuICAgIHRoaXMucHJvamVjdFN0YXRlID0gcHJvamVjdFN0YXRlO1xyXG5cclxuICAgIC8vIHNvcnQgdGhlIHN0YW5kIGlucyBhbmQgc3RvcmUgdGhhdCBhdCB0aGlzLnN0YW5kSW5zXHJcbiAgICAvLyBUT0RPIC0gdGhpbmsgYWJvdXQgZGlmZmVyZW50IHdheXMgdG8gc29ydFxyXG4gICAgdGhpcy5zdGFuZElucyA9IHN0YW5kSW5zLnNvcnQoZnVuY3Rpb24oc3RhbmRJbkEsIHN0YW5kSW5CKSB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZUEgPSBzdGFuZEluQS5nZXRTaXplKCk7XHJcbiAgICAgICAgY29uc3QgYXJlYUEgPSBzaXplQS54ICogc2l6ZUEueTtcclxuICAgICAgICBjb25zdCBzaXplQiA9IHN0YW5kSW5CLmdldFNpemUoKTtcclxuICAgICAgICBjb25zdCBhcmVhQiA9IHNpemVCLnggKiBzaXplQi55O1xyXG5cclxuICAgICAgICBpZiAoYXJlYUEgPiBhcmVhQikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhcmVhQSA9PT0gYXJlYUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5QYWNrZXIucHJvdG90eXBlID0ge1xyXG4gICAgY29uc3RydWN0b3I6IFBhY2tlcixcclxuXHJcbiAgICAvLy8gaXR0ZXJhdGUgdGhyb3VnaCBvdXIgdHJheSwgYW5kIHBsYWNlIGl0IGludG8gb3VyIFwiYnVpbGRwbGF0ZVwiXHJcbiAgICBfcGxhY2VUcmF5Qm9kaWVzKCkge1xyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBzZWxmLnRyYXkuZ2V0VHJheUJvZGllcygpLmZvckVhY2goZnVuY3Rpb24odGIpIHtcclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSB0ZXNzZWxsYXRpb24gZm9yIHRoaXMgb2JqZWN0IGFuZCBncmFiIGl0cyBib3VuZGluZyBib3hcclxuICAgICAgICAgICAgY29uc3QgdGVzc2VsbGF0aW9uID0gc2VsZi50ZXNzZWxsYXRpb25NYXAuZ2V0KHRiLmdldE9jY3VycmVuY2UoKS5nZXRUZXNzZWxsYXRpb25LZXkoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYXlCb2R5Qm91bmRpbmdCb3ggPSBzZWxmLmdlb21ldHJ5U2VydmljZS5nZXRCb3VuZHMoXHJcbiAgICAgICAgICAgICAgICB0Yi5nZXRPY2N1cnJlbmNlKCksXHJcbiAgICAgICAgICAgICAgICB0Yi5nZXRUcmFuc2Zvcm0oKSxcclxuICAgICAgICAgICAgICAgIHRlc3NlbGxhdGlvblxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCBtaW4gPSB0cmF5Qm9keUJvdW5kaW5nQm94Lm1pbjtcclxuICAgICAgICAgICAgY29uc3QgbWF4ID0gdHJheUJvZHlCb3VuZGluZ0JveC5tYXg7XHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgcmVjdCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGJvdW5kaW5nIGJveCwgYW5kIHBsYWNlIGl0XHJcbiAgICAgICAgICAgIHNlbGYuYnVpbGRwbGF0ZS5wbGFjZShcclxuICAgICAgICAgICAgICAgIG5ldyBSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbi54IC0gc2VsZi5pbm5lckd1dHRlcixcclxuICAgICAgICAgICAgICAgICAgICBtaW4ueSAtIHNlbGYuaW5uZXJHdXR0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4LnggLSBtaW4ueCArIDIgKiBzZWxmLmlubmVyR3V0dGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heC55IC0gbWluLnkgKyAyICogc2VsZi5pbm5lckd1dHRlclxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLy8gQ3JlYXRlIGEgbmV3IChlbXB0eSkgYnVpbGRwbGF0ZSBvYmplY3QgYW5kIHN0b3JlIGl0IGluIHRoaXMuYnVpbGRwbGF0ZS5cclxuICAgIC8vLyBVc2UgdGhlIGdldE5leHRUcmF5IGZ1bmN0aW9uIGFuZCByZWFzc2lnbiB0aGlzLnRyYXkuXHJcbiAgICBfaW5jcmVtZW50VHJheSgpIHtcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgICBzZWxmLmJ1aWxkcGxhdGUgPSBuZXcgQnVpbGRwbGF0ZShzZWxmLmJ1aWxkQXJlYSwgc2VsZi5yZXN0cmljdFRvU2luZ2xlVHJheSk7XHJcbiAgICAgICAgY29uc3QgdHJheVN0YXRlID0gc2VsZi5nZXROZXh0VHJheShzZWxmLnRyYXksIHNlbGYucHJvamVjdFN0YXRlKTtcclxuICAgICAgICBzZWxmLnRyYXkgPSB0cmF5U3RhdGUubmV4dFRyYXk7XHJcbiAgICAgICAgc2VsZi5wcm9qZWN0U3RhdGUgPSB0cmF5U3RhdGUubmV3UHJvamVjdFN0YXRlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLy8gcGFjayB0aGUgc3RhbmQgaW5zIGFuZCBwbGFjZSB0aGVtIGluIHNwYWNlcy4gb25jZSB0aGV5IGFyZSBwYWNrZWQsXHJcbiAgICAvLy8gdHJhbnNsYXRlIHRoZSBzdGFuZCBpbnMgYW5kIGFkZCB0aGVtIHRvIHRoZSB0cmF5LlxyXG4gICAgLy8vXHJcbiAgICAvLy8gQHJldHVybnMge3RoaXMudHJheX0gLSBtb2RpZmllZCBmaWxsZWQgdHJheVxyXG4gICAgYXJyYW5nZVRyYXkoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHEuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBvYmplY3QgdG8gc3RvcmUgc3RhbmQgaW5zIHRoYXQgd29uJ3QgZml0IG9udG8gdGhlIGN1cnJlbnQgdHJheVxyXG4gICAgICAgICAgICAgICAgbGV0IGxlZnRvdmVyU3RhbmRJbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgd2UgaGF2ZSBzdGFuZCBpbnMgdGhhdCBoYXZlbid0IGJlZW4gcGxhY2VkIHlldFxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHNlbGYuc3RhbmRJbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGxlZnRvdmVyU3RhbmRJbnMgdG8gYW4gZW1wdHkgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0b3ZlclN0YW5kSW5zID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgYWxsIG9mIHRoZSBib2RpZXMgaW4gdGhlIGN1cnJlbnQgdHJheSBpbiB0aGUgY3VycmVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkcGxhdGVcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wbGFjZVRyYXlCb2RpZXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHBsYWNlIGVhY2ggc3RhbmQgaW4gaW4gdGhlIGN1cnJlbnQgYnVpbGRwbGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBzZWxmLnN0YW5kSW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgc3RhbmQgaW5zIGJvdW5kaW5nIGJveCBhbmQgY3JlYXRlIGEgUmVjdCBmb3IgaXQsIGFkZGluZyBpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaW5uZXIgZ3V0dGVyIHRvIHRoZSBoZWlnaHQgYW5kIHdpZHRoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFuZEluID0gc2VsZi5zdGFuZEluc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHN0YW5kSW4uZ2V0U2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gbmV3IFJlY3QoMCwgMCwgc2l6ZS54ICsgc2VsZi5pbm5lckd1dHRlciAqIDIsIHNpemUueSArIHNlbGYuaW5uZXJHdXR0ZXIgKiAyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBwYWNrIHRoZSBib3VuZGluZyByZWN0IGluIHRoZSBjb3JyZXNwb25kaW5nIGJ1aWxkcGxhdGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHN1Y2Nlc3NmdWwsIHNldCB0aGUgdHJhbnNmb3JtYXRpb24gZm9yIHRoaXMgc3RhbmRpbiwgYW5kIGFkZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCB0byB0aGUgY3VycmVudCB0cmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJ1aWxkcGxhdGUucGFjayhyZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXh0cmFjdCB0aGUgc2hpZnQgaW4gKHgsIHkpIGZyb20gdGhlIHJlY3QsIGFwcGx5IGl0IHRvIHRoZSBzdGFuZCBpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGFkZCB0aGUgc3RhbmQgaW4gdG8gdGhlIHRyYXkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFuZEluLnNldFRyYW5zZm9ybShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm0uY3JlYXRlVHJhbnNsYXRpb25YZm9ybShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC54ICsgc2VsZi5pbm5lckd1dHRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC55ICsgc2VsZi5pbm5lckd1dHRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnRyYXkgPSBzdGFuZEluLmFkZEJvZGllc1RvVHJheShzZWxmLnRyYXkpLm5ld1RyYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhbmQgaW4gZG9lc24ndCBmaXQgb24gdGhlIGN1cnJlbnQgYnVpbGRwbGF0ZSwgc3RvcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGZvciB0aGUgbmV4dCBvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRvdmVyU3RhbmRJbnMucHVzaChzdGFuZEluKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgc3RhbmRpbnMgdG8gdGhlIGFuIGFycmF5IG9mIG9ubHkgdGhlIG9uZXMgdGhhdCBkaWRudCBmaXRcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YW5kSW5zID0gbGVmdG92ZXJTdGFuZElucztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zdGFuZElucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgc3RhbmQgaW5zLCBjcmVhdGUgYW5vdGhlciBidWlsZHBsYXRlIGFuZCB0cmF5IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGVtIHRvLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbmNyZW1lbnRUcmF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5wcm9qZWN0U3RhdGUuc2V0VHJheShzZWxmLnRyYXkpKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxufTtcclxuXHJcbmNsYXNzIE1CQ29tcG9zZXIgZXh0ZW5kcyBDb21wb3NlUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2VvbWV0cnlTZXJ2aWNlKSB7XHJcbiAgICAgICAgc3VwZXIoZ2VvbWV0cnlTZXJ2aWNlKTtcclxuICAgIH1cclxuXHJcbiAgICBhcnJhbmdlU3RhbmRJbnMoc3RhbmRJbnMsIHByb2plY3RTdGF0ZSwgdGVzc2VsbGF0aW9uTWFwLCBjdXJyZW50VHJheSwgcmVzdHJpY3RUb1NpbmdsZVRyYXksIGdldE5leHRUcmF5KSB7XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBlbnZlbG9wZSBzaXplIGFuZCBzdWJ0cmFjdCB0aGUgb3V0ZXIgZ3V0dGVyIGZyb20geCBhbmQgeSxcclxuICAgICAgICAvLyByZXN1bHRpbmcgaW4gdGhlIHRvdGFsIGJ1aWxkIGFyZWFcclxuICAgICAgICBjb25zdCBlbnZlbG9wZVNpemUgPSBwcm9qZWN0U3RhdGUuZ2V0QnVpbGRFbnZlbG9wZSgpLmdldERpbWVuc2lvbnMoKTtcclxuICAgICAgICBjb25zdCBvdXRlckd1dHRlciA9IDAuMDA2MzU7XHJcbiAgICAgICAgY29uc3QgYnVpbGRBcmVhID0ge1xyXG4gICAgICAgICAgICB4OiBlbnZlbG9wZVNpemUueCAtIG91dGVyR3V0dGVyICogMixcclxuICAgICAgICAgICAgeTogZW52ZWxvcGVTaXplLnkgLSBvdXRlckd1dHRlciAqIDIsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHRoZSBpbm5lciBndXR0ZXJcclxuICAgICAgICBjb25zdCBpbm5lckd1dHRlciA9IDAuMDAyO1xyXG5cclxuICAgICAgICAvLyBjcmVhdGUgYSBwcm9taXNlIHdpdGggYSByZXNvbHZlIGFuZCByZWplY3QgKG1heWJlIGFuIHVwZGF0ZSBzb29uPylcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIGNvbXBvc2UgaGVscGVyIHRoYXQgd2UncmUgdXNpbmdcclxuICAgICAgICBjb25zdCBwYWNrZXIgPSBuZXcgUGFja2VyKFxyXG4gICAgICAgICAgICBzZWxmLmdlb21ldHJ5U2VydmljZSxcclxuICAgICAgICAgICAgdGVzc2VsbGF0aW9uTWFwLFxyXG4gICAgICAgICAgICBidWlsZEFyZWEsXHJcbiAgICAgICAgICAgIGlubmVyR3V0dGVyLFxyXG4gICAgICAgICAgICBjdXJyZW50VHJheSxcclxuICAgICAgICAgICAgc3RhbmRJbnMsXHJcbiAgICAgICAgICAgIHJlc3RyaWN0VG9TaW5nbGVUcmF5LFxyXG4gICAgICAgICAgICBnZXROZXh0VHJheSxcclxuICAgICAgICAgICAgcHJvamVjdFN0YXRlXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBhY2tlci5hcnJhbmdlVHJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGFjY2VwdChjb21wb3NlRGF0YSkge1xyXG4gICAgICAgIHJldHVybiBjb21wb3NlRGF0YS5wcm9qZWN0U3RhdGUuZ2V0R2VuZGVyKCkuZ2V0VmVuZG9yKCkgPT09ICdNYWtlckJvdCc7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTUJDb21wb3NlcjtcclxuIl19
