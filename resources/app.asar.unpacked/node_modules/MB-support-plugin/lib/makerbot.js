'use strict';

const q = require('q');

const path = require('path');

const fs = require('fs-extra');

const R = require('ramda');

const tmp = require('tmp');

const JOB_TYPE = require('eagle-print/stores/buildStore').JOB_TYPE;

const {
  SettingsUISchema,
  decodeKey
} = require('@makerbot/settingsui');

const Sliceconfig = require('sliceconfig');

const thing = require('./thing');

const paths = require('./paths'); // The "|| null" is necessary to prevent the grunt tests from throwing an error
// saying that they cannot find module "settingsUI".


const NodeGrue = paths.requireNodeGrue();

const {
  ExtruderTypeEnum,
  EXPERIMENTAL_EXTRUDER
} = require('./constants'); // Configure temp directory behavior


tmp.setGracefulCleanup(); // The module's configuration.

const configuration = createDefaultConfiguration(); /// Returns the module's configuration.  Useful for unit tests and debugging

function config() {
  return configuration;
}
/**
 * Returns an nconf configuration based off of the OS that the software is
 * running on.
 *
 * @returns {nconf} - the configuration
 */


function createDefaultConfiguration() {
  console.info('using default builder configuration');

  const nconf = require('nconf');

  const configData = {
    makerbot: {
      pass_full_profile: require('os').type() != 'Windows_NT'
    }
  };
  nconf.defaults(configData);
  return nconf;
}
/**
 * Return the entire list of 'supported_configurations' from sliceconfig
 **/


function getSupportedConfigurations() {
  console.log('getting "supported_configurations" from sliceconfig');
  const scRunner = new Sliceconfig(paths.getBinDir());
  return scRunner.supportedConfigs();
} /// Does this printer have a machine config?


function hasMachineConfig(p) {
  return p.machineConfig && Object.keys(p.machineConfig).length !== 0;
}
/**
 * Parse the attached_extruders's tool ids into extruder strings
 * found in supported_extruders's list via machineConfig.
 *
 * 07.29.2019 - SliceConfig no longer accepts machineConfig as a
 * parameter. Instead send only the extruders array parsed from
 * machineConfig.
 * 08.28.2019 - Had to add an exception to Experimental Extruder (toolid 99)
 * In machine_config, 99 is labeled as a mk13 extruder.
 *
 * - Ray
 * @param {machineConfig} tray.printer.machineConfig object
 */


function parseExtrudersFromMachineConfig(machineConfig) {
  const {
    attached_extruders,
    supported_extruders
  } = machineConfig.extruder_profiles;
  return attached_extruders.map(({
    id
  }) => {
    return id === EXPERIMENTAL_EXTRUDER ? ExtruderTypeEnum.mk13_experimental : supported_extruders[parseInt(id)];
  });
}
/**
 * Builds a tray
 * @param {Tray} tray - a tray object should have the following
 * <p> printer: the target printer object </p>
 * <p> stlFiles: array of stl file paths </p>
 * <p> transforms: array of transforms for each STL file </p>
 * @param {hash} options - optional arguments
 * @param {function} callback - a node.js style callback function
 * @returns {promise} promise - promise result contains a tray object containing
    the following
 * <p> name: name and extension of the toolpath </p>
 * <p> path: location of the toolpath i.e path or url </p>
 */


function build(tray, options, progressCallback, cancelToken, callback, flux) {
  options = options || {}; /// get a thumbnail from the tray and add it to a temp directory (not in use
  /// yet);

  const createThumbnails = function (tray) {
    try {
      // list of names the thumbnails will save to and where to get the image
      let thumbnailData;

      if (tray.printer.isSixthGen()) {
        // sombrero-style thumbnails
        thumbnailData = [{
          name: 'thumbnail_960x1460.png',
          snapshot: tray.traySnapshots.large
        }, {
          name: 'thumbnail_212x300.png',
          snapshot: tray.traySnapshots.medium
        }, {
          name: 'thumbnail_140x106.png',
          snapshot: tray.traySnapshots.small
        }];
      } else if (tray.printer.isSketchPrinter()) {
        // sketchy-style thumbnail
        thumbnailData = [{
          name: 'thumbnail_90x90.png',
          snapshot: tray.traySnapshots.small
        }];
      } else {
        // standard thumbnails
        thumbnailData = [{
          name: 'thumbnail_320x200.png',
          snapshot: tray.traySnapshots.large
        }, {
          name: 'thumbnail_110x80.png',
          snapshot: tray.traySnapshots.medium
        }, {
          name: 'thumbnail_55x40.png',
          snapshot: tray.traySnapshots.small
        }];
      } // append standard thumbnails used in Teams & PrintFromWeb to  all 5th & 6th Printers


      thumbnailData.push({
        name: 'isometric_thumbnail_120x120.png',
        snapshot: tray.traySnapshots.isometricSmall
      }, {
        name: 'isometric_thumbnail_320x320.png',
        snapshot: tray.traySnapshots.isometricMedium
      }, {
        name: 'isometric_thumbnail_640x640.png',
        snapshot: tray.traySnapshots.isometricLarge
      }); // create a directory for the thumbnails

      const thumbnailDir = tmp.dirSync(); // write a file for a thumbnail into the thumbnail directory
      // @thumbnailInfo:
      //  * name <string> - name for the thumbnail file to be saved
      //  * snapshot <imageURL> - b64 string for the png to be saved

      const write = function (thumbnailInfo) {
        if (!thumbnailInfo) return;
        const thumbnailPath = path.join(thumbnailDir.name, thumbnailInfo.name);
        const imageURL = thumbnailInfo.snapshot.valueOf().dataURL;
        const thumbnailBuffer = new Buffer(imageURL.substring('data:image/png;base64,'.length), 'base64');
        return q.nfapply(fs.writeFile, [thumbnailPath, thumbnailBuffer]);
      }; // Create an array of thumbnail promises to settle/write


      const thumbnailPromises = [];
      thumbnailData.forEach(thumbnail => {
        thumbnailPromises.push(write(thumbnail));
      }); // create a promise for each thumbnail and wrap them all together to return

      return q.all(thumbnailPromises).then(function () {
        return thumbnailDir;
      });
    } catch (error) {
      return q.reject(error);
    }
  }; /// add a input and output filepaths, printer type, and slice settings to args


  const addPathsToArgs = function (args, modelFilePath) {
    // create a temp dir for the model and toolpath files
    const tempDir = tmp.dirSync(); // Copy STL file into temporary directory

    const modelName = path.basename(modelFilePath);
    args.inputPath = path.join(tempDir.name, modelName);
    fs.copySync(modelFilePath, args.inputPath);
    const toolpathIsJtp = !tray.printer.isSketchPrinter(); // path to which we will write the toolpath output from nodegrue

    args.tpPath = path.join(tempDir.name, toolpathIsJtp ? 'print.jsontoolpath' : 'print.gcode'); // path to which we will write the meta.json output from nodegrue; also
    // path of metadata that will be input to sliceconfig's `package_makerbot`
    // command;

    args.metaPath = path.join(tempDir.name, 'meta.json');
    const mbName = `${tray.name || 'untitled'}.makerbot`; // path to the final .makerbot;

    args.outputPath = path.join(tempDir.name, mbName);
    args.makerbotName = mbName;
    args.configPath = path.join(tempDir.name, 'config.json');
    return args;
  };

  const getAccelConfig = flux => {
    const printer = flux.store('PrinterStore').getSelectedPrinter();
    if (printer.isSketchPrinter()) return null;
    const printSettings = flux.store('PrintSettingsStore').getState();
    const {
      botType
    } = printer.getGender();
    const extruders = printer.getAttachedExtruders() ? printer.getAttachedExtruders().join('.') : null;
    const materials = printSettings.materials.selected.join('.');
    const mbirRootDir = paths.getInstallArtifactsRootDir(); // There are no accel configs w/ 5th gen & Experimental Extruder

    if (!extruders || extruders === ExtruderTypeEnum.mk13_experimental) {
      console.log(`exiting accel configs`);
      return null;
    }

    return path.join(mbirRootDir, 'public', botType, extruders, `${materials}.json`) // For production scenario where profiles are nested in app.asar.unpacked
    // and not in app.asar
    .replace(/app\.asar/, 'app.asar.unpacked');
  };

  function handleProgress(progressData) {
    try {
      // turn progress into an array so we treat single and multiple entries
      // the same
      let progressJson = progressData.split('\n');

      if (progressJson.length > 1 && progressJson[progressJson.length - 1] === '') {
        progressJson = progressJson[progressJson.length - 2];
      } else {
        progressJson = progressJson[progressJson.length - 1];
      }

      if (progressJson && progressCallback) {
        progressJson = JSON.parse(progressJson); // progress callback wants progress as decimals

        progressCallback(progressJson.totalPercentComplete / 100, undefined);
      }
    } catch (error) {
      console.log(`Slice Progress Error for line ${progressData}: ${error}`);
    }
  } // if we don't have stl files in our tray
  // - OR - if we return an undefined value within the stlFiles array
  // just return a rejection


  if (tray.stlFiles === undefined || tray.stlFiles.includes(undefined)) {
    return q.reject(new Error('Unsupported tray object')).nodeify(callback);
  } // build a promise that will do preprocessing and then slice the file.


  return q.Promise(function (resolve, reject, notify) {
    let args = {
      printerType: tray.printer.getGender().botType
    }; // start print process on bot if necessary

    let startPrintPromise;

    if (tray.parameters && tray.parameters.jobType === JOB_TYPE.PRINT) {
      // (printing is only allowed for bots that will be using .makerbots)
      const mbName = `${tray.name || 'untitled'}.makerbot`;
      startPrintPromise = tray.printer.startPrint(mbName, cancelToken);
    } else {
      startPrintPromise = q();
    }
    /**
     * Generate the list of extruder to model selections based on the
     * list of bodyProperties from the tray.
     *
     * -- NOTE --
     * getProperty/getValue is GC's hack ontop of ImmutableJs therefore
     * breaks mb-plugin's unit tests
     *
     * - Ray
     */


    const assignedExtruderList = tray.bodyProperties.map(bodyProperty => {
      return bodyProperty.toJSON().info.extruder.value;
    }); // call slice config with the slice command

    startPrintPromise // start by creating a dot thing file for this tray
    .then(function () {
      return thing.createThingFile(tray.stlFiles, assignedExtruderList, tray.transforms, tray.name);
    }, function (error) {
      reject(error);
    }) // then fetch the profile with which to slice from sliceconfig
    .then(function (thingFilePath) {
      args.command = 'get_profile';
      args = addPathsToArgs(args, thingFilePath);
      args = R.mergeAll([args, getProfileArgs(tray, tray.printer, options, flux, cancelToken, callback)]);
      return runSliceConfig(args, cancelToken, callback);
    }, function (error) {
      reject(error);
    }) // then dump it into a file to pass to nodegrue
    .then(function (profileJson) {
      return q.nfapply(fs.writeFile, [args.configPath, JSON.stringify(profileJson)]);
    }, function (error) {
      reject(error);
    }).then( // create the toolpath and base metadata using the newly created dot thing
    // if there is an error in createThingFile, reject the build
    function () {
      const toolpathIsJtp = !tray.printer.isSketchPrinter();
      const toolpather = new NodeGrue.NodeToolpather();
      const accelConfigFilePath = getAccelConfig(flux);

      if (cancelToken && cancelToken.isCancelled()) {
        // if the cancel token has already been used (e.g. cancel was hit
        // while generating the dot thing to slice), reject.
        const err = new Error('Cancelled');
        err.type = 'cancel';
        reject(err);
      } else {
        const {
          sliceCompletionPromise,
          cancelFunc
        } = toolpather.runMiracleGrue(args.configPath, args.inputPath, handleProgress, toolpathIsJtp ? args.tpPath : null, args.metaPath, toolpathIsJtp ? null : args.tpPath, accelConfigFilePath);

        if (cancelToken) {
          // if the cancel token is used while slicing, reject.
          cancelToken.on('cancel', () => {
            cancelFunc();
          });
        }

        return sliceCompletionPromise;
      }
    }, function (error) {
      reject(error);
    }).then( // create thumbnails
    function () {
      return createThumbnails(tray);
    }, function (error) {
      // (Cancelling a slice will reject the sliceCompletionPromise)
      if (error.message == 'Cancelled') {
        error.type = 'cancel';
      }

      reject(error);
    }).then( // add the thumbnail directory to the args list and run slice config
    // to package the final .makerbot. if createThumbnails failed,
    // log it and run slice config without the thumbnail directory argument
    function (thumbnailDir) {
      args.command = 'package_makerbot';
      args.thumbnailDir = thumbnailDir.name; // rename the `tpPath` property to `inputPath` so
      // sliceconfig.js is able to direct it properly to the
      // `-i` arg to sliceconfig command line.

      args.inputPath = args.tpPath;
      delete args.tpPath;
      return runSliceConfig(args, cancelToken, callback);
    }, function (error) {
      console.log(error);
      args.command = 'package_makerbot';
      return runSliceConfig(args, cancelToken, callback);
    }).then( // when slicing via slice config finishes up, resolve with the makerbot
    // file name and path. reject on errors. report progress back to the
    // progress callback.
    function () {
      resolve({
        name: args.makerbotName,
        path: args.outputPath
      });
    }, function (error) {
      if (tray.parameters && tray.parameters.jobType === JOB_TYPE.PRINT) {
        tray.printer.cancel();
      }

      reject(error);
    });
  }).nodeify(callback);
}
/**
 * get args needed to generate a miracle grue profile
 *
 * @param {Tray} tray - a tray object should have the following
 *    <p> printer: the target printer object </p>
 *    <p> bodyProperties: an array of list of overrides
 * @param {Printer} printer - a machine that contains the following
 *    <p> machineConfig - a description of that machines properties </p>
 *    <p> gender - the type of machine that this is</p>
 * @param {hash} options - optional arguments
 *
 * @returns {object} args
 */


function getProfileArgs(tray, printer, options, flux) {
  const args = {};
  printer = printer || tray.printer; // add the materials, print mode and overrides

  const configuration = configurationFromTray(tray);
  const printSettingsStore = flux.store('PrintSettingsStore');
  const printSettings = printSettingsStore.getState();
  const storeOverrides = printSettingsStore.getOverrides();
  options = options || {};
  args.overrides = options.overrides ? R.mergeAll([storeOverrides, options.overrides]) : storeOverrides;
  args.materials = options.materials ? options.materials.selected : printSettings.materials.selected;
  args.printMode = printSettings.printMode.selected;
  args.profilePath = configuration.profilePath; // add the machine config or bot name depending on whats there
  // NOTE: machine config differs on live & archetype Method, do not pass machine config to Method bot

  args.printerType = printer.getGender().botType;

  if (printer.isSketchPrinter()) {
    // Grab the only supported extruder
    args.extruders = printSettings.extruders.supported[0];
  } else if (hasMachineConfig(printer) && printer.isConnected() && printer.isFifthGen()) {
    args.extruders = parseExtrudersFromMachineConfig(printer.machineConfig);
  } else {
    args.extruders = printer.getAttachedExtruders();
  }

  return args;
}
/**
 * generate a miracle grue profile
 *
 * @param {Tray} tray - a tray object should have the following
 *    <p> printer: the target printer object </p>
 *    <p> bodyProperties: an array of list of overrides
 * @param {Printer} printer - a machine that contains the following
 *    <p> machineConfig - a description of that machines properties </p>
 *    <p> gender - the type of machine that this is</p>
 * @param {hash} options - optional arguments
 * @param {function} callback - a node.js style callback function
 *
 * @returns {promise} promise - promise result contains a Profile JSON object
 */


function getProfile(tray, printer, options, flux, cancelToken, callback) {
  let args = {
    command: 'get_profile'
  }; // call slice config with the slice command

  args = R.mergeAll([args, getProfileArgs(tray, printer, options, flux)]);
  return runSliceConfig(args, cancelToken, callback);
}
/**
 * create the slice settings (as sliceconfig expects them) for a tray
 *
 * @param {Tray} tray - an object representing a tray of models
 *    <p> bodyProperties - a list of properties, one for each body
 *    <p> printer - an object representing a printer
 *
 *  @returns {Dict} - a json dict of settings formatted for slice config
 */


function configurationFromTray(tray) {
  if (!tray.bodyProperties || tray.bodyProperties.length === 0) return {}; // setup a configuration object to fill out

  const configuration = {
    materials: [null, null],
    printMode: null,
    overrides: {}
  }; // convert from an immutable map to a js object. is there a better way?

  const properties = tray.bodyProperties[0].toJSON(); // helper function that makes sure we care about this property

  function realProperty(prop) {
    return prop !== undefined && prop.value !== undefined;
  } // loop through all the properties


  for (const property in properties) {
    if (realProperty(properties[property])) {
      if (property === 'materials') {
        configuration.materials = properties.materials.value;
      } else if (property === 'printMode') {
        configuration.printMode = properties.printMode.value;
      } else if (property === 'customProfilePath') {
        configuration.profilePath = properties.customProfilePath.value[0];
      } else if (property === 'rotationLock' || property === 'orientation' || property === 'extruders') {
        // We skip rotationLock and orientation because we never want to hand them to sliceConfig
        // at some point, let's actually remove rotationLock from the tray, instead of just ignoring it
        // We skip extruders because we get them from the printer object itself
        continue;
      } else {
        // All other properties are assumed to be overrides. Use the decodeKey
        // function from the sliceconfig interface to convert the key to use the
        // correct delimitors and set the override.
        const decodedProperty = decodeKey(property);
        configuration.overrides[decodedProperty] = properties[property].value;
      }
    }
  }

  return configuration;
}
/**
 * get a schema describing available parameters that UI can set
 *
 * @param {Tray} tray - a tray object should have the following
 *    <p> printer: the target printer object </p>
 *    <p> bodyProperties: an array of list of overrides
 * @param {Printer} printer - a tray object should have the following
 *
 * @returns {promise} - promise result contains a json schema for available
 *  parameters.
 */


function getSchema(tray, printer, ignoreExtruderArgs = false, flux, cancelToken, callback) {
  const args = {
    command: 'get_schema'
  };
  printer = printer || tray.printer; // add the materials, print mode and overrides

  const configuration = configurationFromTray(tray);
  const printSettingsStore = flux.store('PrintSettingsStore');
  const printSettings = printSettingsStore.getState();
  args.overrides = printSettingsStore.getOverrides();
  args.materials = printSettings.materials.selected;
  args.printMode = printSettings.printMode.selected;
  args.profilePath = configuration.profilePath; // add the machine config or bot name depending on whats there

  args.printerType = printer.getGender().botType;

  if (printer.isSketchPrinter()) {
    // Grab the only supported extruder
    args.extruders = printSettings.extruders.supported[0];
  } else if (hasMachineConfig(printer) && printer.isConnected() && printer.isFifthGen()) {
    args.extruders = parseExtrudersFromMachineConfig(printer.machineConfig);
  } else {
    const attachedExtruders = printer.getAttachedExtruders();
    const hasExperimentalExtruder = attachedExtruders && R.contains(ExtruderTypeEnum.mk13_experimental, attachedExtruders); // Experimental Extruder should only be assigned if connected to the
    // printer. Otherwise, don't pass extruder argument and have
    // sliceconfig return back default selected extruder.
    //
    // To revert back to default extruders going from Method => to Method X,
    // don't build out the extruders arg. (Offline/Archetypes only)

    if (!ignoreExtruderArgs && !hasExperimentalExtruder && !attachedExtruders.includes(undefined)) {
      args.extruders = attachedExtruders;
    }
  }

  return runSliceConfig(args, cancelToken, callback).then(schema => {
    // In rare cases, sliceconfig returns emptry string, (""), resulting
    // errors with SettingsUISchema. Instead, lets exit out early before
    // things break.
    // -- Ray
    if (R.isEmpty(schema)) return;
    const sc = new Sliceconfig(paths.getBinDir());
    schema.supported_configurations = sc.supportedConfigs();
    return new SettingsUISchema(schema);
  });
}
/**
 * get the current version of sliceconfig
 * @returns {promise} - promise result contains a string containing the version
 */


function getVersion(callback) {
  const args = {
    command: 'get_version'
  };
  return runSliceConfig(args, null, callback);
}
/**
 * runs sliceconfig for a command with arguments
 *
 * for more information on what arguments are needed with each command, see the
 * command line interface documentation in the slice config repo at
 * github.com/makerbot/sliceconfig/blob/develop/doc/command_line_interface.md
 *
 * @param {list} args - optional arguments for sliceconfig
 * @param {function} callback - a node.js style callback function
 *
 * @returns {promise} promise - promise result depends on the command passed in.
 *  if command['notify'] is false, resolve contains stdout from slice config. if
 *  command['notify'] is true, resolve is empty.
 */


function runSliceConfig(args, cancelToken, callback) {
  return q.Promise(function (resolve, reject, notify) {
    // call slice config using the given command and arguments
    const scRunner = new Sliceconfig(paths.getBinDir());

    if (args && args.command === 'slice') {
      console.log(args);
    }

    const sliceConfigProcess = scRunner.execute(args);

    if (cancelToken) {
      // if the cancel token has already been used (e.g. cancel was hit
      // while generating the dot thing to slice), reject.
      if (cancelToken.isCancelled()) {
        sliceConfigProcess.kill();
        const err = new Error('Cancelled');
        err.type = 'cancel';
        reject(err);
      } else {
        // if the cancel token is used while slicing, reject.
        cancelToken.on('cancel', () => {
          sliceConfigProcess.kill();
          const err = new Error('Cancelled');
          err.type = 'cancel';
          reject(err);
        });
      }
    }

    sliceConfigProcess.on('data', data => {
      switch (data.type) {
        case 'error':
          reject(data.content);
          break;

        case 'info':
          // figure out how to get this into the 'end' call
          resolve(data.content);
          break;

        case 'logging':
          // do some logging?
          break;

        case 'progress':
          // Only reporting for type: slice, not others
          // else pre-birdwing bots get 2 progress bars.
          if ((data.content.substring(0, 1) === '{' || data.content.substring(0, 1) === '[') && JSON.parse(data.content).type && JSON.parse(data.content).type === 'slice') {
            notify(data.content);
            break;
          }

          break;

        case 'default':
          console.log(`unsupported type\n:${data}`);
      }
    });
  }).nodeify(callback);
}
/**
 * Shutdown the builder (cleaning up any resources)
 */


function shutdown() {// tbd what do we need to shutdown here? existing processes?
}

module.exports = {
  build,
  getProfile,
  getSchema,
  getSupportedConfigurations,
  shutdown,
  config,
  getVersion
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ha2VyYm90LmpzIl0sIm5hbWVzIjpbInEiLCJyZXF1aXJlIiwicGF0aCIsImZzIiwiUiIsInRtcCIsIkpPQl9UWVBFIiwiU2V0dGluZ3NVSVNjaGVtYSIsImRlY29kZUtleSIsIlNsaWNlY29uZmlnIiwidGhpbmciLCJwYXRocyIsIk5vZGVHcnVlIiwicmVxdWlyZU5vZGVHcnVlIiwiRXh0cnVkZXJUeXBlRW51bSIsIkVYUEVSSU1FTlRBTF9FWFRSVURFUiIsInNldEdyYWNlZnVsQ2xlYW51cCIsImNvbmZpZ3VyYXRpb24iLCJjcmVhdGVEZWZhdWx0Q29uZmlndXJhdGlvbiIsImNvbmZpZyIsImNvbnNvbGUiLCJpbmZvIiwibmNvbmYiLCJjb25maWdEYXRhIiwibWFrZXJib3QiLCJwYXNzX2Z1bGxfcHJvZmlsZSIsInR5cGUiLCJkZWZhdWx0cyIsImdldFN1cHBvcnRlZENvbmZpZ3VyYXRpb25zIiwibG9nIiwic2NSdW5uZXIiLCJnZXRCaW5EaXIiLCJzdXBwb3J0ZWRDb25maWdzIiwiaGFzTWFjaGluZUNvbmZpZyIsInAiLCJtYWNoaW5lQ29uZmlnIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInBhcnNlRXh0cnVkZXJzRnJvbU1hY2hpbmVDb25maWciLCJhdHRhY2hlZF9leHRydWRlcnMiLCJzdXBwb3J0ZWRfZXh0cnVkZXJzIiwiZXh0cnVkZXJfcHJvZmlsZXMiLCJtYXAiLCJpZCIsIm1rMTNfZXhwZXJpbWVudGFsIiwicGFyc2VJbnQiLCJidWlsZCIsInRyYXkiLCJvcHRpb25zIiwicHJvZ3Jlc3NDYWxsYmFjayIsImNhbmNlbFRva2VuIiwiY2FsbGJhY2siLCJmbHV4IiwiY3JlYXRlVGh1bWJuYWlscyIsInRodW1ibmFpbERhdGEiLCJwcmludGVyIiwiaXNTaXh0aEdlbiIsIm5hbWUiLCJzbmFwc2hvdCIsInRyYXlTbmFwc2hvdHMiLCJsYXJnZSIsIm1lZGl1bSIsInNtYWxsIiwiaXNTa2V0Y2hQcmludGVyIiwicHVzaCIsImlzb21ldHJpY1NtYWxsIiwiaXNvbWV0cmljTWVkaXVtIiwiaXNvbWV0cmljTGFyZ2UiLCJ0aHVtYm5haWxEaXIiLCJkaXJTeW5jIiwid3JpdGUiLCJ0aHVtYm5haWxJbmZvIiwidGh1bWJuYWlsUGF0aCIsImpvaW4iLCJpbWFnZVVSTCIsInZhbHVlT2YiLCJkYXRhVVJMIiwidGh1bWJuYWlsQnVmZmVyIiwiQnVmZmVyIiwic3Vic3RyaW5nIiwibmZhcHBseSIsIndyaXRlRmlsZSIsInRodW1ibmFpbFByb21pc2VzIiwiZm9yRWFjaCIsInRodW1ibmFpbCIsImFsbCIsInRoZW4iLCJlcnJvciIsInJlamVjdCIsImFkZFBhdGhzVG9BcmdzIiwiYXJncyIsIm1vZGVsRmlsZVBhdGgiLCJ0ZW1wRGlyIiwibW9kZWxOYW1lIiwiYmFzZW5hbWUiLCJpbnB1dFBhdGgiLCJjb3B5U3luYyIsInRvb2xwYXRoSXNKdHAiLCJ0cFBhdGgiLCJtZXRhUGF0aCIsIm1iTmFtZSIsIm91dHB1dFBhdGgiLCJtYWtlcmJvdE5hbWUiLCJjb25maWdQYXRoIiwiZ2V0QWNjZWxDb25maWciLCJzdG9yZSIsImdldFNlbGVjdGVkUHJpbnRlciIsInByaW50U2V0dGluZ3MiLCJnZXRTdGF0ZSIsImJvdFR5cGUiLCJnZXRHZW5kZXIiLCJleHRydWRlcnMiLCJnZXRBdHRhY2hlZEV4dHJ1ZGVycyIsIm1hdGVyaWFscyIsInNlbGVjdGVkIiwibWJpclJvb3REaXIiLCJnZXRJbnN0YWxsQXJ0aWZhY3RzUm9vdERpciIsInJlcGxhY2UiLCJoYW5kbGVQcm9ncmVzcyIsInByb2dyZXNzRGF0YSIsInByb2dyZXNzSnNvbiIsInNwbGl0IiwiSlNPTiIsInBhcnNlIiwidG90YWxQZXJjZW50Q29tcGxldGUiLCJ1bmRlZmluZWQiLCJzdGxGaWxlcyIsImluY2x1ZGVzIiwiRXJyb3IiLCJub2RlaWZ5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJub3RpZnkiLCJwcmludGVyVHlwZSIsInN0YXJ0UHJpbnRQcm9taXNlIiwicGFyYW1ldGVycyIsImpvYlR5cGUiLCJQUklOVCIsInN0YXJ0UHJpbnQiLCJhc3NpZ25lZEV4dHJ1ZGVyTGlzdCIsImJvZHlQcm9wZXJ0aWVzIiwiYm9keVByb3BlcnR5IiwidG9KU09OIiwiZXh0cnVkZXIiLCJ2YWx1ZSIsImNyZWF0ZVRoaW5nRmlsZSIsInRyYW5zZm9ybXMiLCJ0aGluZ0ZpbGVQYXRoIiwiY29tbWFuZCIsIm1lcmdlQWxsIiwiZ2V0UHJvZmlsZUFyZ3MiLCJydW5TbGljZUNvbmZpZyIsInByb2ZpbGVKc29uIiwic3RyaW5naWZ5IiwidG9vbHBhdGhlciIsIk5vZGVUb29scGF0aGVyIiwiYWNjZWxDb25maWdGaWxlUGF0aCIsImlzQ2FuY2VsbGVkIiwiZXJyIiwic2xpY2VDb21wbGV0aW9uUHJvbWlzZSIsImNhbmNlbEZ1bmMiLCJydW5NaXJhY2xlR3J1ZSIsIm9uIiwibWVzc2FnZSIsImNhbmNlbCIsImNvbmZpZ3VyYXRpb25Gcm9tVHJheSIsInByaW50U2V0dGluZ3NTdG9yZSIsInN0b3JlT3ZlcnJpZGVzIiwiZ2V0T3ZlcnJpZGVzIiwib3ZlcnJpZGVzIiwicHJpbnRNb2RlIiwicHJvZmlsZVBhdGgiLCJzdXBwb3J0ZWQiLCJpc0Nvbm5lY3RlZCIsImlzRmlmdGhHZW4iLCJnZXRQcm9maWxlIiwicHJvcGVydGllcyIsInJlYWxQcm9wZXJ0eSIsInByb3AiLCJwcm9wZXJ0eSIsImN1c3RvbVByb2ZpbGVQYXRoIiwiZGVjb2RlZFByb3BlcnR5IiwiZ2V0U2NoZW1hIiwiaWdub3JlRXh0cnVkZXJBcmdzIiwiYXR0YWNoZWRFeHRydWRlcnMiLCJoYXNFeHBlcmltZW50YWxFeHRydWRlciIsImNvbnRhaW5zIiwic2NoZW1hIiwiaXNFbXB0eSIsInNjIiwic3VwcG9ydGVkX2NvbmZpZ3VyYXRpb25zIiwiZ2V0VmVyc2lvbiIsInNsaWNlQ29uZmlnUHJvY2VzcyIsImV4ZWN1dGUiLCJraWxsIiwiZGF0YSIsImNvbnRlbnQiLCJzaHV0ZG93biIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLE1BQU1BLENB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R0FBakMsSUFBd0NvSCxJQUFJLENBQUNDLE9BQUwsQ0FBYXJILFNBQWIsQ0FBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsTUFBaUMsR0FBMUUsS0FDQTJDLElBQUksQ0FBQ0MsS0FBTCxDQUFXd0UsSUFBSSxDQUFDQyxPQUFoQixFQUF5QjNLLElBRHpCLElBRUFpRyxJQUFJLENBQUNDLEtBQUwsQ0FBV3dFLElBQUksQ0FBQ0MsT0FBaEIsRUFBeUIzSyxJQUF6QixLQUFrQyxPQUh0QyxFQUlFO0FBQ0UyRyxZQUFBQSxNQUFNLENBQUMrRCxJQUFJLENBQUNDLE9BQU4sQ0FBTjtBQUNBO0FBQ0g7O0FBQ0Q7O0FBQ0osYUFBSyxTQUFMO0FBQ0lqTCxVQUFBQSxPQUFPLENBQUNTLEdBQVIsQ0FBYSxzQkFBcUJ1SyxJQUFLLEVBQXZDO0FBeEJSO0FBMEJILEtBM0JEO0FBNEJILEdBeERFLEVBeURGbEUsT0F6REUsQ0F5RE05RSxRQXpETixDQUFQO0FBMERIO0FBQ0Q7QUFDQTtBQUNBOzs7QUFDQSxTQUFTa0osUUFBVCxHQUFvQixDQUNoQjtBQUNIOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFDYnpKLEVBQUFBLEtBRGE7QUFFYmlJLEVBQUFBLFVBRmE7QUFHYk8sRUFBQUEsU0FIYTtBQUliM0osRUFBQUEsMEJBSmE7QUFLYjBLLEVBQUFBLFFBTGE7QUFNYm5MLEVBQUFBLE1BTmE7QUFPYjZLLEVBQUFBO0FBUGEsQ0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBxID0gcmVxdWlyZSgncScpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XHJcbmNvbnN0IFIgPSByZXF1aXJlKCdyYW1kYScpO1xyXG5jb25zdCB0bXAgPSByZXF1aXJlKCd0bXAnKTtcclxuY29uc3QgSk9CX1RZUEUgPSByZXF1aXJlKCdlYWdsZS1wcmludC9zdG9yZXMvYnVpbGRTdG9yZScpLkpPQl9UWVBFO1xyXG5jb25zdCB7IFNldHRpbmdzVUlTY2hlbWEsIGRlY29kZUtleSB9ID0gcmVxdWlyZSgnQG1ha2VyYm90L3NldHRpbmdzdWknKTtcclxuY29uc3QgU2xpY2Vjb25maWcgPSByZXF1aXJlKCdzbGljZWNvbmZpZycpO1xyXG5cclxuY29uc3QgdGhpbmcgPSByZXF1aXJlKCcuL3RoaW5nJyk7XHJcbmNvbnN0IHBhdGhzID0gcmVxdWlyZSgnLi9wYXRocycpO1xyXG4vLyBUaGUgXCJ8fCBudWxsXCIgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgdGhlIGdydW50IHRlc3RzIGZyb20gdGhyb3dpbmcgYW4gZXJyb3JcclxuLy8gc2F5aW5nIHRoYXQgdGhleSBjYW5ub3QgZmluZCBtb2R1bGUgXCJzZXR0aW5nc1VJXCIuXHJcbmNvbnN0IE5vZGVHcnVlID0gcGF0aHMucmVxdWlyZU5vZGVHcnVlKCk7XHJcblxyXG5jb25zdCB7IEV4dHJ1ZGVyVHlwZUVudW0sIEVYUEVSSU1FTlRBTF9FWFRSVURFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxuXHJcbi8vIENvbmZpZ3VyZSB0ZW1wIGRpcmVjdG9yeSBiZWhhdmlvclxyXG50bXAuc2V0R3JhY2VmdWxDbGVhbnVwKCk7XHJcblxyXG4vLyBUaGUgbW9kdWxlJ3MgY29uZmlndXJhdGlvbi5cclxuY29uc3QgY29uZmlndXJhdGlvbiA9IGNyZWF0ZURlZmF1bHRDb25maWd1cmF0aW9uKCk7XHJcblxyXG4vLy8gUmV0dXJucyB0aGUgbW9kdWxlJ3MgY29uZmlndXJhdGlvbi4gIFVzZWZ1bCBmb3IgdW5pdCB0ZXN0cyBhbmQgZGVidWdnaW5nXHJcbmZ1bmN0aW9uIGNvbmZpZygpIHtcclxuICAgIHJldHVybiBjb25maWd1cmF0aW9uO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBuY29uZiBjb25maWd1cmF0aW9uIGJhc2VkIG9mZiBvZiB0aGUgT1MgdGhhdCB0aGUgc29mdHdhcmUgaXNcclxuICogcnVubmluZyBvbi5cclxuICpcclxuICogQHJldHVybnMge25jb25mfSAtIHRoZSBjb25maWd1cmF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0Q29uZmlndXJhdGlvbigpIHtcclxuICAgIGNvbnNvbGUuaW5mbygndXNpbmcgZGVmYXVsdCBidWlsZGVyIGNvbmZpZ3VyYXRpb24nKTtcclxuICAgIGNvbnN0IG5jb25mID0gcmVxdWlyZSgnbmNvbmYnKTtcclxuXHJcbiAgICBjb25zdCBjb25maWdEYXRhID0ge1xyXG4gICAgICAgIG1ha2VyYm90OiB7IHBhc3NfZnVsbF9wcm9maWxlOiByZXF1aXJlKCdvcycpLnR5cGUoKSAhPSAnV2luZG93c19OVCcgfSxcclxuICAgIH07XHJcblxyXG4gICAgbmNvbmYuZGVmYXVsdHMoY29uZmlnRGF0YSk7XHJcbiAgICByZXR1cm4gbmNvbmY7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGVudGlyZSBsaXN0IG9mICdzdXBwb3J0ZWRfY29uZmlndXJhdGlvbnMnIGZyb20gc2xpY2Vjb25maWdcclxuICoqL1xyXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRDb25maWd1cmF0aW9ucygpIHtcclxuICAgIGNvbnNvbGUubG9nKCdnZXR0aW5nIFwic3VwcG9ydGVkX2NvbmZpZ3VyYXRpb25zXCIgZnJvbSBzbGljZWNvbmZpZycpO1xyXG4gICAgY29uc3Qgc2NSdW5uZXIgPSBuZXcgU2xpY2Vjb25maWcocGF0aHMuZ2V0QmluRGlyKCkpO1xyXG5cclxuICAgIHJldHVybiBzY1J1bm5lci5zdXBwb3J0ZWRDb25maWdzKCk7XHJcbn1cclxuXHJcbi8vLyBEb2VzIHRoaXMgcHJpbnRlciBoYXZlIGEgbWFjaGluZSBjb25maWc/XHJcbmZ1bmN0aW9uIGhhc01hY2hpbmVDb25maWcocCkge1xyXG4gICAgcmV0dXJuIHAubWFjaGluZUNvbmZpZyAmJiBPYmplY3Qua2V5cyhwLm1hY2hpbmVDb25maWcpLmxlbmd0aCAhPT0gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHRoZSBhdHRhY2hlZF9leHRydWRlcnMncyB0b29sIGlkcyBpbnRvIGV4dHJ1ZGVyIHN0cmluZ3NcclxuICogZm91bmQgaW4gc3VwcG9ydGVkX2V4dHJ1ZGVycydzIGxpc3QgdmlhIG1hY2hpbmVDb25maWcuXHJcbiAqXHJcbiAqIDA3LjI5LjIwMTkgLSBTbGljZUNvbmZpZyBubyBsb25nZXIgYWNjZXB0cyBtYWNoaW5lQ29uZmlnIGFzIGFcclxuICogcGFyYW1ldGVyLiBJbnN0ZWFkIHNlbmQgb25seSB0aGUgZXh0cnVkZXJzIGFycmF5IHBhcnNlZCBmcm9tXHJcbiAqIG1hY2hpbmVDb25maWcuXHJcbiAqIDA4LjI4LjIwMTkgLSBIYWQgdG8gYWRkIGFuIGV4Y2VwdGlvbiB0byBFeHBlcmltZW50YWwgRXh0cnVkZXIgKHRvb2xpZCA5OSlcclxuICogSW4gbWFjaGluZV9jb25maWcsIDk5IGlzIGxhYmVsZWQgYXMgYSBtazEzIGV4dHJ1ZGVyLlxyXG4gKlxyXG4gKiAtIFJheVxyXG4gKiBAcGFyYW0ge21hY2hpbmVDb25maWd9IHRyYXkucHJpbnRlci5tYWNoaW5lQ29uZmlnIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VFeHRydWRlcnNGcm9tTWFjaGluZUNvbmZpZyhtYWNoaW5lQ29uZmlnKSB7XHJcbiAgICBjb25zdCB7IGF0dGFjaGVkX2V4dHJ1ZGVycywgc3VwcG9ydGVkX2V4dHJ1ZGVycyB9ID0gbWFjaGluZUNvbmZpZy5leHRydWRlcl9wcm9maWxlcztcclxuICAgIHJldHVybiBhdHRhY2hlZF9leHRydWRlcnMubWFwKCh7IGlkIH0pID0+IHtcclxuICAgICAgICByZXR1cm4gaWQgPT09IEVYUEVSSU1FTlRBTF9FWFRSVURFUiA/IEV4dHJ1ZGVyVHlwZUVudW0ubWsxM19leHBlcmltZW50YWwgOiBzdXBwb3J0ZWRfZXh0cnVkZXJzW3BhcnNlSW50KGlkKV07XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIHRyYXlcclxuICogQHBhcmFtIHtUcmF5fSB0cmF5IC0gYSB0cmF5IG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nXHJcbiAqIDxwPiBwcmludGVyOiB0aGUgdGFyZ2V0IHByaW50ZXIgb2JqZWN0IDwvcD5cclxuICogPHA+IHN0bEZpbGVzOiBhcnJheSBvZiBzdGwgZmlsZSBwYXRocyA8L3A+XHJcbiAqIDxwPiB0cmFuc2Zvcm1zOiBhcnJheSBvZiB0cmFuc2Zvcm1zIGZvciBlYWNoIFNUTCBmaWxlIDwvcD5cclxuICogQHBhcmFtIHtoYXNofSBvcHRpb25zIC0gb3B0aW9uYWwgYXJndW1lbnRzXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gYSBub2RlLmpzIHN0eWxlIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtwcm9taXNlfSBwcm9taXNlIC0gcHJvbWlzZSByZXN1bHQgY29udGFpbnMgYSB0cmF5IG9iamVjdCBjb250YWluaW5nXHJcbiAgICB0aGUgZm9sbG93aW5nXHJcbiAqIDxwPiBuYW1lOiBuYW1lIGFuZCBleHRlbnNpb24gb2YgdGhlIHRvb2xwYXRoIDwvcD5cclxuICogPHA+IHBhdGg6IGxvY2F0aW9uIG9mIHRoZSB0b29scGF0aCBpLmUgcGF0aCBvciB1cmwgPC9wPlxyXG4gKi9cclxuZnVuY3Rpb24gYnVpbGQodHJheSwgb3B0aW9ucywgcHJvZ3Jlc3NDYWxsYmFjaywgY2FuY2VsVG9rZW4sIGNhbGxiYWNrLCBmbHV4KSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAvLy8gZ2V0IGEgdGh1bWJuYWlsIGZyb20gdGhlIHRyYXkgYW5kIGFkZCBpdCB0byBhIHRlbXAgZGlyZWN0b3J5IChub3QgaW4gdXNlXHJcbiAgICAvLy8geWV0KTtcclxuICAgIGNvbnN0IGNyZWF0ZVRodW1ibmFpbHMgPSBmdW5jdGlvbih0cmF5KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gbGlzdCBvZiBuYW1lcyB0aGUgdGh1bWJuYWlscyB3aWxsIHNhdmUgdG8gYW5kIHdoZXJlIHRvIGdldCB0aGUgaW1hZ2VcclxuICAgICAgICAgICAgbGV0IHRodW1ibmFpbERhdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAodHJheS5wcmludGVyLmlzU2l4dGhHZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc29tYnJlcm8tc3R5bGUgdGh1bWJuYWlsc1xyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsRGF0YSA9IFtcclxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0aHVtYm5haWxfOTYweDE0NjAucG5nJywgc25hcHNob3Q6IHRyYXkudHJheVNuYXBzaG90cy5sYXJnZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3RodW1ibmFpbF8yMTJ4MzAwLnBuZycsIHNuYXBzaG90OiB0cmF5LnRyYXlTbmFwc2hvdHMubWVkaXVtIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndGh1bWJuYWlsXzE0MHgxMDYucG5nJywgc25hcHNob3Q6IHRyYXkudHJheVNuYXBzaG90cy5zbWFsbCB9LFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0cmF5LnByaW50ZXIuaXNTa2V0Y2hQcmludGVyKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNrZXRjaHktc3R5bGUgdGh1bWJuYWlsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWxEYXRhID0gW3sgbmFtZTogJ3RodW1ibmFpbF85MHg5MC5wbmcnLCBzbmFwc2hvdDogdHJheS50cmF5U25hcHNob3RzLnNtYWxsIH1dO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQgdGh1bWJuYWlsc1xyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsRGF0YSA9IFtcclxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0aHVtYm5haWxfMzIweDIwMC5wbmcnLCBzbmFwc2hvdDogdHJheS50cmF5U25hcHNob3RzLmxhcmdlIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndGh1bWJuYWlsXzExMHg4MC5wbmcnLCBzbmFwc2hvdDogdHJheS50cmF5U25hcHNob3RzLm1lZGl1bSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3RodW1ibmFpbF81NXg0MC5wbmcnLCBzbmFwc2hvdDogdHJheS50cmF5U25hcHNob3RzLnNtYWxsIH0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBhcHBlbmQgc3RhbmRhcmQgdGh1bWJuYWlscyB1c2VkIGluIFRlYW1zICYgUHJpbnRGcm9tV2ViIHRvICBhbGwgNXRoICYgNnRoIFByaW50ZXJzXHJcbiAgICAgICAgICAgIHRodW1ibmFpbERhdGEucHVzaChcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaXNvbWV0cmljX3RodW1ibmFpbF8xMjB4MTIwLnBuZycsXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcHNob3Q6IHRyYXkudHJheVNuYXBzaG90cy5pc29tZXRyaWNTbWFsbCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2lzb21ldHJpY190aHVtYm5haWxfMzIweDMyMC5wbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgIHNuYXBzaG90OiB0cmF5LnRyYXlTbmFwc2hvdHMuaXNvbWV0cmljTWVkaXVtLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaXNvbWV0cmljX3RodW1ibmFpbF82NDB4NjQwLnBuZycsXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcHNob3Q6IHRyYXkudHJheVNuYXBzaG90cy5pc29tZXRyaWNMYXJnZSxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGRpcmVjdG9yeSBmb3IgdGhlIHRodW1ibmFpbHNcclxuICAgICAgICAgICAgY29uc3QgdGh1bWJuYWlsRGlyID0gdG1wLmRpclN5bmMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHdyaXRlIGEgZmlsZSBmb3IgYSB0aHVtYm5haWwgaW50byB0aGUgdGh1bWJuYWlsIGRpcmVjdG9yeVxyXG4gICAgICAgICAgICAvLyBAdGh1bWJuYWlsSW5mbzpcclxuICAgICAgICAgICAgLy8gICogbmFtZSA8c3RyaW5nPiAtIG5hbWUgZm9yIHRoZSB0aHVtYm5haWwgZmlsZSB0byBiZSBzYXZlZFxyXG4gICAgICAgICAgICAvLyAgKiBzbmFwc2hvdCA8aW1hZ2VVUkw+IC0gYjY0IHN0cmluZyBmb3IgdGhlIHBuZyB0byBiZSBzYXZlZFxyXG4gICAgICAgICAgICBjb25zdCB3cml0ZSA9IGZ1bmN0aW9uKHRodW1ibmFpbEluZm8pIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGh1bWJuYWlsSW5mbykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRodW1ibmFpbFBhdGggPSBwYXRoLmpvaW4odGh1bWJuYWlsRGlyLm5hbWUsIHRodW1ibmFpbEluZm8ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVVSTCA9IHRodW1ibmFpbEluZm8uc25hcHNob3QudmFsdWVPZigpLmRhdGFVUkw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aHVtYm5haWxCdWZmZXIgPSBuZXcgQnVmZmVyKGltYWdlVVJMLnN1YnN0cmluZygnZGF0YTppbWFnZS9wbmc7YmFzZTY0LCcubGVuZ3RoKSwgJ2Jhc2U2NCcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHEubmZhcHBseShmcy53cml0ZUZpbGUsIFt0aHVtYm5haWxQYXRoLCB0aHVtYm5haWxCdWZmZXJdKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBhcnJheSBvZiB0aHVtYm5haWwgcHJvbWlzZXMgdG8gc2V0dGxlL3dyaXRlXHJcbiAgICAgICAgICAgIGNvbnN0IHRodW1ibmFpbFByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgIHRodW1ibmFpbERhdGEuZm9yRWFjaCh0aHVtYm5haWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsUHJvbWlzZXMucHVzaCh3cml0ZSh0aHVtYm5haWwpKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBwcm9taXNlIGZvciBlYWNoIHRodW1ibmFpbCBhbmQgd3JhcCB0aGVtIGFsbCB0b2dldGhlciB0byByZXR1cm5cclxuICAgICAgICAgICAgcmV0dXJuIHEuYWxsKHRodW1ibmFpbFByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRodW1ibmFpbERpcjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHEucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vLyBhZGQgYSBpbnB1dCBhbmQgb3V0cHV0IGZpbGVwYXRocywgcHJpbnRlciB0eXBlLCBhbmQgc2xpY2Ugc2V0dGluZ3MgdG8gYXJnc1xyXG4gICAgY29uc3QgYWRkUGF0aHNUb0FyZ3MgPSBmdW5jdGlvbihhcmdzLCBtb2RlbEZpbGVQYXRoKSB7XHJcbiAgICAgICAgLy8gY3JlYXRlIGEgdGVtcCBkaXIgZm9yIHRoZSBtb2RlbCBhbmQgdG9vbHBhdGggZmlsZXNcclxuICAgICAgICBjb25zdCB0ZW1wRGlyID0gdG1wLmRpclN5bmMoKTtcclxuXHJcbiAgICAgICAgLy8gQ29weSBTVEwgZmlsZSBpbnRvIHRlbXBvcmFyeSBkaXJlY3RvcnlcclxuICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSBwYXRoLmJhc2VuYW1lKG1vZGVsRmlsZVBhdGgpO1xyXG4gICAgICAgIGFyZ3MuaW5wdXRQYXRoID0gcGF0aC5qb2luKHRlbXBEaXIubmFtZSwgbW9kZWxOYW1lKTtcclxuICAgICAgICBmcy5jb3B5U3luYyhtb2RlbEZpbGVQYXRoLCBhcmdzLmlucHV0UGF0aCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRvb2xwYXRoSXNKdHAgPSAhdHJheS5wcmludGVyLmlzU2tldGNoUHJpbnRlcigpO1xyXG4gICAgICAgIC8vIHBhdGggdG8gd2hpY2ggd2Ugd2lsbCB3cml0ZSB0aGUgdG9vbHBhdGggb3V0cHV0IGZyb20gbm9kZWdydWVcclxuICAgICAgICBhcmdzLnRwUGF0aCA9IHBhdGguam9pbih0ZW1wRGlyLm5hbWUsIHRvb2xwYXRoSXNKdHAgPyAncHJpbnQuanNvbnRvb2xwYXRoJyA6ICdwcmludC5nY29kZScpO1xyXG4gICAgICAgIC8vIHBhdGggdG8gd2hpY2ggd2Ugd2lsbCB3cml0ZSB0aGUgbWV0YS5qc29uIG91dHB1dCBmcm9tIG5vZGVncnVlOyBhbHNvXHJcbiAgICAgICAgLy8gcGF0aCBvZiBtZXRhZGF0YSB0aGF0IHdpbGwgYmUgaW5wdXQgdG8gc2xpY2Vjb25maWcncyBgcGFja2FnZV9tYWtlcmJvdGBcclxuICAgICAgICAvLyBjb21tYW5kO1xyXG4gICAgICAgIGFyZ3MubWV0YVBhdGggPSBwYXRoLmpvaW4odGVtcERpci5uYW1lLCAnbWV0YS5qc29uJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IG1iTmFtZSA9IGAke3RyYXkubmFtZSB8fCAndW50aXRsZWQnfS5tYWtlcmJvdGA7XHJcbiAgICAgICAgLy8gcGF0aCB0byB0aGUgZmluYWwgLm1ha2VyYm90O1xyXG4gICAgICAgIGFyZ3Mub3V0cHV0UGF0aCA9IHBhdGguam9pbih0ZW1wRGlyLm5hbWUsIG1iTmFtZSk7XHJcbiAgICAgICAgYXJncy5tYWtlcmJvdE5hbWUgPSBtYk5hbWU7XHJcblxyXG4gICAgICAgIGFyZ3MuY29uZmlnUGF0aCA9IHBhdGguam9pbih0ZW1wRGlyLm5hbWUsICdjb25maWcuanNvbicpO1xyXG5cclxuICAgICAgICByZXR1cm4gYXJncztcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZ2V0QWNjZWxDb25maWcgPSBmbHV4ID0+IHtcclxuICAgICAgICBjb25zdCBwcmludGVyID0gZmx1eC5zdG9yZSgnUHJpbnRlclN0b3JlJykuZ2V0U2VsZWN0ZWRQcmludGVyKCk7XHJcbiAgICAgICAgaWYgKHByaW50ZXIuaXNTa2V0Y2hQcmludGVyKCkpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBjb25zdCBwcmludFNldHRpbmdzID0gZmx1eC5zdG9yZSgnUHJpbnRTZXR0aW5nc1N0b3JlJykuZ2V0U3RhdGUoKTtcclxuICAgICAgICBjb25zdCB7IGJvdFR5cGUgfSA9IHByaW50ZXIuZ2V0R2VuZGVyKCk7XHJcbiAgICAgICAgY29uc3QgZXh0cnVkZXJzID0gcHJpbnRlci5nZXRBdHRhY2hlZEV4dHJ1ZGVycygpID8gcHJpbnRlci5nZXRBdHRhY2hlZEV4dHJ1ZGVycygpLmpvaW4oJy4nKSA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxzID0gcHJpbnRTZXR0aW5ncy5tYXRlcmlhbHMuc2VsZWN0ZWQuam9pbignLicpO1xyXG4gICAgICAgIGNvbnN0IG1iaXJSb290RGlyID0gcGF0aHMuZ2V0SW5zdGFsbEFydGlmYWN0c1Jvb3REaXIoKTtcclxuXHJcbiAgICAgICAgLy8gVGhlcmUgYXJlIG5vIGFjY2VsIGNvbmZpZ3Mgdy8gNXRoIGdlbiAmIEV4cGVyaW1lbnRhbCBFeHRydWRlclxyXG4gICAgICAgIGlmICghZXh0cnVkZXJzIHx8IGV4dHJ1ZGVycyA9PT0gRXh0cnVkZXJUeXBlRW51bS5tazEzX2V4cGVyaW1lbnRhbCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgZXhpdGluZyBhY2NlbCBjb25maWdzYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgcGF0aFxyXG4gICAgICAgICAgICAgICAgLmpvaW4obWJpclJvb3REaXIsICdwdWJsaWMnLCBib3RUeXBlLCBleHRydWRlcnMsIGAke21hdGVyaWFsc30uanNvbmApXHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgcHJvZHVjdGlvbiBzY2VuYXJpbyB3aGVyZSBwcm9maWxlcyBhcmUgbmVzdGVkIGluIGFwcC5hc2FyLnVucGFja2VkXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgbm90IGluIGFwcC5hc2FyXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvYXBwXFwuYXNhci8sICdhcHAuYXNhci51bnBhY2tlZCcpXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUHJvZ3Jlc3MocHJvZ3Jlc3NEYXRhKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gdHVybiBwcm9ncmVzcyBpbnRvIGFuIGFycmF5IHNvIHdlIHRyZWF0IHNpbmdsZSBhbmQgbXVsdGlwbGUgZW50cmllc1xyXG4gICAgICAgICAgICAvLyB0aGUgc2FtZVxyXG4gICAgICAgICAgICBsZXQgcHJvZ3Jlc3NKc29uID0gcHJvZ3Jlc3NEYXRhLnNwbGl0KCdcXG4nKTtcclxuICAgICAgICAgICAgaWYgKHByb2dyZXNzSnNvbi5sZW5ndGggPiAxICYmIHByb2dyZXNzSnNvbltwcm9ncmVzc0pzb24ubGVuZ3RoIC0gMV0gPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0pzb24gPSBwcm9ncmVzc0pzb25bcHJvZ3Jlc3NKc29uLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NKc29uID0gcHJvZ3Jlc3NKc29uW3Byb2dyZXNzSnNvbi5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHByb2dyZXNzSnNvbiAmJiBwcm9ncmVzc0NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0pzb24gPSBKU09OLnBhcnNlKHByb2dyZXNzSnNvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3MgY2FsbGJhY2sgd2FudHMgcHJvZ3Jlc3MgYXMgZGVjaW1hbHNcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2socHJvZ3Jlc3NKc29uLnRvdGFsUGVyY2VudENvbXBsZXRlIC8gMTAwLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFNsaWNlIFByb2dyZXNzIEVycm9yIGZvciBsaW5lICR7cHJvZ3Jlc3NEYXRhfTogJHtlcnJvcn1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBzdGwgZmlsZXMgaW4gb3VyIHRyYXlcclxuICAgIC8vIC0gT1IgLSBpZiB3ZSByZXR1cm4gYW4gdW5kZWZpbmVkIHZhbHVlIHdpdGhpbiB0aGUgc3RsRmlsZXMgYXJyYXlcclxuICAgIC8vIGp1c3QgcmV0dXJuIGEgcmVqZWN0aW9uXHJcbiAgICBpZiAodHJheS5zdGxGaWxlcyA9PT0gdW5kZWZpbmVkIHx8IHRyYXkuc3RsRmlsZXMuaW5jbHVkZXModW5kZWZpbmVkKSkge1xyXG4gICAgICAgIHJldHVybiBxLnJlamVjdChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRyYXkgb2JqZWN0JykpLm5vZGVpZnkoY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGJ1aWxkIGEgcHJvbWlzZSB0aGF0IHdpbGwgZG8gcHJlcHJvY2Vzc2luZyBhbmQgdGhlbiBzbGljZSB0aGUgZmlsZS5cclxuICAgIHJldHVybiBxXHJcbiAgICAgICAgLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpIHtcclxuICAgICAgICAgICAgbGV0IGFyZ3MgPSB7IHByaW50ZXJUeXBlOiB0cmF5LnByaW50ZXIuZ2V0R2VuZGVyKCkuYm90VHlwZSB9O1xyXG5cclxuICAgICAgICAgICAgLy8gc3RhcnQgcHJpbnQgcHJvY2VzcyBvbiBib3QgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgIGxldCBzdGFydFByaW50UHJvbWlzZTtcclxuICAgICAgICAgICAgaWYgKHRyYXkucGFyYW1ldGVycyAmJiB0cmF5LnBhcmFtZXRlcnMuam9iVHlwZSA9PT0gSk9CX1RZUEUuUFJJTlQpIHtcclxuICAgICAgICAgICAgICAgIC8vIChwcmludGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIGJvdHMgdGhhdCB3aWxsIGJlIHVzaW5nIC5tYWtlcmJvdHMpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYk5hbWUgPSBgJHt0cmF5Lm5hbWUgfHwgJ3VudGl0bGVkJ30ubWFrZXJib3RgO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQcmludFByb21pc2UgPSB0cmF5LnByaW50ZXIuc3RhcnRQcmludChtYk5hbWUsIGNhbmNlbFRva2VuKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0UHJpbnRQcm9taXNlID0gcSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2VuZXJhdGUgdGhlIGxpc3Qgb2YgZXh0cnVkZXIgdG8gbW9kZWwgc2VsZWN0aW9ucyBiYXNlZCBvbiB0aGVcclxuICAgICAgICAgICAgICogbGlzdCBvZiBib2R5UHJvcGVydGllcyBmcm9tIHRoZSB0cmF5LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAtLSBOT1RFIC0tXHJcbiAgICAgICAgICAgICAqIGdldFByb3BlcnR5L2dldFZhbHVlIGlzIEdDJ3MgaGFjayBvbnRvcCBvZiBJbW11dGFibGVKcyB0aGVyZWZvcmVcclxuICAgICAgICAgICAgICogYnJlYWtzIG1iLXBsdWdpbidzIHVuaXQgdGVzdHNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogLSBSYXlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbmVkRXh0cnVkZXJMaXN0ID0gdHJheS5ib2R5UHJvcGVydGllcy5tYXAoYm9keVByb3BlcnR5ID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBib2R5UHJvcGVydHkudG9KU09OKCkuaW5mby5leHRydWRlci52YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBjYWxsIHNsaWNlIGNvbmZpZyB3aXRoIHRoZSBzbGljZSBjb21tYW5kXHJcbiAgICAgICAgICAgIHN0YXJ0UHJpbnRQcm9taXNlXHJcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBieSBjcmVhdGluZyBhIGRvdCB0aGluZyBmaWxlIGZvciB0aGlzIHRyYXlcclxuICAgICAgICAgICAgICAgIC50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpbmcuY3JlYXRlVGhpbmdGaWxlKHRyYXkuc3RsRmlsZXMsIGFzc2lnbmVkRXh0cnVkZXJMaXN0LCB0cmF5LnRyYW5zZm9ybXMsIHRyYXkubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gZmV0Y2ggdGhlIHByb2ZpbGUgd2l0aCB3aGljaCB0byBzbGljZSBmcm9tIHNsaWNlY29uZmlnXHJcbiAgICAgICAgICAgICAgICAudGhlbihcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbih0aGluZ0ZpbGVQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuY29tbWFuZCA9ICdnZXRfcHJvZmlsZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhZGRQYXRoc1RvQXJncyhhcmdzLCB0aGluZ0ZpbGVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFIubWVyZ2VBbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFByb2ZpbGVBcmdzKHRyYXksIHRyYXkucHJpbnRlciwgb3B0aW9ucywgZmx1eCwgY2FuY2VsVG9rZW4sIGNhbGxiYWNrKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5TbGljZUNvbmZpZyhhcmdzLCBjYW5jZWxUb2tlbiwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGR1bXAgaXQgaW50byBhIGZpbGUgdG8gcGFzcyB0byBub2RlZ3J1ZVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24ocHJvZmlsZUpzb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHEubmZhcHBseShmcy53cml0ZUZpbGUsIFthcmdzLmNvbmZpZ1BhdGgsIEpTT04uc3RyaW5naWZ5KHByb2ZpbGVKc29uKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHRvb2xwYXRoIGFuZCBiYXNlIG1ldGFkYXRhIHVzaW5nIHRoZSBuZXdseSBjcmVhdGVkIGRvdCB0aGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGVycm9yIGluIGNyZWF0ZVRoaW5nRmlsZSwgcmVqZWN0IHRoZSBidWlsZFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29scGF0aElzSnRwID0gIXRyYXkucHJpbnRlci5pc1NrZXRjaFByaW50ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbHBhdGhlciA9IG5ldyBOb2RlR3J1ZS5Ob2RlVG9vbHBhdGhlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2NlbENvbmZpZ0ZpbGVQYXRoID0gZ2V0QWNjZWxDb25maWcoZmx1eCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsVG9rZW4gJiYgY2FuY2VsVG9rZW4uaXNDYW5jZWxsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNhbmNlbCB0b2tlbiBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgKGUuZy4gY2FuY2VsIHdhcyBoaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIGdlbmVyYXRpbmcgdGhlIGRvdCB0aGluZyB0byBzbGljZSksIHJlamVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignQ2FuY2VsbGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIudHlwZSA9ICdjYW5jZWwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNsaWNlQ29tcGxldGlvblByb21pc2UsIGNhbmNlbEZ1bmMgfSA9IHRvb2xwYXRoZXIucnVuTWlyYWNsZUdydWUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5jb25maWdQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuaW5wdXRQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xwYXRoSXNKdHAgPyBhcmdzLnRwUGF0aCA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5tZXRhUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29scGF0aElzSnRwID8gbnVsbCA6IGFyZ3MudHBQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VsQ29uZmlnRmlsZVBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmNlbFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNhbmNlbCB0b2tlbiBpcyB1c2VkIHdoaWxlIHNsaWNpbmcsIHJlamVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxUb2tlbi5vbignY2FuY2VsJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlQ29tcGxldGlvblByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRodW1ibmFpbHNcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRodW1ibmFpbHModHJheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoQ2FuY2VsbGluZyBhIHNsaWNlIHdpbGwgcmVqZWN0IHRoZSBzbGljZUNvbXBsZXRpb25Qcm9taXNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PSAnQ2FuY2VsbGVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IudHlwZSA9ICdjYW5jZWwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSB0aHVtYm5haWwgZGlyZWN0b3J5IHRvIHRoZSBhcmdzIGxpc3QgYW5kIHJ1biBzbGljZSBjb25maWdcclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBwYWNrYWdlIHRoZSBmaW5hbCAubWFrZXJib3QuIGlmIGNyZWF0ZVRodW1ibmFpbHMgZmFpbGVkLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZyBpdCBhbmQgcnVuIHNsaWNlIGNvbmZpZyB3aXRob3V0IHRoZSB0aHVtYm5haWwgZGlyZWN0b3J5IGFyZ3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24odGh1bWJuYWlsRGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuY29tbWFuZCA9ICdwYWNrYWdlX21ha2VyYm90JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy50aHVtYm5haWxEaXIgPSB0aHVtYm5haWxEaXIubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVuYW1lIHRoZSBgdHBQYXRoYCBwcm9wZXJ0eSB0byBgaW5wdXRQYXRoYCBzb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbGljZWNvbmZpZy5qcyBpcyBhYmxlIHRvIGRpcmVjdCBpdCBwcm9wZXJseSB0byB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYC1pYCBhcmcgdG8gc2xpY2Vjb25maWcgY29tbWFuZCBsaW5lLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmlucHV0UGF0aCA9IGFyZ3MudHBQYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXJncy50cFBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5TbGljZUNvbmZpZyhhcmdzLCBjYW5jZWxUb2tlbiwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbW1hbmQgPSAncGFja2FnZV9tYWtlcmJvdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5TbGljZUNvbmZpZyhhcmdzLCBjYW5jZWxUb2tlbiwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIC50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gc2xpY2luZyB2aWEgc2xpY2UgY29uZmlnIGZpbmlzaGVzIHVwLCByZXNvbHZlIHdpdGggdGhlIG1ha2VyYm90XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsZSBuYW1lIGFuZCBwYXRoLiByZWplY3Qgb24gZXJyb3JzLiByZXBvcnQgcHJvZ3Jlc3MgYmFjayB0byB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9ncmVzcyBjYWxsYmFjay5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IG5hbWU6IGFyZ3MubWFrZXJib3ROYW1lLCBwYXRoOiBhcmdzLm91dHB1dFBhdGggfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJheS5wYXJhbWV0ZXJzICYmIHRyYXkucGFyYW1ldGVycy5qb2JUeXBlID09PSBKT0JfVFlQRS5QUklOVCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJheS5wcmludGVyLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCBhcmdzIG5lZWRlZCB0byBnZW5lcmF0ZSBhIG1pcmFjbGUgZ3J1ZSBwcm9maWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7VHJheX0gdHJheSAtIGEgdHJheSBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZ1xyXG4gKiAgICA8cD4gcHJpbnRlcjogdGhlIHRhcmdldCBwcmludGVyIG9iamVjdCA8L3A+XHJcbiAqICAgIDxwPiBib2R5UHJvcGVydGllczogYW4gYXJyYXkgb2YgbGlzdCBvZiBvdmVycmlkZXNcclxuICogQHBhcmFtIHtQcmludGVyfSBwcmludGVyIC0gYSBtYWNoaW5lIHRoYXQgY29udGFpbnMgdGhlIGZvbGxvd2luZ1xyXG4gKiAgICA8cD4gbWFjaGluZUNvbmZpZyAtIGEgZGVzY3JpcHRpb24gb2YgdGhhdCBtYWNoaW5lcyBwcm9wZXJ0aWVzIDwvcD5cclxuICogICAgPHA+IGdlbmRlciAtIHRoZSB0eXBlIG9mIG1hY2hpbmUgdGhhdCB0aGlzIGlzPC9wPlxyXG4gKiBAcGFyYW0ge2hhc2h9IG9wdGlvbnMgLSBvcHRpb25hbCBhcmd1bWVudHNcclxuICpcclxuICogQHJldHVybnMge29iamVjdH0gYXJnc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UHJvZmlsZUFyZ3ModHJheSwgcHJpbnRlciwgb3B0aW9ucywgZmx1eCkge1xyXG4gICAgY29uc3QgYXJncyA9IHt9O1xyXG4gICAgcHJpbnRlciA9IHByaW50ZXIgfHwgdHJheS5wcmludGVyO1xyXG5cclxuICAgIC8vIGFkZCB0aGUgbWF0ZXJpYWxzLCBwcmludCBtb2RlIGFuZCBvdmVycmlkZXNcclxuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uRnJvbVRyYXkodHJheSk7XHJcbiAgICBjb25zdCBwcmludFNldHRpbmdzU3RvcmUgPSBmbHV4LnN0b3JlKCdQcmludFNldHRpbmdzU3RvcmUnKTtcclxuICAgIGNvbnN0IHByaW50U2V0dGluZ3MgPSBwcmludFNldHRpbmdzU3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIGNvbnN0IHN0b3JlT3ZlcnJpZGVzID0gcHJpbnRTZXR0aW5nc1N0b3JlLmdldE92ZXJyaWRlcygpO1xyXG5cclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIGFyZ3Mub3ZlcnJpZGVzID0gb3B0aW9ucy5vdmVycmlkZXMgPyBSLm1lcmdlQWxsKFtzdG9yZU92ZXJyaWRlcywgb3B0aW9ucy5vdmVycmlkZXNdKSA6IHN0b3JlT3ZlcnJpZGVzO1xyXG4gICAgYXJncy5tYXRlcmlhbHMgPSBvcHRpb25zLm1hdGVyaWFscyA/IG9wdGlvbnMubWF0ZXJpYWxzLnNlbGVjdGVkIDogcHJpbnRTZXR0aW5ncy5tYXRlcmlhbHMuc2VsZWN0ZWQ7XHJcbiAgICBhcmdzLnByaW50TW9kZSA9IHByaW50U2V0dGluZ3MucHJpbnRNb2RlLnNlbGVjdGVkO1xyXG4gICAgYXJncy5wcm9maWxlUGF0aCA9IGNvbmZpZ3VyYXRpb24ucHJvZmlsZVBhdGg7XHJcblxyXG4gICAgLy8gYWRkIHRoZSBtYWNoaW5lIGNvbmZpZyBvciBib3QgbmFtZSBkZXBlbmRpbmcgb24gd2hhdHMgdGhlcmVcclxuICAgIC8vIE5PVEU6IG1hY2hpbmUgY29uZmlnIGRpZmZlcnMgb24gbGl2ZSAmIGFyY2hldHlwZSBNZXRob2QsIGRvIG5vdCBwYXNzIG1hY2hpbmUgY29uZmlnIHRvIE1ldGhvZCBib3RcclxuICAgIGFyZ3MucHJpbnRlclR5cGUgPSBwcmludGVyLmdldEdlbmRlcigpLmJvdFR5cGU7XHJcbiAgICBpZiAocHJpbnRlci5pc1NrZXRjaFByaW50ZXIoKSkge1xyXG4gICAgICAgIC8vIEdyYWIgdGhlIG9ubHkgc3VwcG9ydGVkIGV4dHJ1ZGVyXHJcbiAgICAgICAgYXJncy5leHRydWRlcnMgPSBwcmludFNldHRpbmdzLmV4dHJ1ZGVycy5zdXBwb3J0ZWRbMF07XHJcbiAgICB9IGVsc2UgaWYgKGhhc01hY2hpbmVDb25maWcocHJpbnRlcikgJiYgcHJpbnRlci5pc0Nvbm5lY3RlZCgpICYmIHByaW50ZXIuaXNGaWZ0aEdlbigpKSB7XHJcbiAgICAgICAgYXJncy5leHRydWRlcnMgPSBwYXJzZUV4dHJ1ZGVyc0Zyb21NYWNoaW5lQ29uZmlnKHByaW50ZXIubWFjaGluZUNvbmZpZyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFyZ3MuZXh0cnVkZXJzID0gcHJpbnRlci5nZXRBdHRhY2hlZEV4dHJ1ZGVycygpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhcmdzO1xyXG59XHJcblxyXG4vKipcclxuICogZ2VuZXJhdGUgYSBtaXJhY2xlIGdydWUgcHJvZmlsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1RyYXl9IHRyYXkgLSBhIHRyYXkgb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmdcclxuICogICAgPHA+IHByaW50ZXI6IHRoZSB0YXJnZXQgcHJpbnRlciBvYmplY3QgPC9wPlxyXG4gKiAgICA8cD4gYm9keVByb3BlcnRpZXM6IGFuIGFycmF5IG9mIGxpc3Qgb2Ygb3ZlcnJpZGVzXHJcbiAqIEBwYXJhbSB7UHJpbnRlcn0gcHJpbnRlciAtIGEgbWFjaGluZSB0aGF0IGNvbnRhaW5zIHRoZSBmb2xsb3dpbmdcclxuICogICAgPHA+IG1hY2hpbmVDb25maWcgLSBhIGRlc2NyaXB0aW9uIG9mIHRoYXQgbWFjaGluZXMgcHJvcGVydGllcyA8L3A+XHJcbiAqICAgIDxwPiBnZW5kZXIgLSB0aGUgdHlwZSBvZiBtYWNoaW5lIHRoYXQgdGhpcyBpczwvcD5cclxuICogQHBhcmFtIHtoYXNofSBvcHRpb25zIC0gb3B0aW9uYWwgYXJndW1lbnRzXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gYSBub2RlLmpzIHN0eWxlIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtwcm9taXNlfSBwcm9taXNlIC0gcHJvbWlzZSByZXN1bHQgY29udGFpbnMgYSBQcm9maWxlIEpTT04gb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQcm9maWxlKHRyYXksIHByaW50ZXIsIG9wdGlvbnMsIGZsdXgsIGNhbmNlbFRva2VuLCBjYWxsYmFjaykge1xyXG4gICAgbGV0IGFyZ3MgPSB7IGNvbW1hbmQ6ICdnZXRfcHJvZmlsZScgfTtcclxuICAgIC8vIGNhbGwgc2xpY2UgY29uZmlnIHdpdGggdGhlIHNsaWNlIGNvbW1hbmRcclxuICAgIGFyZ3MgPSBSLm1lcmdlQWxsKFthcmdzLCBnZXRQcm9maWxlQXJncyh0cmF5LCBwcmludGVyLCBvcHRpb25zLCBmbHV4KV0pO1xyXG4gICAgcmV0dXJuIHJ1blNsaWNlQ29uZmlnKGFyZ3MsIGNhbmNlbFRva2VuLCBjYWxsYmFjayk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgdGhlIHNsaWNlIHNldHRpbmdzIChhcyBzbGljZWNvbmZpZyBleHBlY3RzIHRoZW0pIGZvciBhIHRyYXlcclxuICpcclxuICogQHBhcmFtIHtUcmF5fSB0cmF5IC0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIHRyYXkgb2YgbW9kZWxzXHJcbiAqICAgIDxwPiBib2R5UHJvcGVydGllcyAtIGEgbGlzdCBvZiBwcm9wZXJ0aWVzLCBvbmUgZm9yIGVhY2ggYm9keVxyXG4gKiAgICA8cD4gcHJpbnRlciAtIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBwcmludGVyXHJcbiAqXHJcbiAqICBAcmV0dXJucyB7RGljdH0gLSBhIGpzb24gZGljdCBvZiBzZXR0aW5ncyBmb3JtYXR0ZWQgZm9yIHNsaWNlIGNvbmZpZ1xyXG4gKi9cclxuZnVuY3Rpb24gY29uZmlndXJhdGlvbkZyb21UcmF5KHRyYXkpIHtcclxuICAgIGlmICghdHJheS5ib2R5UHJvcGVydGllcyB8fCB0cmF5LmJvZHlQcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHt9O1xyXG5cclxuICAgIC8vIHNldHVwIGEgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gZmlsbCBvdXRcclxuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB7XHJcbiAgICAgICAgbWF0ZXJpYWxzOiBbbnVsbCwgbnVsbF0sXHJcbiAgICAgICAgcHJpbnRNb2RlOiBudWxsLFxyXG4gICAgICAgIG92ZXJyaWRlczoge30sXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGNvbnZlcnQgZnJvbSBhbiBpbW11dGFibGUgbWFwIHRvIGEganMgb2JqZWN0LiBpcyB0aGVyZSBhIGJldHRlciB3YXk/XHJcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gdHJheS5ib2R5UHJvcGVydGllc1swXS50b0pTT04oKTtcclxuXHJcbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdGhhdCBtYWtlcyBzdXJlIHdlIGNhcmUgYWJvdXQgdGhpcyBwcm9wZXJ0eVxyXG4gICAgZnVuY3Rpb24gcmVhbFByb3BlcnR5KHByb3ApIHtcclxuICAgICAgICByZXR1cm4gcHJvcCAhPT0gdW5kZWZpbmVkICYmIHByb3AudmFsdWUgIT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcclxuICAgICAgICBpZiAocmVhbFByb3BlcnR5KHByb3BlcnRpZXNbcHJvcGVydHldKSkge1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydHkgPT09ICdtYXRlcmlhbHMnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLm1hdGVyaWFscyA9IHByb3BlcnRpZXMubWF0ZXJpYWxzLnZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAncHJpbnRNb2RlJykge1xyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5wcmludE1vZGUgPSBwcm9wZXJ0aWVzLnByaW50TW9kZS52YWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ2N1c3RvbVByb2ZpbGVQYXRoJykge1xyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5wcm9maWxlUGF0aCA9IHByb3BlcnRpZXMuY3VzdG9tUHJvZmlsZVBhdGgudmFsdWVbMF07XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09ICdyb3RhdGlvbkxvY2snIHx8IHByb3BlcnR5ID09PSAnb3JpZW50YXRpb24nIHx8IHByb3BlcnR5ID09PSAnZXh0cnVkZXJzJykge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2tpcCByb3RhdGlvbkxvY2sgYW5kIG9yaWVudGF0aW9uIGJlY2F1c2Ugd2UgbmV2ZXIgd2FudCB0byBoYW5kIHRoZW0gdG8gc2xpY2VDb25maWdcclxuICAgICAgICAgICAgICAgIC8vIGF0IHNvbWUgcG9pbnQsIGxldCdzIGFjdHVhbGx5IHJlbW92ZSByb3RhdGlvbkxvY2sgZnJvbSB0aGUgdHJheSwgaW5zdGVhZCBvZiBqdXN0IGlnbm9yaW5nIGl0XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2tpcCBleHRydWRlcnMgYmVjYXVzZSB3ZSBnZXQgdGhlbSBmcm9tIHRoZSBwcmludGVyIG9iamVjdCBpdHNlbGZcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQWxsIG90aGVyIHByb3BlcnRpZXMgYXJlIGFzc3VtZWQgdG8gYmUgb3ZlcnJpZGVzLiBVc2UgdGhlIGRlY29kZUtleVxyXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gZnJvbSB0aGUgc2xpY2Vjb25maWcgaW50ZXJmYWNlIHRvIGNvbnZlcnQgdGhlIGtleSB0byB1c2UgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRlbGltaXRvcnMgYW5kIHNldCB0aGUgb3ZlcnJpZGUuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVkUHJvcGVydHkgPSBkZWNvZGVLZXkocHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5vdmVycmlkZXNbZGVjb2RlZFByb3BlcnR5XSA9IHByb3BlcnRpZXNbcHJvcGVydHldLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb25maWd1cmF0aW9uO1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IGEgc2NoZW1hIGRlc2NyaWJpbmcgYXZhaWxhYmxlIHBhcmFtZXRlcnMgdGhhdCBVSSBjYW4gc2V0XHJcbiAqXHJcbiAqIEBwYXJhbSB7VHJheX0gdHJheSAtIGEgdHJheSBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZ1xyXG4gKiAgICA8cD4gcHJpbnRlcjogdGhlIHRhcmdldCBwcmludGVyIG9iamVjdCA8L3A+XHJcbiAqICAgIDxwPiBib2R5UHJvcGVydGllczogYW4gYXJyYXkgb2YgbGlzdCBvZiBvdmVycmlkZXNcclxuICogQHBhcmFtIHtQcmludGVyfSBwcmludGVyIC0gYSB0cmF5IG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtwcm9taXNlfSAtIHByb21pc2UgcmVzdWx0IGNvbnRhaW5zIGEganNvbiBzY2hlbWEgZm9yIGF2YWlsYWJsZVxyXG4gKiAgcGFyYW1ldGVycy5cclxuICovXHJcbmZ1bmN0aW9uIGdldFNjaGVtYSh0cmF5LCBwcmludGVyLCBpZ25vcmVFeHRydWRlckFyZ3MgPSBmYWxzZSwgZmx1eCwgY2FuY2VsVG9rZW4sIGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBhcmdzID0geyBjb21tYW5kOiAnZ2V0X3NjaGVtYScgfTtcclxuICAgIHByaW50ZXIgPSBwcmludGVyIHx8IHRyYXkucHJpbnRlcjtcclxuXHJcbiAgICAvLyBhZGQgdGhlIG1hdGVyaWFscywgcHJpbnQgbW9kZSBhbmQgb3ZlcnJpZGVzXHJcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbkZyb21UcmF5KHRyYXkpO1xyXG4gICAgY29uc3QgcHJpbnRTZXR0aW5nc1N0b3JlID0gZmx1eC5zdG9yZSgnUHJpbnRTZXR0aW5nc1N0b3JlJyk7XHJcbiAgICBjb25zdCBwcmludFNldHRpbmdzID0gcHJpbnRTZXR0aW5nc1N0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgYXJncy5vdmVycmlkZXMgPSBwcmludFNldHRpbmdzU3RvcmUuZ2V0T3ZlcnJpZGVzKCk7XHJcbiAgICBhcmdzLm1hdGVyaWFscyA9IHByaW50U2V0dGluZ3MubWF0ZXJpYWxzLnNlbGVjdGVkO1xyXG4gICAgYXJncy5wcmludE1vZGUgPSBwcmludFNldHRpbmdzLnByaW50TW9kZS5zZWxlY3RlZDtcclxuICAgIGFyZ3MucHJvZmlsZVBhdGggPSBjb25maWd1cmF0aW9uLnByb2ZpbGVQYXRoO1xyXG5cclxuICAgIC8vIGFkZCB0aGUgbWFjaGluZSBjb25maWcgb3IgYm90IG5hbWUgZGVwZW5kaW5nIG9uIHdoYXRzIHRoZXJlXHJcbiAgICBhcmdzLnByaW50ZXJUeXBlID0gcHJpbnRlci5nZXRHZW5kZXIoKS5ib3RUeXBlO1xyXG4gICAgaWYgKHByaW50ZXIuaXNTa2V0Y2hQcmludGVyKCkpIHtcclxuICAgICAgICAvLyBHcmFiIHRoZSBvbmx5IHN1cHBvcnRlZCBleHRydWRlclxyXG4gICAgICAgIGFyZ3MuZXh0cnVkZXJzID0gcHJpbnRTZXR0aW5ncy5leHRydWRlcnMuc3VwcG9ydGVkWzBdO1xyXG4gICAgfSBlbHNlIGlmIChoYXNNYWNoaW5lQ29uZmlnKHByaW50ZXIpICYmIHByaW50ZXIuaXNDb25uZWN0ZWQoKSAmJiBwcmludGVyLmlzRmlmdGhHZW4oKSkge1xyXG4gICAgICAgIGFyZ3MuZXh0cnVkZXJzID0gcGFyc2VFeHRydWRlcnNGcm9tTWFjaGluZUNvbmZpZyhwcmludGVyLm1hY2hpbmVDb25maWcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBhdHRhY2hlZEV4dHJ1ZGVycyA9IHByaW50ZXIuZ2V0QXR0YWNoZWRFeHRydWRlcnMoKTtcclxuICAgICAgICBjb25zdCBoYXNFeHBlcmltZW50YWxFeHRydWRlciA9XHJcbiAgICAgICAgICAgIGF0dGFjaGVkRXh0cnVkZXJzICYmIFIuY29udGFpbnMoRXh0cnVkZXJUeXBlRW51bS5tazEzX2V4cGVyaW1lbnRhbCwgYXR0YWNoZWRFeHRydWRlcnMpO1xyXG4gICAgICAgIC8vIEV4cGVyaW1lbnRhbCBFeHRydWRlciBzaG91bGQgb25seSBiZSBhc3NpZ25lZCBpZiBjb25uZWN0ZWQgdG8gdGhlXHJcbiAgICAgICAgLy8gcHJpbnRlci4gT3RoZXJ3aXNlLCBkb24ndCBwYXNzIGV4dHJ1ZGVyIGFyZ3VtZW50IGFuZCBoYXZlXHJcbiAgICAgICAgLy8gc2xpY2Vjb25maWcgcmV0dXJuIGJhY2sgZGVmYXVsdCBzZWxlY3RlZCBleHRydWRlci5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRvIHJldmVydCBiYWNrIHRvIGRlZmF1bHQgZXh0cnVkZXJzIGdvaW5nIGZyb20gTWV0aG9kID0+IHRvIE1ldGhvZCBYLFxyXG4gICAgICAgIC8vIGRvbid0IGJ1aWxkIG91dCB0aGUgZXh0cnVkZXJzIGFyZy4gKE9mZmxpbmUvQXJjaGV0eXBlcyBvbmx5KVxyXG4gICAgICAgIGlmICghaWdub3JlRXh0cnVkZXJBcmdzICYmICFoYXNFeHBlcmltZW50YWxFeHRydWRlciAmJiAhYXR0YWNoZWRFeHRydWRlcnMuaW5jbHVkZXModW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICBhcmdzLmV4dHJ1ZGVycyA9IGF0dGFjaGVkRXh0cnVkZXJzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcnVuU2xpY2VDb25maWcoYXJncywgY2FuY2VsVG9rZW4sIGNhbGxiYWNrKS50aGVuKHNjaGVtYSA9PiB7XHJcbiAgICAgICAgLy8gSW4gcmFyZSBjYXNlcywgc2xpY2Vjb25maWcgcmV0dXJucyBlbXB0cnkgc3RyaW5nLCAoXCJcIiksIHJlc3VsdGluZ1xyXG4gICAgICAgIC8vIGVycm9ycyB3aXRoIFNldHRpbmdzVUlTY2hlbWEuIEluc3RlYWQsIGxldHMgZXhpdCBvdXQgZWFybHkgYmVmb3JlXHJcbiAgICAgICAgLy8gdGhpbmdzIGJyZWFrLlxyXG4gICAgICAgIC8vIC0tIFJheVxyXG4gICAgICAgIGlmIChSLmlzRW1wdHkoc2NoZW1hKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBzYyA9IG5ldyBTbGljZWNvbmZpZyhwYXRocy5nZXRCaW5EaXIoKSk7XHJcbiAgICAgICAgc2NoZW1hLnN1cHBvcnRlZF9jb25maWd1cmF0aW9ucyA9IHNjLnN1cHBvcnRlZENvbmZpZ3MoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZXR0aW5nc1VJU2NoZW1hKHNjaGVtYSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIHNsaWNlY29uZmlnXHJcbiAqIEByZXR1cm5zIHtwcm9taXNlfSAtIHByb21pc2UgcmVzdWx0IGNvbnRhaW5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHZlcnNpb25cclxuICovXHJcbmZ1bmN0aW9uIGdldFZlcnNpb24oY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IGFyZ3MgPSB7IGNvbW1hbmQ6ICdnZXRfdmVyc2lvbicgfTtcclxuICAgIHJldHVybiBydW5TbGljZUNvbmZpZyhhcmdzLCBudWxsLCBjYWxsYmFjayk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBydW5zIHNsaWNlY29uZmlnIGZvciBhIGNvbW1hbmQgd2l0aCBhcmd1bWVudHNcclxuICpcclxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gd2hhdCBhcmd1bWVudHMgYXJlIG5lZWRlZCB3aXRoIGVhY2ggY29tbWFuZCwgc2VlIHRoZVxyXG4gKiBjb21tYW5kIGxpbmUgaW50ZXJmYWNlIGRvY3VtZW50YXRpb24gaW4gdGhlIHNsaWNlIGNvbmZpZyByZXBvIGF0XHJcbiAqIGdpdGh1Yi5jb20vbWFrZXJib3Qvc2xpY2Vjb25maWcvYmxvYi9kZXZlbG9wL2RvYy9jb21tYW5kX2xpbmVfaW50ZXJmYWNlLm1kXHJcbiAqXHJcbiAqIEBwYXJhbSB7bGlzdH0gYXJncyAtIG9wdGlvbmFsIGFyZ3VtZW50cyBmb3Igc2xpY2Vjb25maWdcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBhIG5vZGUuanMgc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb25cclxuICpcclxuICogQHJldHVybnMge3Byb21pc2V9IHByb21pc2UgLSBwcm9taXNlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSBjb21tYW5kIHBhc3NlZCBpbi5cclxuICogIGlmIGNvbW1hbmRbJ25vdGlmeSddIGlzIGZhbHNlLCByZXNvbHZlIGNvbnRhaW5zIHN0ZG91dCBmcm9tIHNsaWNlIGNvbmZpZy4gaWZcclxuICogIGNvbW1hbmRbJ25vdGlmeSddIGlzIHRydWUsIHJlc29sdmUgaXMgZW1wdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBydW5TbGljZUNvbmZpZyhhcmdzLCBjYW5jZWxUb2tlbiwgY2FsbGJhY2spIHtcclxuICAgIHJldHVybiBxXHJcbiAgICAgICAgLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpIHtcclxuICAgICAgICAgICAgLy8gY2FsbCBzbGljZSBjb25maWcgdXNpbmcgdGhlIGdpdmVuIGNvbW1hbmQgYW5kIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICBjb25zdCBzY1J1bm5lciA9IG5ldyBTbGljZWNvbmZpZyhwYXRocy5nZXRCaW5EaXIoKSk7XHJcbiAgICAgICAgICAgIGlmIChhcmdzICYmIGFyZ3MuY29tbWFuZCA9PT0gJ3NsaWNlJykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2xpY2VDb25maWdQcm9jZXNzID0gc2NSdW5uZXIuZXhlY3V0ZShhcmdzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjYW5jZWxUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNhbmNlbCB0b2tlbiBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgKGUuZy4gY2FuY2VsIHdhcyBoaXRcclxuICAgICAgICAgICAgICAgIC8vIHdoaWxlIGdlbmVyYXRpbmcgdGhlIGRvdCB0aGluZyB0byBzbGljZSksIHJlamVjdC5cclxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxUb2tlbi5pc0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xpY2VDb25maWdQcm9jZXNzLmtpbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0NhbmNlbGxlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVyci50eXBlID0gJ2NhbmNlbCc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjYW5jZWwgdG9rZW4gaXMgdXNlZCB3aGlsZSBzbGljaW5nLCByZWplY3QuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsVG9rZW4ub24oJ2NhbmNlbCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2VDb25maWdQcm9jZXNzLmtpbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdDYW5jZWxsZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnR5cGUgPSAnY2FuY2VsJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNsaWNlQ29uZmlnUHJvY2Vzcy5vbignZGF0YScsIGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChkYXRhLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbmZvJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlndXJlIG91dCBob3cgdG8gZ2V0IHRoaXMgaW50byB0aGUgJ2VuZCcgY2FsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xvZ2dpbmcnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBzb21lIGxvZ2dpbmc/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Byb2dyZXNzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZXBvcnRpbmcgZm9yIHR5cGU6IHNsaWNlLCBub3Qgb3RoZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgcHJlLWJpcmR3aW5nIGJvdHMgZ2V0IDIgcHJvZ3Jlc3MgYmFycy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGEuY29udGVudC5zdWJzdHJpbmcoMCwgMSkgPT09ICd7JyB8fCBkYXRhLmNvbnRlbnQuc3Vic3RyaW5nKDAsIDEpID09PSAnWycpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGRhdGEuY29udGVudCkudHlwZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShkYXRhLmNvbnRlbnQpLnR5cGUgPT09ICdzbGljZSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZnkoZGF0YS5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlZmF1bHQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgdW5zdXBwb3J0ZWQgdHlwZVxcbjoke2RhdGF9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xyXG59XHJcbi8qKlxyXG4gKiBTaHV0ZG93biB0aGUgYnVpbGRlciAoY2xlYW5pbmcgdXAgYW55IHJlc291cmNlcylcclxuICovXHJcbmZ1bmN0aW9uIHNodXRkb3duKCkge1xyXG4gICAgLy8gdGJkIHdoYXQgZG8gd2UgbmVlZCB0byBzaHV0ZG93biBoZXJlPyBleGlzdGluZyBwcm9jZXNzZXM/XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgYnVpbGQsXHJcbiAgICBnZXRQcm9maWxlLFxyXG4gICAgZ2V0U2NoZW1hLFxyXG4gICAgZ2V0U3VwcG9ydGVkQ29uZmlndXJhdGlvbnMsXHJcbiAgICBzaHV0ZG93bixcclxuICAgIGNvbmZpZyxcclxuICAgIGdldFZlcnNpb24sXHJcbn07XHJcbiJdfQ==
