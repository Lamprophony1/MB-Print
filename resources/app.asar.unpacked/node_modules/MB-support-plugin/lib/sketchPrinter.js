'use strict';

const q = require('q');

const Printer = require('eagle-print/model/printer');

const EventEmitter = require('eventemitter3');

const request = require('request');

const path = require('path');

const fs = require('fs-extra');

const util = require('./util.js');

const {
  maybe
} = require('./utils/maybe');

const {
  PrinterConnTypeEnum,
  PrinterStateEnum,
  FifthGenBots,
  SixthGenBots,
  GenderToType,
  ExtruderTypeEnum
} = require('./constants'); // TODO: Move this out to default-config to support staging URL in the future


const reflectorUrl = 'https://reflector.makerbot.com';

class SketchPrinter extends Printer {
  constructor(printerInfo, gender, userToken, printerManager, flux) {
    const data = {
      id: printerInfo.uid,
      connected: true,
      printer_status: {
        state: 'Unauthenticated'
      }
    };
    super(data, null, gender); // NOTE - Flux gets injected through PrinterStore via
    // this.injectFlux method. Check line 112-115 in
    // /stores/printerStore.js

    this._flux = maybe(flux);
    this._gender = gender;
    this._machineConfig = {}; // Notifications for critical updates (system, states, schema updates, etc..)

    this._updateNotifications = new EventEmitter();
    this.attachedExtruders = [ExtruderTypeEnum.sketch_extruder];
    this._printerInfo = printerInfo; // these are status properties generic to eagle-print's printer

    this._info = {};
    this._info.printer_status = {};
    this.setState(PrinterStateEnum.Unauthenticated);
    this._info.printer_status.current_print_job = {};
    this._info.printer_status.current_print_job.percent_done = 0; // these ones are makerbot specific, in case they may come in handy

    this._info.printer_status.current_process = null;
    this._info.printer_status.toolheads = null; // Errors from error_notifications and from processes go in here;
    // an error will get removed when acknowledgeError gets called for it
    // or when an error_acknowledged is received

    this._errors = new Map(); // this should only be available if the bot's process is in the 'failed' state
    // should only ever have one entry - this is incorrect and has been changed now
    // It will contain all state change errors.

    this._info.printer_status.state_change_errors = new Map();
    this._info.update_firmware_available = null;
    this._cameraFeedActive = false;
    this.userToken = userToken;
    this.cameraFeedIntervalId = null;
    this.updatePrinterStatus();
    this._sendCmdToReflector = this._sendCmdToReflector.bind(this);
    this._pollCmdFromReflector = this._pollCmdFromReflector.bind(this);
    this.emptyCameraImageBase64 = null;
    const emptyCameraImagePath = path.resolve(__dirname, './ui/views/images/empty.png');
    fs.readFile(emptyCameraImagePath, (err, data) => {
      if (err) {
        throw err;
      }

      this.emptyCameraImageBase64 = data;
    });
    this.printerManager = printerManager;
    this.checkAlive();
  }

  _initPrinter() {// Add machine config code here
    // this._getMachineConfig().done();
  }

  checkAlive() {
    setInterval(() => {
      const uid = this._printerInfo.uid;
      const printersList = this.printerManager.sketchPrinterList;
      const printersListHasBot = printersList.includes(uid);

      if (printersListHasBot && this.getStatus().state === PrinterStateEnum.Offline) {
        this.updatePrinterStatus();
      } else if (!printersListHasBot && this.getStatus().state !== PrinterStateEnum.Offline) {
        this.disconnect('Printer is not on Reflector printer list');
      }
    }, 5 * 1000); //every 5 seconds
  }

  disconnect(error) {
    this._updateNotifications.emit('dying_scream', error); // Put this back when we figure out getting flux in here
    //this.flux.actions.message.printerDisconnect(this._printerInfo.uid);


    this.setState(PrinterStateEnum.Offline);
  }

  addError(error) {
    this._errors.set(error.code, error);

    this._updateNotifications.emit('error');
  }

  removeError(errorId) {
    this._errors.delete(errorId);

    this._updateNotifications.emit('error');
  }

  saveStateError(err) {
    err.isStateErr = true;
    this.addError(err);
  }

  clearStateErrors() {
    for (const errEntry of this._errors) {
      const [errId, err] = errEntry;

      if (err.isStateErr) {
        this.removeError(errId);
      }
    }
  }

  getLastError() {
    // gets the most recent error
    let lastErr;

    for (const val of this._errors.values()) lastErr = val;

    return lastErr;
  }

  acknowledgeLastError() {
    const lastErr = this.getLastError();
    this.acknowledgeError(lastErr.error_id);
  }

  isMissingExtruder() {
    return false;
  }

  getChamberInfo() {
    return [];
  }

  getSpoolInfo() {
    return q(null);
  }

  processMethodExists(method) {
    const {
      current_process
    } = this._printerInfo.info;
    const processMethods = current_process ? current_process.methods : [];
    return processMethods.includes(method);
  }

  getTrackingInfo() {
    const data = {
      printer_id: this.getId(),
      printer_type: util.genderToCodeName(this.getInfo().model)
    };
    return data;
  }

  _errorAcknowledgedCallback(errorId) {
    this.removeError(errorId);
  }

  acknowledgeError(errorId) {
    // If this error was not internally-generated (ie. error code <= 0),
    // acknowledge the error with the printer; the error should then eventually
    // get cleared on this side from feedback from kaiten...
    if (errorId > -1) {
      let ackPromise = q();
      if (this.processMethodExists('acknowledge_error')) ackPromise = this.invoke('ProcessMethod', ['acknowledge_error']);else if (this.processMethodExists('acknowledge_failure')) ackPromise = this.invoke('ProcessMethod', ['acknowledge_failure']);
      return ackPromise.then(() => {
        return this.invoke('Acknowledged', [errorId]);
      }).then(() => {
        // clear the error after calling AcknowledgeError in case for
        // some reason we miss the error_acknowledged notification
        this._errorAcknowledgedCallback(errorId);
      }).done();
    } else {
      // else, just remove it
      this.removeError(errorId);
    }
  }

  getInfo() {
    return {
      vendor: 'MakerBot',
      model: this._botGender,
      modelName: this._info.name,
      firmware_version: this.firmwareVersion
    };
  }

  getStatus() {
    return this._info.printer_status;
  }

  getDisplayStatus() {
    return this.getStatus().state;
  }

  isAuthenticated() {
    const {
      state
    } = this.getStatus();
    return ![PrinterStateEnum.Reconnecting, PrinterStateEnum.Unauthenticated].includes(state);
  }

  isConnected() {
    const {
      state
    } = this.getStatus();
    return ![PrinterStateEnum.Offline, PrinterStateEnum.Reconnecting].includes(state);
  }

  deauthenticate() {}

  cancel() {
    return this.invoke('cancel');
  }

  _getMachineConfig() {
    return q(this._printer.GetMachineConfig()).then(config => {
      this._machineConfig = config;
    });
  }

  _updateFromExtruderChange(index, config) {// TODO(shirley): make this work, when I actually figure out how to
    // get these notifications from the bot...
  }

  authenticate(authInfo) {}

  getCodeName() {
    return util.genderToCodeName(this.getGender().getName());
  }

  getConnectionType() {
    return PrinterConnTypeEnum.REFLECTOR;
  }

  getCameraImage() {
    const options = {
      method: 'GET',
      url: `${reflectorUrl}/printers/${this.getIserial()}/image`,
      headers: {
        'Authorization': `Bearer ${this.userToken}`,
        'Content-Type': 'image/jpeg'
      },
      encoding: null
    };

    const convertImageData = imageData => {
      const imageBuffer = new Buffer(imageData);
      imageData = imageBuffer.toString('base64');
      return `data:image/jpeg;base64,${imageData}`;
    };

    return q.Promise((resolve, reject, notify) => {
      request(options, (err, res, body) => {
        if (err) {
          console.error(err);
          resolve(convertImageData(this.emptyCameraImageBase64));
        } else if (!res || ![200, 201].includes(res.statusCode) || !res.body || res.body === '' || res.body.length < 1) {
          resolve(convertImageData(this.emptyCameraImageBase64));
        } else {
          const dataUrl = convertImageData(body);
          resolve(dataUrl);
        }
      });
    });
  }

  getCameraFeed(cameraFrameCallback) {
    if (!this.cameraFeedIntervalId) {
      // Grab the first image, then...
      this.getCameraImage().then(imageData => {
        // Return imageData back via callback
        cameraFrameCallback(imageData); // Set up setInterval to ping for imageData

        this.cameraFeedIntervalId = setInterval(() => {
          this.getCameraImage().then(imageData => {
            cameraFrameCallback(imageData);
          });
        }, 30 * 1000);
      });
    }
  }

  endCameraFeed() {
    if (this.cameraFeedIntervalId) {
      clearInterval(this.cameraFeedIntervalId);
      this.cameraFeedIntervalId = null;
    }
  } // extruderList should be an array, even if there is only one extruder


  setAttachedExtruders(extruderList, index = null) {
    if (index !== null) {
      this.attachedExtruders[index] = extruderList;
    } else {
      this.attachedExtruders = extruderList;
    }
  }

  getAttachedExtruders() {
    return this.attachedExtruders;
  }

  _fwVerDictToString() {
    if (!this._printerInfo.info) return '0.0.0';
    const {
      firmware_version
    } = this._printerInfo.info;
    const {
      major,
      minor,
      bugfix,
      build
    } = firmware_version;
    return `${major}.${minor}.${bugfix}.${build}`;
  } // doing this (just in case) until eagle-print's printer settles down...


  get rawData() {
    return this._info;
  }

  get machineConfig() {
    return undefined; //this._machineConfig;
  }

  get firmwareVersion() {
    return this._fwVerDictToString();
  }

  get apiVersion() {
    return '0.0.0';
  }

  get currentState() {
    return this._info;
  }

  get _botGender() {
    return this._gender.getName();
  }

  get updateNotifications() {
    return this._updateNotifications;
  }

  checkForUnsupportedExtruderConfigurations() {
    return {
      result: false
    };
  }

  hasExtruderMaterialMismatch() {
    return false;
  }

  isFifthGen() {
    const botType = GenderToType[this.getModel()];
    return FifthGenBots.includes(botType);
  }

  isSixthGen() {
    const botType = GenderToType[this.getModel()];
    return SixthGenBots.includes(botType);
  }

  setState(state) {
    if (state !== this.getStatus().state) {
      this._info.printer_status.state = state;
    }
  }

  getName() {
    return this._printerInfo.name;
  }

  updatePrinterStatus() {
    const {
      current_process: currProcess
    } = this._printerInfo.info;

    if (!currProcess) {
      this.setState(PrinterStateEnum.Idle);
      this._info.printer_status = Object.assign({}, this._info.printer_status, {
        current_process: null,
        current_print_job: {
          percent_done: 0
        }
      });
    } else {
      this.setState(PrinterStateEnum.Busy);
      this._info.printer_status = Object.assign({}, this._info.printer_status, {
        current_process: currProcess,
        current_print_job: {
          percent_done: currProcess.name === 'PrintProcess' && currProcess.step === 'printing' ? currProcess.progress : null
        }
      });
    }

    const {
      state
    } = this.getStatus();
    const {
      Busy,
      Pending,
      Idle
    } = PrinterStateEnum;

    if ([Busy, Pending, Idle].includes(state)) {
      if (currProcess && currProcess.error) {
        this.saveStateError(currProcess.error);
      } else {
        this.clearStateErrors();
      }
    }

    this._flux.map(flux => flux.actions.PrinterDetailsActions.status(this.getId(), {}));
  }

  updateFromPrinterInfo(printerInfo) {
    this._printerInfo = printerInfo;
    this.updatePrinterStatus();
  }

  invoke(kaitenMethod, params = {}) {
    if (!kaitenMethod) return q(null); // Not elegant at all, but to truly capture the state of which the
    // polling of the command + polling with printer status, we'll need to
    // record the previous current_process (if null) or step (if currPros
    // not null)

    const {
      current_process
    } = this._printerInfo.info;
    const oldCurrProcOrStep = current_process && current_process.step;
    return this._sendCmdToReflector(kaitenMethod, params).then(cmdId => {
      return this._pollCmdFromReflector(cmdId, oldCurrProcOrStep, 2);
    });
  }
  /**
   * Send Kaiten Cmds to Reflector via POST-REQUEST for Sketch Printers
   * @param {str} method - kaiten method (snakecasing please!)
   * @param {obj/array} params - (obj) params contains additional arguments listed in
   *                             kaiten-API.md document. (array) - contains the process
   *                             method name needed to pass into params object...
   */


  _sendCmdToReflector(method, params) {
    const defer = q.defer();
    const options = {
      headers: {
        'Authorization': `Bearer ${this.userToken}`,
        'Content-Type': 'application/json'
      },
      url: `${reflectorUrl}/printers/${this.getIserial()}/commands`,
      method: 'POST',
      body: JSON.stringify({
        // ARGGGHHH! camelcasing vs snakecasing
        method: method === 'ProcessMethod' ? 'process_method' : method,
        params: Array.isArray(params) ? {
          method: params[0]
        } : params
      })
    };
    request(options, (err, res, body) => {
      if (err || ![200, 201].includes(res.statusCode)) {
        console.error(`Reflector REST API Error: Unable to process '${method}' command.`, err);
        defer.reject(err || res.body);
      } else {
        console.log(`Reflector REST API: Sent '${method}' command success`);
        const jsonRes = JSON.parse(body); // ATM, we're not invoking multiple cmds via reflector,
        // therefore return the first element of cmdIds array

        defer.resolve(jsonRes[0]);
      }
    });
    return defer.promise;
  }
  /**
   * Poll Reflector for status update on a command via GET-REQUEST for Sketch Printers
   * @param {str} cmdId - command id return reflector after sending a cmd request
   * @param {str/null} oldCurrProcOrStep - old state for comparing during polling
   * @param {int} timeInterval - time delay between polling for cmd status (seconds)
   **/


  _pollCmdFromReflector(cmdId, oldCurrProcOrStep, timeInterval) {
    const defer = q.defer();
    const options = {
      headers: {
        'Authorization': `Bearer ${this.userToken}`,
        'Content-Type': 'application/json'
      },
      url: `${reflectorUrl}/printers/${this.getIserial()}/commands/${cmdId}`,
      method: 'GET'
    };
    const pollingInterval = setInterval(() => {
      request(options, (err, res, body) => {
        if (err || ![200, 201].includes(res.statusCode)) {
          console.error(`Reflector REST API Error: Unable to poll command id: [${cmdId}].`, err);
          clearInterval(pollingInterval);
          defer.reject(err || res.body);
        } else {
          const jsonRes = JSON.parse(body);
          const {
            status
          } = jsonRes; // Not elegant at all, but to truly capture the state of which the
          // polling of the command + polling with printer status, we'll need to
          // record the previous current_process (if null) or step (if currPros
          // not null)

          const {
            current_process
          } = this._printerInfo.info;
          const newCurrProcOrStep = current_process && current_process.step; // TODO - find another logic condition to keep the spinner
          // loading because _printerInfo is still not up-to-date

          if (status === 'ack' && oldCurrProcOrStep !== newCurrProcOrStep) {
            clearInterval(pollingInterval);
            defer.resolve();
          }
        }
      });
    }, timeInterval * 1000);
  } // after slice -> upload the .makerbot


  uploadFileToCloudslicer(dotMakerbotFile) {
    const options = {
      method: 'POST',
      url: `${reflectorUrl}/printers/${this.getIserial()}/upload`,
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Authorization': `Bearer ${this.userToken}`
      },
      body: dotMakerbotFile
    };
    return q.Promise((resolve, reject) => {
      return request(options, (error, response, body) => {
        // how should errors be handled?
        if (error) {
          throw new Error(error);
        } else {
          // return the GCP file location URL
          const makerbotFileURL = JSON.parse(response.body).url;
          resolve(this.startCloudPrint(makerbotFileURL));
        }
      });
    });
  } // send print command with stored .makerbot


  startCloudPrint(makerbotFileURL) {
    const params = {
      url: makerbotFileURL,
      ensure_build_plate_clear: false
    };
    this.invoke('external_print', params);
  } /// Toolpath object made from what is returned by 'build' in makerbot.js...


  sendPrintFile(dotMakerbotFile) {
    if (this.getStatus().state !== PrinterStateEnum.Idle) {
      throw 'Unable to print to this printer at this time';
    }

    const filePath = path.resolve(__dirname, dotMakerbotFile.get('path'));
    return q(fs.readFile(filePath, (err, data) => {
      if (err) {
        throw err;
      } else {
        return this.uploadFileToCloudslicer(data);
      }
    }));
  }

  startPrint() {
    // This is here just for consistency with materbot-printer.js, and does nothing.
    return q();
  }

  changeFilament(processMethod, idleMethod) {
    if (this.getStatus().state === PrinterStateEnum.Busy) {
      return this.invoke('process_method', {
        method: processMethod
      });
    } else {
      return this.invoke(idleMethod);
    }
  }

  loadFilament() {
    const processMethod = 'load_filament';
    const idleMethod = 'load_filament';
    return this.changeFilament(processMethod, idleMethod);
  }

  unloadFilament() {
    const processMethod = 'unload_filament';
    const idleMethod = 'unload_filament';
    return this.changeFilament(processMethod, idleMethod);
  }

  stopFilament() {
    if (this.getStatus().state === PrinterStateEnum.Busy) {
      return this.invoke('process_method', {
        method: 'stop_filament'
      });
    }

    return this.cancel();
  }

  getExtruderInfo() {
    return this._printerInfo.info.toolheads ? this._printerInfo.info.toolheads.extruder : [];
  }

  getAllExtruderInfo() {
    return q(this.getExtruderInfo());
  }

  getSystemInfo() {
    return this._printerInfo.info || {};
  }

  getNetworkState() {
    return {};
  }

  getIpAddress() {
    return this._printerInfo.info ? this._printerInfo.info.ip : null;
  }

  getPlatformInfo() {
    return this._printerInfo.info.toolheads ? this._printerInfo.info.toolheads.platform : [];
  }

  getIserial() {
    return this.getId().split(':')[2];
  }

  getCurrentExtruderType() {
    return ExtruderTypeEnum.sketch_extruder;
  }

  isSketchPrinter() {
    return true;
  } // /stores/printerStore.js


  injectFlux(flux) {
    this._flux = maybe(flux);
    return this;
  }

}

module.exports = SketchPrinter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNrZXRjaFByaW50ZXIuanMiXSwibmFtZXMiOlsicSIsInJlcXVpcmUiLCJQcmludGVyIiwiRXZlbnRFbWl0dGVyIiwicmVxdWVzdCIsInBhdGgiLCJmcyIsInV0aWwiLCJtYXliZSIsIlByaW50ZXJDb25uVHlwZUVudW0iLCJQcmludGVyU3RhdGVFbnVtIiwiRmlmdGhHZW5Cb3RzIiwiU2l4dGhHZW5Cb3RzIiwiR2VuZGVyVG9UeXBlIiwiRXh0cnVkZXJUeXBlRW51bSIsInJlZmxlY3RvclVybCIsIlNrZXRjaFByaW50ZXIiLCJjb25zdHJ1Y3RvciIsInByaW50ZXJJbmZvIiwiZ2VuZGVyIiwidXNlclRva2VuIiwicHJpbnRlck1hbmFnZXIiLCJmbHV4IiwiZGF0YSIsImlkIiwidWlkIiwiY29ubmVjdGVkIiwicHJpbnRlcl9zdGF0dXMiLCJzdGF0ZSIsIl9mbHV4IiwiX2dlbmRlciIsIl9tYWNoaW5lQ29uZmlnIiwiX3VwZGF0ZU5vdGlmaWNhdGlvbnMiLCJhdHRhY2hlZEV4dHJ1ZGVycyIsInNrZXRjaF9leHRydWRlciIsIl9wcmludGVySW5mbyIsIl9pbmZvIiwic2V0U3RhdGUiLCJVbmF1dGhlbnRpY2F0ZWQiLCJjdXJyZW50X3ByaW50X2pvYiIsInBlcmNlbnRfZG9uZSIsImN1cnJlbnRfcHJvY2VzcyIsInRvb2xoZWFkcyIsIl9lcnJvcnMiLCJNYXAiLCJzdGF0ZV9jaGFuZ2VfZXJyb3JzIiwidXBkYXRlX2Zpcm13YXJlX2F2YWlsYWJsZSIsIl9jYW1lcmFGZWVkQWN0aXZlIiwiY2FtZXJhRmVlZEludGVydmFsSWQiLCJ1cGRhdGVQcmludGVyU3RhdHVzIiwiX3NlbmRDbWRUb1JlZmxlY3RvciIsImJpbmQiLCJfcG9sbENtZEZyb21SZWZsZWN0b3IiLCJlbXB0eUNhbWVyYUltYWdlQmFzZTY0IiwiZW1wdHlDYW1lcmFJbWFnZVBhdGgiLCJyZXNvbHZlIiwiX19kaXJuYW1lIiwicmVhZEZpbGUiLCJlcnIiLCJjaGVja0FsaXZlIiwiX2luaXRQcmludGVyIiwic2V0SW50ZXJ2YWwiLCJwcmludGVyc0xpc3QiLCJza2V0Y2hQcmludGVyTGlzdCIsInByaW50ZXJzTGlzdEhhc0JvdCIsImluY2x1ZGVzIiwiZ2V0U3RhdHVzIiwiT2ZmbGluZSIsImRpc2Nvbm5lY3QiLCJlcnJvciIsImVtaXQiLCJhZGRFcnJvciIsInNldCIsImNvZGUiLCJyZW1vdmVFcnJvciIsImVycm9ySWQiLCJkZWxldGUiLCJzYXZlU3RhdGVFcnJvciIsImlzU3RhdGVFcnIiLCJjbGVhclN0YXRlRXJyb3JzIiwiZXJyRW50cnkiLCJlcnJJZCIsImdldExhc3RFcnJvciIsImxhc3RFcnIiLCJ2YWwiLCJ2YWx1ZXMiLCJhY2tub3dsZWRnZUxhc3RFcnJvciIsImFja25vd2xlZGdlRXJyb3IiLCJlcnJvcl9pZCIsImlzTWlzc2luZ0V4dHJ1ZGVyIiwiZ2V0Q2hhbWJlckluZm8iLCJnZXRTcG9vbEluZm8iLCJwcm9jZXNzTWV0aG9kRXhpc3RzIiwibWV0aG9kIiwiaW5mbyIsInByb2Nlc3NNZXRob2RzIiwibWV0aG9kcyIsImdldFRyYWNraW5nSW5mbyIsInByaW50ZXJfaWQiLCJnZXRJZCIsInByaW50ZXJfdHlwZSIsImdlbmRlclRvQ29kZU5hbWUiLCJnZXRJbmZvIiwibW9kZWwiLCJfZXJyb3JBY2tub3dsZWRnZWRDYWxsYmFjayIsImFja1Byb21pc2UiLCJpbnZva2UiLCJ0aGVuIiwiZG9uZSIsInZlbmRvciIsIl9ib3RHZW5kZXIiLCJtb2RlbE5hbWUiLCJuYW1lIiwiZmlybXdhcmVfdmVyc2lvbiIsImZpcm13YXJlVmVyc2lvbiIsImdldERpc3BsYXlTdGF0dXMiLCJpc0F1dGhlbnRpY2F0ZWQiLCJSZWNvbm5lY3RpbmciLCJpc0Nvbm5lY3RlZCIsImRlYXV0aGVudGljYXRlIiwiY2FuY2VsIiwiX2dldE1hY2hpbmVDb25maWciLCJfcHJpbnRlciIsIkdldE1hY2hpbmVDb25maWciLCJjb25maWciLCJfdXBkYXRlRnJvbUV4dHJ1ZGVyQ2hhbmdlIiwiaW5kZXgiLCJhdXRoZW50aWNhdGUiLCJhdXRoSW5mbyIsImdldENvZGVOYW1lIiwiZ2V0R2VuZGVyIiwiZ2V0TmFtZSIsImdldENvbm5lY3Rpb25UeXBlIiwiUkVGTEVDVE9SIiwiZ2V0Q2FtZXJhSW1hZ2UiLCJvcHRpb25zIiwidXJsIiwiZ2V0SXNlcmlhbCIsImhlYWRlcnMiLCJlbmNvZGluZyIsImNvbnZlcnRJbWFnZURhdGEiLCJpbWFnZURhdGEiLCJpbWFnZUJ1ZmZlciIsIkJ1ZmZlciIsInRvU3RyaW5nIiwiUHJvbWlzZSIsInJlamVjdCIsIm5vdGlmeSIsInJlcyIsImJvZHkiLCJjb25zb2xlIiwic3RhdHVzQ29kZSIsImxlbmd0aCIsImRhdGFVcmwiLCJnZXRDYW1lcmFGZWVkIiwiY2FtZXJhRnJhbWVDYWxsYmFjayIsImVuZENhbWVyYUZlZWQiLCJjbGVhckludGVydmFsIiwic2V0QXR0YWNoZWRFeHRydWRlcnMiLCJleHRydWRlckxpc3QiLCJnZXRBdHRhY2hlZEV4dHJ1ZGVycyIsIl9md1ZlckRpY3RUb1N0cmluZyIsIm1ham9yIiwibWlub3IiLCJidWdmaXgiLCJidWlsZCIsInJhd0RhdGEiLCJtYWNoaW5lQ29uZmlnIiwidW5kZWZpbmVkIiwiYXBpVmVyc2lvbiIsImN1cnJlbnRTdGF0ZSIsInVwZGF0ZU5vdGlmaWNhdGlvbnMiLCJjaGVja0ZvclVuc3VwcG9ydGVkRXh0cnVkZXJDb25maWd1cmF0aW9ucyIsInJlc3VsdCIsImhhc0V4dHJ1ZGVyTWF0ZXJpYWxNaXNtYXRjaCIsImlzRmlmdGhHZW4iLCJib3RUeXBlIiwiZ2V0TW9kZWwiLCJpc1NpeHRoR2VuIiwiY3VyclByb2Nlc3MiLCJJZGxlIiwiT2JqZWN0IiwiYXNzaWduIiwiQnVzeSIsInN0ZXAiLCJwcm9ncmVzcyIsIlBlbmRpbmciLCJtYXAiLCJhY3Rpb25zIiwiUHJpbnRlckRldGFpbHNBY3Rpb25zIiwic3RhdHVzIiwidXBkYXRlRnJvbVByaW50ZXJJbmZvIiwia2FpdGVuTWV0aG9kIiwicGFyYW1zIiwib2xkQ3VyclByb2NPclN0ZXAiLCJjbWRJZCIsImRlZmVyIiwiSlNPTiIsInN0cmluZ2lmeSIsIkFycmF5IiwiaXNBcnJheSIsImxvZyIsImpzb25SZXMiLCJwYXJzZSIsInByb21pc2UiLCJ0aW1lSW50ZXJ2YWwiLCJwb2xsaW5nSW50ZXJ2YWwiLCJuZXdDdXJyUHJvY09yU3RlcCIsInVwbG9hZEZpbGVUb0Nsb3Vkc2xpY2VyIiwiZG90TWFrZXJib3RGaWxlIiwicmVzcG9uc2UiLCJFcnJvciIsIm1ha2VyYm90RmlsZVVSTCIsInN0YXJ0Q2xvdWRQcmludCIsImVuc3VyZV9idWlsZF9wbGF0ZV9jbGVhciIsInNlbmRQcmludEZpbGUiLCJmaWxlUGF0aCIsImdldCIsInN0YXJ0UHJpbnQiLCJjaGFuZ2VGaWxhbWVudCIsInByb2Nlc3NNZXRob2QiLCJpZGxlTWV0aG9kIiwibG9hZEZpbGFtZW50IiwidW5sb2FkRmlsYW1lbnQiLCJzdG9wRmlsYW1lbnQiLCJnZXRFeHRydWRlckluZm8iLCJleHRydWRlciIsImdldEFsbEV4dHJ1ZGVySW5mbyIsImdldFN5c3RlbUluZm8iLCJnZXROZXR3b3JrU3RhdGUiLCJnZXRJcEFkZHJlc3MiLCJpcCIsImdldFBsYXRmb3JtSW5mbyIsInBsYXRmb3JtIiwic3BsaXQiLCJnZXRDdXJyZW50RXh0cnVkZXJUeXBlIiwiaXNTa2V0Y2hQcmludGVyIiwiaW5qZWN0Rmx1eCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLE1BQU1BLENBQUMsR0FBR0MsT0FBTyxDQUFDLEdBQUQsQ0FBakI7O0FBQ0EsTUFBTUMsT0FBTyxHQUFHRCxPQUFPLENBQUMsMkJBQUQsQ0FBdkI7O0FBQ0EsTUFBTUUsWUFBWSxHQUFHRixPQUFPLENBQUMsZUFBRCxDQUE1Qjs7QUFDQSxNQUFNRyxPQUFPLEdBQUdILE9BQU8sQ0FBQyxTQUFELENBQXZCOztBQUNBLE1BQU1JLElBQUksR0FBR0osT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsTUFBTUssRUFBRSxHQUFHTCxPQUFPLENBQUMsVUFBRCxDQUFsQjs7QUFFQSxNQUFNTSxJQUFJLEdBQUdOLE9BQU8sQ0FBQyxXQUFELENBQXBCOztBQUNBLE1BQU07QUFBRU8sRUFBQUE7QUFBRixJQUFZUCxPQUFPLENBQUMsZUFBRCxDQUF6Qjs7QUFDQSxNQUFNO0FBQ0ZRLEVBQUFBLG1CQURFO0FBRUZDLEVBQUFBLGdCQUZFO0FBR0ZDLEVBQUFBLFlBSEU7QUFJRkMsRUFBQUEsWUFKRTtBQUtGQyxFQUFBQSxZQUxFO0FBTUZDLEVBQUFBO0FBTkUsSUFPRmIsT0FBTyxDQUFDLGFBQUQsQ0FQWCxDLENBU0E7OztBQUNBLE1BQU1jLFlBQVksR0FBRyxnQ0FBckI7O0FBRUEsTUFBTUMsYUFBTixTQUE0QmQsT0FBNUIsQ0FBb0M7QUFDaENlLEVBQUFBLFdBQVcsQ0FBQ0MsV0FBRCxFQUFjQyxNQUFkLEVBQXNCQyxTQUF0QixFQUFpQ0MsY0FBakMsRUFBaURDLElBQWpELEVBQXVEO0FBQzlELFVBQU1DLElBQUksR0FBRztBQUNUQyxNQUFBQSxFQUFFLEVBQUVOLFdBQVcsQ0FBQ08sR0FEUDtBQUVUQyxNQUFBQSxTQUFTLEVBQUUsSUFGRjtBQUdUQyxNQUFBQSxjQUFjLEVBQUU7QUFDWkMsUUFBQUEsS0FBSyxFQUFFO0FBREs7QUFIUCxLQUFiO0FBUUEsVUFBTUwsSUFBTixFQUFZLElBQVosRUFBa0JKLE1BQWxCLEVBVDhELENBVzlEO0FBQ0E7QUFDQTs7QUFDQSxTQUFLVSxLQUFMLEdBQWFyQixLQUFLLENBQUNjLElBQUQsQ0FBbEI7QUFFQSxTQUFLUSxPQUFMLEdBQWVYLE1BQWY7QUFDQSxTQUFLWSxjQUFMLEdBQXNCLEVBQXRCLENBakI4RCxDQW1COUQ7O0FBQ0EsU0FBS0Msb0JBQUwsR0FBNEIsSUFBSTdCLFlBQUosRUFBNUI7QUFFQSxTQUFLOEIsaUJBQUwsR0FBeUIsQ0FBQ25CLGdCQUFnQixDQUFDb0IsZUFBbEIsQ0FBekI7QUFFQSxTQUFLQyxZQUFMLEdBQW9CakIsV0FBcEIsQ0F4QjhELENBMEI5RDs7QUFDQSxTQUFLa0IsS0FBTCxHQUFhLEVBQWI7QUFDQSxTQUFLQSxLQUFMLENBQVdULGNBQVgsR0FBNEIsRUFBNUI7QUFDQSxTQUFLVSxRQUFMLENBQWMzQixnQkFBZ0IsQ0FBQzRCLGVBQS9CO0FBQ0EsU0FBS0YsS0FBTCxDQUFXVCxjQUFYLENBQTBCWSxpQkFBMUIsR0FBOEMsRUFBOUM7QUFDQSxTQUFLSCxLQUFMLENBQVdULGNBQVgsQ0FBMEJZLGlCQUExQixDQUE0Q0MsWUFBNUMsR0FBMkQsQ0FBM0QsQ0EvQjhELENBaUM5RDs7QUFDQSxTQUFLSixLQUFMLENBQVdULGNBQVgsQ0FBMEJjLGVBQTFCLEdBQTRDLElBQTVDO0FBQ0EsU0FBS0wsS0FBTCxDQUFXVCxjQUFYLENBQTBCZSxTQUExQixHQUFzQyxJQUF0QyxDQW5DOEQsQ0FvQzlEO0FBQ0E7QUFDQTs7QUFDQSxTQUFLQyxPQUFMLEdBQWUsSUFBSUMsR0FBSixFQUFmLENBdkM4RCxDQXlDOUQ7QUFDQTtBQUNBOztBQUNBLFNBQUtSLEtBQUwsQ0FBV1QsY0FBWCxDQUEwQmtCLG1CQUExQixHQUFnRCxJQUFJRCxHQUFKLEVBQWhEO0FBQ0EsU0FBS1IsS0FBTCxDQUFXVSx5QkFBWCxHQUF1QyxJQUF2QztBQUVBLFNBQUtDLGlCQUFMLEdBQXlCLEtBQXpCO0FBRUEsU0FBSzNCLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0EsU0FBSzRCLG9CQUFMLEdBQTRCLElBQTVCO0FBRUEsU0FBS0MsbUJBQUw7QUFFQSxTQUFLQyxtQkFBTCxHQUEyQixLQUFLQSxtQkFBTCxDQUF5QkMsSUFBekIsQ0FBOEIsSUFBOUIsQ0FBM0I7QUFDQSxTQUFLQyxxQkFBTCxHQUE2QixLQUFLQSxxQkFBTCxDQUEyQkQsSUFBM0IsQ0FBZ0MsSUFBaEMsQ0FBN0I7QUFFQSxTQUFLRSxzQkFBTCxHQUE4QixJQUE5QjtBQUVBLFVBQU1DLG9CQUFvQixHQUFHakQsSUFBSSxDQUFDa0QsT0FBTCxDQUFhQyxTQUFiLEVBQXdCLDZCQUF4QixDQUE3QjtBQUNBbEQsSUFBQUEsRUFBRSxDQUFDbUQsUUFBSCxDQUFZSCxvQkFBWixFQUFrQyxDQUFDSSxHQUFELEVBQU1uQyxJQUFOLEtBQWU7QUFDN0MsVUFBSW1DLEdBQUosRUFBUztBQUNMLGNBQU1BLEdBQU47QUFDSDs7QUFDRCxXQUFLTCxzQkFBTCxHQUE4QjlCLElBQTlCO0FBQ0gsS0FMRDtBQU9BLFNBQUtGLGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0EsU0FBS3NDLFVBQUw7QUFDSDs7QUFFREMsRUFBQUEsWUFBWSxHQUFHLENBQ1g7QUFDQTtBQUNIOztBQUVERCxFQUFBQSxVQUFVLEdBQUc7QUFDVEUsSUFBQUEsV0FBVyxDQUFDLE1BQU07QUFDZCxZQUFNcEMsR0FBRyxHQUFHLEtBQUtVLFlBQUwsQ0FBa0JWLEdBQTlCO0FBQ0EsWUFBTXFDLFlBQVksR0FBRyxLQUFLekMsY0FBTCxDQUFvQjBDLGlCQUF6QztBQUNBLFlBQU1DLGtCQUFrQixHQUFHRixZQUFZLENBQUNHLFFBQWIsQ0FBc0J4QyxHQUF0QixDQUEzQjs7QUFDQSxVQUFJdUMsa0JBQWtCLElBQUksS0FBS0UsU0FBTCxHQUFpQnRDLEtBQWpCLEtBQTJCbEIsZ0JBQWdCLENBQUN5RCxPQUF0RSxFQUErRTtBQUMzRSxhQUFLbEIsbUJBQUw7QUFDSCxPQUZELE1BRU8sSUFBSSxDQUFDZSxrQkFBRCxJQUF1QixLQUFLRSxTQUFMLEdBQWlCdEMsS0FBakIsS0FBMkJsQixnQkFBZ0IsQ0FBQ3lELE9BQXZFLEVBQWdGO0FBQ25GLGFBQUtDLFVBQUwsQ0FBZ0IsMENBQWhCO0FBQ0g7QUFDSixLQVRVLEVBU1IsSUFBSSxJQVRJLENBQVgsQ0FEUyxDQVVLO0FBQ2pCOztBQUVEQSxFQUFBQSxVQUFVLENBQUNDLEtBQUQsRUFBUTtBQUNkLFNBQUtyQyxvQkFBTCxDQUEwQnNDLElBQTFCLENBQStCLGNBQS9CLEVBQStDRCxLQUEvQyxFQURjLENBRWQ7QUFDQTs7O0FBQ0EsU0FBS2hDLFFBQUwsQ0FBYzNCLGdCQUFnQixDQUFDeUQsT0FBL0I7QUFDSDs7QUFFREksRUFBQUEsUUFBUSxDQUFDRixLQUFELEVBQVE7QUFDWixTQUFLMUIsT0FBTCxDQUFhNkIsR0FBYixDQUFpQkgsS0FBSyxDQUFDSSxJQUF2QixFQUE2QkosS0FBN0I7O0FBQ0EsU0FBS3JDLG9CQUFMLENBQTBCc0MsSUFBMUIsQ0FBK0IsT0FBL0I7QUFDSDs7QUFFREksRUFBQUEsV0FBVyxDQUFDQyxPQUFELEVBQVU7QUFDakIsU0FBS2hDLE9BQUwsQ0FBYWlDLE1BQWIsQ0FBb0JELE9BQXBCOztBQUNBLFNBQUszQyxvQkFBTCxDQUEwQnNDLElBQTFCLENBQStCLE9BQS9CO0FBQ0g7O0FBRURPLEVBQUFBLGNBQWMsQ0FBQ25CLEdBQUQsRUFBTTtBQUNoQkEsSUFBQUEsR0FBRyxDQUFDb0IsVUFBSixHQUFpQixJQUFqQjtBQUNBLFNBQUtQLFFBQUwsQ0FBY2IsR0FBZDtBQUNIOztBQUVEcUIsRUFBQUEsZ0JBQWdCLEdBQUc7QUFDZixTQUFLLE1BQU1DLFFBQVgsSUFBdUIsS0FBS3JDLE9BQTVCLEVBQXFDO0FBQ2pDLFlBQU0sQ0FBQ3NDLEtBQUQsRUFBUXZCLEdBQVIsSUFBZXNCLFFBQXJCOztBQUNBLFVBQUl0QixHQUFHLENBQUNvQixVQUFSLEVBQW9CO0FBQ2hCLGFBQUtKLFdBQUwsQ0FBaUJPLEtBQWpCO0FBQ0g7QUFDSjtBQUNKOztBQUVEQyxFQUFBQSxZQUFZLEdBQUc7QUFDWDtBQUNBLFFBQUlDLE9BQUo7O0FBQ0EsU0FBSyxNQUFNQyxHQUFYLElBQWtCLEtBQUt6QyxPQUFMLENBQWEwQyxNQUFiLEVBQWxCLEVBQXlDRixPQUFPLEdBQUdDLEdBQVY7O0FBQ3pDLFdBQU9ELE9BQVA7QUFDSDs7QUFFREcsRUFBQUEsb0JBQW9CLEdBQUc7QUFDbkIsVUFBTUgsT0FBTyxHQUFHLEtBQUtELFlBQUwsRUFBaEI7QUFDQSxTQUFLSyxnQkFBTCxDQUFzQkosT0FBTyxDQUFDSyxRQUE5QjtBQUNIOztBQUVEQyxFQUFBQSxpQkFBaUIsR0FBRztBQUNoQixXQUFPLEtBQVA7QUFDSDs7QUFFREMsRUFBQUEsY0FBYyxHQUFHO0FBQ2IsV0FBTyxFQUFQO0FBQ0g7O0FBRURDLEVBQUFBLFlBQVksR0FBRztBQUNYLFdBQU8zRixDQUFDLENBQUMsSUFBRCxDQUFSO0FBQ0g7O0FBRUQ0RixFQUFBQSxtQkFBbUIsQ0FBQ0MsTUFBRCxFQUFTO0FBQ3hCLFVBQU07QUFBRXBELE1BQUFBO0FBQUYsUUFBc0IsS0FBS04sWUFBTCxDQUFrQjJELElBQTlDO0FBQ0EsVUFBTUMsY0FBYyxHQUFHdEQsZUFBZSxHQUFHQSxlQUFlLENBQUN1RCxPQUFuQixHQUE2QixFQUFuRTtBQUNBLFdBQU9ELGNBQWMsQ0FBQzlCLFFBQWYsQ0FBd0I0QixNQUF4QixDQUFQO0FBQ0g7O0FBRURJLEVBQUFBLGVBQWUsR0FBRztBQUNkLFVBQU0xRSxJQUFJLEdBQUc7QUFDVDJFLE1BQUFBLFVBQVUsRUFBRSxLQUFLQyxLQUFMLEVBREg7QUFFVEMsTUFBQUEsWUFBWSxFQUFFN0YsSUFBSSxDQUFDOEYsZ0JBQUwsQ0FBc0IsS0FBS0MsT0FBTCxHQUFlQyxLQUFyQztBQUZMLEtBQWI7QUFJQSxXQUFPaEYsSUFBUDtBQUNIOztBQUVEaUYsRUFBQUEsMEJBQTBCLENBQUM3QixPQUFELEVBQVU7QUFDaEMsU0FBS0QsV0FBTCxDQUFpQkMsT0FBakI7QUFDSDs7QUFFRFksRUFBQUEsZ0JBQWdCLENBQUNaLE9BQUQsRUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxRQUFJQSxPQUFPLEdBQUcsQ0FBQyxDQUFmLEVBQWtCO0FBQ2QsVUFBSThCLFVBQVUsR0FBR3pHLENBQUMsRUFBbEI7QUFDQSxVQUFJLEtBQUs0RixtQkFBTCxDQUF5QixtQkFBekIsQ0FBSixFQUNJYSxVQUFVLEdBQUcsS0FBS0MsTUFBTCxDQUFZLGVBQVosRUFBNkIsQ0FBQyxtQkFBRCxDQUE3QixDQUFiLENBREosS0FFSyxJQUFJLEtBQUtkLG1CQUFMLENBQXlCLHFCQUF6QixDQUFKLEVBQ0RhLFVBQVUsR0FBRyxLQUFLQyxNQUFMLENBQVksZUFBWixFQUE2QixDQUFDLHFCQUFELENBQTdCLENBQWI7QUFFSixhQUFPRCxVQUFVLENBQ1pFLElBREUsQ0FDRyxNQUFNO0FBQ1IsZUFBTyxLQUFLRCxNQUFMLENBQVksY0FBWixFQUE0QixDQUFDL0IsT0FBRCxDQUE1QixDQUFQO0FBQ0gsT0FIRSxFQUlGZ0MsSUFKRSxDQUlHLE1BQU07QUFDUjtBQUNBO0FBQ0EsYUFBS0gsMEJBQUwsQ0FBZ0M3QixPQUFoQztBQUNILE9BUkUsRUFTRmlDLElBVEUsRUFBUDtBQVVILEtBakJELE1BaUJPO0FBQ0g7QUFDQSxXQUFLbEMsV0FBTCxDQUFpQkMsT0FBakI7QUFDSDtBQUNKOztBQUVEMkIsRUFBQUEsT0FBTyxHQUFHO0FBQ04sV0FBTztBQUNITyxNQUFBQSxNQUFNLEVBQUUsVUFETDtBQUVITixNQUFBQSxLQUFLLEVBQUUsS0FBS08sVUFGVDtBQUdIQyxNQUFBQSxTQUFTLEVBQUUsS0FBSzNFLEtBQUwsQ0FBVzRFLElBSG5CO0FBSUhDLE1BQUFBLGdCQUFnQixFQUFFLEtBQUtDO0FBSnBCLEtBQVA7QUFNSDs7QUFFRGhELEVBQUFBLFNBQVMsR0FBRztBQUNSLFdBQU8sS0FBSzlCLEtBQUwsQ0FBV1QsY0FBbEI7QUFDSDs7QUFFRHdGLEVBQUFBLGdCQUFnQixHQUFHO0FBQ2YsV0FBTyxLQUFLakQsU0FBTCxHQUFpQnRDLEtBQXhCO0FBQ0g7O0FBRUR3RixFQUFBQSxlQUFlLEdBQUc7QUFDZCxVQUFNO0FBQUV4RixNQUFBQTtBQUFGLFFBQVksS0FBS3NDLFNBQUwsRUFBbEI7QUFDQSxXQUFPLENBQUMsQ0FBQ3hELGdCQUFnQixDQUFDMkcsWUFBbEIsRUFBZ0MzRyxnQkFBZ0IsQ0FBQzRCLGVBQWpELEVBQWtFMkIsUUFBbEUsQ0FBMkVyQyxLQUEzRSxDQUFSO0FBQ0g7O0FBRUQwRixFQUFBQSxXQUFXLEdBQUc7QUFDVixVQUFNO0FBQUUxRixNQUFBQTtBQUFGLFFBQVksS0FBS3NDLFNBQUwsRUFBbEI7QUFDQSxXQUFPLENBQUMsQ0FBQ3hELGdCQUFnQixDQUFDeUQsT0FBbEIsRUFBMkJ6RCxnQkFBZ0IsQ0FBQzJHLFlBQTVDLEVBQTBEcEQsUUFBMUQsQ0FBbUVyQyxLQUFuRSxDQUFSO0FBQ0g7O0FBRUQyRixFQUFBQSxjQUFjLEdBQUcsQ0FBRTs7QUFFbkJDLEVBQUFBLE1BQU0sR0FBRztBQUNMLFdBQU8sS0FBS2QsTUFBTCxDQUFZLFFBQVosQ0FBUDtBQUNIOztBQUVEZSxFQUFBQSxpQkFBaUIsR0FBRztBQUNoQixXQUFPekgsQ0FBQyxDQUFDLEtBQUswSCxRQUFMLENBQWNDLGdCQUFkLEVBQUQsQ0FBRCxDQUFvQ2hCLElBQXBDLENBQXlDaUIsTUFBTSxJQUFJO0FBQ3RELFdBQUs3RixjQUFMLEdBQXNCNkYsTUFBdEI7QUFDSCxLQUZNLENBQVA7QUFHSDs7QUFFREMsRUFBQUEseUJBQXlCLENBQUNDLEtBQUQsRUFBUUYsTUFBUixFQUFnQixDQUNyQztBQUNBO0FBQ0g7O0FBRURHLEVBQUFBLFlBQVksQ0FBQ0MsUUFBRCxFQUFXLENBQUU7O0FBRXpCQyxFQUFBQSxXQUFXLEdBQUc7QUFDVixXQUFPMUgsSUFBSSxDQUFDOEYsZ0JBQUwsQ0FBc0IsS0FBSzZCLFNBQUwsR0FBaUJDLE9BQWpCLEVBQXRCLENBQVA7QUFDSDs7QUFFREMsRUFBQUEsaUJBQWlCLEdBQUc7QUFDaEIsV0FBTzNILG1CQUFtQixDQUFDNEgsU0FBM0I7QUFDSDs7QUFFREMsRUFBQUEsY0FBYyxHQUFHO0FBQ2IsVUFBTUMsT0FBTyxHQUFHO0FBQ1oxQyxNQUFBQSxNQUFNLEVBQUUsS0FESTtBQUVaMkMsTUFBQUEsR0FBRyxFQUFHLEdBQUV6SCxZQUFhLGFBQVksS0FBSzBILFVBQUwsRUFBa0IsUUFGdkM7QUFHWkMsTUFBQUEsT0FBTyxFQUFFO0FBQ0wseUJBQWtCLFVBQVMsS0FBS3RILFNBQVUsRUFEckM7QUFFTCx3QkFBZ0I7QUFGWCxPQUhHO0FBT1p1SCxNQUFBQSxRQUFRLEVBQUU7QUFQRSxLQUFoQjs7QUFTQSxVQUFNQyxnQkFBZ0IsR0FBR0MsU0FBUyxJQUFJO0FBQ2xDLFlBQU1DLFdBQVcsR0FBRyxJQUFJQyxNQUFKLENBQVdGLFNBQVgsQ0FBcEI7QUFDQUEsTUFBQUEsU0FBUyxHQUFHQyxXQUFXLENBQUNFLFFBQVosQ0FBcUIsUUFBckIsQ0FBWjtBQUNBLGFBQVEsMEJBQXlCSCxTQUFVLEVBQTNDO0FBQ0gsS0FKRDs7QUFNQSxXQUFPN0ksQ0FBQyxDQUFDaUosT0FBRixDQUFVLENBQUMxRixPQUFELEVBQVUyRixNQUFWLEVBQWtCQyxNQUFsQixLQUE2QjtBQUMxQy9JLE1BQUFBLE9BQU8sQ0FBQ21JLE9BQUQsRUFBVSxDQUFDN0UsR0FBRCxFQUFNMEYsR0FBTixFQUFXQyxJQUFYLEtBQW9CO0FBQ2pDLFlBQUkzRixHQUFKLEVBQVM7QUFDTDRGLFVBQUFBLE9BQU8sQ0FBQ2pGLEtBQVIsQ0FBY1gsR0FBZDtBQUNBSCxVQUFBQSxPQUFPLENBQUNxRixnQkFBZ0IsQ0FBQyxLQUFLdkYsc0JBQU4sQ0FBakIsQ0FBUDtBQUNILFNBSEQsTUFHTyxJQUNILENBQUMrRixHQUFELElBQ0EsQ0FBQyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVduRixRQUFYLENBQW9CbUYsR0FBRyxDQUFDRyxVQUF4QixDQURELElBRUEsQ0FBQ0gsR0FBRyxDQUFDQyxJQUZMLElBR0FELEdBQUcsQ0FBQ0MsSUFBSixLQUFhLEVBSGIsSUFJQUQsR0FBRyxDQUFDQyxJQUFKLENBQVNHLE1BQVQsR0FBa0IsQ0FMZixFQU1MO0FBQ0VqRyxVQUFBQSxPQUFPLENBQUNxRixnQkFBZ0IsQ0FBQyxLQUFLdkYsc0JBQU4sQ0FBakIsQ0FBUDtBQUNILFNBUk0sTUFRQTtBQUNILGdCQUFNb0csT0FBTyxHQUFHYixnQkFBZ0IsQ0FBQ1MsSUFBRCxDQUFoQztBQUNBOUYsVUFBQUEsT0FBTyxDQUFDa0csT0FBRCxDQUFQO0FBQ0g7QUFDSixPQWhCTSxDQUFQO0FBaUJILEtBbEJNLENBQVA7QUFtQkg7O0FBRURDLEVBQUFBLGFBQWEsQ0FBQ0MsbUJBQUQsRUFBc0I7QUFDL0IsUUFBSSxDQUFDLEtBQUszRyxvQkFBVixFQUFnQztBQUM1QjtBQUNBLFdBQUtzRixjQUFMLEdBQXNCM0IsSUFBdEIsQ0FBMkJrQyxTQUFTLElBQUk7QUFDcEM7QUFDQWMsUUFBQUEsbUJBQW1CLENBQUNkLFNBQUQsQ0FBbkIsQ0FGb0MsQ0FJcEM7O0FBQ0EsYUFBSzdGLG9CQUFMLEdBQTRCYSxXQUFXLENBQUMsTUFBTTtBQUMxQyxlQUFLeUUsY0FBTCxHQUFzQjNCLElBQXRCLENBQTJCa0MsU0FBUyxJQUFJO0FBQ3BDYyxZQUFBQSxtQkFBbUIsQ0FBQ2QsU0FBRCxDQUFuQjtBQUNILFdBRkQ7QUFHSCxTQUpzQyxFQUlwQyxLQUFLLElBSitCLENBQXZDO0FBS0gsT0FWRDtBQVdIO0FBQ0o7O0FBRURlLEVBQUFBLGFBQWEsR0FBRztBQUNaLFFBQUksS0FBSzVHLG9CQUFULEVBQStCO0FBQzNCNkcsTUFBQUEsYUFBYSxDQUFDLEtBQUs3RyxvQkFBTixDQUFiO0FBQ0EsV0FBS0Esb0JBQUwsR0FBNEIsSUFBNUI7QUFDSDtBQUNKLEdBL1MrQixDQWlUaEM7OztBQUNBOEcsRUFBQUEsb0JBQW9CLENBQUNDLFlBQUQsRUFBZWpDLEtBQUssR0FBRyxJQUF2QixFQUE2QjtBQUM3QyxRQUFJQSxLQUFLLEtBQUssSUFBZCxFQUFvQjtBQUNoQixXQUFLN0YsaUJBQUwsQ0FBdUI2RixLQUF2QixJQUFnQ2lDLFlBQWhDO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsV0FBSzlILGlCQUFMLEdBQXlCOEgsWUFBekI7QUFDSDtBQUNKOztBQUVEQyxFQUFBQSxvQkFBb0IsR0FBRztBQUNuQixXQUFPLEtBQUsvSCxpQkFBWjtBQUNIOztBQUVEZ0ksRUFBQUEsa0JBQWtCLEdBQUc7QUFDakIsUUFBSSxDQUFDLEtBQUs5SCxZQUFMLENBQWtCMkQsSUFBdkIsRUFBNkIsT0FBTyxPQUFQO0FBRTdCLFVBQU07QUFBRW1CLE1BQUFBO0FBQUYsUUFBdUIsS0FBSzlFLFlBQUwsQ0FBa0IyRCxJQUEvQztBQUNBLFVBQU07QUFBRW9FLE1BQUFBLEtBQUY7QUFBU0MsTUFBQUEsS0FBVDtBQUFnQkMsTUFBQUEsTUFBaEI7QUFBd0JDLE1BQUFBO0FBQXhCLFFBQWtDcEQsZ0JBQXhDO0FBRUEsV0FBUSxHQUFFaUQsS0FBTSxJQUFHQyxLQUFNLElBQUdDLE1BQU8sSUFBR0MsS0FBTSxFQUE1QztBQUNILEdBclUrQixDQXVVaEM7OztBQUNBLE1BQUlDLE9BQUosR0FBYztBQUNWLFdBQU8sS0FBS2xJLEtBQVo7QUFDSDs7QUFFRCxNQUFJbUksYUFBSixHQUFvQjtBQUNoQixXQUFPQyxTQUFQLENBRGdCLENBQ0U7QUFDckI7O0FBRUQsTUFBSXRELGVBQUosR0FBc0I7QUFDbEIsV0FBTyxLQUFLK0Msa0JBQUwsRUFBUDtBQUNIOztBQUVELE1BQUlRLFVBQUosR0FBaUI7QUFDYixXQUFPLE9BQVA7QUFDSDs7QUFFRCxNQUFJQyxZQUFKLEdBQW1CO0FBQ2YsV0FBTyxLQUFLdEksS0FBWjtBQUNIOztBQUVELE1BQUkwRSxVQUFKLEdBQWlCO0FBQ2IsV0FBTyxLQUFLaEYsT0FBTCxDQUFhcUcsT0FBYixFQUFQO0FBQ0g7O0FBRUQsTUFBSXdDLG1CQUFKLEdBQTBCO0FBQ3RCLFdBQU8sS0FBSzNJLG9CQUFaO0FBQ0g7O0FBRUQ0SSxFQUFBQSx5Q0FBeUMsR0FBRztBQUN4QyxXQUFPO0FBQ0hDLE1BQUFBLE1BQU0sRUFBRTtBQURMLEtBQVA7QUFHSDs7QUFFREMsRUFBQUEsMkJBQTJCLEdBQUc7QUFDMUIsV0FBTyxLQUFQO0FBQ0g7O0FBRURDLEVBQUFBLFVBQVUsR0FBRztBQUNULFVBQU1DLE9BQU8sR0FBR25LLFlBQVksQ0FBQyxLQUFLb0ssUUFBTCxFQUFELENBQTVCO0FBQ0EsV0FBT3RLLFlBQVksQ0FBQ3NELFFBQWIsQ0FBc0IrRyxPQUF0QixDQUFQO0FBQ0g7O0FBRURFLEVBQUFBLFVBQVUsR0FBRztBQUNULFVBQU1GLE9BQU8sR0FBR25LLFlBQVksQ0FBQyxLQUFLb0ssUUFBTCxFQUFELENBQTVCO0FBQ0EsV0FBT3JLLFlBQVksQ0FBQ3FELFFBQWIsQ0FBc0IrRyxPQUF0QixDQUFQO0FBQ0g7O0FBRUQzSSxFQUFBQSxRQUFRLENBQUNULEtBQUQsRUFBUTtBQUNaLFFBQUlBLEtBQUssS0FBSyxLQUFLc0MsU0FBTCxHQUFpQnRDLEtBQS9CLEVBQXNDO0FBQ2xDLFdBQUtRLEtBQUwsQ0FBV1QsY0FBWCxDQUEwQkMsS0FBMUIsR0FBa0NBLEtBQWxDO0FBQ0g7QUFDSjs7QUFFRHVHLEVBQUFBLE9BQU8sR0FBRztBQUNOLFdBQU8sS0FBS2hHLFlBQUwsQ0FBa0I2RSxJQUF6QjtBQUNIOztBQUVEL0QsRUFBQUEsbUJBQW1CLEdBQUc7QUFDbEIsVUFBTTtBQUFFUixNQUFBQSxlQUFlLEVBQUUwSTtBQUFuQixRQUFtQyxLQUFLaEosWUFBTCxDQUFrQjJELElBQTNEOztBQUVBLFFBQUksQ0FBQ3FGLFdBQUwsRUFBa0I7QUFDZCxXQUFLOUksUUFBTCxDQUFjM0IsZ0JBQWdCLENBQUMwSyxJQUEvQjtBQUNBLFdBQUtoSixLQUFMLENBQVdULGNBQVgsR0FBNEIwSixNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUtsSixLQUFMLENBQVdULGNBQTdCLEVBQTZDO0FBQ3JFYyxRQUFBQSxlQUFlLEVBQUUsSUFEb0Q7QUFFckVGLFFBQUFBLGlCQUFpQixFQUFFO0FBQUVDLFVBQUFBLFlBQVksRUFBRTtBQUFoQjtBQUZrRCxPQUE3QyxDQUE1QjtBQUlILEtBTkQsTUFNTztBQUNILFdBQUtILFFBQUwsQ0FBYzNCLGdCQUFnQixDQUFDNkssSUFBL0I7QUFDQSxXQUFLbkosS0FBTCxDQUFXVCxjQUFYLEdBQTRCMEosTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLbEosS0FBTCxDQUFXVCxjQUE3QixFQUE2QztBQUNyRWMsUUFBQUEsZUFBZSxFQUFFMEksV0FEb0Q7QUFFckU1SSxRQUFBQSxpQkFBaUIsRUFBRTtBQUNmQyxVQUFBQSxZQUFZLEVBQ1IySSxXQUFXLENBQUNuRSxJQUFaLEtBQXFCLGNBQXJCLElBQXVDbUUsV0FBVyxDQUFDSyxJQUFaLEtBQXFCLFVBQTVELEdBQ01MLFdBQVcsQ0FBQ00sUUFEbEIsR0FFTTtBQUpLO0FBRmtELE9BQTdDLENBQTVCO0FBU0g7O0FBRUQsVUFBTTtBQUFFN0osTUFBQUE7QUFBRixRQUFZLEtBQUtzQyxTQUFMLEVBQWxCO0FBQ0EsVUFBTTtBQUFFcUgsTUFBQUEsSUFBRjtBQUFRRyxNQUFBQSxPQUFSO0FBQWlCTixNQUFBQTtBQUFqQixRQUEwQjFLLGdCQUFoQzs7QUFDQSxRQUFJLENBQUM2SyxJQUFELEVBQU9HLE9BQVAsRUFBZ0JOLElBQWhCLEVBQXNCbkgsUUFBdEIsQ0FBK0JyQyxLQUEvQixDQUFKLEVBQTJDO0FBQ3ZDLFVBQUl1SixXQUFXLElBQUlBLFdBQVcsQ0FBQzlHLEtBQS9CLEVBQXNDO0FBQ2xDLGFBQUtRLGNBQUwsQ0FBb0JzRyxXQUFXLENBQUM5RyxLQUFoQztBQUNILE9BRkQsTUFFTztBQUNILGFBQUtVLGdCQUFMO0FBQ0g7QUFDSjs7QUFFRCxTQUFLbEQsS0FBTCxDQUFXOEosR0FBWCxDQUFlckssSUFBSSxJQUFJQSxJQUFJLENBQUNzSyxPQUFMLENBQWFDLHFCQUFiLENBQW1DQyxNQUFuQyxDQUEwQyxLQUFLM0YsS0FBTCxFQUExQyxFQUF3RCxFQUF4RCxDQUF2QjtBQUNIOztBQUVENEYsRUFBQUEscUJBQXFCLENBQUM3SyxXQUFELEVBQWM7QUFDL0IsU0FBS2lCLFlBQUwsR0FBb0JqQixXQUFwQjtBQUNBLFNBQUsrQixtQkFBTDtBQUNIOztBQUVEeUQsRUFBQUEsTUFBTSxDQUFDc0YsWUFBRCxFQUFlQyxNQUFNLEdBQUcsRUFBeEIsRUFBNEI7QUFDOUIsUUFBSSxDQUFDRCxZQUFMLEVBQW1CLE9BQU9oTSxDQUFDLENBQUMsSUFBRCxDQUFSLENBRFcsQ0FHOUI7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBTTtBQUFFeUMsTUFBQUE7QUFBRixRQUFzQixLQUFLTixZQUFMLENBQWtCMkQsSUFBOUM7QUFDQSxVQUFNb0csaUJBQWlCLEdBQUd6SixlQUFlLElBQUlBLGVBQWUsQ0FBQytJLElBQTdEO0FBRUEsV0FBTyxLQUFLdEksbUJBQUwsQ0FBeUI4SSxZQUF6QixFQUF1Q0MsTUFBdkMsRUFBK0N0RixJQUEvQyxDQUFvRHdGLEtBQUssSUFBSTtBQUNoRSxhQUFPLEtBQUsvSSxxQkFBTCxDQUEyQitJLEtBQTNCLEVBQWtDRCxpQkFBbEMsRUFBcUQsQ0FBckQsQ0FBUDtBQUNILEtBRk0sQ0FBUDtBQUdIO0FBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNJaEosRUFBQUEsbUJBQW1CLENBQUMyQyxNQUFELEVBQVNvRyxNQUFULEVBQWlCO0FBQ2hDLFVBQU1HLEtBQUssR0FBR3BNLENBQUMsQ0FBQ29NLEtBQUYsRUFBZDtBQUNBLFVBQU03RCxPQUFPLEdBQUc7QUFDWkcsTUFBQUEsT0FBTyxFQUFFO0FBQ0wseUJBQWtCLFVBQVMsS0FBS3RILFNBQVUsRUFEckM7QUFFTCx3QkFBZ0I7QUFGWCxPQURHO0FBS1pvSCxNQUFBQSxHQUFHLEVBQUcsR0FBRXpILFlBQWEsYUFBWSxLQUFLMEgsVUFBTCxFQUFrQixXQUx2QztBQU1aNUMsTUFBQUEsTUFBTSxFQUFFLE1BTkk7QUFPWndELE1BQUFBLElBQUksRUFBRWdELElBQUksQ0FBQ0MsU0FBTCxDQUFlO0FBQ2pCO0FBQ0F6RyxRQUFBQSxNQUFNLEVBQUVBLE1BQU0sS0FBSyxlQUFYLEdBQTZCLGdCQUE3QixHQUFnREEsTUFGdkM7QUFHakJvRyxRQUFBQSxNQUFNLEVBQUVNLEtBQUssQ0FBQ0MsT0FBTixDQUFjUCxNQUFkLElBQXdCO0FBQUVwRyxVQUFBQSxNQUFNLEVBQUVvRyxNQUFNLENBQUMsQ0FBRDtBQUFoQixTQUF4QixHQUFnREE7QUFIdkMsT0FBZjtBQVBNLEtBQWhCO0FBY0E3TCxJQUFBQSxPQUFPLENBQUNtSSxPQUFELEVBQVUsQ0FBQzdFLEdBQUQsRUFBTTBGLEdBQU4sRUFBV0MsSUFBWCxLQUFvQjtBQUNqQyxVQUFJM0YsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXTyxRQUFYLENBQW9CbUYsR0FBRyxDQUFDRyxVQUF4QixDQUFaLEVBQWlEO0FBQzdDRCxRQUFBQSxPQUFPLENBQUNqRixLQUFSLENBQWUsZ0RBQStDd0IsTUFBTyxZQUFyRSxFQUFrRm5DLEdBQWxGO0FBQ0EwSSxRQUFBQSxLQUFLLENBQUNsRCxNQUFOLENBQWF4RixHQUFHLElBQUkwRixHQUFHLENBQUNDLElBQXhCO0FBQ0gsT0FIRCxNQUdPO0FBQ0hDLFFBQUFBLE9BQU8sQ0FBQ21ELEdBQVIsQ0FBYSw2QkFBNEI1RyxNQUFPLG1CQUFoRDtBQUNBLGNBQU02RyxPQUFPLEdBQUdMLElBQUksQ0FBQ00sS0FBTCxDQUFXdEQsSUFBWCxDQUFoQixDQUZHLENBSUg7QUFDQTs7QUFDQStDLFFBQUFBLEtBQUssQ0FBQzdJLE9BQU4sQ0FBY21KLE9BQU8sQ0FBQyxDQUFELENBQXJCO0FBQ0g7QUFDSixLQVpNLENBQVA7QUFjQSxXQUFPTixLQUFLLENBQUNRLE9BQWI7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0l4SixFQUFBQSxxQkFBcUIsQ0FBQytJLEtBQUQsRUFBUUQsaUJBQVIsRUFBMkJXLFlBQTNCLEVBQXlDO0FBQzFELFVBQU1ULEtBQUssR0FBR3BNLENBQUMsQ0FBQ29NLEtBQUYsRUFBZDtBQUNBLFVBQU03RCxPQUFPLEdBQUc7QUFDWkcsTUFBQUEsT0FBTyxFQUFFO0FBQ0wseUJBQWtCLFVBQVMsS0FBS3RILFNBQVUsRUFEckM7QUFFTCx3QkFBZ0I7QUFGWCxPQURHO0FBS1pvSCxNQUFBQSxHQUFHLEVBQUcsR0FBRXpILFlBQWEsYUFBWSxLQUFLMEgsVUFBTCxFQUFrQixhQUFZMEQsS0FBTSxFQUx6RDtBQU1adEcsTUFBQUEsTUFBTSxFQUFFO0FBTkksS0FBaEI7QUFTQSxVQUFNaUgsZUFBZSxHQUFHakosV0FBVyxDQUFDLE1BQU07QUFDdEN6RCxNQUFBQSxPQUFPLENBQUNtSSxPQUFELEVBQVUsQ0FBQzdFLEdBQUQsRUFBTTBGLEdBQU4sRUFBV0MsSUFBWCxLQUFvQjtBQUNqQyxZQUFJM0YsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXTyxRQUFYLENBQW9CbUYsR0FBRyxDQUFDRyxVQUF4QixDQUFaLEVBQWlEO0FBQzdDRCxVQUFBQSxPQUFPLENBQUNqRixLQUFSLENBQWUseURBQXdEOEgsS0FBTSxJQUE3RSxFQUFrRnpJLEdBQWxGO0FBQ0FtRyxVQUFBQSxhQUFhLENBQUNpRCxlQUFELENBQWI7QUFDQVYsVUFBQUEsS0FBSyxDQUFDbEQsTUFBTixDQUFheEYsR0FBRyxJQUFJMEYsR0FBRyxDQUFDQyxJQUF4QjtBQUNILFNBSkQsTUFJTztBQUNILGdCQUFNcUQsT0FBTyxHQUFHTCxJQUFJLENBQUNNLEtBQUwsQ0FBV3RELElBQVgsQ0FBaEI7QUFDQSxnQkFBTTtBQUFFeUMsWUFBQUE7QUFBRixjQUFhWSxPQUFuQixDQUZHLENBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsZ0JBQU07QUFBRWpLLFlBQUFBO0FBQUYsY0FBc0IsS0FBS04sWUFBTCxDQUFrQjJELElBQTlDO0FBQ0EsZ0JBQU1pSCxpQkFBaUIsR0FBR3RLLGVBQWUsSUFBSUEsZUFBZSxDQUFDK0ksSUFBN0QsQ0FSRyxDQVNIO0FBQ0E7O0FBQ0EsY0FBSU0sTUFBTSxLQUFLLEtBQVgsSUFBb0JJLGlCQUFpQixLQUFLYSxpQkFBOUMsRUFBaUU7QUFDN0RsRCxZQUFBQSxhQUFhLENBQUNpRCxlQUFELENBQWI7QUFDQVYsWUFBQUEsS0FBSyxDQUFDN0ksT0FBTjtBQUNIO0FBQ0o7QUFDSixPQXJCTSxDQUFQO0FBc0JILEtBdkJrQyxFQXVCaENzSixZQUFZLEdBQUcsSUF2QmlCLENBQW5DO0FBd0JILEdBMWdCK0IsQ0E0Z0JoQzs7O0FBQ0FHLEVBQUFBLHVCQUF1QixDQUFDQyxlQUFELEVBQWtCO0FBQ3JDLFVBQU0xRSxPQUFPLEdBQUc7QUFDWjFDLE1BQUFBLE1BQU0sRUFBRSxNQURJO0FBRVoyQyxNQUFBQSxHQUFHLEVBQUcsR0FBRXpILFlBQWEsYUFBWSxLQUFLMEgsVUFBTCxFQUFrQixTQUZ2QztBQUdaQyxNQUFBQSxPQUFPLEVBQUU7QUFDTCx3QkFBZ0IsbUNBRFg7QUFFTCx5QkFBa0IsVUFBUyxLQUFLdEgsU0FBVTtBQUZyQyxPQUhHO0FBT1ppSSxNQUFBQSxJQUFJLEVBQUU0RDtBQVBNLEtBQWhCO0FBVUEsV0FBT2pOLENBQUMsQ0FBQ2lKLE9BQUYsQ0FBVSxDQUFDMUYsT0FBRCxFQUFVMkYsTUFBVixLQUFxQjtBQUNsQyxhQUFPOUksT0FBTyxDQUFDbUksT0FBRCxFQUFVLENBQUNsRSxLQUFELEVBQVE2SSxRQUFSLEVBQWtCN0QsSUFBbEIsS0FBMkI7QUFDL0M7QUFDQSxZQUFJaEYsS0FBSixFQUFXO0FBQ1AsZ0JBQU0sSUFBSThJLEtBQUosQ0FBVTlJLEtBQVYsQ0FBTjtBQUNILFNBRkQsTUFFTztBQUNIO0FBQ0EsZ0JBQU0rSSxlQUFlLEdBQUdmLElBQUksQ0FBQ00sS0FBTCxDQUFXTyxRQUFRLENBQUM3RCxJQUFwQixFQUEwQmIsR0FBbEQ7QUFDQWpGLFVBQUFBLE9BQU8sQ0FBQyxLQUFLOEosZUFBTCxDQUFxQkQsZUFBckIsQ0FBRCxDQUFQO0FBQ0g7QUFDSixPQVRhLENBQWQ7QUFVSCxLQVhNLENBQVA7QUFZSCxHQXBpQitCLENBc2lCaEM7OztBQUNBQyxFQUFBQSxlQUFlLENBQUNELGVBQUQsRUFBa0I7QUFDN0IsVUFBTW5CLE1BQU0sR0FBRztBQUFFekQsTUFBQUEsR0FBRyxFQUFFNEUsZUFBUDtBQUF3QkUsTUFBQUEsd0JBQXdCLEVBQUU7QUFBbEQsS0FBZjtBQUNBLFNBQUs1RyxNQUFMLENBQVksZ0JBQVosRUFBOEJ1RixNQUE5QjtBQUNILEdBMWlCK0IsQ0E0aUJoQzs7O0FBQ0FzQixFQUFBQSxhQUFhLENBQUNOLGVBQUQsRUFBa0I7QUFDM0IsUUFBSSxLQUFLL0ksU0FBTCxHQUFpQnRDLEtBQWpCLEtBQTJCbEIsZ0JBQWdCLENBQUMwSyxJQUFoRCxFQUFzRDtBQUNsRCxZQUFNLDhDQUFOO0FBQ0g7O0FBQ0QsVUFBTW9DLFFBQVEsR0FBR25OLElBQUksQ0FBQ2tELE9BQUwsQ0FBYUMsU0FBYixFQUF3QnlKLGVBQWUsQ0FBQ1EsR0FBaEIsQ0FBb0IsTUFBcEIsQ0FBeEIsQ0FBakI7QUFDQSxXQUFPek4sQ0FBQyxDQUNKTSxFQUFFLENBQUNtRCxRQUFILENBQVkrSixRQUFaLEVBQXNCLENBQUM5SixHQUFELEVBQU1uQyxJQUFOLEtBQWU7QUFDakMsVUFBSW1DLEdBQUosRUFBUztBQUNMLGNBQU1BLEdBQU47QUFDSCxPQUZELE1BRU87QUFDSCxlQUFPLEtBQUtzSix1QkFBTCxDQUE2QnpMLElBQTdCLENBQVA7QUFDSDtBQUNKLEtBTkQsQ0FESSxDQUFSO0FBU0g7O0FBRURtTSxFQUFBQSxVQUFVLEdBQUc7QUFDVDtBQUNBLFdBQU8xTixDQUFDLEVBQVI7QUFDSDs7QUFFRDJOLEVBQUFBLGNBQWMsQ0FBQ0MsYUFBRCxFQUFnQkMsVUFBaEIsRUFBNEI7QUFDdEMsUUFBSSxLQUFLM0osU0FBTCxHQUFpQnRDLEtBQWpCLEtBQTJCbEIsZ0JBQWdCLENBQUM2SyxJQUFoRCxFQUFzRDtBQUNsRCxhQUFPLEtBQUs3RSxNQUFMLENBQVksZ0JBQVosRUFBOEI7QUFBRWIsUUFBQUEsTUFBTSxFQUFFK0g7QUFBVixPQUE5QixDQUFQO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsYUFBTyxLQUFLbEgsTUFBTCxDQUFZbUgsVUFBWixDQUFQO0FBQ0g7QUFDSjs7QUFFREMsRUFBQUEsWUFBWSxHQUFHO0FBQ1gsVUFBTUYsYUFBYSxHQUFHLGVBQXRCO0FBQ0EsVUFBTUMsVUFBVSxHQUFHLGVBQW5CO0FBQ0EsV0FBTyxLQUFLRixjQUFMLENBQW9CQyxhQUFwQixFQUFtQ0MsVUFBbkMsQ0FBUDtBQUNIOztBQUVERSxFQUFBQSxjQUFjLEdBQUc7QUFDYixVQUFNSCxhQUFhLEdBQUcsaUJBQXRCO0FBQ0EsVUFBTUMsVUFBVSxHQUFHLGlCQUFuQjtBQUNBLFdBQU8sS0FBS0YsY0FBTCxDQUFvQkMsYUFBcEIsRUFBbUNDLFVBQW5DLENBQVA7QUFDSDs7QUFFREcsRUFBQUEsWUFBWSxHQUFHO0FBQ1gsUUFBSSxLQUFLOUosU0FBTCxHQUFpQnRDLEtBQWpCLEtBQTJCbEIsZ0JBQWdCLENBQUM2SyxJQUFoRCxFQUFzRDtBQUNsRCxhQUFPLEtBQUs3RSxNQUFMLENBQVksZ0JBQVosRUFBOEI7QUFBRWIsUUFBQUEsTUFBTSxFQUFFO0FBQVYsT0FBOUIsQ0FBUDtBQUNIOztBQUVELFdBQU8sS0FBSzJCLE1BQUwsRUFBUDtBQUNIOztBQUVEeUcsRUFBQUEsZUFBZSxHQUFHO0FBQ2QsV0FBTyxLQUFLOUwsWUFBTCxDQUFrQjJELElBQWxCLENBQXVCcEQsU0FBdkIsR0FBbUMsS0FBS1AsWUFBTCxDQUFrQjJELElBQWxCLENBQXVCcEQsU0FBdkIsQ0FBaUN3TCxRQUFwRSxHQUErRSxFQUF0RjtBQUNIOztBQUVEQyxFQUFBQSxrQkFBa0IsR0FBRztBQUNqQixXQUFPbk8sQ0FBQyxDQUFDLEtBQUtpTyxlQUFMLEVBQUQsQ0FBUjtBQUNIOztBQUVERyxFQUFBQSxhQUFhLEdBQUc7QUFDWixXQUFPLEtBQUtqTSxZQUFMLENBQWtCMkQsSUFBbEIsSUFBMEIsRUFBakM7QUFDSDs7QUFFRHVJLEVBQUFBLGVBQWUsR0FBRztBQUNkLFdBQU8sRUFBUDtBQUNIOztBQUVEQyxFQUFBQSxZQUFZLEdBQUc7QUFDWCxXQUFPLEtBQUtuTSxZQUFMLENBQWtCMkQsSUFBbEIsR0FBeUIsS0FBSzNELFlBQUwsQ0FBa0IyRCxJQUFsQixDQUF1QnlJLEVBQWhELEdBQXFELElBQTVEO0FBQ0g7O0FBRURDLEVBQUFBLGVBQWUsR0FBRztBQUNkLFdBQU8sS0FBS3JNLFlBQUwsQ0FBa0IyRCxJQUFsQixDQUF1QnBELFNBQXZCLEdBQW1DLEtBQUtQLFlBQUwsQ0FBa0IyRCxJQUFsQixDQUF1QnBELFNBQXZCLENBQWlDK0wsUUFBcEUsR0FBK0UsRUFBdEY7QUFDSDs7QUFFRGhHLEVBQUFBLFVBQVUsR0FBRztBQUNULFdBQU8sS0FBS3RDLEtBQUwsR0FBYXVJLEtBQWIsQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBUDtBQUNIOztBQUVEQyxFQUFBQSxzQkFBc0IsR0FBRztBQUNyQixXQUFPN04sZ0JBQWdCLENBQUNvQixlQUF4QjtBQUNIOztBQUVEME0sRUFBQUEsZUFBZSxHQUFHO0FBQ2QsV0FBTyxJQUFQO0FBQ0gsR0Fob0IrQixDQWtvQmhDOzs7QUFDQUMsRUFBQUEsVUFBVSxDQUFDdk4sSUFBRCxFQUFPO0FBQ2IsU0FBS08sS0FBTCxHQUFhckIsS0FBSyxDQUFDYyxJQUFELENBQWxCO0FBQ0EsV0FBTyxJQUFQO0FBQ0g7O0FBdG9CK0I7O0FBeW9CcEN3TixNQUFNLENBQUNDLE9BQVAsR0FBaUIvTixhQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IHEgPSByZXF1aXJlKCdxJyk7XHJcbmNvbnN0IFByaW50ZXIgPSByZXF1aXJlKCdlYWdsZS1wcmludC9tb2RlbC9wcmludGVyJyk7XHJcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcclxuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJ3JlcXVlc3QnKTtcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKCdmcy1leHRyYScpO1xyXG5cclxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbC5qcycpO1xyXG5jb25zdCB7IG1heWJlIH0gPSByZXF1aXJlKCcuL3V0aWxzL21heWJlJyk7XHJcbmNvbnN0IHtcclxuICAgIFByaW50ZXJDb25uVHlwZUVudW0sXHJcbiAgICBQcmludGVyU3RhdGVFbnVtLFxyXG4gICAgRmlmdGhHZW5Cb3RzLFxyXG4gICAgU2l4dGhHZW5Cb3RzLFxyXG4gICAgR2VuZGVyVG9UeXBlLFxyXG4gICAgRXh0cnVkZXJUeXBlRW51bSxcclxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcblxyXG4vLyBUT0RPOiBNb3ZlIHRoaXMgb3V0IHRvIGRlZmF1bHQtY29uZmlnIHRvIHN1cHBvcnQgc3RhZ2luZyBVUkwgaW4gdGhlIGZ1dHVyZVxyXG5jb25zdCByZWZsZWN0b3JVcmwgPSAnaHR0cHM6Ly9yZWZsZWN0b3IubWFrZXJib3QuY29tJztcclxuXHJcbmNsYXNzIFNrZXRjaFByaW50ZXIgZXh0ZW5kcyBQcmludGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByaW50ZXJJbmZvLCBnZW5kZXIsIHVzZXJUb2tlbiwgcHJpbnRlck1hbmFnZXIsIGZsdXgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICBpZDogcHJpbnRlckluZm8udWlkLFxyXG4gICAgICAgICAgICBjb25uZWN0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIHByaW50ZXJfc3RhdHVzOiB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1VuYXV0aGVudGljYXRlZCcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc3VwZXIoZGF0YSwgbnVsbCwgZ2VuZGVyKTtcclxuXHJcbiAgICAgICAgLy8gTk9URSAtIEZsdXggZ2V0cyBpbmplY3RlZCB0aHJvdWdoIFByaW50ZXJTdG9yZSB2aWFcclxuICAgICAgICAvLyB0aGlzLmluamVjdEZsdXggbWV0aG9kLiBDaGVjayBsaW5lIDExMi0xMTUgaW5cclxuICAgICAgICAvLyAvc3RvcmVzL3ByaW50ZXJTdG9yZS5qc1xyXG4gICAgICAgIHRoaXMuX2ZsdXggPSBtYXliZShmbHV4KTtcclxuXHJcbiAgICAgICAgdGhpcy5fZ2VuZGVyID0gZ2VuZGVyO1xyXG4gICAgICAgIHRoaXMuX21hY2hpbmVDb25maWcgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gTm90aWZpY2F0aW9ucyBmb3IgY3JpdGljYWwgdXBkYXRlcyAoc3lzdGVtLCBzdGF0ZXMsIHNjaGVtYSB1cGRhdGVzLCBldGMuLilcclxuICAgICAgICB0aGlzLl91cGRhdGVOb3RpZmljYXRpb25zID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICAgICAgICB0aGlzLmF0dGFjaGVkRXh0cnVkZXJzID0gW0V4dHJ1ZGVyVHlwZUVudW0uc2tldGNoX2V4dHJ1ZGVyXTtcclxuXHJcbiAgICAgICAgdGhpcy5fcHJpbnRlckluZm8gPSBwcmludGVySW5mbztcclxuXHJcbiAgICAgICAgLy8gdGhlc2UgYXJlIHN0YXR1cyBwcm9wZXJ0aWVzIGdlbmVyaWMgdG8gZWFnbGUtcHJpbnQncyBwcmludGVyXHJcbiAgICAgICAgdGhpcy5faW5mbyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2luZm8ucHJpbnRlcl9zdGF0dXMgPSB7fTtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKFByaW50ZXJTdGF0ZUVudW0uVW5hdXRoZW50aWNhdGVkKTtcclxuICAgICAgICB0aGlzLl9pbmZvLnByaW50ZXJfc3RhdHVzLmN1cnJlbnRfcHJpbnRfam9iID0ge307XHJcbiAgICAgICAgdGhpcy5faW5mby5wcmludGVyX3N0YXR1cy5jdXJyZW50X3ByaW50X2pvYi5wZXJjZW50X2RvbmUgPSAwO1xyXG5cclxuICAgICAgICAvLyB0aGVzZSBvbmVzIGFyZSBtYWtlcmJvdCBzcGVjaWZpYywgaW4gY2FzZSB0aGV5IG1heSBjb21lIGluIGhhbmR5XHJcbiAgICAgICAgdGhpcy5faW5mby5wcmludGVyX3N0YXR1cy5jdXJyZW50X3Byb2Nlc3MgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2luZm8ucHJpbnRlcl9zdGF0dXMudG9vbGhlYWRzID0gbnVsbDtcclxuICAgICAgICAvLyBFcnJvcnMgZnJvbSBlcnJvcl9ub3RpZmljYXRpb25zIGFuZCBmcm9tIHByb2Nlc3NlcyBnbyBpbiBoZXJlO1xyXG4gICAgICAgIC8vIGFuIGVycm9yIHdpbGwgZ2V0IHJlbW92ZWQgd2hlbiBhY2tub3dsZWRnZUVycm9yIGdldHMgY2FsbGVkIGZvciBpdFxyXG4gICAgICAgIC8vIG9yIHdoZW4gYW4gZXJyb3JfYWNrbm93bGVkZ2VkIGlzIHJlY2VpdmVkXHJcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGJlIGF2YWlsYWJsZSBpZiB0aGUgYm90J3MgcHJvY2VzcyBpcyBpbiB0aGUgJ2ZhaWxlZCcgc3RhdGVcclxuICAgICAgICAvLyBzaG91bGQgb25seSBldmVyIGhhdmUgb25lIGVudHJ5IC0gdGhpcyBpcyBpbmNvcnJlY3QgYW5kIGhhcyBiZWVuIGNoYW5nZWQgbm93XHJcbiAgICAgICAgLy8gSXQgd2lsbCBjb250YWluIGFsbCBzdGF0ZSBjaGFuZ2UgZXJyb3JzLlxyXG4gICAgICAgIHRoaXMuX2luZm8ucHJpbnRlcl9zdGF0dXMuc3RhdGVfY2hhbmdlX2Vycm9ycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9pbmZvLnVwZGF0ZV9maXJtd2FyZV9hdmFpbGFibGUgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLl9jYW1lcmFGZWVkQWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMudXNlclRva2VuID0gdXNlclRva2VuO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhRmVlZEludGVydmFsSWQgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVByaW50ZXJTdGF0dXMoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2VuZENtZFRvUmVmbGVjdG9yID0gdGhpcy5fc2VuZENtZFRvUmVmbGVjdG9yLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fcG9sbENtZEZyb21SZWZsZWN0b3IgPSB0aGlzLl9wb2xsQ21kRnJvbVJlZmxlY3Rvci5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLmVtcHR5Q2FtZXJhSW1hZ2VCYXNlNjQgPSBudWxsO1xyXG5cclxuICAgICAgICBjb25zdCBlbXB0eUNhbWVyYUltYWdlUGF0aCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuL3VpL3ZpZXdzL2ltYWdlcy9lbXB0eS5wbmcnKTtcclxuICAgICAgICBmcy5yZWFkRmlsZShlbXB0eUNhbWVyYUltYWdlUGF0aCwgKGVyciwgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbXB0eUNhbWVyYUltYWdlQmFzZTY0ID0gZGF0YTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5wcmludGVyTWFuYWdlciA9IHByaW50ZXJNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuY2hlY2tBbGl2ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIF9pbml0UHJpbnRlcigpIHtcclxuICAgICAgICAvLyBBZGQgbWFjaGluZSBjb25maWcgY29kZSBoZXJlXHJcbiAgICAgICAgLy8gdGhpcy5fZ2V0TWFjaGluZUNvbmZpZygpLmRvbmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBjaGVja0FsaXZlKCkge1xyXG4gICAgICAgIHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdWlkID0gdGhpcy5fcHJpbnRlckluZm8udWlkO1xyXG4gICAgICAgICAgICBjb25zdCBwcmludGVyc0xpc3QgPSB0aGlzLnByaW50ZXJNYW5hZ2VyLnNrZXRjaFByaW50ZXJMaXN0O1xyXG4gICAgICAgICAgICBjb25zdCBwcmludGVyc0xpc3RIYXNCb3QgPSBwcmludGVyc0xpc3QuaW5jbHVkZXModWlkKTtcclxuICAgICAgICAgICAgaWYgKHByaW50ZXJzTGlzdEhhc0JvdCAmJiB0aGlzLmdldFN0YXR1cygpLnN0YXRlID09PSBQcmludGVyU3RhdGVFbnVtLk9mZmxpbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJpbnRlclN0YXR1cygpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFwcmludGVyc0xpc3RIYXNCb3QgJiYgdGhpcy5nZXRTdGF0dXMoKS5zdGF0ZSAhPT0gUHJpbnRlclN0YXRlRW51bS5PZmZsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoJ1ByaW50ZXIgaXMgbm90IG9uIFJlZmxlY3RvciBwcmludGVyIGxpc3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDUgKiAxMDAwKTsgLy9ldmVyeSA1IHNlY29uZHNcclxuICAgIH1cclxuXHJcbiAgICBkaXNjb25uZWN0KGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTm90aWZpY2F0aW9ucy5lbWl0KCdkeWluZ19zY3JlYW0nLCBlcnJvcik7XHJcbiAgICAgICAgLy8gUHV0IHRoaXMgYmFjayB3aGVuIHdlIGZpZ3VyZSBvdXQgZ2V0dGluZyBmbHV4IGluIGhlcmVcclxuICAgICAgICAvL3RoaXMuZmx1eC5hY3Rpb25zLm1lc3NhZ2UucHJpbnRlckRpc2Nvbm5lY3QodGhpcy5fcHJpbnRlckluZm8udWlkKTtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKFByaW50ZXJTdGF0ZUVudW0uT2ZmbGluZSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9lcnJvcnMuc2V0KGVycm9yLmNvZGUsIGVycm9yKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVOb3RpZmljYXRpb25zLmVtaXQoJ2Vycm9yJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlRXJyb3IoZXJyb3JJZCkge1xyXG4gICAgICAgIHRoaXMuX2Vycm9ycy5kZWxldGUoZXJyb3JJZCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTm90aWZpY2F0aW9ucy5lbWl0KCdlcnJvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIHNhdmVTdGF0ZUVycm9yKGVycikge1xyXG4gICAgICAgIGVyci5pc1N0YXRlRXJyID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFkZEVycm9yKGVycik7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJTdGF0ZUVycm9ycygpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVyckVudHJ5IG9mIHRoaXMuX2Vycm9ycykge1xyXG4gICAgICAgICAgICBjb25zdCBbZXJySWQsIGVycl0gPSBlcnJFbnRyeTtcclxuICAgICAgICAgICAgaWYgKGVyci5pc1N0YXRlRXJyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUVycm9yKGVycklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRMYXN0RXJyb3IoKSB7XHJcbiAgICAgICAgLy8gZ2V0cyB0aGUgbW9zdCByZWNlbnQgZXJyb3JcclxuICAgICAgICBsZXQgbGFzdEVycjtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9lcnJvcnMudmFsdWVzKCkpIGxhc3RFcnIgPSB2YWw7XHJcbiAgICAgICAgcmV0dXJuIGxhc3RFcnI7XHJcbiAgICB9XHJcblxyXG4gICAgYWNrbm93bGVkZ2VMYXN0RXJyb3IoKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdEVyciA9IHRoaXMuZ2V0TGFzdEVycm9yKCk7XHJcbiAgICAgICAgdGhpcy5hY2tub3dsZWRnZUVycm9yKGxhc3RFcnIuZXJyb3JfaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzTWlzc2luZ0V4dHJ1ZGVyKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRDaGFtYmVySW5mbygpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3Bvb2xJbmZvKCkge1xyXG4gICAgICAgIHJldHVybiBxKG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb2Nlc3NNZXRob2RFeGlzdHMobWV0aG9kKSB7XHJcbiAgICAgICAgY29uc3QgeyBjdXJyZW50X3Byb2Nlc3MgfSA9IHRoaXMuX3ByaW50ZXJJbmZvLmluZm87XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc01ldGhvZHMgPSBjdXJyZW50X3Byb2Nlc3MgPyBjdXJyZW50X3Byb2Nlc3MubWV0aG9kcyA6IFtdO1xyXG4gICAgICAgIHJldHVybiBwcm9jZXNzTWV0aG9kcy5pbmNsdWRlcyhtZXRob2QpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRyYWNraW5nSW5mbygpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICBwcmludGVyX2lkOiB0aGlzLmdldElkKCksXHJcbiAgICAgICAgICAgIHByaW50ZXJfdHlwZTogdXRpbC5nZW5kZXJUb0NvZGVOYW1lKHRoaXMuZ2V0SW5mbygpLm1vZGVsKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIF9lcnJvckFja25vd2xlZGdlZENhbGxiYWNrKGVycm9ySWQpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUVycm9yKGVycm9ySWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGFja25vd2xlZGdlRXJyb3IoZXJyb3JJZCkge1xyXG4gICAgICAgIC8vIElmIHRoaXMgZXJyb3Igd2FzIG5vdCBpbnRlcm5hbGx5LWdlbmVyYXRlZCAoaWUuIGVycm9yIGNvZGUgPD0gMCksXHJcbiAgICAgICAgLy8gYWNrbm93bGVkZ2UgdGhlIGVycm9yIHdpdGggdGhlIHByaW50ZXI7IHRoZSBlcnJvciBzaG91bGQgdGhlbiBldmVudHVhbGx5XHJcbiAgICAgICAgLy8gZ2V0IGNsZWFyZWQgb24gdGhpcyBzaWRlIGZyb20gZmVlZGJhY2sgZnJvbSBrYWl0ZW4uLi5cclxuICAgICAgICBpZiAoZXJyb3JJZCA+IC0xKSB7XHJcbiAgICAgICAgICAgIGxldCBhY2tQcm9taXNlID0gcSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzTWV0aG9kRXhpc3RzKCdhY2tub3dsZWRnZV9lcnJvcicpKVxyXG4gICAgICAgICAgICAgICAgYWNrUHJvbWlzZSA9IHRoaXMuaW52b2tlKCdQcm9jZXNzTWV0aG9kJywgWydhY2tub3dsZWRnZV9lcnJvciddKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9jZXNzTWV0aG9kRXhpc3RzKCdhY2tub3dsZWRnZV9mYWlsdXJlJykpXHJcbiAgICAgICAgICAgICAgICBhY2tQcm9taXNlID0gdGhpcy5pbnZva2UoJ1Byb2Nlc3NNZXRob2QnLCBbJ2Fja25vd2xlZGdlX2ZhaWx1cmUnXSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYWNrUHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludm9rZSgnQWNrbm93bGVkZ2VkJywgW2Vycm9ySWRdKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgdGhlIGVycm9yIGFmdGVyIGNhbGxpbmcgQWNrbm93bGVkZ2VFcnJvciBpbiBjYXNlIGZvclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbWUgcmVhc29uIHdlIG1pc3MgdGhlIGVycm9yX2Fja25vd2xlZGdlZCBub3RpZmljYXRpb25cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvckFja25vd2xlZGdlZENhbGxiYWNrKGVycm9ySWQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5kb25lKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZWxzZSwganVzdCByZW1vdmUgaXRcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFcnJvcihlcnJvcklkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SW5mbygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZW5kb3I6ICdNYWtlckJvdCcsXHJcbiAgICAgICAgICAgIG1vZGVsOiB0aGlzLl9ib3RHZW5kZXIsXHJcbiAgICAgICAgICAgIG1vZGVsTmFtZTogdGhpcy5faW5mby5uYW1lLFxyXG4gICAgICAgICAgICBmaXJtd2FyZV92ZXJzaW9uOiB0aGlzLmZpcm13YXJlVmVyc2lvbixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGdldFN0YXR1cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5mby5wcmludGVyX3N0YXR1cztcclxuICAgIH1cclxuXHJcbiAgICBnZXREaXNwbGF5U3RhdHVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXR1cygpLnN0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGlzQXV0aGVudGljYXRlZCgpIHtcclxuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSB0aGlzLmdldFN0YXR1cygpO1xyXG4gICAgICAgIHJldHVybiAhW1ByaW50ZXJTdGF0ZUVudW0uUmVjb25uZWN0aW5nLCBQcmludGVyU3RhdGVFbnVtLlVuYXV0aGVudGljYXRlZF0uaW5jbHVkZXMoc3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzQ29ubmVjdGVkKCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHRoaXMuZ2V0U3RhdHVzKCk7XHJcbiAgICAgICAgcmV0dXJuICFbUHJpbnRlclN0YXRlRW51bS5PZmZsaW5lLCBQcmludGVyU3RhdGVFbnVtLlJlY29ubmVjdGluZ10uaW5jbHVkZXMoc3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlYXV0aGVudGljYXRlKCkge31cclxuXHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52b2tlKCdjYW5jZWwnKTtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0TWFjaGluZUNvbmZpZygpIHtcclxuICAgICAgICByZXR1cm4gcSh0aGlzLl9wcmludGVyLkdldE1hY2hpbmVDb25maWcoKSkudGhlbihjb25maWcgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9tYWNoaW5lQ29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF91cGRhdGVGcm9tRXh0cnVkZXJDaGFuZ2UoaW5kZXgsIGNvbmZpZykge1xyXG4gICAgICAgIC8vIFRPRE8oc2hpcmxleSk6IG1ha2UgdGhpcyB3b3JrLCB3aGVuIEkgYWN0dWFsbHkgZmlndXJlIG91dCBob3cgdG9cclxuICAgICAgICAvLyBnZXQgdGhlc2Ugbm90aWZpY2F0aW9ucyBmcm9tIHRoZSBib3QuLi5cclxuICAgIH1cclxuXHJcbiAgICBhdXRoZW50aWNhdGUoYXV0aEluZm8pIHt9XHJcblxyXG4gICAgZ2V0Q29kZU5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWwuZ2VuZGVyVG9Db2RlTmFtZSh0aGlzLmdldEdlbmRlcigpLmdldE5hbWUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q29ubmVjdGlvblR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByaW50ZXJDb25uVHlwZUVudW0uUkVGTEVDVE9SO1xyXG4gICAgfVxyXG5cclxuICAgIGdldENhbWVyYUltYWdlKCkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgIHVybDogYCR7cmVmbGVjdG9yVXJsfS9wcmludGVycy8ke3RoaXMuZ2V0SXNlcmlhbCgpfS9pbWFnZWAsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMudXNlclRva2VufWAsXHJcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2ltYWdlL2pwZWcnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbmNvZGluZzogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGNvbnZlcnRJbWFnZURhdGEgPSBpbWFnZURhdGEgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZUJ1ZmZlciA9IG5ldyBCdWZmZXIoaW1hZ2VEYXRhKTtcclxuICAgICAgICAgICAgaW1hZ2VEYXRhID0gaW1hZ2VCdWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gYGRhdGE6aW1hZ2UvanBlZztiYXNlNjQsJHtpbWFnZURhdGF9YDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gcS5Qcm9taXNlKChyZXNvbHZlLCByZWplY3QsIG5vdGlmeSkgPT4ge1xyXG4gICAgICAgICAgICByZXF1ZXN0KG9wdGlvbnMsIChlcnIsIHJlcywgYm9keSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNvbnZlcnRJbWFnZURhdGEodGhpcy5lbXB0eUNhbWVyYUltYWdlQmFzZTY0KSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICFyZXMgfHxcclxuICAgICAgICAgICAgICAgICAgICAhWzIwMCwgMjAxXS5pbmNsdWRlcyhyZXMuc3RhdHVzQ29kZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAhcmVzLmJvZHkgfHxcclxuICAgICAgICAgICAgICAgICAgICByZXMuYm9keSA9PT0gJycgfHxcclxuICAgICAgICAgICAgICAgICAgICByZXMuYm9keS5sZW5ndGggPCAxXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNvbnZlcnRJbWFnZURhdGEodGhpcy5lbXB0eUNhbWVyYUltYWdlQmFzZTY0KSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFVcmwgPSBjb252ZXJ0SW1hZ2VEYXRhKGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YVVybCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldENhbWVyYUZlZWQoY2FtZXJhRnJhbWVDYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghdGhpcy5jYW1lcmFGZWVkSW50ZXJ2YWxJZCkge1xyXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSBmaXJzdCBpbWFnZSwgdGhlbi4uLlxyXG4gICAgICAgICAgICB0aGlzLmdldENhbWVyYUltYWdlKCkudGhlbihpbWFnZURhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGltYWdlRGF0YSBiYWNrIHZpYSBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgY2FtZXJhRnJhbWVDYWxsYmFjayhpbWFnZURhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNldCB1cCBzZXRJbnRlcnZhbCB0byBwaW5nIGZvciBpbWFnZURhdGFcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhRmVlZEludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDYW1lcmFJbWFnZSgpLnRoZW4oaW1hZ2VEYXRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FtZXJhRnJhbWVDYWxsYmFjayhpbWFnZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSwgMzAgKiAxMDAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGVuZENhbWVyYUZlZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FtZXJhRmVlZEludGVydmFsSWQpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNhbWVyYUZlZWRJbnRlcnZhbElkKTtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmFGZWVkSW50ZXJ2YWxJZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGV4dHJ1ZGVyTGlzdCBzaG91bGQgYmUgYW4gYXJyYXksIGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmUgZXh0cnVkZXJcclxuICAgIHNldEF0dGFjaGVkRXh0cnVkZXJzKGV4dHJ1ZGVyTGlzdCwgaW5kZXggPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoZWRFeHRydWRlcnNbaW5kZXhdID0gZXh0cnVkZXJMaXN0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoZWRFeHRydWRlcnMgPSBleHRydWRlckxpc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldEF0dGFjaGVkRXh0cnVkZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dGFjaGVkRXh0cnVkZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIF9md1ZlckRpY3RUb1N0cmluZygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3ByaW50ZXJJbmZvLmluZm8pIHJldHVybiAnMC4wLjAnO1xyXG5cclxuICAgICAgICBjb25zdCB7IGZpcm13YXJlX3ZlcnNpb24gfSA9IHRoaXMuX3ByaW50ZXJJbmZvLmluZm87XHJcbiAgICAgICAgY29uc3QgeyBtYWpvciwgbWlub3IsIGJ1Z2ZpeCwgYnVpbGQgfSA9IGZpcm13YXJlX3ZlcnNpb247XHJcblxyXG4gICAgICAgIHJldHVybiBgJHttYWpvcn0uJHttaW5vcn0uJHtidWdmaXh9LiR7YnVpbGR9YDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkb2luZyB0aGlzIChqdXN0IGluIGNhc2UpIHVudGlsIGVhZ2xlLXByaW50J3MgcHJpbnRlciBzZXR0bGVzIGRvd24uLi5cclxuICAgIGdldCByYXdEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBtYWNoaW5lQ29uZmlnKCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vdGhpcy5fbWFjaGluZUNvbmZpZztcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZmlybXdhcmVWZXJzaW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9md1ZlckRpY3RUb1N0cmluZygpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBhcGlWZXJzaW9uKCkge1xyXG4gICAgICAgIHJldHVybiAnMC4wLjAnO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBjdXJyZW50U3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm87XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IF9ib3RHZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmRlci5nZXROYW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHVwZGF0ZU5vdGlmaWNhdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU5vdGlmaWNhdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tGb3JVbnN1cHBvcnRlZEV4dHJ1ZGVyQ29uZmlndXJhdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGhhc0V4dHJ1ZGVyTWF0ZXJpYWxNaXNtYXRjaCgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaXNGaWZ0aEdlbigpIHtcclxuICAgICAgICBjb25zdCBib3RUeXBlID0gR2VuZGVyVG9UeXBlW3RoaXMuZ2V0TW9kZWwoKV07XHJcbiAgICAgICAgcmV0dXJuIEZpZnRoR2VuQm90cy5pbmNsdWRlcyhib3RUeXBlKTtcclxuICAgIH1cclxuXHJcbiAgICBpc1NpeHRoR2VuKCkge1xyXG4gICAgICAgIGNvbnN0IGJvdFR5cGUgPSBHZW5kZXJUb1R5cGVbdGhpcy5nZXRNb2RlbCgpXTtcclxuICAgICAgICByZXR1cm4gU2l4dGhHZW5Cb3RzLmluY2x1ZGVzKGJvdFR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlICE9PSB0aGlzLmdldFN0YXR1cygpLnN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luZm8ucHJpbnRlcl9zdGF0dXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpbnRlckluZm8ubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVQcmludGVyU3RhdHVzKCkge1xyXG4gICAgICAgIGNvbnN0IHsgY3VycmVudF9wcm9jZXNzOiBjdXJyUHJvY2VzcyB9ID0gdGhpcy5fcHJpbnRlckluZm8uaW5mbztcclxuXHJcbiAgICAgICAgaWYgKCFjdXJyUHJvY2Vzcykge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKFByaW50ZXJTdGF0ZUVudW0uSWRsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luZm8ucHJpbnRlcl9zdGF0dXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9pbmZvLnByaW50ZXJfc3RhdHVzLCB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50X3Byb2Nlc3M6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50X3ByaW50X2pvYjogeyBwZXJjZW50X2RvbmU6IDAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShQcmludGVyU3RhdGVFbnVtLkJ1c3kpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbmZvLnByaW50ZXJfc3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5faW5mby5wcmludGVyX3N0YXR1cywge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudF9wcm9jZXNzOiBjdXJyUHJvY2VzcyxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRfcHJpbnRfam9iOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudF9kb25lOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyUHJvY2Vzcy5uYW1lID09PSAnUHJpbnRQcm9jZXNzJyAmJiBjdXJyUHJvY2Vzcy5zdGVwID09PSAncHJpbnRpbmcnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnJQcm9jZXNzLnByb2dyZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHRoaXMuZ2V0U3RhdHVzKCk7XHJcbiAgICAgICAgY29uc3QgeyBCdXN5LCBQZW5kaW5nLCBJZGxlIH0gPSBQcmludGVyU3RhdGVFbnVtO1xyXG4gICAgICAgIGlmIChbQnVzeSwgUGVuZGluZywgSWRsZV0uaW5jbHVkZXMoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyUHJvY2VzcyAmJiBjdXJyUHJvY2Vzcy5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlU3RhdGVFcnJvcihjdXJyUHJvY2Vzcy5lcnJvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU3RhdGVFcnJvcnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZmx1eC5tYXAoZmx1eCA9PiBmbHV4LmFjdGlvbnMuUHJpbnRlckRldGFpbHNBY3Rpb25zLnN0YXR1cyh0aGlzLmdldElkKCksIHt9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRnJvbVByaW50ZXJJbmZvKHByaW50ZXJJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5fcHJpbnRlckluZm8gPSBwcmludGVySW5mbztcclxuICAgICAgICB0aGlzLnVwZGF0ZVByaW50ZXJTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBpbnZva2Uoa2FpdGVuTWV0aG9kLCBwYXJhbXMgPSB7fSkge1xyXG4gICAgICAgIGlmICgha2FpdGVuTWV0aG9kKSByZXR1cm4gcShudWxsKTtcclxuXHJcbiAgICAgICAgLy8gTm90IGVsZWdhbnQgYXQgYWxsLCBidXQgdG8gdHJ1bHkgY2FwdHVyZSB0aGUgc3RhdGUgb2Ygd2hpY2ggdGhlXHJcbiAgICAgICAgLy8gcG9sbGluZyBvZiB0aGUgY29tbWFuZCArIHBvbGxpbmcgd2l0aCBwcmludGVyIHN0YXR1cywgd2UnbGwgbmVlZCB0b1xyXG4gICAgICAgIC8vIHJlY29yZCB0aGUgcHJldmlvdXMgY3VycmVudF9wcm9jZXNzIChpZiBudWxsKSBvciBzdGVwIChpZiBjdXJyUHJvc1xyXG4gICAgICAgIC8vIG5vdCBudWxsKVxyXG4gICAgICAgIGNvbnN0IHsgY3VycmVudF9wcm9jZXNzIH0gPSB0aGlzLl9wcmludGVySW5mby5pbmZvO1xyXG4gICAgICAgIGNvbnN0IG9sZEN1cnJQcm9jT3JTdGVwID0gY3VycmVudF9wcm9jZXNzICYmIGN1cnJlbnRfcHJvY2Vzcy5zdGVwO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZENtZFRvUmVmbGVjdG9yKGthaXRlbk1ldGhvZCwgcGFyYW1zKS50aGVuKGNtZElkID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvbGxDbWRGcm9tUmVmbGVjdG9yKGNtZElkLCBvbGRDdXJyUHJvY09yU3RlcCwgMik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIEthaXRlbiBDbWRzIHRvIFJlZmxlY3RvciB2aWEgUE9TVC1SRVFVRVNUIGZvciBTa2V0Y2ggUHJpbnRlcnNcclxuICAgICAqIEBwYXJhbSB7c3RyfSBtZXRob2QgLSBrYWl0ZW4gbWV0aG9kIChzbmFrZWNhc2luZyBwbGVhc2UhKVxyXG4gICAgICogQHBhcmFtIHtvYmovYXJyYXl9IHBhcmFtcyAtIChvYmopIHBhcmFtcyBjb250YWlucyBhZGRpdGlvbmFsIGFyZ3VtZW50cyBsaXN0ZWQgaW5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrYWl0ZW4tQVBJLm1kIGRvY3VtZW50LiAoYXJyYXkpIC0gY29udGFpbnMgdGhlIHByb2Nlc3NcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgbmFtZSBuZWVkZWQgdG8gcGFzcyBpbnRvIHBhcmFtcyBvYmplY3QuLi5cclxuICAgICAqL1xyXG4gICAgX3NlbmRDbWRUb1JlZmxlY3RvcihtZXRob2QsIHBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IGRlZmVyID0gcS5kZWZlcigpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMudXNlclRva2VufWAsXHJcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1cmw6IGAke3JlZmxlY3RvclVybH0vcHJpbnRlcnMvJHt0aGlzLmdldElzZXJpYWwoKX0vY29tbWFuZHNgLFxyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgLy8gQVJHR0dISEghIGNhbWVsY2FzaW5nIHZzIHNuYWtlY2FzaW5nXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCA9PT0gJ1Byb2Nlc3NNZXRob2QnID8gJ3Byb2Nlc3NfbWV0aG9kJyA6IG1ldGhvZCxcclxuICAgICAgICAgICAgICAgIHBhcmFtczogQXJyYXkuaXNBcnJheShwYXJhbXMpID8geyBtZXRob2Q6IHBhcmFtc1swXSB9IDogcGFyYW1zLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXF1ZXN0KG9wdGlvbnMsIChlcnIsIHJlcywgYm9keSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyIHx8ICFbMjAwLCAyMDFdLmluY2x1ZGVzKHJlcy5zdGF0dXNDb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUmVmbGVjdG9yIFJFU1QgQVBJIEVycm9yOiBVbmFibGUgdG8gcHJvY2VzcyAnJHttZXRob2R9JyBjb21tYW5kLmAsIGVycik7XHJcbiAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QoZXJyIHx8IHJlcy5ib2R5KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWZsZWN0b3IgUkVTVCBBUEk6IFNlbnQgJyR7bWV0aG9kfScgY29tbWFuZCBzdWNjZXNzYCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uUmVzID0gSlNPTi5wYXJzZShib2R5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBVE0sIHdlJ3JlIG5vdCBpbnZva2luZyBtdWx0aXBsZSBjbWRzIHZpYSByZWZsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVyZWZvcmUgcmV0dXJuIHRoZSBmaXJzdCBlbGVtZW50IG9mIGNtZElkcyBhcnJheVxyXG4gICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShqc29uUmVzWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvbGwgUmVmbGVjdG9yIGZvciBzdGF0dXMgdXBkYXRlIG9uIGEgY29tbWFuZCB2aWEgR0VULVJFUVVFU1QgZm9yIFNrZXRjaCBQcmludGVyc1xyXG4gICAgICogQHBhcmFtIHtzdHJ9IGNtZElkIC0gY29tbWFuZCBpZCByZXR1cm4gcmVmbGVjdG9yIGFmdGVyIHNlbmRpbmcgYSBjbWQgcmVxdWVzdFxyXG4gICAgICogQHBhcmFtIHtzdHIvbnVsbH0gb2xkQ3VyclByb2NPclN0ZXAgLSBvbGQgc3RhdGUgZm9yIGNvbXBhcmluZyBkdXJpbmcgcG9sbGluZ1xyXG4gICAgICogQHBhcmFtIHtpbnR9IHRpbWVJbnRlcnZhbCAtIHRpbWUgZGVsYXkgYmV0d2VlbiBwb2xsaW5nIGZvciBjbWQgc3RhdHVzIChzZWNvbmRzKVxyXG4gICAgICoqL1xyXG4gICAgX3BvbGxDbWRGcm9tUmVmbGVjdG9yKGNtZElkLCBvbGRDdXJyUHJvY09yU3RlcCwgdGltZUludGVydmFsKSB7XHJcbiAgICAgICAgY29uc3QgZGVmZXIgPSBxLmRlZmVyKCk7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dGhpcy51c2VyVG9rZW59YCxcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVybDogYCR7cmVmbGVjdG9yVXJsfS9wcmludGVycy8ke3RoaXMuZ2V0SXNlcmlhbCgpfS9jb21tYW5kcy8ke2NtZElkfWAsXHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcG9sbGluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgICAgICByZXF1ZXN0KG9wdGlvbnMsIChlcnIsIHJlcywgYm9keSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVyciB8fCAhWzIwMCwgMjAxXS5pbmNsdWRlcyhyZXMuc3RhdHVzQ29kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBSZWZsZWN0b3IgUkVTVCBBUEkgRXJyb3I6IFVuYWJsZSB0byBwb2xsIGNvbW1hbmQgaWQ6IFske2NtZElkfV0uYCwgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHBvbGxpbmdJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVqZWN0KGVyciB8fCByZXMuYm9keSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb25SZXMgPSBKU09OLnBhcnNlKGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhdHVzIH0gPSBqc29uUmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBlbGVnYW50IGF0IGFsbCwgYnV0IHRvIHRydWx5IGNhcHR1cmUgdGhlIHN0YXRlIG9mIHdoaWNoIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvbGxpbmcgb2YgdGhlIGNvbW1hbmQgKyBwb2xsaW5nIHdpdGggcHJpbnRlciBzdGF0dXMsIHdlJ2xsIG5lZWQgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyByZWNvcmQgdGhlIHByZXZpb3VzIGN1cnJlbnRfcHJvY2VzcyAoaWYgbnVsbCkgb3Igc3RlcCAoaWYgY3VyclByb3NcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGN1cnJlbnRfcHJvY2VzcyB9ID0gdGhpcy5fcHJpbnRlckluZm8uaW5mbztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDdXJyUHJvY09yU3RlcCA9IGN1cnJlbnRfcHJvY2VzcyAmJiBjdXJyZW50X3Byb2Nlc3Muc3RlcDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0gZmluZCBhbm90aGVyIGxvZ2ljIGNvbmRpdGlvbiB0byBrZWVwIHRoZSBzcGlubmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9hZGluZyBiZWNhdXNlIF9wcmludGVySW5mbyBpcyBzdGlsbCBub3QgdXAtdG8tZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdhY2snICYmIG9sZEN1cnJQcm9jT3JTdGVwICE9PSBuZXdDdXJyUHJvY09yU3RlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHBvbGxpbmdJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIHRpbWVJbnRlcnZhbCAqIDEwMDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFmdGVyIHNsaWNlIC0+IHVwbG9hZCB0aGUgLm1ha2VyYm90XHJcbiAgICB1cGxvYWRGaWxlVG9DbG91ZHNsaWNlcihkb3RNYWtlcmJvdEZpbGUpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgdXJsOiBgJHtyZWZsZWN0b3JVcmx9L3ByaW50ZXJzLyR7dGhpcy5nZXRJc2VyaWFsKCl9L3VwbG9hZGAsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcclxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMudXNlclRva2VufWAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IGRvdE1ha2VyYm90RmlsZSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gcS5Qcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Qob3B0aW9ucywgKGVycm9yLCByZXNwb25zZSwgYm9keSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gaG93IHNob3VsZCBlcnJvcnMgYmUgaGFuZGxlZD9cclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgR0NQIGZpbGUgbG9jYXRpb24gVVJMXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFrZXJib3RGaWxlVVJMID0gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KS51cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnN0YXJ0Q2xvdWRQcmludChtYWtlcmJvdEZpbGVVUkwpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2VuZCBwcmludCBjb21tYW5kIHdpdGggc3RvcmVkIC5tYWtlcmJvdFxyXG4gICAgc3RhcnRDbG91ZFByaW50KG1ha2VyYm90RmlsZVVSTCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgdXJsOiBtYWtlcmJvdEZpbGVVUkwsIGVuc3VyZV9idWlsZF9wbGF0ZV9jbGVhcjogZmFsc2UgfTtcclxuICAgICAgICB0aGlzLmludm9rZSgnZXh0ZXJuYWxfcHJpbnQnLCBwYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyBUb29scGF0aCBvYmplY3QgbWFkZSBmcm9tIHdoYXQgaXMgcmV0dXJuZWQgYnkgJ2J1aWxkJyBpbiBtYWtlcmJvdC5qcy4uLlxyXG4gICAgc2VuZFByaW50RmlsZShkb3RNYWtlcmJvdEZpbGUpIHtcclxuICAgICAgICBpZiAodGhpcy5nZXRTdGF0dXMoKS5zdGF0ZSAhPT0gUHJpbnRlclN0YXRlRW51bS5JZGxlKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdVbmFibGUgdG8gcHJpbnQgdG8gdGhpcyBwcmludGVyIGF0IHRoaXMgdGltZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgZG90TWFrZXJib3RGaWxlLmdldCgncGF0aCcpKTtcclxuICAgICAgICByZXR1cm4gcShcclxuICAgICAgICAgICAgZnMucmVhZEZpbGUoZmlsZVBhdGgsIChlcnIsIGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwbG9hZEZpbGVUb0Nsb3Vkc2xpY2VyKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRQcmludCgpIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGhlcmUganVzdCBmb3IgY29uc2lzdGVuY3kgd2l0aCBtYXRlcmJvdC1wcmludGVyLmpzLCBhbmQgZG9lcyBub3RoaW5nLlxyXG4gICAgICAgIHJldHVybiBxKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhbmdlRmlsYW1lbnQocHJvY2Vzc01ldGhvZCwgaWRsZU1ldGhvZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdldFN0YXR1cygpLnN0YXRlID09PSBQcmludGVyU3RhdGVFbnVtLkJ1c3kpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW52b2tlKCdwcm9jZXNzX21ldGhvZCcsIHsgbWV0aG9kOiBwcm9jZXNzTWV0aG9kIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludm9rZShpZGxlTWV0aG9kKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZEZpbGFtZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NNZXRob2QgPSAnbG9hZF9maWxhbWVudCc7XHJcbiAgICAgICAgY29uc3QgaWRsZU1ldGhvZCA9ICdsb2FkX2ZpbGFtZW50JztcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VGaWxhbWVudChwcm9jZXNzTWV0aG9kLCBpZGxlTWV0aG9kKTtcclxuICAgIH1cclxuXHJcbiAgICB1bmxvYWRGaWxhbWVudCgpIHtcclxuICAgICAgICBjb25zdCBwcm9jZXNzTWV0aG9kID0gJ3VubG9hZF9maWxhbWVudCc7XHJcbiAgICAgICAgY29uc3QgaWRsZU1ldGhvZCA9ICd1bmxvYWRfZmlsYW1lbnQnO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUZpbGFtZW50KHByb2Nlc3NNZXRob2QsIGlkbGVNZXRob2QpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0b3BGaWxhbWVudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5nZXRTdGF0dXMoKS5zdGF0ZSA9PT0gUHJpbnRlclN0YXRlRW51bS5CdXN5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludm9rZSgncHJvY2Vzc19tZXRob2QnLCB7IG1ldGhvZDogJ3N0b3BfZmlsYW1lbnQnIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RXh0cnVkZXJJbmZvKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcmludGVySW5mby5pbmZvLnRvb2xoZWFkcyA/IHRoaXMuX3ByaW50ZXJJbmZvLmluZm8udG9vbGhlYWRzLmV4dHJ1ZGVyIDogW107XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0QWxsRXh0cnVkZXJJbmZvKCkge1xyXG4gICAgICAgIHJldHVybiBxKHRoaXMuZ2V0RXh0cnVkZXJJbmZvKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFN5c3RlbUluZm8oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW50ZXJJbmZvLmluZm8gfHwge307XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TmV0d29ya1N0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRJcEFkZHJlc3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW50ZXJJbmZvLmluZm8gPyB0aGlzLl9wcmludGVySW5mby5pbmZvLmlwIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRQbGF0Zm9ybUluZm8oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW50ZXJJbmZvLmluZm8udG9vbGhlYWRzID8gdGhpcy5fcHJpbnRlckluZm8uaW5mby50b29saGVhZHMucGxhdGZvcm0gOiBbXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRJc2VyaWFsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldElkKCkuc3BsaXQoJzonKVsyXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRDdXJyZW50RXh0cnVkZXJUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiBFeHRydWRlclR5cGVFbnVtLnNrZXRjaF9leHRydWRlcjtcclxuICAgIH1cclxuXHJcbiAgICBpc1NrZXRjaFByaW50ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gL3N0b3Jlcy9wcmludGVyU3RvcmUuanNcclxuICAgIGluamVjdEZsdXgoZmx1eCkge1xyXG4gICAgICAgIHRoaXMuX2ZsdXggPSBtYXliZShmbHV4KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTa2V0Y2hQcmludGVyO1xyXG4iXX0=
