'use strict';

const React = require('react');

const DOM = React.DOM;
const ce = React.createElement;

const _ = require('lodash');

const FluxComponent = require('eagle-print/views/flux_component');

const Button = require('eagle-print/views/ui/button');
/**
 * The entire reason for this thing existing is to make the slider on ZOffset work. Basically,
 * to make the button both aware of state, and have the slider not re-render (effectively killing
 * the mouse-drag action), I had to wrap the button in its own component, so I could render just that, and
 * leave the parent (zOffset) unaffected. This is basically a hack to make the slider play nice with everything.
 */


class ZOffsetButton extends FluxComponent {
  constructor(props, context) {
    super(props, context);
    this.i18n = this.props.flux.getService('TranslationService');

    _.assign(this.state, {
      disabled: this.props.disabled
    });
  }
  /**
   * Enable the button
   */


  enable() {
    this.setState({
      disabled: false
    });
  }
  /**
   * Disable the button
   */


  disable() {
    this.setState({
      disabled: true
    });
  }

  isDisabled() {
    return this.state.disabled;
  }
  /**
   * Some extra text as per the spec
   */


  _changesText() {
    if (this.state.disabled === true) {
      return DOM.div();
    }

    return DOM.div({
      style: {
        marginTop: 20
      }
    }, DOM.p({}, this.i18n.t('mb:zoffset.changes')), DOM.p({}, this.i18n.t('mb:zoffset.caution')));
  }

  render() {
    return DOM.div({
      className: 'zoffset-button-container'
    }, ce(Button, {
      type: `secondary ${this.state.disabled ? 'disabled' : ''}`,
      onClick: this.props.onClick,
      disabled: this.state.disabled
    }, this.i18n.t('mb:zoffset.apply')), this._changesText());
  }

}

module.exports = ZOffsetButton;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInpvZmZzZXRCdXR0b24uanMiXSwibmFtZXMiOlsiUmVhY3QiLCJyZXF1aXJlIiwiRE9NIiwiY2UiLCJjcmVhdGVFbGVtZW50IiwiXyIsIkZsdXhDb21wb25lbnQiLCJCdXR0b24iLCJaT2Zmc2V0QnV0dG9uIiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImNvbnRleHQiLCJpMThuIiwiZmx1eCIsImdldFNlcnZpY2UiLCJhc3NpZ24iLCJzdGF0ZSIsImRpc2FibGVkIiwiZW5hYmxlIiwic2V0U3RhdGUiLCJkaXNhYmxlIiwiaXNEaXNhYmxlZCIsIl9jaGFuZ2VzVGV4dCIsImRpdiIsInN0eWxlIiwibWFyZ2luVG9wIiwicCIsInQiLCJyZW5kZXIiLCJjbGFzc05hbWUiLCJ0eXBlIiwib25DbGljayIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLE1BQU1BLEtBQUssR0FBR0MsT0FBTyxDQUFDLE9BQUQsQ0FBckI7O0FBQ0EsTUFBTUMsR0FBRyxHQUFHRixLQUFLLENBQUNFLEdBQWxCO0FBQ0EsTUFBTUMsRUFBRSxHQUFHSCxLQUFLLENBQUNJLGFBQWpCOztBQUNBLE1BQU1DLENBQUMsR0FBR0osT0FBTyxDQUFDLFFBQUQsQ0FBakI7O0FBQ0EsTUFBTUssYUFBYSxHQUFHTCxPQUFPLENBQUMsa0NBQUQsQ0FBN0I7O0FBQ0EsTUFBTU0sTUFBTSxHQUFHTixPQUFPLENBQUMsNkJBQUQsQ0FBdEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1PLGFBQU4sU0FBNEJGLGFBQTVCLENBQTBDO0FBQ3RDRyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBUUMsT0FBUixFQUFpQjtBQUN4QixVQUFNRCxLQUFOLEVBQWFDLE9BQWI7QUFDQSxTQUFLQyxJQUFMLEdBQVksS0FBS0YsS0FBTCxDQUFXRyxJQUFYLENBQWdCQyxVQUFoQixDQUEyQixvQkFBM0IsQ0FBWjs7QUFFQVQsSUFBQUEsQ0FBQyxDQUFDVSxNQUFGLENBQVMsS0FBS0MsS0FBZCxFQUFxQjtBQUNqQkMsTUFBQUEsUUFBUSxFQUFFLEtBQUtQLEtBQUwsQ0FBV087QUFESixLQUFyQjtBQUdIO0FBRUQ7QUFDSjtBQUNBOzs7QUFDSUMsRUFBQUEsTUFBTSxHQUFHO0FBQ0wsU0FBS0MsUUFBTCxDQUFjO0FBQUVGLE1BQUFBLFFBQVEsRUFBRTtBQUFaLEtBQWQ7QUFDSDtBQUVEO0FBQ0o7QUFDQTs7O0FBQ0lHLEVBQUFBLE9BQU8sR0FBRztBQUNOLFNBQUtELFFBQUwsQ0FBYztBQUFFRixNQUFBQSxRQUFRLEVBQUU7QUFBWixLQUFkO0FBQ0g7O0FBRURJLEVBQUFBLFVBQVUsR0FBRztBQUNULFdBQU8sS0FBS0wsS0FBTCxDQUFXQyxRQUFsQjtBQUNIO0FBRUQ7QUFDSjtBQUNBOzs7QUFDSUssRUFBQUEsWUFBWSxHQUFHO0FBQ1gsUUFBSSxLQUFLTixLQUFMLENBQVdDLFFBQVgsS0FBd0IsSUFBNUIsRUFBa0M7QUFDOUIsYUFBT2YsR0FBRyxDQUFDcUIsR0FBSixFQUFQO0FBQ0g7O0FBRUQsV0FBT3JCLEdBQUcsQ0FBQ3FCLEdBQUosQ0FDSDtBQUFFQyxNQUFBQSxLQUFLLEVBQUU7QUFBRUMsUUFBQUEsU0FBUyxFQUFFO0FBQWI7QUFBVCxLQURHLEVBRUh2QixHQUFHLENBQUN3QixDQUFKLENBQU0sRUFBTixFQUFVLEtBQUtkLElBQUwsQ0FBVWUsQ0FBVixDQUFZLG9CQUFaLENBQVYsQ0FGRyxFQUdIekIsR0FBRyxDQUFDd0IsQ0FBSixDQUFNLEVBQU4sRUFBVSxLQUFLZCxJQUFMLENBQVVlLENBQVYsQ0FBWSxvQkFBWixDQUFWLENBSEcsQ0FBUDtBQUtIOztBQUVEQyxFQUFBQSxNQUFNLEdBQUc7QUFDTCxXQUFPMUIsR0FBRyxDQUFDcUIsR0FBSixDQUNIO0FBQUVNLE1BQUFBLFNBQVMsRUFBRTtBQUFiLEtBREcsRUFFSDFCLEVBQUUsQ0FDRUksTUFERixFQUVFO0FBQ0l1QixNQUFBQSxJQUFJLEVBQUcsYUFBWSxLQUFLZCxLQUFMLENBQVdDLFFBQVgsR0FBc0IsVUFBdEIsR0FBbUMsRUFBRyxFQUQ3RDtBQUVJYyxNQUFBQSxPQUFPLEVBQUUsS0FBS3JCLEtBQUwsQ0FBV3FCLE9BRnhCO0FBR0lkLE1BQUFBLFFBQVEsRUFBRSxLQUFLRCxLQUFMLENBQVdDO0FBSHpCLEtBRkYsRUFPRSxLQUFLTCxJQUFMLENBQVVlLENBQVYsQ0FBWSxrQkFBWixDQVBGLENBRkMsRUFXSCxLQUFLTCxZQUFMLEVBWEcsQ0FBUDtBQWFIOztBQXpEcUM7O0FBNEQxQ1UsTUFBTSxDQUFDQyxPQUFQLEdBQWlCekIsYUFBakIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbmNvbnN0IERPTSA9IFJlYWN0LkRPTTtcclxuY29uc3QgY2UgPSBSZWFjdC5jcmVhdGVFbGVtZW50O1xyXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbmNvbnN0IEZsdXhDb21wb25lbnQgPSByZXF1aXJlKCdlYWdsZS1wcmludC92aWV3cy9mbHV4X2NvbXBvbmVudCcpO1xyXG5jb25zdCBCdXR0b24gPSByZXF1aXJlKCdlYWdsZS1wcmludC92aWV3cy91aS9idXR0b24nKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZW50aXJlIHJlYXNvbiBmb3IgdGhpcyB0aGluZyBleGlzdGluZyBpcyB0byBtYWtlIHRoZSBzbGlkZXIgb24gWk9mZnNldCB3b3JrLiBCYXNpY2FsbHksXHJcbiAqIHRvIG1ha2UgdGhlIGJ1dHRvbiBib3RoIGF3YXJlIG9mIHN0YXRlLCBhbmQgaGF2ZSB0aGUgc2xpZGVyIG5vdCByZS1yZW5kZXIgKGVmZmVjdGl2ZWx5IGtpbGxpbmdcclxuICogdGhlIG1vdXNlLWRyYWcgYWN0aW9uKSwgSSBoYWQgdG8gd3JhcCB0aGUgYnV0dG9uIGluIGl0cyBvd24gY29tcG9uZW50LCBzbyBJIGNvdWxkIHJlbmRlciBqdXN0IHRoYXQsIGFuZFxyXG4gKiBsZWF2ZSB0aGUgcGFyZW50ICh6T2Zmc2V0KSB1bmFmZmVjdGVkLiBUaGlzIGlzIGJhc2ljYWxseSBhIGhhY2sgdG8gbWFrZSB0aGUgc2xpZGVyIHBsYXkgbmljZSB3aXRoIGV2ZXJ5dGhpbmcuXHJcbiAqL1xyXG5jbGFzcyBaT2Zmc2V0QnV0dG9uIGV4dGVuZHMgRmx1eENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KTtcclxuICAgICAgICB0aGlzLmkxOG4gPSB0aGlzLnByb3BzLmZsdXguZ2V0U2VydmljZSgnVHJhbnNsYXRpb25TZXJ2aWNlJyk7XHJcblxyXG4gICAgICAgIF8uYXNzaWduKHRoaXMuc3RhdGUsIHtcclxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMucHJvcHMuZGlzYWJsZWQsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgdGhlIGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBlbmFibGUoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGRpc2FibGVkOiBmYWxzZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGUgdGhlIGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlKCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBkaXNhYmxlZDogdHJ1ZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpc0Rpc2FibGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRpc2FibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29tZSBleHRyYSB0ZXh0IGFzIHBlciB0aGUgc3BlY1xyXG4gICAgICovXHJcbiAgICBfY2hhbmdlc1RleHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlzYWJsZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERPTS5kaXYoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBET00uZGl2KFxyXG4gICAgICAgICAgICB7IHN0eWxlOiB7IG1hcmdpblRvcDogMjAgfSB9LFxyXG4gICAgICAgICAgICBET00ucCh7fSwgdGhpcy5pMThuLnQoJ21iOnpvZmZzZXQuY2hhbmdlcycpKSxcclxuICAgICAgICAgICAgRE9NLnAoe30sIHRoaXMuaTE4bi50KCdtYjp6b2Zmc2V0LmNhdXRpb24nKSlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICByZXR1cm4gRE9NLmRpdihcclxuICAgICAgICAgICAgeyBjbGFzc05hbWU6ICd6b2Zmc2V0LWJ1dHRvbi1jb250YWluZXInIH0sXHJcbiAgICAgICAgICAgIGNlKFxyXG4gICAgICAgICAgICAgICAgQnV0dG9uLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGBzZWNvbmRhcnkgJHt0aGlzLnN0YXRlLmRpc2FibGVkID8gJ2Rpc2FibGVkJyA6ICcnfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogdGhpcy5wcm9wcy5vbkNsaWNrLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLnN0YXRlLmRpc2FibGVkLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHRoaXMuaTE4bi50KCdtYjp6b2Zmc2V0LmFwcGx5JylcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlc1RleHQoKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWk9mZnNldEJ1dHRvbjtcclxuIl19
