'use strict';

const ToolpathParser = require('eagle-print/services/providers/toolpathParser');

const q = require('q');

const JSZip = require('jszip'); // let stream = require('stream');


const JSONStream = require('JSONStream');

const es = require('event-stream');

const {
  isEqual
} = require('lodash');

const ParamsProvider = require('./parameters');

const {
  BotTypeEnum
} = require('./constants');

const {
  GcodeParserStream
} = require('./gcode_toolpath_parser.js');

const INCHES_PER_MM = 0.0393701;
const EXTRUDER_A = '199';
const EXTRUDER_B = '198';
const SUPPORT = {
  [EXTRUDER_A]: '201',
  [EXTRUDER_B]: '207'
}; /// Object that holds state of the parser and updates it based on new commands.
///
/// @buildVolume - the bounds of the machine, used to offset toolpath commands
///   correctly.
/// @totalRaftLayers - number of layers that are in the raft
/// @extruderCount - the number of extruders used in this print

const ParserState = function (buildVolume, totalRaftLayers, extruderCount) {
  // we expect each layer to have the following format:
  //  {
  //    totalNrMoves: number, (all moves)
  //    totalNrHeadMoves: number, (moves that are just head moves)
  //    totalLength: number
  //    movesModel: { type, [Move]}
  //    movesSupport: { type, [Move]}
  //  }
  //
  this.totalMoves = 0;
  this.totalTravelMoves = 0;
  this.totalLength = 0; // NOTE: at some point we're going to want to break this down in a finer way
  // where we have lists of for each model on the plate. that will require a
  // change to how we encode moves though.

  this.movesModel = [];
  this.movesSupport = []; // variables that we'll use to compute the layer data

  this.index = 0;
  this.isModel = true;
  this.isTravel = true;
  this.lastMove = {};
  this.preCmdTag = null;
  this.totalLayers = 0;
  this.lastExtruderMoves = {
    a: 0,
    b: 0
  };
  this.currExtruder = null; // EXTRUDER_A, EXTRUDER_B, or null
  // store the meta data on the current layer

  this.lowerPosition = 0;
  this.upperPosition = 0;
  this.thickness = 0;
  this.width = 0; // generate x and y offsets. in eagle, (0, 0) is the lower left corner of
  // the buildplate. in miracle grue, it is the center of the build plate.

  this.xOffset = buildVolume.x / 2;
  this.yOffset = buildVolume.y / 2;
  this.totalRaftLayers = totalRaftLayers;
  this.extruderCount = extruderCount;
};

ParserState.prototype = {
  constructor: ParserState,

  /// parse a commands function out and pass it to the appropriate parsing
  /// method.
  ///
  /// @command - the jsontoolpath command to parse as an Object
  ///   * function <string> - what this commmands purpose is
  parseCommand(command) {
    if (command.function == 'move') {
      return this.parseMoveCommand(command);
    } else if (command.function == 'comment') {
      return this.parseCommentCommand(command);
    }
  },

  /// parse a comment command, emitting a new layer, and updating our layer
  /// meta data
  ///
  /// for each layer, we will have a comment declaring its chunk number, the
  /// upper bounds, the lower bounds, the width, and the thickness for that
  /// layer. there is also a comment for the end of a print.
  ///
  /// @command - the jsontoolpath comment command to parse as an Object
  ///   * parameters.comment <string> - a comment adding info about this layer
  parseCommentCommand(command) {
    const comment = command.parameters.comment; // regex used to pull a float out of a string

    const floatRegex = /\d+[.]?\d*/; // check to see if this comment is for the lower position

    const lowerPosRegex = /lower position.*\d+[.]?\d*/i;
    const lowerPositionMatch = comment.match(lowerPosRegex);

    if (lowerPositionMatch) {
      // note on syntax: the +(<string>) will cast the match as a number.
      this.lowerPosition = +comment.match(floatRegex)[0] * INCHES_PER_MM;
      return;
    } // check to see if this comment is for the upper position


    const upperPosRegex = /upper position.*\d+[.]?\d*/i;
    const upperPositionMatch = comment.match(upperPosRegex);

    if (upperPositionMatch) {
      this.upperPosition = +comment.match(floatRegex)[0] * INCHES_PER_MM;
      return;
    } // check to see if this comment is for the thickness


    const thicknessRegex = /thickness.*\d+[.]?\d*/i;
    const thicknessMatch = comment.match(thicknessRegex);

    if (thicknessMatch) {
      this.thickness = +comment.match(floatRegex)[0] * INCHES_PER_MM;
      return;
    } // check to see if this comment is for the width


    const widthRegex = /width.*\d+[.]?\d*/i;
    const widthMatch = comment.match(widthRegex);

    if (widthMatch) {
      this.width = +comment.match(floatRegex)[0] * INCHES_PER_MM;
      return;
    } // check to see if this comment is for the chunk number


    const chunkRegex = /chunk.*\d/i;
    const layerSectionRegex = /layer section.*\d.*[(]\d*[)]/i;

    if (comment.match(chunkRegex) || comment.match(layerSectionRegex)) {
      this.totalLayers++;
      return this.reachedEndOfLayer();
    }

    const materialRegex = /material.*(\d)/i;
    const materialMatch = comment.match(materialRegex);

    if (materialMatch) {
      const extruderID = materialMatch[1];

      if (extruderID === '0') {
        this.currExtruder = EXTRUDER_A;
      } else if (extruderID === '1') {
        this.currExtruder = EXTRUDER_B;
      } else {
        console.error('Unknown extruder id:', extruderID);
      }

      return;
    } // check to see if this comment is for the end of the print


    if (comment === 'End of print') {
      return this.reachedEndOfLayer();
    }
  },

  /// parse a move command and update our moves, travel moves, length, and
  /// moves arrays accordingly.
  ///
  /// @command - the jsontoolpath command to parse as an Object
  ///   * parameters - x, y, z, a, b and feedrate for this command
  ///   * tags - array of strings tagging this move
  parseMoveCommand(command) {
    // update the move index, current move, and current tag
    this.index++;
    this.currentMove = {
      x: (command.parameters.x + this.xOffset) * INCHES_PER_MM,
      y: (command.parameters.y + this.yOffset) * INCHES_PER_MM,
      z: command.parameters.z * INCHES_PER_MM,
      index: this.index
    };
    this.loadCurrentTag(command.tags[0]); // update the total moves and total travel moves

    if (this.isTravel) {
      this.totalTravelMoves++;
    }

    this.totalMoves++; // if this is a dual-material print, use extruder A vs extruder B logic

    if (this.extruderCount > 1) {
      if (this.currExtruder === EXTRUDER_A) {
        this.movesModel.push(this.currentMove);
      } else {
        this.movesSupport.push(this.currentMove);
      } // if this is a single-material print, use model vs support logic

    } else {
      if (this.isModel) {
        this.movesModel.push(this.currentMove);
      } else {
        this.movesSupport.push(this.currentMove);
        this.cleanupPrevRestartWithSupportMoves(command.tags[0]);
      }
    } // keep track of preview command tag for possible cleanup


    this.preCmdTag = command.tags[0]; // set the last move to the one we just parsed

    this.lastMove = this.currentMove;
  },

  /**
   * Bugfix/Patch (PEN-2878) -- Ray
   *
   * The assumption with threeEngineToolpathLoader is that the first supportMoves will
   * always have an area of zero.
   *
   * With the mb jsontp, it safe to assume that every support island has a "restart"
   * before it starts the extrusion of the support. The "restart" move in "this.movesModel"
   * has an area of zero. We'll just pop this move out and prepend it into "this.movesSupport".
   *
   * @param {string} currCmdTag
   */
  cleanupPrevRestartWithSupportMoves(currCmdTag) {
    if (this.preCmdTag === 'Restart' && currCmdTag === 'Support' && this.movesModel.length > 0) {
      const restartMove = this.movesModel.pop();
      const indexMove = this.movesSupport.findIndex(mv => isEqual(mv, this.currentMove));

      if (indexMove === 0) {
        this.movesSupport.unshift(restartMove);
      } else {
        this.movesSupport.splice(indexMove - 1, 0, restartMove);
      }
    }
  },

  /// update this.isTravelMove and this.isModel based on @tag{string}, a tag
  /// from miracle_grue.
  loadCurrentTag(tag) {
    switch (tag) {
      case 'Trailing Extrusion Move':
        this.isTravel = false;
        break;

      case 'Anchor':
      case 'Bridge':
      case 'Infill':
      case 'Inset':
      case 'Outline':
      case 'Spur':
        this.isTravel = false;
        this.isModel = true;
        break;

      case 'Support':
      case 'Purge':
      case 'Invalid Move':
        this.isTravel = false;
        this.isModel = false;
        break;

      case 'Backlash Compensation':
      case 'Connection':
      case 'Long Restart':
      case 'Long Retract':
      case 'Restart':
      case 'Retract':
      case 'Leaky Travel Move':
      case 'Travel Move':
        this.isTravel = true;
        break;

      default:
        if (this.logger) {
          this.logger.info(`tag not found: ${tag}`);
        }

    } // all raft layers are tagged as support


    if (this.totalLayers <= this.totalRaftLayers) {
      this.isModel = false;
    } // use the width and thickness of this layer to create the area.
    // TODO(zap) - edit the drawing of extrusions to better reflect width
    // and thickness instead of just area.


    this.currentMove.area = this.isTravel ? 0 : this.width * this.thickness;
  },

  /// update the deferred promise with the data on the finished layer and
  /// reinitialize layer data.
  reachedEndOfLayer() {
    let layer;
    const extruder = this.currExtruder || EXTRUDER_A; // check that we have actual moves in this layer

    if (this.totalMoves - this.totalTravelMoves !== 0) {
      // create layer object
      layer = {
        totalNrMoves: this.totalMoves,
        totalNrHeadMoves: this.totalTravelMoves,
        movesMaterial: {
          [extruder]: this.movesModel
        },
        movesSupport: {
          [SUPPORT[extruder]]: this.movesSupport
        },
        upperPosition: this.upperPosition,
        lowerPosition: this.lowerPosition
      };
    } // reset our state


    this.totalMoves = 0;
    this.totalTravelMoves = 0;
    this.totalLength = 0;
    this.movesModel = [];
    this.movesSupport = [];
    this.index = 0;
    this.isModel = true;
    this.isTravel = true;
    this.lastMove = {};
    return layer;
  }

};

class MBToolpathParser extends ToolpathParser {
  constructor(loggingService, miracleConfig, buildVolume) {
    super();
    this.logger = loggingService;
    /*
     *  {
     *    header: { sliceHeight: number },
     *    layers: [ {
     *      totalNrMoves: number, (all moves)
     *      totalNrHeadMoves: number, (moves that are just head moves)
     *      totalLength: number,
     *      movesModel: { type, [Move]}
     *      movesSupport: { type, [Move]}
     *    }]
     *  }
     */

    this.parsedData = {
      header: {
        sliceHeight: null
      },
      layers: []
    };
    this.paramsProvider = new ParamsProvider();
  } /// @return the extention for mb slice files


  getExt() {
    return '.makerbot';
  }

  getExtensions() {
    return ['.makerbot'];
  }

  unzipToolpath(read, filePath) {
    const result = {};
    return read(filePath).then(zippedFileData => {
      return JSZip.loadAsync(zippedFileData);
    }).then(zippedFile => {
      result.tpStream = zippedFile.files['print.jsontoolpath'] ? zippedFile.file('print.jsontoolpath').nodeStream() : zippedFile.file('print.gcode').nodeStream();
      return zippedFile.file('meta.json').async('string');
    }).then(metaData => {
      result.metaData = JSON.parse(metaData);
      return result;
    });
  } /// @metadata - the data from a meta.json file as a JSON object


  loadToolpath(metaData, tpStream, messaging) {
    const self = this; // reset parsed data option

    self.parsedData = {
      header: {
        sliceHeight: null
      },
      layers: []
    }; /// extract heights, and initialize parser state

    self.parsedData.header.sliceHeight = metaData.miracle_config.gaggles.default.layerHeight * INCHES_PER_MM; /// @miracleConfig - the config Object
    ///   * raftBaseLayers
    ///   * raftInterfaceLayers
    ///   * raftSurfaceLayers
    /// @return raft thickness in number of layers

    const calculateRaftLayers = function (miracleConfig) {
      // rafts are turned off, the height is 0
      if (!miracleConfig.doRaft) {
        return 0;
      } // start at zero and add up the height of the raft given the
      // number of layers and their thicknesses


      const {
        numberOfLayers: raftBaseLayers
      } = miracleConfig.raftProfiles.base;
      const {
        numberOfLayers: raftInterfaceLayers
      } = miracleConfig.raftProfiles.interface;
      const {
        numberOfLayers: raftSurfaceLayers
      } = miracleConfig.raftProfiles.surface;
      return raftBaseLayers + raftInterfaceLayers + raftSurfaceLayers;
    }; // Sometimes the meta.json has two extruder distances,
    // but the second one is 0.0. This accounts for that.


    const extruderCount = metaData.extrusion_distances_mm.length < 2 || metaData.extrusion_distances_mm[1] <= 0 ? 1 : metaData.extrusion_distances_mm.length;
    const buildVolumeParams = self.paramsProvider.getParamsByBotType(metaData.bot_type).buildVolume.envelopeSize;

    const getBuildVolumeInMM = function (buildVolumeInMeters) {
      const buildVolume = {};
      Object.keys(buildVolumeInMeters).forEach(axis => {
        buildVolume[axis] = buildVolumeParams[axis] * 1000;
      });
      return buildVolume;
    };

    const isSketchPrinter = metaData.bot_type === BotTypeEnum.sketch;
    const parsingParams = {
      totalRaftLayers: calculateRaftLayers(metaData.miracle_config.gaggles.default),
      buildVolume: getBuildVolumeInMM(buildVolumeParams),
      extruderCount,
      isSketchPrinter
    }; /// Parse a @toolpathNodeStream. when finished, resolve the @deferred promise
    /// with the parsed and formatted data.

    const parseToolpath = function (toolpathNodeStream, parsingParams) {
      messaging.display();
      const defered = new q.defer();
      const parserState = new ParserState(parsingParams.buildVolume, parsingParams.totalRaftLayers, parsingParams.extruderCount);

      const parseCommand = function (command) {
        return parserState.parseCommand(command);
      };

      if (!parsingParams.isSketchPrinter) {
        // pipe stream to a jsonstream parser that parses out each command.
        // pipe parsed out json blobs to the parseCommand function above.
        toolpathNodeStream.pipe(JSONStream.parse('*.*')).pipe(es.mapSync(parseCommand)).on('data', function (layer) {
          self.parsedData.layers.push(layer);
        }).on('end', function (data) {
          messaging.dismiss();
          defered.resolve(self.parsedData);
        });
      } else {
        // For Sketch printers, the toolpathNodeStream is a gcode
        // readable file nodejs stream.
        // Check "unzipToolpath" for more info
        const parserStream = GcodeParserStream(toolpathNodeStream, parsingParams);
        parserStream.on('data', chunk => {
          self.parsedData.layers.push(chunk);
        }).on('end', () => {
          messaging.dismiss();
          defered.resolve(self.parsedData);
        });
      } // return the promise from the parser state.


      return defered.promise;
    };

    return parseToolpath(tpStream, parsingParams).catch(function (err) {
      throw new Error(err);
    });
  }

}

module.exports = MBToolpathParser;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1iX3Rvb2xwYXRoX3BhcnNlci5qcyJdLCJuYW1lcyI6WyJUb29scGF0aFBhcnNlciIsInJlcXVpcmUiLCJxIiwiSlNaaXAiLCJKU09OU3RyZWFtIiwiZXMiLCJpc0VxdWFsIiwiUGFyYW1zUHJvdmlkZXIiLCJCb3RUeXBlRW51bSIsIkdjb2RlUGFyc2VyU3RyZWFtIiwiSU5DSEVTX1BFUl9NTSIsIkVYVFJVREVSX0EiLCJFWFRSVURFUl9CIiwiU1VQUE9SVCIsIlBhcnNlclN0YXRlIiwiYnVpbGRWb2x1bWUiLCJ0b3RhbFJhZnRMYXllcnMiLCJleHRydWRlckNvdW50IiwidG90YWxNb3ZlcyIsInRvdGFsVHJhdmVsTW92ZXMiLCJ0b3RhbExlbmd0aCIsIm1vdmVzTW9kZWwiLCJtb3Zlc1N1cHBvcnQiLCJpbmRleCIsImlzTW9kZWwiLCJpc1RyYXZlbCIsImxhc3RNb3ZlIiwicHJlQ21kVGFnIiwidG90YWxMYXllcnMiLCJsYXN0RXh0cnVkZXJNb3ZlcyIsImEiLCJiIiwiY3VyckV4dHJ1ZGVyIiwibG93ZXJQb3NpdGlvbiIsInVwcGVyUG9zaXRpb24iLCJ0aGlja25lc3MiLCJ3aWR0aCIsInhPZmZzZXQiLCJ4IiwieU9mZnNldCIsInkiLCJwcm90b3R5cGUiLCJjb25zdHJ1Y3RvciIsInBhcnNlQ29tbWFuZCIsImNvbW1hbmQiLCJmdW5jdGlvbiIsInBhcnNlTW92ZUNvbW1hbmQiLCJwYXJzZUNvbW1lbnRDb21tYW5kIiwiY29tbWVudCIsInBhcmFtZXRlcnMiLCJmbG9hdFJlZ2V4IiwibG93ZXJQb3NSZWdleCIsImxvd2VyUG9zaXRpb25NYXRjaCIsIm1hdGNoIiwidXBwZXJQb3NSZWdleCIsInVwcGVyUG9zaXRpb25NYXRjaCIsInRoaWNrbmVzc1JlZ2V4IiwidGhpY2tuZXNzTWF0Y2giLCJ3aWR0aFJlZ2V4Iiwid2lkdGhNYXRjaCIsImNodW5rUmVnZXgiLCJsYXllclNlY3Rpb25SZWdleCIsInJlYWNoZWRFbmRPZkxheWVyIiwibWF0ZXJpYWxSZWdleCIsIm1hdGVyaWFsTWF0Y2giLCJleHRydWRlcklEIiwiY29uc29sZSIsImVycm9yIiwiY3VycmVudE1vdmUiLCJ6IiwibG9hZEN1cnJlbnRUYWciLCJ0YWdzIiwicHVzaCIsImNsZWFudXBQcmV2UmVzdGFydFdpdGhTdXBwb3J0TW92ZXMiLCJjdXJyQ21kVGFnIiwibGVuZ3RoIiwicmVzdGFydE1vdmUiLCJwb3AiLCJpbmRleE1vdmUiLCJmaW5kSW5kZXgiLCJtdiIsInVuc2hpZnQiLCJzcGxpY2UiLCJ0YWciLCJsb2dnZXIiLCJpbmZvIiwiYXJlYSIsImxheWVyIiwiZXh0cnVkZXIiLCJ0b3RhbE5yTW92ZXMiLCJ0b3RhbE5ySGVhZE1vdmVzIiwibW92ZXNNYXRlcmlhbCIsIk1CVG9vbHBhdGhQYXJzZXIiLCJsb2dnaW5nU2VydmljZSIsIm1pcmFjbGVDb25maWciLCJwYXJzZWREYXRhIiwiaGVhZGVyIiwic2xpY2VIZWlnaHQiLCJsYXllcnMiLCJwYXJhbXNQcm92aWRlciIsImdldEV4dCIsImdldEV4dGVuc2lvbnMiLCJ1bnppcFRvb2xwYXRoIiwicmVhZCIsImZpbGVQYXRoIiwicmVzdWx0IiwidGhlbiIsInppcHBlZEZpbGVEYXRhIiwibG9hZEFzeW5jIiwiemlwcGVkRmlsZSIsInRwU3RyZWFtIiwiZmlsZXMiLCJmaWxlIiwibm9kZVN0cmVhbSIsImFzeW5jIiwibWV0YURhdGEiLCJKU09OIiwicGFyc2UiLCJsb2FkVG9vbHBhdGgiLCJtZXNzYWdpbmciLCJzZWxmIiwibWlyYWNsZV9jb25maWciLCJnYWdnbGVzIiwiZGVmYXVsdCIsImxheWVySGVpZ2h0IiwiY2FsY3VsYXRlUmFmdExheWVycyIsImRvUmFmdCIsIm51bWJlck9mTGF5ZXJzIiwicmFmdEJhc2VMYXllcnMiLCJyYWZ0UHJvZmlsZXMiLCJiYXNlIiwicmFmdEludGVyZmFjZUxheWVycyIsImludGVyZmFjZSIsInJhZnRTdXJmYWNlTGF5ZXJzIiwic3VyZmFjZSIsImV4dHJ1c2lvbl9kaXN0YW5jZXNfbW0iLCJidWlsZFZvbHVtZVBhcmFtcyIsImdldFBhcmFtc0J5Qm90VHlwZSIsImJvdF90eXBlIiwiZW52ZWxvcGVTaXplIiwiZ2V0QnVpbGRWb2x1bWVJbk1NIiwiYnVpbGRWb2x1bWVJbk1ldGVycyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiYXhpcyIsImlzU2tldGNoUHJpbnRlciIsInNrZXRjaCIsInBhcnNpbmdQYXJhbXMiLCJwYXJzZVRvb2xwYXRoIiwidG9vbHBhdGhOb2RlU3RyZWFtIiwiZGlzcGxheSIsImRlZmVyZWQiLCJkZWZlciIsInBhcnNlclN0YXRlIiwicGlwZSIsIm1hcFN5bmMiLCJvbiIsImRhdGEiLCJkaXNtaXNzIiwicmVzb2x2ZSIsInBhcnNlclN0cmVhbSIsImNodW5rIiwicHJvbWlzZSIsImNhdGNoIiwiZXJyIiwiRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxNQUFNQSxjQUFjLEdBQUdDLE9BQU8sQ0FBQywrQ0FBRCxDQUE5Qjs7QUFDQSxNQUFNQyxDQUFDLEdBQUdELE9BQU8sQ0FBQyxHQUFELENBQWpCOztBQUNBLE1BQU1FLEtBQUssR0FBR0YsT0FBTyxDQUFDLE9BQUQsQ0FBckIsQyxDQUNBOzs7QUFDQSxNQUFNRyxVQUFVLEdBQUdILE9BQU8sQ0FBQyxZQUFELENBQTFCOztBQUNBLE1BQU1JLEVBQUUsR0FBR0osT0FBTyxDQUFDLGNBQUQsQ0FBbEI7O0FBQ0EsTUFBTTtBQUFDSyxFQUFBQTtBQUFELElBQVlMLE9BQU8sQ0FBQyxRQUFELENBQXpCOztBQUVBLE1BQU1NLGNBQWMsR0FBR04sT0FBTyxDQUFDLGNBQUQsQ0FBOUI7O0FBQ0EsTUFBTTtBQUFFTyxFQUFBQTtBQUFGLElBQWtCUCxPQUFPLENBQUMsYUFBRCxDQUEvQjs7QUFDQSxNQUFNO0FBQUVRLEVBQUFBO0FBQUYsSUFBd0JSLE9BQU8sQ0FBQyw0QkFBRCxDQUFyQzs7QUFFQSxNQUFNUyxhQUFhLEdBQUcsU0FBdEI7QUFFQSxNQUFNQyxVQUFVLEdBQUcsS0FBbkI7QUFDQSxNQUFN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Q0FBQ1EsT0FBUixDQUFnQnhDLElBQUksQ0FBQ3pCLFVBQXJCO0FBQ0gsU0FUTDtBQVVILE9BYkQsTUFhTztBQUNIO0FBQ0E7QUFDQTtBQUNBLGNBQU1rRSxZQUFZLEdBQUd4SixpQkFBaUIsQ0FBQzZJLGtCQUFELEVBQXFCRixhQUFyQixDQUF0QztBQUVBYSxRQUFBQSxZQUFZLENBQ1BKLEVBREwsQ0FDUSxNQURSLEVBQ2dCSyxLQUFLLElBQUk7QUFDakIxQyxVQUFBQSxJQUFJLENBQUN6QixVQUFMLENBQWdCRyxNQUFoQixDQUF1QjFCLElBQXZCLENBQTRCMEYsS0FBNUI7QUFDSCxTQUhMLEVBSUtMLEVBSkwsQ0FJUSxLQUpSLEVBSWUsTUFBTTtBQUNidEMsVUFBQUEsU0FBUyxDQUFDd0MsT0FBVjtBQUNBUCxVQUFBQSxPQUFPLENBQUNRLE9BQVIsQ0FBZ0J4QyxJQUFJLENBQUN6QixVQUFyQjtBQUNILFNBUEw7QUFRSCxPQTFDNkQsQ0E0QzlEOzs7QUFDQSxhQUFPeUQsT0FBTyxDQUFDVyxPQUFmO0FBQ0gsS0E5Q0Q7O0FBZ0RBLFdBQU9kLGFBQWEsQ0FBQ3ZDLFFBQUQsRUFBV3NDLGFBQVgsQ0FBYixDQUF1Q2dCLEtBQXZDLENBQTZDLFVBQVNDLEdBQVQsRUFBYztBQUM5RCxZQUFNLElBQUlDLEtBQUosQ0FBVUQsR0FBVixDQUFOO0FBQ0gsS0FGTSxDQUFQO0FBR0g7O0FBN0p5Qzs7QUFnSzlDRSxNQUFNLENBQUNDLE9BQVAsR0FBaUI1RSxnQkFBakIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBUb29scGF0aFBhcnNlciA9IHJlcXVpcmUoJ2VhZ2xlLXByaW50L3NlcnZpY2VzL3Byb3ZpZGVycy90b29scGF0aFBhcnNlcicpO1xyXG5jb25zdCBxID0gcmVxdWlyZSgncScpO1xyXG5jb25zdCBKU1ppcCA9IHJlcXVpcmUoJ2pzemlwJyk7XHJcbi8vIGxldCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcclxuY29uc3QgSlNPTlN0cmVhbSA9IHJlcXVpcmUoJ0pTT05TdHJlYW0nKTtcclxuY29uc3QgZXMgPSByZXF1aXJlKCdldmVudC1zdHJlYW0nKTtcclxuY29uc3Qge2lzRXF1YWx9ID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcblxyXG5jb25zdCBQYXJhbXNQcm92aWRlciA9IHJlcXVpcmUoJy4vcGFyYW1ldGVycycpO1xyXG5jb25zdCB7IEJvdFR5cGVFbnVtIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5jb25zdCB7IEdjb2RlUGFyc2VyU3RyZWFtIH0gPSByZXF1aXJlKCcuL2djb2RlX3Rvb2xwYXRoX3BhcnNlci5qcycpO1xyXG5cclxuY29uc3QgSU5DSEVTX1BFUl9NTSA9IDAuMDM5MzcwMTtcclxuXHJcbmNvbnN0IEVYVFJVREVSX0EgPSAnMTk5JztcclxuY29uc3QgRVhUUlVERVJfQiA9ICcxOTgnO1xyXG5jb25zdCBTVVBQT1JUID0ge1xyXG4gICAgW0VYVFJVREVSX0FdOiAnMjAxJyxcclxuICAgIFtFWFRSVURFUl9CXTogJzIwNycsXHJcbn07XHJcblxyXG4vLy8gT2JqZWN0IHRoYXQgaG9sZHMgc3RhdGUgb2YgdGhlIHBhcnNlciBhbmQgdXBkYXRlcyBpdCBiYXNlZCBvbiBuZXcgY29tbWFuZHMuXHJcbi8vL1xyXG4vLy8gQGJ1aWxkVm9sdW1lIC0gdGhlIGJvdW5kcyBvZiB0aGUgbWFjaGluZSwgdXNlZCB0byBvZmZzZXQgdG9vbHBhdGggY29tbWFuZHNcclxuLy8vICAgY29ycmVjdGx5LlxyXG4vLy8gQHRvdGFsUmFmdExheWVycyAtIG51bWJlciBvZiBsYXllcnMgdGhhdCBhcmUgaW4gdGhlIHJhZnRcclxuLy8vIEBleHRydWRlckNvdW50IC0gdGhlIG51bWJlciBvZiBleHRydWRlcnMgdXNlZCBpbiB0aGlzIHByaW50XHJcbmNvbnN0IFBhcnNlclN0YXRlID0gZnVuY3Rpb24oYnVpbGRWb2x1bWUsIHRvdGFsUmFmdExheWVycywgZXh0cnVkZXJDb3VudCkge1xyXG4gICAgLy8gd2UgZXhwZWN0IGVhY2ggbGF5ZXIgdG8gaGF2ZSB0aGUgZm9sbG93aW5nIGZvcm1hdDpcclxuICAgIC8vICB7XHJcbiAgICAvLyAgICB0b3RhbE5yTW92ZXM6IG51bWJlciwgKGFsbCBtb3ZlcylcclxuICAgIC8vICAgIHRvdGFsTnJIZWFkTW92ZXM6IG51bWJlciwgKG1vdmVzIHRoYXQgYXJlIGp1c3QgaGVhZCBtb3ZlcylcclxuICAgIC8vICAgIHRvdGFsTGVuZ3RoOiBudW1iZXJcclxuICAgIC8vICAgIG1vdmVzTW9kZWw6IHsgdHlwZSwgW01vdmVdfVxyXG4gICAgLy8gICAgbW92ZXNTdXBwb3J0OiB7IHR5cGUsIFtNb3ZlXX1cclxuICAgIC8vICB9XHJcbiAgICAvL1xyXG4gICAgdGhpcy50b3RhbE1vdmVzID0gMDtcclxuICAgIHRoaXMudG90YWxUcmF2ZWxNb3ZlcyA9IDA7XHJcbiAgICB0aGlzLnRvdGFsTGVuZ3RoID0gMDtcclxuICAgIC8vIE5PVEU6IGF0IHNvbWUgcG9pbnQgd2UncmUgZ29pbmcgdG8gd2FudCB0byBicmVhayB0aGlzIGRvd24gaW4gYSBmaW5lciB3YXlcclxuICAgIC8vIHdoZXJlIHdlIGhhdmUgbGlzdHMgb2YgZm9yIGVhY2ggbW9kZWwgb24gdGhlIHBsYXRlLiB0aGF0IHdpbGwgcmVxdWlyZSBhXHJcbiAgICAvLyBjaGFuZ2UgdG8gaG93IHdlIGVuY29kZSBtb3ZlcyB0aG91Z2guXHJcbiAgICB0aGlzLm1vdmVzTW9kZWwgPSBbXTtcclxuICAgIHRoaXMubW92ZXNTdXBwb3J0ID0gW107XHJcblxyXG4gICAgLy8gdmFyaWFibGVzIHRoYXQgd2UnbGwgdXNlIHRvIGNvbXB1dGUgdGhlIGxheWVyIGRhdGFcclxuICAgIHRoaXMuaW5kZXggPSAwO1xyXG4gICAgdGhpcy5pc01vZGVsID0gdHJ1ZTtcclxuICAgIHRoaXMuaXNUcmF2ZWwgPSB0cnVlO1xyXG4gICAgdGhpcy5sYXN0TW92ZSA9IHt9O1xyXG4gICAgdGhpcy5wcmVDbWRUYWcgPSBudWxsO1xyXG4gICAgdGhpcy50b3RhbExheWVycyA9IDA7XHJcbiAgICB0aGlzLmxhc3RFeHRydWRlck1vdmVzID0geyBhOiAwLCBiOiAwIH07XHJcbiAgICB0aGlzLmN1cnJFeHRydWRlciA9IG51bGw7IC8vIEVYVFJVREVSX0EsIEVYVFJVREVSX0IsIG9yIG51bGxcclxuXHJcbiAgICAvLyBzdG9yZSB0aGUgbWV0YSBkYXRhIG9uIHRoZSBjdXJyZW50IGxheWVyXHJcbiAgICB0aGlzLmxvd2VyUG9zaXRpb24gPSAwO1xyXG4gICAgdGhpcy51cHBlclBvc2l0aW9uID0gMDtcclxuICAgIHRoaXMudGhpY2tuZXNzID0gMDtcclxuICAgIHRoaXMud2lkdGggPSAwO1xyXG5cclxuICAgIC8vIGdlbmVyYXRlIHggYW5kIHkgb2Zmc2V0cy4gaW4gZWFnbGUsICgwLCAwKSBpcyB0aGUgbG93ZXIgbGVmdCBjb3JuZXIgb2ZcclxuICAgIC8vIHRoZSBidWlsZHBsYXRlLiBpbiBtaXJhY2xlIGdydWUsIGl0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIGJ1aWxkIHBsYXRlLlxyXG4gICAgdGhpcy54T2Zmc2V0ID0gYnVpbGRWb2x1bWUueCAvIDI7XHJcbiAgICB0aGlzLnlPZmZzZXQgPSBidWlsZFZvbHVtZS55IC8gMjtcclxuICAgIHRoaXMudG90YWxSYWZ0TGF5ZXJzID0gdG90YWxSYWZ0TGF5ZXJzO1xyXG5cclxuICAgIHRoaXMuZXh0cnVkZXJDb3VudCA9IGV4dHJ1ZGVyQ291bnQ7XHJcbn07XHJcblxyXG5QYXJzZXJTdGF0ZS5wcm90b3R5cGUgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcjogUGFyc2VyU3RhdGUsXHJcblxyXG4gICAgLy8vIHBhcnNlIGEgY29tbWFuZHMgZnVuY3Rpb24gb3V0IGFuZCBwYXNzIGl0IHRvIHRoZSBhcHByb3ByaWF0ZSBwYXJzaW5nXHJcbiAgICAvLy8gbWV0aG9kLlxyXG4gICAgLy8vXHJcbiAgICAvLy8gQGNvbW1hbmQgLSB0aGUganNvbnRvb2xwYXRoIGNvbW1hbmQgdG8gcGFyc2UgYXMgYW4gT2JqZWN0XHJcbiAgICAvLy8gICAqIGZ1bmN0aW9uIDxzdHJpbmc+IC0gd2hhdCB0aGlzIGNvbW1tYW5kcyBwdXJwb3NlIGlzXHJcbiAgICBwYXJzZUNvbW1hbmQoY29tbWFuZCkge1xyXG4gICAgICAgIGlmIChjb21tYW5kLmZ1bmN0aW9uID09ICdtb3ZlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1vdmVDb21tYW5kKGNvbW1hbmQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZC5mdW5jdGlvbiA9PSAnY29tbWVudCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb21tZW50Q29tbWFuZChjb21tYW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vLyBwYXJzZSBhIGNvbW1lbnQgY29tbWFuZCwgZW1pdHRpbmcgYSBuZXcgbGF5ZXIsIGFuZCB1cGRhdGluZyBvdXIgbGF5ZXJcclxuICAgIC8vLyBtZXRhIGRhdGFcclxuICAgIC8vL1xyXG4gICAgLy8vIGZvciBlYWNoIGxheWVyLCB3ZSB3aWxsIGhhdmUgYSBjb21tZW50IGRlY2xhcmluZyBpdHMgY2h1bmsgbnVtYmVyLCB0aGVcclxuICAgIC8vLyB1cHBlciBib3VuZHMsIHRoZSBsb3dlciBib3VuZHMsIHRoZSB3aWR0aCwgYW5kIHRoZSB0aGlja25lc3MgZm9yIHRoYXRcclxuICAgIC8vLyBsYXllci4gdGhlcmUgaXMgYWxzbyBhIGNvbW1lbnQgZm9yIHRoZSBlbmQgb2YgYSBwcmludC5cclxuICAgIC8vL1xyXG4gICAgLy8vIEBjb21tYW5kIC0gdGhlIGpzb250b29scGF0aCBjb21tZW50IGNvbW1hbmQgdG8gcGFyc2UgYXMgYW4gT2JqZWN0XHJcbiAgICAvLy8gICAqIHBhcmFtZXRlcnMuY29tbWVudCA8c3RyaW5nPiAtIGEgY29tbWVudCBhZGRpbmcgaW5mbyBhYm91dCB0aGlzIGxheWVyXHJcbiAgICBwYXJzZUNvbW1lbnRDb21tYW5kKGNvbW1hbmQpIHtcclxuICAgICAgICBjb25zdCBjb21tZW50ID0gY29tbWFuZC5wYXJhbWV0ZXJzLmNvbW1lbnQ7XHJcbiAgICAgICAgLy8gcmVnZXggdXNlZCB0byBwdWxsIGEgZmxvYXQgb3V0IG9mIGEgc3RyaW5nXHJcbiAgICAgICAgY29uc3QgZmxvYXRSZWdleCA9IC9cXGQrWy5dP1xcZCovO1xyXG5cclxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhpcyBjb21tZW50IGlzIGZvciB0aGUgbG93ZXIgcG9zaXRpb25cclxuICAgICAgICBjb25zdCBsb3dlclBvc1JlZ2V4ID0gL2xvd2VyIHBvc2l0aW9uLipcXGQrWy5dP1xcZCovaTtcclxuICAgICAgICBjb25zdCBsb3dlclBvc2l0aW9uTWF0Y2ggPSBjb21tZW50Lm1hdGNoKGxvd2VyUG9zUmVnZXgpO1xyXG4gICAgICAgIGlmIChsb3dlclBvc2l0aW9uTWF0Y2gpIHtcclxuICAgICAgICAgICAgLy8gbm90ZSBvbiBzeW50YXg6IHRoZSArKDxzdHJpbmc+KSB3aWxsIGNhc3QgdGhlIG1hdGNoIGFzIGEgbnVtYmVyLlxyXG4gICAgICAgICAgICB0aGlzLmxvd2VyUG9zaXRpb24gPSArY29tbWVudC5tYXRjaChmbG9hdFJlZ2V4KVswXSAqIElOQ0hFU19QRVJfTU07XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGlzIGNvbW1lbnQgaXMgZm9yIHRoZSB1cHBlciBwb3NpdGlvblxyXG4gICAgICAgIGNvbnN0IHVwcGVyUG9zUmVnZXggPSAvdXBwZXIgcG9zaXRpb24uKlxcZCtbLl0/XFxkKi9pO1xyXG4gICAgICAgIGNvbnN0IHVwcGVyUG9zaXRpb25NYXRjaCA9IGNvbW1lbnQubWF0Y2godXBwZXJQb3NSZWdleCk7XHJcbiAgICAgICAgaWYgKHVwcGVyUG9zaXRpb25NYXRjaCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwcGVyUG9zaXRpb24gPSArY29tbWVudC5tYXRjaChmbG9hdFJlZ2V4KVswXSAqIElOQ0hFU19QRVJfTU07XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGlzIGNvbW1lbnQgaXMgZm9yIHRoZSB0aGlja25lc3NcclxuICAgICAgICBjb25zdCB0aGlja25lc3NSZWdleCA9IC90aGlja25lc3MuKlxcZCtbLl0/XFxkKi9pO1xyXG4gICAgICAgIGNvbnN0IHRoaWNrbmVzc01hdGNoID0gY29tbWVudC5tYXRjaCh0aGlja25lc3NSZWdleCk7XHJcbiAgICAgICAgaWYgKHRoaWNrbmVzc01hdGNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhpY2tuZXNzID0gK2NvbW1lbnQubWF0Y2goZmxvYXRSZWdleClbMF0gKiBJTkNIRVNfUEVSX01NO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhpcyBjb21tZW50IGlzIGZvciB0aGUgd2lkdGhcclxuICAgICAgICBjb25zdCB3aWR0aFJlZ2V4ID0gL3dpZHRoLipcXGQrWy5dP1xcZCovaTtcclxuICAgICAgICBjb25zdCB3aWR0aE1hdGNoID0gY29tbWVudC5tYXRjaCh3aWR0aFJlZ2V4KTtcclxuICAgICAgICBpZiAod2lkdGhNYXRjaCkge1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gK2NvbW1lbnQubWF0Y2goZmxvYXRSZWdleClbMF0gKiBJTkNIRVNfUEVSX01NO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhpcyBjb21tZW50IGlzIGZvciB0aGUgY2h1bmsgbnVtYmVyXHJcbiAgICAgICAgY29uc3QgY2h1bmtSZWdleCA9IC9jaHVuay4qXFxkL2k7XHJcbiAgICAgICAgY29uc3QgbGF5ZXJTZWN0aW9uUmVnZXggPSAvbGF5ZXIgc2VjdGlvbi4qXFxkLipbKF1cXGQqWyldL2k7XHJcbiAgICAgICAgaWYgKGNvbW1lbnQubWF0Y2goY2h1bmtSZWdleCkgfHwgY29tbWVudC5tYXRjaChsYXllclNlY3Rpb25SZWdleCkpIHtcclxuICAgICAgICAgICAgdGhpcy50b3RhbExheWVycysrO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFjaGVkRW5kT2ZMYXllcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxSZWdleCA9IC9tYXRlcmlhbC4qKFxcZCkvaTtcclxuICAgICAgICBjb25zdCBtYXRlcmlhbE1hdGNoID0gY29tbWVudC5tYXRjaChtYXRlcmlhbFJlZ2V4KTtcclxuICAgICAgICBpZiAobWF0ZXJpYWxNYXRjaCkge1xyXG4gICAgICAgICAgICBjb25zdCBleHRydWRlcklEID0gbWF0ZXJpYWxNYXRjaFsxXTtcclxuICAgICAgICAgICAgaWYgKGV4dHJ1ZGVySUQgPT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyRXh0cnVkZXIgPSBFWFRSVURFUl9BO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJ1ZGVySUQgPT09ICcxJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyRXh0cnVkZXIgPSBFWFRSVURFUl9CO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5rbm93biBleHRydWRlciBpZDonLCBleHRydWRlcklEKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhpcyBjb21tZW50IGlzIGZvciB0aGUgZW5kIG9mIHRoZSBwcmludFxyXG4gICAgICAgIGlmIChjb21tZW50ID09PSAnRW5kIG9mIHByaW50Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFjaGVkRW5kT2ZMYXllcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8vIHBhcnNlIGEgbW92ZSBjb21tYW5kIGFuZCB1cGRhdGUgb3VyIG1vdmVzLCB0cmF2ZWwgbW92ZXMsIGxlbmd0aCwgYW5kXHJcbiAgICAvLy8gbW92ZXMgYXJyYXlzIGFjY29yZGluZ2x5LlxyXG4gICAgLy8vXHJcbiAgICAvLy8gQGNvbW1hbmQgLSB0aGUganNvbnRvb2xwYXRoIGNvbW1hbmQgdG8gcGFyc2UgYXMgYW4gT2JqZWN0XHJcbiAgICAvLy8gICAqIHBhcmFtZXRlcnMgLSB4LCB5LCB6LCBhLCBiIGFuZCBmZWVkcmF0ZSBmb3IgdGhpcyBjb21tYW5kXHJcbiAgICAvLy8gICAqIHRhZ3MgLSBhcnJheSBvZiBzdHJpbmdzIHRhZ2dpbmcgdGhpcyBtb3ZlXHJcbiAgICBwYXJzZU1vdmVDb21tYW5kKGNvbW1hbmQpIHtcclxuICAgICAgICAvLyB1cGRhdGUgdGhlIG1vdmUgaW5kZXgsIGN1cnJlbnQgbW92ZSwgYW5kIGN1cnJlbnQgdGFnXHJcbiAgICAgICAgdGhpcy5pbmRleCsrO1xyXG4gICAgICAgIHRoaXMuY3VycmVudE1vdmUgPSB7XHJcbiAgICAgICAgICAgIHg6IChjb21tYW5kLnBhcmFtZXRlcnMueCArIHRoaXMueE9mZnNldCkgKiBJTkNIRVNfUEVSX01NLFxyXG4gICAgICAgICAgICB5OiAoY29tbWFuZC5wYXJhbWV0ZXJzLnkgKyB0aGlzLnlPZmZzZXQpICogSU5DSEVTX1BFUl9NTSxcclxuICAgICAgICAgICAgejogY29tbWFuZC5wYXJhbWV0ZXJzLnogKiBJTkNIRVNfUEVSX01NLFxyXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubG9hZEN1cnJlbnRUYWcoY29tbWFuZC50YWdzWzBdKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0b3RhbCBtb3ZlcyBhbmQgdG90YWwgdHJhdmVsIG1vdmVzXHJcbiAgICAgICAgaWYgKHRoaXMuaXNUcmF2ZWwpIHtcclxuICAgICAgICAgICAgdGhpcy50b3RhbFRyYXZlbE1vdmVzKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudG90YWxNb3ZlcysrO1xyXG5cclxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgZHVhbC1tYXRlcmlhbCBwcmludCwgdXNlIGV4dHJ1ZGVyIEEgdnMgZXh0cnVkZXIgQiBsb2dpY1xyXG4gICAgICAgIGlmICh0aGlzLmV4dHJ1ZGVyQ291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJFeHRydWRlciA9PT0gRVhUUlVERVJfQSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3Zlc01vZGVsLnB1c2godGhpcy5jdXJyZW50TW92ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVzU3VwcG9ydC5wdXNoKHRoaXMuY3VycmVudE1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBzaW5nbGUtbWF0ZXJpYWwgcHJpbnQsIHVzZSBtb2RlbCB2cyBzdXBwb3J0IGxvZ2ljXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3Zlc01vZGVsLnB1c2godGhpcy5jdXJyZW50TW92ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVzU3VwcG9ydC5wdXNoKHRoaXMuY3VycmVudE1vdmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwUHJldlJlc3RhcnRXaXRoU3VwcG9ydE1vdmVzKGNvbW1hbmQudGFnc1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBwcmV2aWV3IGNvbW1hbmQgdGFnIGZvciBwb3NzaWJsZSBjbGVhbnVwXHJcbiAgICAgICAgdGhpcy5wcmVDbWRUYWcgPSBjb21tYW5kLnRhZ3NbMF07XHJcbiAgICAgICAgLy8gc2V0IHRoZSBsYXN0IG1vdmUgdG8gdGhlIG9uZSB3ZSBqdXN0IHBhcnNlZFxyXG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB0aGlzLmN1cnJlbnRNb3ZlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1Z2ZpeC9QYXRjaCAoUEVOLTI4NzgpIC0tIFJheVxyXG4gICAgICpcclxuICAgICAqIFRoZSBhc3N1bXB0aW9uIHdpdGggdGhyZWVFbmdpbmVUb29scGF0aExvYWRlciBpcyB0aGF0IHRoZSBmaXJzdCBzdXBwb3J0TW92ZXMgd2lsbFxyXG4gICAgICogYWx3YXlzIGhhdmUgYW4gYXJlYSBvZiB6ZXJvLlxyXG4gICAgICpcclxuICAgICAqIFdpdGggdGhlIG1iIGpzb250cCwgaXQgc2FmZSB0byBhc3N1bWUgdGhhdCBldmVyeSBzdXBwb3J0IGlzbGFuZCBoYXMgYSBcInJlc3RhcnRcIlxyXG4gICAgICogYmVmb3JlIGl0IHN0YXJ0cyB0aGUgZXh0cnVzaW9uIG9mIHRoZSBzdXBwb3J0LiBUaGUgXCJyZXN0YXJ0XCIgbW92ZSBpbiBcInRoaXMubW92ZXNNb2RlbFwiXHJcbiAgICAgKiBoYXMgYW4gYXJlYSBvZiB6ZXJvLiBXZSdsbCBqdXN0IHBvcCB0aGlzIG1vdmUgb3V0IGFuZCBwcmVwZW5kIGl0IGludG8gXCJ0aGlzLm1vdmVzU3VwcG9ydFwiLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyQ21kVGFnXHJcbiAgICAgKi9cclxuICAgIGNsZWFudXBQcmV2UmVzdGFydFdpdGhTdXBwb3J0TW92ZXMoY3VyckNtZFRhZykge1xyXG4gICAgICAgIGlmICh0aGlzLnByZUNtZFRhZyA9PT0gJ1Jlc3RhcnQnICYmIGN1cnJDbWRUYWcgPT09ICdTdXBwb3J0JyAmJiB0aGlzLm1vdmVzTW9kZWwubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN0YXJ0TW92ZSA9IHRoaXMubW92ZXNNb2RlbC5wb3AoKTtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXhNb3ZlID0gdGhpcy5tb3Zlc1N1cHBvcnQuZmluZEluZGV4KG12ID0+IGlzRXF1YWwobXYsIHRoaXMuY3VycmVudE1vdmUpKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4TW92ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3Zlc1N1cHBvcnQudW5zaGlmdChyZXN0YXJ0TW92ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVzU3VwcG9ydC5zcGxpY2UoaW5kZXhNb3ZlIC0gMSwgMCwgcmVzdGFydE1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLy8gdXBkYXRlIHRoaXMuaXNUcmF2ZWxNb3ZlIGFuZCB0aGlzLmlzTW9kZWwgYmFzZWQgb24gQHRhZ3tzdHJpbmd9LCBhIHRhZ1xyXG4gICAgLy8vIGZyb20gbWlyYWNsZV9ncnVlLlxyXG4gICAgbG9hZEN1cnJlbnRUYWcodGFnKSB7XHJcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcclxuICAgICAgICAgICAgY2FzZSAnVHJhaWxpbmcgRXh0cnVzaW9uIE1vdmUnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1RyYXZlbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0FuY2hvcic6XHJcbiAgICAgICAgICAgIGNhc2UgJ0JyaWRnZSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0luZmlsbCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0luc2V0JzpcclxuICAgICAgICAgICAgY2FzZSAnT3V0bGluZSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1NwdXInOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1RyYXZlbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc01vZGVsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdTdXBwb3J0JzpcclxuICAgICAgICAgICAgY2FzZSAnUHVyZ2UnOlxyXG4gICAgICAgICAgICBjYXNlICdJbnZhbGlkIE1vdmUnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1RyYXZlbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc01vZGVsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnQmFja2xhc2ggQ29tcGVuc2F0aW9uJzpcclxuICAgICAgICAgICAgY2FzZSAnQ29ubmVjdGlvbic6XHJcbiAgICAgICAgICAgIGNhc2UgJ0xvbmcgUmVzdGFydCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0xvbmcgUmV0cmFjdCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1Jlc3RhcnQnOlxyXG4gICAgICAgICAgICBjYXNlICdSZXRyYWN0JzpcclxuICAgICAgICAgICAgY2FzZSAnTGVha3kgVHJhdmVsIE1vdmUnOlxyXG4gICAgICAgICAgICBjYXNlICdUcmF2ZWwgTW92ZSc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzVHJhdmVsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9nZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgdGFnIG5vdCBmb3VuZDogJHt0YWd9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhbGwgcmFmdCBsYXllcnMgYXJlIHRhZ2dlZCBhcyBzdXBwb3J0XHJcbiAgICAgICAgaWYgKHRoaXMudG90YWxMYXllcnMgPD0gdGhpcy50b3RhbFJhZnRMYXllcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5pc01vZGVsID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1c2UgdGhlIHdpZHRoIGFuZCB0aGlja25lc3Mgb2YgdGhpcyBsYXllciB0byBjcmVhdGUgdGhlIGFyZWEuXHJcbiAgICAgICAgLy8gVE9ETyh6YXApIC0gZWRpdCB0aGUgZHJhd2luZyBvZiBleHRydXNpb25zIHRvIGJldHRlciByZWZsZWN0IHdpZHRoXHJcbiAgICAgICAgLy8gYW5kIHRoaWNrbmVzcyBpbnN0ZWFkIG9mIGp1c3QgYXJlYS5cclxuICAgICAgICB0aGlzLmN1cnJlbnRNb3ZlLmFyZWEgPSB0aGlzLmlzVHJhdmVsID8gMCA6IHRoaXMud2lkdGggKiB0aGlzLnRoaWNrbmVzcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8vIHVwZGF0ZSB0aGUgZGVmZXJyZWQgcHJvbWlzZSB3aXRoIHRoZSBkYXRhIG9uIHRoZSBmaW5pc2hlZCBsYXllciBhbmRcclxuICAgIC8vLyByZWluaXRpYWxpemUgbGF5ZXIgZGF0YS5cclxuICAgIHJlYWNoZWRFbmRPZkxheWVyKCkge1xyXG4gICAgICAgIGxldCBsYXllcjtcclxuICAgICAgICBjb25zdCBleHRydWRlciA9IHRoaXMuY3VyckV4dHJ1ZGVyIHx8IEVYVFJVREVSX0E7XHJcbiAgICAgICAgLy8gY2hlY2sgdGhhdCB3ZSBoYXZlIGFjdHVhbCBtb3ZlcyBpbiB0aGlzIGxheWVyXHJcbiAgICAgICAgaWYgKHRoaXMudG90YWxNb3ZlcyAtIHRoaXMudG90YWxUcmF2ZWxNb3ZlcyAhPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgbGF5ZXIgb2JqZWN0XHJcbiAgICAgICAgICAgIGxheWVyID0ge1xyXG4gICAgICAgICAgICAgICAgdG90YWxOck1vdmVzOiB0aGlzLnRvdGFsTW92ZXMsXHJcbiAgICAgICAgICAgICAgICB0b3RhbE5ySGVhZE1vdmVzOiB0aGlzLnRvdGFsVHJhdmVsTW92ZXMsXHJcbiAgICAgICAgICAgICAgICBtb3Zlc01hdGVyaWFsOiB7IFtleHRydWRlcl06IHRoaXMubW92ZXNNb2RlbCB9LFxyXG4gICAgICAgICAgICAgICAgbW92ZXNTdXBwb3J0OiB7IFtTVVBQT1JUW2V4dHJ1ZGVyXV06IHRoaXMubW92ZXNTdXBwb3J0IH0sXHJcbiAgICAgICAgICAgICAgICB1cHBlclBvc2l0aW9uOiB0aGlzLnVwcGVyUG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICBsb3dlclBvc2l0aW9uOiB0aGlzLmxvd2VyUG9zaXRpb24sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXNldCBvdXIgc3RhdGVcclxuICAgICAgICB0aGlzLnRvdGFsTW92ZXMgPSAwO1xyXG4gICAgICAgIHRoaXMudG90YWxUcmF2ZWxNb3ZlcyA9IDA7XHJcbiAgICAgICAgdGhpcy50b3RhbExlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5tb3Zlc01vZGVsID0gW107XHJcbiAgICAgICAgdGhpcy5tb3Zlc1N1cHBvcnQgPSBbXTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLmlzTW9kZWwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaXNUcmF2ZWwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxheWVyO1xyXG4gICAgfSxcclxufTtcclxuXHJcbmNsYXNzIE1CVG9vbHBhdGhQYXJzZXIgZXh0ZW5kcyBUb29scGF0aFBhcnNlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihsb2dnaW5nU2VydmljZSwgbWlyYWNsZUNvbmZpZywgYnVpbGRWb2x1bWUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2luZ1NlcnZpY2U7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogIHtcclxuICAgICAgICAgKiAgICBoZWFkZXI6IHsgc2xpY2VIZWlnaHQ6IG51bWJlciB9LFxyXG4gICAgICAgICAqICAgIGxheWVyczogWyB7XHJcbiAgICAgICAgICogICAgICB0b3RhbE5yTW92ZXM6IG51bWJlciwgKGFsbCBtb3ZlcylcclxuICAgICAgICAgKiAgICAgIHRvdGFsTnJIZWFkTW92ZXM6IG51bWJlciwgKG1vdmVzIHRoYXQgYXJlIGp1c3QgaGVhZCBtb3ZlcylcclxuICAgICAgICAgKiAgICAgIHRvdGFsTGVuZ3RoOiBudW1iZXIsXHJcbiAgICAgICAgICogICAgICBtb3Zlc01vZGVsOiB7IHR5cGUsIFtNb3ZlXX1cclxuICAgICAgICAgKiAgICAgIG1vdmVzU3VwcG9ydDogeyB0eXBlLCBbTW92ZV19XHJcbiAgICAgICAgICogICAgfV1cclxuICAgICAgICAgKiAgfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFyc2VkRGF0YSA9IHsgaGVhZGVyOiB7IHNsaWNlSGVpZ2h0OiBudWxsIH0sIGxheWVyczogW10gfTtcclxuICAgICAgICB0aGlzLnBhcmFtc1Byb3ZpZGVyID0gbmV3IFBhcmFtc1Byb3ZpZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIEByZXR1cm4gdGhlIGV4dGVudGlvbiBmb3IgbWIgc2xpY2UgZmlsZXNcclxuICAgIGdldEV4dCgpIHtcclxuICAgICAgICByZXR1cm4gJy5tYWtlcmJvdCc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RXh0ZW5zaW9ucygpIHtcclxuICAgICAgICByZXR1cm4gWycubWFrZXJib3QnXTtcclxuICAgIH1cclxuXHJcbiAgICB1bnppcFRvb2xwYXRoKHJlYWQsIGZpbGVQYXRoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XHJcblxyXG4gICAgICAgIHJldHVybiByZWFkKGZpbGVQYXRoKVxyXG4gICAgICAgICAgICAudGhlbih6aXBwZWRGaWxlRGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNaaXAubG9hZEFzeW5jKHppcHBlZEZpbGVEYXRhKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oemlwcGVkRmlsZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQudHBTdHJlYW0gPSB6aXBwZWRGaWxlLmZpbGVzWydwcmludC5qc29udG9vbHBhdGgnXVxyXG4gICAgICAgICAgICAgICAgICAgID8gemlwcGVkRmlsZS5maWxlKCdwcmludC5qc29udG9vbHBhdGgnKS5ub2RlU3RyZWFtKClcclxuICAgICAgICAgICAgICAgICAgICA6IHppcHBlZEZpbGUuZmlsZSgncHJpbnQuZ2NvZGUnKS5ub2RlU3RyZWFtKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gemlwcGVkRmlsZS5maWxlKCdtZXRhLmpzb24nKS5hc3luYygnc3RyaW5nJyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKG1ldGFEYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5tZXRhRGF0YSA9IEpTT04ucGFyc2UobWV0YURhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIEBtZXRhZGF0YSAtIHRoZSBkYXRhIGZyb20gYSBtZXRhLmpzb24gZmlsZSBhcyBhIEpTT04gb2JqZWN0XHJcbiAgICBsb2FkVG9vbHBhdGgobWV0YURhdGEsIHRwU3RyZWFtLCBtZXNzYWdpbmcpIHtcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgLy8gcmVzZXQgcGFyc2VkIGRhdGEgb3B0aW9uXHJcbiAgICAgICAgc2VsZi5wYXJzZWREYXRhID0geyBoZWFkZXI6IHsgc2xpY2VIZWlnaHQ6IG51bGwgfSwgbGF5ZXJzOiBbXSB9O1xyXG5cclxuICAgICAgICAvLy8gZXh0cmFjdCBoZWlnaHRzLCBhbmQgaW5pdGlhbGl6ZSBwYXJzZXIgc3RhdGVcclxuICAgICAgICBzZWxmLnBhcnNlZERhdGEuaGVhZGVyLnNsaWNlSGVpZ2h0ID0gbWV0YURhdGEubWlyYWNsZV9jb25maWcuZ2FnZ2xlcy5kZWZhdWx0LmxheWVySGVpZ2h0ICogSU5DSEVTX1BFUl9NTTtcclxuXHJcbiAgICAgICAgLy8vIEBtaXJhY2xlQ29uZmlnIC0gdGhlIGNvbmZpZyBPYmplY3RcclxuICAgICAgICAvLy8gICAqIHJhZnRCYXNlTGF5ZXJzXHJcbiAgICAgICAgLy8vICAgKiByYWZ0SW50ZXJmYWNlTGF5ZXJzXHJcbiAgICAgICAgLy8vICAgKiByYWZ0U3VyZmFjZUxheWVyc1xyXG4gICAgICAgIC8vLyBAcmV0dXJuIHJhZnQgdGhpY2tuZXNzIGluIG51bWJlciBvZiBsYXllcnNcclxuICAgICAgICBjb25zdCBjYWxjdWxhdGVSYWZ0TGF5ZXJzID0gZnVuY3Rpb24obWlyYWNsZUNvbmZpZykge1xyXG4gICAgICAgICAgICAvLyByYWZ0cyBhcmUgdHVybmVkIG9mZiwgdGhlIGhlaWdodCBpcyAwXHJcbiAgICAgICAgICAgIGlmICghbWlyYWNsZUNvbmZpZy5kb1JhZnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBzdGFydCBhdCB6ZXJvIGFuZCBhZGQgdXAgdGhlIGhlaWdodCBvZiB0aGUgcmFmdCBnaXZlbiB0aGVcclxuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGxheWVycyBhbmQgdGhlaXIgdGhpY2tuZXNzZXNcclxuICAgICAgICAgICAgY29uc3QgeyBudW1iZXJPZkxheWVyczogcmFmdEJhc2VMYXllcnMgfSA9IG1pcmFjbGVDb25maWcucmFmdFByb2ZpbGVzLmJhc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbnVtYmVyT2ZMYXllcnM6IHJhZnRJbnRlcmZhY2VMYXllcnMgfSA9IG1pcmFjbGVDb25maWcucmFmdFByb2ZpbGVzLmludGVyZmFjZTtcclxuICAgICAgICAgICAgY29uc3QgeyBudW1iZXJPZkxheWVyczogcmFmdFN1cmZhY2VMYXllcnMgfSA9IG1pcmFjbGVDb25maWcucmFmdFByb2ZpbGVzLnN1cmZhY2U7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmFmdEJhc2VMYXllcnMgKyByYWZ0SW50ZXJmYWNlTGF5ZXJzICsgcmFmdFN1cmZhY2VMYXllcnM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZSBtZXRhLmpzb24gaGFzIHR3byBleHRydWRlciBkaXN0YW5jZXMsXHJcbiAgICAgICAgLy8gYnV0IHRoZSBzZWNvbmQgb25lIGlzIDAuMC4gVGhpcyBhY2NvdW50cyBmb3IgdGhhdC5cclxuICAgICAgICBjb25zdCBleHRydWRlckNvdW50ID1cclxuICAgICAgICAgICAgbWV0YURhdGEuZXh0cnVzaW9uX2Rpc3RhbmNlc19tbS5sZW5ndGggPCAyIHx8IG1ldGFEYXRhLmV4dHJ1c2lvbl9kaXN0YW5jZXNfbW1bMV0gPD0gMFxyXG4gICAgICAgICAgICAgICAgPyAxXHJcbiAgICAgICAgICAgICAgICA6IG1ldGFEYXRhLmV4dHJ1c2lvbl9kaXN0YW5jZXNfbW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICBjb25zdCBidWlsZFZvbHVtZVBhcmFtcyA9IHNlbGYucGFyYW1zUHJvdmlkZXIuZ2V0UGFyYW1zQnlCb3RUeXBlKG1ldGFEYXRhLmJvdF90eXBlKS5idWlsZFZvbHVtZS5lbnZlbG9wZVNpemU7XHJcbiAgICAgICAgY29uc3QgZ2V0QnVpbGRWb2x1bWVJbk1NID0gZnVuY3Rpb24oYnVpbGRWb2x1bWVJbk1ldGVycykge1xyXG4gICAgICAgICAgICBjb25zdCBidWlsZFZvbHVtZSA9IHt9O1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhidWlsZFZvbHVtZUluTWV0ZXJzKS5mb3JFYWNoKGF4aXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRWb2x1bWVbYXhpc10gPSBidWlsZFZvbHVtZVBhcmFtc1theGlzXSAqIDEwMDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRWb2x1bWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNTa2V0Y2hQcmludGVyID0gbWV0YURhdGEuYm90X3R5cGUgPT09IEJvdFR5cGVFbnVtLnNrZXRjaDtcclxuXHJcbiAgICAgICAgY29uc3QgcGFyc2luZ1BhcmFtcyA9IHtcclxuICAgICAgICAgICAgdG90YWxSYWZ0TGF5ZXJzOiBjYWxjdWxhdGVSYWZ0TGF5ZXJzKG1ldGFEYXRhLm1pcmFjbGVfY29uZmlnLmdhZ2dsZXMuZGVmYXVsdCksXHJcbiAgICAgICAgICAgIGJ1aWxkVm9sdW1lOiBnZXRCdWlsZFZvbHVtZUluTU0oYnVpbGRWb2x1bWVQYXJhbXMpLFxyXG4gICAgICAgICAgICBleHRydWRlckNvdW50LFxyXG4gICAgICAgICAgICBpc1NrZXRjaFByaW50ZXIsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8vIFBhcnNlIGEgQHRvb2xwYXRoTm9kZVN0cmVhbS4gd2hlbiBmaW5pc2hlZCwgcmVzb2x2ZSB0aGUgQGRlZmVycmVkIHByb21pc2VcclxuICAgICAgICAvLy8gd2l0aCB0aGUgcGFyc2VkIGFuZCBmb3JtYXR0ZWQgZGF0YS5cclxuICAgICAgICBjb25zdCBwYXJzZVRvb2xwYXRoID0gZnVuY3Rpb24odG9vbHBhdGhOb2RlU3RyZWFtLCBwYXJzaW5nUGFyYW1zKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2luZy5kaXNwbGF5KCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBkZWZlcmVkID0gbmV3IHEuZGVmZXIoKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlclN0YXRlID0gbmV3IFBhcnNlclN0YXRlKFxyXG4gICAgICAgICAgICAgICAgcGFyc2luZ1BhcmFtcy5idWlsZFZvbHVtZSxcclxuICAgICAgICAgICAgICAgIHBhcnNpbmdQYXJhbXMudG90YWxSYWZ0TGF5ZXJzLFxyXG4gICAgICAgICAgICAgICAgcGFyc2luZ1BhcmFtcy5leHRydWRlckNvdW50XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwYXJzZUNvbW1hbmQgPSBmdW5jdGlvbihjb21tYW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyU3RhdGUucGFyc2VDb21tYW5kKGNvbW1hbmQpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKCFwYXJzaW5nUGFyYW1zLmlzU2tldGNoUHJpbnRlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gcGlwZSBzdHJlYW0gdG8gYSBqc29uc3RyZWFtIHBhcnNlciB0aGF0IHBhcnNlcyBvdXQgZWFjaCBjb21tYW5kLlxyXG4gICAgICAgICAgICAgICAgLy8gcGlwZSBwYXJzZWQgb3V0IGpzb24gYmxvYnMgdG8gdGhlIHBhcnNlQ29tbWFuZCBmdW5jdGlvbiBhYm92ZS5cclxuICAgICAgICAgICAgICAgIHRvb2xwYXRoTm9kZVN0cmVhbVxyXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKEpTT05TdHJlYW0ucGFyc2UoJyouKicpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKGVzLm1hcFN5bmMocGFyc2VDb21tYW5kKSlcclxuICAgICAgICAgICAgICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbihsYXllcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcnNlZERhdGEubGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2luZy5kaXNtaXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyZWQucmVzb2x2ZShzZWxmLnBhcnNlZERhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRm9yIFNrZXRjaCBwcmludGVycywgdGhlIHRvb2xwYXRoTm9kZVN0cmVhbSBpcyBhIGdjb2RlXHJcbiAgICAgICAgICAgICAgICAvLyByZWFkYWJsZSBmaWxlIG5vZGVqcyBzdHJlYW0uXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBcInVuemlwVG9vbHBhdGhcIiBmb3IgbW9yZSBpbmZvXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZXJTdHJlYW0gPSBHY29kZVBhcnNlclN0cmVhbSh0b29scGF0aE5vZGVTdHJlYW0sIHBhcnNpbmdQYXJhbXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHBhcnNlclN0cmVhbVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignZGF0YScsIGNodW5rID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJzZWREYXRhLmxheWVycy5wdXNoKGNodW5rKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdpbmcuZGlzbWlzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcmVkLnJlc29sdmUoc2VsZi5wYXJzZWREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBwcm9taXNlIGZyb20gdGhlIHBhcnNlciBzdGF0ZS5cclxuICAgICAgICAgICAgcmV0dXJuIGRlZmVyZWQucHJvbWlzZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gcGFyc2VUb29scGF0aCh0cFN0cmVhbSwgcGFyc2luZ1BhcmFtcykuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1CVG9vbHBhdGhQYXJzZXI7XHJcbiJdfQ==
