'use strict';

const Immutable = require('immutable');

const q = require('q');

const EventEmitter = require('eventemitter3');

const _ = require('lodash');

const request = require('request');

const croissant = require('./croissant');

const ArchetypePrinter = require('./archetype_printer');

const MakerBotPrinter = require('./makerbot-printer');

const SketchPrinter = require('./sketchPrinter');

const Errors = require('./errors');

const PrinterStateEnum = require('./constants').PrinterStateEnum;

const PrinterConnTypeEnum = require('./constants').PrinterConnTypeEnum;

const BotTypeEnum = require('./constants').BotTypeEnum;

const PRINTER_AUTH_TIMEOUT = require('./constants').PRINTER_AUTH_TIMEOUT;

const ConnectionManager = require('./printerConnectionManager');

const util = require('./util');

const {
  parseConnType,
  compareConnType
} = require('./utils/printerConnectionUtil'); // TODO: Move this out to default-config to support staging URL in the future


const reflectorUrl = 'https://reflector.makerbot.com';
/*
Events:
    add_printer: request that a printer be added to My Printers
    remove_printer: request that a printer be removed from My Printers
    update_printer_list: request that the printer list in printer store be updated
*/

class PrinterManager extends EventEmitter {
  constructor(parameterService, loggingService, tvApiClient, trackingService, userInfo, token, storedPrintersManager) {
    super();
    this._parameterService = parameterService;
    this._logger = loggingService;
    this._tvApiClient = tvApiClient;
    this._trackingService = trackingService;
    this._storedPrintersManager = storedPrintersManager;
    this._printerCache = new Immutable.Map();
    this._connectionManagers = new Map();
    this._finder = null;
    this._findingPromise = null;
    this._startFinderTimeout = null;
    this._stopFinderTimeout = null;
    this._pollingReflectorId = null;
    this._userInfo = userInfo;
    this._userToken = token;
    this._currentPrinters = [];
    this._authPromises = new Map();
    this.reconnectPrinters = this.reconnectPrinters.bind(this);
    this._pollReflectorForSketchPrinters = this._pollReflectorForSketchPrinters.bind(this);
    this._reconnectMakerBotPrinter = this._reconnectMakerBotPrinter.bind(this);
    this._reconnectSketchPrinter = this._reconnectSketchPrinter.bind(this);
    this.sketchPrinterList = [];
  }

  init() {
    const self = this; // load up printers from stored

    let loadPrintersPromise;

    if (this._userToken) {
      loadPrintersPromise = this._userPrintersFromStored(this._userToken);
    } else {
      loadPrintersPromise = this._loadAnonymousPrinters();
    }

    return loadPrintersPromise.then(function () {
      return self._loadArchetypePrinters(self._userToken);
    }).then(function () {
      for (const printer of self.getPrinters()) self.emit('add_printer', printer); // force update of printer store


      self.emit('update_printer_list');
    });
  }

  _loadArchetypePrinters(token) {
    const archetypePrinterPromises = [];

    const archetypeIds = this._storedPrintersManager.getArchetypePrinters(this._userToken);

    for (const id of archetypeIds) {
      const info = this._storedPrintersManager.getPrinter(id);

      archetypePrinterPromises.push(this._createArchetypePrinter(info.vendor, info.gender));
    }

    return q.allSettled(archetypePrinterPromises);
  }

  stop() {
    for (const promise of this._authPromises.values()) {
      promise.cancel();
    }

    for (const uid of this._currentPrinters) {
      const printer = this._printerCache.get(uid);

      if (printer) printer.disconnect();
    } // disable the continuation that schedules find to start up again...


    if (this._findingPromise) this._findingPromise.cancelFindingContinuation();

    if (this._startFinderTimeout) {
      // if startFnderTimeout is set, finder has already stopped, and the
      // stop promise resolved
      clearTimeout(this._startFinderTimeout);
      return q();
    } else if (this._stopFinderTimeout) {
      // if stopFinderTimeout is set, we are waiting to stop the detector
      // clear the timeout and stop immediately
      const self = this;
      clearTimeout(this._stopFinderTimeout);
      return this._finder.stopFindingPrinters().then(function () {
        return self._findingPromise;
      });
    } else {
      // if neither are set, stop has been called; return the promise waiting
      // for stop to finish
      return this._findingPromise;
    }
  }

  _getUserPrintersFromWeb() {
    // these promises return maps of uid -> printerInfo
    const printerInfosPromise = q(this._tvApiClient.getUserPrintersFromReflector(this._userToken).then(userPrinterListRes => {
      const userPrinters = userPrinterListRes.printers;
      const supportedReflectorBots = {};
      Object.keys(userPrinters).map(printerId => {
        // filter out no-longer-supported bots
        const botType = userPrinters[printerId].status.bot_type;

        if (BotTypeEnum.hasOwnProperty(botType)) {
          supportedReflectorBots[printerId] = userPrinters[printerId];
        }
      });
      return this._getReflectorPrinterInfos(supportedReflectorBots);
    }, err => {
      // failed to fetch from reflector, but that's okay...
      this._logger.warn('Failed to fetch printer list from reflector for user: ', err);

      throw err;
    })); // treat the list gotten from tvApiClient as the absolute truth
    // of printers associated with the account; if printers are in
    // this list but not in the stored, add them; if printers are not
    // in this list but are in stored, clean them out

    return printerInfosPromise.then(results => {
      // if we failed to fetch printers from reflector,
      // don't bother cleaning; we don't want to mistakenly deauthenticate
      // all the user's printers....
      if (!results) return; // clean

      const storedUserPrinters = this._storedPrintersManager.getUserPrinters(this._userToken);

      for (const uid of storedUserPrinters) {
        /**
         * If storedUserPrinters contain a printer (uid) not present in
         * tvApiClient's list, remove it.
         *
         * If tvApiClient has a printer (uid) not present in
         * storedUserPrinters list, then it will be added to the stored
         * list via createPrinter flow.
         *
         * However, if a printer (uid) is found in both tvApiClient and
         * in storedUserPrinters lists, use storedUserPrinters info.
         * This will avoid automatically setting the printer to
         * reflector.
         *
         * -- Ray
         **/
        if (!Object.keys(results).includes(uid)) {
          this._storedPrintersManager.removePrinterForUser(uid, this._userToken);

          this.emit('remove_printer', this._printerCache.get(uid));
        } else {
          // TODO - Try LAN before attempting reflector on app-load
          // but only when we're capable of falling back to reflector
          // with LAN connections...
          const cachedPrinter = this._storedPrintersManager.getPrinter(uid);

          results[uid] = this._printerInfoFromSavedInfo({
            printer_info: cachedPrinter.printer_info
          });
        }
      }

      return this._offlinePrintersFromPrinterInfosList(results);
    });
  }

  start(clientSecret) {
    // if there is a logged-in user, try loading their printer list from web
    let loadPrintersPromise = q();
    if (this._userToken) loadPrintersPromise = this._getUserPrintersFromWeb();
    return loadPrintersPromise.then(() => {
      return this._loadArchetypePrinters();
    }).then(() => {
      // ensure that all our printers make it onto the My Printers list...
      for (const uid of this._currentPrinters) {
        this.emit('add_printer', this._printerCache.get(uid));
      }
    }).finally(() => {
      // Find Croissant printers
      // start detection regardless of success/failure of printer loading
      // there's some weirdness with making a new finder before the last one
      // has been stopped, so make it here, where the previous should
      // definitely have been stopped...
      this._finder = new croissant.PrinterFinder();

      this._finder.setClientSecret(clientSecret);

      if (this._userInfo && this._userToken) {
        this._finder.setThingiverseInfo(this._userInfo.name, this._userToken);
      } else {
        // The new auth flow _always_ requires a username
        // TODO: Get the local username when not logged in
        const username = this._userInfo ? this._userInfo.name : 'ANON';

        this._finder.setUsernameOnly(username);
      }

      this._findPrinters(); // Poll Reflector for Sketch Printers every 5 seconds


      this._pollReflectorForSketchPrinters(5);
    });
  }
  /**
   * Polls Reflector via GET-REQUEST for Sketch Printers
   * @param {int} timeInterval - Delay in seconds between each GET-request
   */


  _pollReflectorForSketchPrinters(timeInterval) {
    if (!this._pollingReflectorId) {
      const options = {
        headers: {
          'Authorization': `Bearer ${this._userToken}`,
          'Content-Type': 'application/json'
        },
        url: `${reflectorUrl}/printers`
      };

      this._logger.info(`Polling Reflector-GET for Sketch Printers`);

      this._pollingReflectorId = setInterval(() => {
        request(options, (err, res, body) => {
          if (err || ![200, 201].includes(res.statusCode)) {
            this._logger.warn(`REQUEST Error. Unable to fetch printer list. ${err}`);
          } else {
            const {
              printers
            } = JSON.parse(body);
            const sketchPrinterIds = Object.keys(printers).filter(id => id.match(/^(28571627)/g));
            const sketchUids = sketchPrinterIds.map(id => this._uidFromBotTypeAndIserial(BotTypeEnum.sketch, id));
            this.sketchPrinterList = sketchUids;
            sketchPrinterIds.forEach(printerId => {
              const tvPrinterInfo = printers[printerId];
              /*
               * reflector may send back a response with an ID but no status until fully
               * declaring the bot offline (for ~5 mins). if that happens we don't want to add this
               * entry to the printer list
               */

              if (_.isEmpty(tvPrinterInfo.status)) return q(null);

              const printerInfo = this._formatReflectorPrinterInfo(tvPrinterInfo);

              if (!this._printerCache.get(`2857:1627:${printerId}`)) {
                this._logger.info(`New Sketch Printer detected [${printerId}]. Adding printer.`);

                this._createPrinter(printerInfo).then(printer => {
                  // emit change to update printers list
                  this.emit('add_printer', printer);
                  this.emit('update_printer_list');
                }).catch(err => this._logger.log(err));
              } else {
                if (process.env.NODE_ENV && process.env.NODE_ENV !== 'production') {
                  console.log(`Existing Sketch Printer detected:`, printerId);
                } // otherwise check the cache & bring it back online


                q(this._printerCache.get(`2857:1627:${printerId}`)).then(printer => {
                  printer.updateFromPrinterInfo(printerInfo);
                });
              }
            });
          }
        });
      }, timeInterval * 1000);
    }
  }

  _loadAnonymousPrinters() {
    const anonPrinterUids = this._storedPrintersManager.getAnonymousPrinters();

    return this._offlinePrintersFromUidList(anonPrinterUids);
  }

  _offlinePrintersFromUidList(uids) {
    const printerPromises = [];

    const handleErr = err => {
      this._logger.warn(err);
    };

    for (const uid of uids) {
      const savedInfo = this._storedPrintersManager.getPrinter(uid);

      const printerInfo = this._printerInfoFromSavedInfo(savedInfo);

      printerPromises.push(this._createOfflinePrinter(printerInfo, savedInfo.machineConfig).catch(handleErr));
    }

    return q.allSettled(printerPromises);
  }

  _offlinePrintersFromPrinterInfosList(printerInfos) {
    const printerPromises = [];

    const handleErr = err => {
      this._logger.warn(err);
    };

    Object.keys(printerInfos).map(printerId => {
      const savedInfo = this._storedPrintersManager.getPrinter(printerId) || {};
      printerPromises.push(this._createOfflinePrinter(printerInfos[printerId], savedInfo.machineConfig).catch(handleErr));
    });
    return q.allSettled(printerPromises);
  }

  _getReflectorPrinterInfos(userPrinters) {
    const printerInfos = {};
    const printerIds = Object.keys(userPrinters);
    printerIds.map(id => {
      // _formatReflectorPrinterInfo assumes that the printer will be of new enough
      // firmware to have a status.bot_type; we will ignore printers that
      // do not have it
      try {
        const printerInfo = this._formatReflectorPrinterInfo(userPrinters[id]);

        printerInfos[printerInfo.uid] = printerInfo;
      } catch (err) {
        this._logger.warn(`Failed to add user printer ${printersList[id].name}: ${err}`);
      }
    });
    return printerInfos;
  }

  _userPrintersFromStored(token) {
    const storedUserPrinters = this._storedPrintersManager.getUserPrinters(token);

    return this._offlinePrintersFromUidList(storedUserPrinters);
  }

  _uidFromBotTypeAndIserial(bot_type, iserial) {
    let vid;
    let pid;

    if (bot_type === BotTypeEnum.sketch) {
      vid = '2857';
      pid = '1627';
    } else {
      vid = '23c1';
      pid = `0000${bot_type.split('_')[1]}`.slice(-4);
    }

    return [vid, pid, iserial].join(':');
  }

  _formatReflectorPrinterInfo(tvPrinterInfo) {
    const printerInfo = new croissant.PrinterInfo();
    printerInfo.name = tvPrinterInfo.name;
    printerInfo.address = tvPrinterInfo.status.ip;
    printerInfo.uid = this._uidFromBotTypeAndIserial(tvPrinterInfo.status.bot_type, tvPrinterInfo.printer_id);
    printerInfo.info = tvPrinterInfo.status;
    printerInfo.connType = parseConnType(tvPrinterInfo);
    return printerInfo;
  }

  _printerInfoFromSavedInfo(savedInfo) {
    const printerInfo = new croissant.PrinterInfo();
    printerInfo.name = savedInfo.printer_info.name;
    printerInfo.address = savedInfo.printer_info.address;
    printerInfo.uid = savedInfo.printer_info.uid;
    printerInfo.info = savedInfo.printer_info.info;
    printerInfo.connType = parseConnType(savedInfo.printer_info);
    return printerInfo;
  }

  _createOfflinePrinter(printerInfo, machineConfig) {
    const printer = this._printerCache.get(printerInfo.uid);

    if (printer) {
      // assume the info we're receiving here is the latest for this printer;
      // if this printer object has already been made, update its info in
      // MBPrinter and stored info
      printer.updateFromPrinterInfo(printerInfo);
      return this._storedPrintersManager.updateStoredInfo(printerInfo).then(() => {
        return printer;
      });
    }

    return this._createPrinter(printerInfo, machineConfig).then(printer => {
      printer.setState(PrinterStateEnum.Reconnecting);

      this._currentPrinters.push(printer.getId());

      return printer;
    });
  }

  getPrinter(uid) {
    return this._printerCache.get(uid);
  }

  getPrinters() {
    return this._printerCache.toArray();
  }

  _findPrinters() {
    // start finding printers; this will stop the finder after 3 secs, and
    // then start it 3 secs after _findingPromise resolves
    const self = this;

    if (!self._findingPromise || !self._findingPromise.isPending()) {
      self._stopFinderTimeout = setTimeout(function () {
        self._stopFinderTimeout = null;
        q(self._finder.stopFindingPrinters()).done();
      }, 3000);
      self._findingPromise = q(self._finder.findPrinters(function (printerInfo) {
        let printerPromise; // first detection

        if (!self._printerCache.get(printerInfo.uid)) {
          printerPromise = self._createPrinter(printerInfo).catch(function (err) {
            self._logger.log(err);
          });
        } else {
          printerPromise = q(self._printerCache.get(printerInfo.uid));
        }

        printerPromise.then(function (printer) {
          const connectionManager = self._connectionManagers.get(printerInfo.uid); // check if this printer is coming back online


          if (printer.getStatus().state === PrinterStateEnum.Offline) {
            if (self._currentPrinters.indexOf(printerInfo.uid) !== -1) {
              printer.setState(PrinterStateEnum.Reconnecting);
            } else {
              printer.setState(PrinterStateEnum.Unauthenticated);
            }
          }

          connectionManager.updateInfo(printerInfo);
        });
      })); // hack to make this continuation cancellable....

      self._findingPromise.afterFinding = function () {
        self._checkConnections();

        self._startFinderTimeout = setTimeout(function () {
          self._startFinderTimeout = null;

          self._findPrinters();
        }, 3000);
      };

      self._findingPromise.cancelFindingContinuation = function () {
        self._findingPromise.afterFinding = null;
      };

      self._findingPromise.then(function () {
        if (self._findingPromise.afterFinding) {
          self._findingPromise.afterFinding();
        }
      }).catch(function (err) {
        self._logger.error(err);
      }).done();
    }
  }

  _checkConnections() {
    const self = this;

    for (const pair of self._connectionManagers) {
      const key = pair[0];
      const val = pair[1];
      val.checkConnections().catch(function (err) {
        if (err.type) {
          const printer = self._printerCache.get(key); // TODO: doublecheck this...


          printer.addError(Errors.getPluginError(err.type));

          self._logger.error(err);
        }
      }).done();
    }
  }

  addArchetypePrinter(vendorName, genderName) {
    const self = this;
    return q(this._createArchetypePrinter(vendorName, genderName)).then(function (printer) {
      self._storedPrintersManager.storeArchetype(printer.getId(), vendorName, genderName, self._userToken);

      return printer;
    });
  }

  _createArchetypePrinter(vendorName, genderName) {
    return this._parameterService.getGender('MakerBot', genderName).then(gender => {
      const printer = new ArchetypePrinter(vendorName, gender);

      this._currentPrinters.push(printer.getId());

      this._printerCache = this._printerCache.set(printer.getId(), printer);
      return printer;
    });
  }

  _attachTrackingEvents(printer) {
    printer.updateNotifications.on('conn_type_change', () => {
      const trackingInfo = util.trackingInfoForPrinter(printer);
      const newConnType = printer.getConnectionType();

      if (newConnType === PrinterConnTypeEnum.USB) {
        this._trackingService.addEvent(_.merge({
          name: 'Printer Added USB'
        }, trackingInfo));
      }
    });
    printer.updateNotifications.on('dying_scream', err => {
      console.log(`${printer.getName()} | ${err} | Connection: ${printer.getConnectionType()}`);
      /** ** Monkey Patching **
       *
       * When a USB connection dies, there is a chance that the croissant
       * network discovery will pick up the printer. BUT there is a
       * higher chance that it won't be picked up by the network
       * discovery.
       *
       * Let's attempt to connect via IP address before deciding to label
       * the printer as "OFFLINE".
       *
       * -- Ray
       **/

      if (printer.getConnectionType() === PrinterConnTypeEnum.USB) {
        if (printer.getIpAddress()) {
          this.addByIp(printer.getIpAddress());
          printer.setState(PrinterStateEnum.Reconnecting);

          this._logger.log(`${PrinterConnTypeEnum.USB} Connection dropped out. Switching ${printer.getName()} to ${PrinterConnTypeEnum.NETWORK} at ${printer.getIpAddress()}...`);

          return printer.updateNotifications.emit('doDisconnect', false);
        }

        return printer.updateNotifications.emit('doDisconnect', true);
      }

      if (printer.getConnectionType() === PrinterConnTypeEnum.NETWORK) {
        const trackingInfo = util.trackingInfoForPrinter(printer);

        this._trackingService.addEvent(_.merge({
          name: 'Printer Disconnected from Network'
        }, trackingInfo));

        if (this._userToken) {
          // Reconstruct printerInfo w/ reflector connection
          // Croissant only cares about the userToken & uid
          // BUT for the app to properly assign reflector connection,
          // the IP address needs to be parsed out from 'tcp:<ipaddr>
          // :port#' to '<ipaddr>'
          const currPrinterInfo = this._connectionManagers.get(printer.getId())._printerInfos.get(PrinterConnTypeEnum.NETWORK);

          const {
            address,
            info
          } = currPrinterInfo;
          printer.setState(PrinterStateEnum.Reconnecting);
          currPrinterInfo.address = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/.test(address) ? address : address.split(':')[1];
          currPrinterInfo.info = {
            bot_type: info.bot_type
          };
          currPrinterInfo.connType = PrinterConnTypeEnum.REFLECTOR;

          this._logger.log(`${PrinterConnTypeEnum.NETWORK} Connection dropped out. Switching ${printer.getName()} over to Reflector...`);

          this._createPrinter(currPrinterInfo).then(printer => {
            this._connectionManagers.get(currPrinterInfo.uid).updateInfo(currPrinterInfo);

            try {
              this.authFromStored(currPrinterInfo);
              return printer.updateNotifications.emit('doDisconnect', false);
            } catch (err) {
              console.log(err);
            }
          });
        }

        return printer.updateNotifications.emit('doDisconnect', true);
      }
    }); // http://jira.makerbot.net/browse/PEN-1255
    // Commenting out until we figure out when exactly we want these events
    // to be sent from our side...

    /*
    let pp = 'PrintProcess';
      let sendPrintTrackingEvent = (name) => {
        let trackingInfo = util.trackingInfoForPrinter(printer);
        trackingInfo.extruder_type = printer.getCurrentExtruderType();
        this._trackingService.addEvent(
            _.merge({ name: name }, trackingInfo));
    };
      printer.updateNotifications.on(
        'process_completed',
        (info) => {
            if (info.current_process.name === pp)
                sendPrintTrackingEvent("Print Completed");
        });
      printer.updateNotifications.on(
        'process_cancelled',
        (info) => {
            if (info.current_process.name === pp)
                sendPrintTrackingEvent("Print Cancelled");
        });
      printer.updateNotifications.on(
        'process_failed',
        (info) => {
            if (info.current_process.name === pp)
                sendPrintTrackingEvent("Print Failed");
        });
    */
  }

  _createPrinter(printerInfo, machineConfig) {
    const self = this;

    if (printerInfo.info.bot_type === BotTypeEnum.sketch) {
      return self._getGender(printerInfo.info.bot_type).then(function (gender) {
        const printer = new SketchPrinter(printerInfo, gender, self._userToken, self);
        self._printerCache = self._printerCache.set(printerInfo.uid, printer);

        self._attachTrackingEvents(printer);

        return printer;
      });
    }

    const connectionManager = new ConnectionManager();
    connectionManager.updateInfo(printerInfo);
    self._connectionManagers = self._connectionManagers.set(printerInfo.uid, connectionManager); // hook up events

    connectionManager.on('need_auth', function (printerInfo, doneCallback) {
      self.authFromStored(printerInfo).nodeify(doneCallback);
    });
    connectionManager.on('update', function (printerInfo) {
      // only update stored info for bot if we're storing info for it
      if (self._storedPrintersManager.getPrinter(printerInfo.uid)) self._storedPrintersManager.updateStoredInfo(printerInfo);
    }, this);
    return self._getGender(printerInfo.info.bot_type).then(function (gender) {
      const printer = new MakerBotPrinter(printerInfo, gender, machineConfig, connectionManager);
      self._printerCache = self._printerCache.set(printerInfo.uid, printer);

      self._attachTrackingEvents(printer);

      return printer;
    });
  }

  _getGender(bot_type) {
    const genderName = util.botTypeToGender(bot_type);
    return this._parameterService.getGender('MakerBot', genderName, bot_type);
  }

  addByIp(ip) {
    const self = this;
    return q(self._finder.findByIp(ip)).then(function (printerInfo) {
      // filter out non-supported bots from being connected
      if (!BotTypeEnum.hasOwnProperty(printerInfo.info.bot_type)) return;
      let printer = undefined;

      const cachedPrinter = self._printerCache.get(printerInfo.uid);

      printer = compareConnType(cachedPrinter, printerInfo) >= 0 ? cachedPrinter : printer;
      const printerPromise = printer ? q(printer) : self._createPrinter(printerInfo);
      return printerPromise.then(function (printer) {
        if (printer.isAuthenticated()) return printer;

        self._connectionManagers.get(printerInfo.uid).updateInfo(printerInfo); // attempt to auth from stored info; if it fails, just
        // return the printer and auth will be requested for it


        try {
          return self.authFromStored(printerInfo);
        } catch (err) {
          return printer;
        }
      });
    });
  }

  reconnectPrinters() {
    this._logger.info(`Reconnecting Printers...`); // List through all the current printers and try to reauth using
    // the latest printerInfo from the _connectionManager.


    this._currentPrinters.forEach(uid => {
      const printer = this._printerCache.get(uid);

      if (printer.getConnectionType() === PrinterConnTypeEnum.ARCHETYPE) return;

      if (!printer.isSketchPrinter()) {
        this._reconnectMakerBotPrinter(uid, printer);
      } else {
        this._reconnectSketchPrinter(printer);
      }
    });
  }

  _reconnectMakerBotPrinter(uid, printer) {
    const currConnManager = this._connectionManagers.get(uid);

    const {
      _currentConnType
    } = currConnManager;

    const printerInfo = currConnManager._printerInfos.get(_currentConnType);

    if (printerInfo) {
      // ONLY reconnect to printers with PrinterInfo
      // OFFLINE Printers will not have a croissant.printerInfo
      // stored in connectionManager
      this._logger.info(`Reconnecting ${printer.getName()} printer via ${printerInfo.connType}`);

      this.authFromStored(printerInfo);
    }
  }

  _reconnectSketchPrinter(printer) {
    const options = {
      headers: {
        'Authorization': `Bearer ${this._userToken}`,
        'Content-Type': 'application/json'
      },
      url: `${reflectorUrl}/printers/${printer.getIserial()}`
    };
    request(options, (err, res, body) => {
      if (err || ![200, 201].includes(res.statusCode)) {
        this._logger.info(`Error! Unable to reconnect via Reflector for Sketch Printer ${printer.getName()}`);

        printer.setState(PrinterStateEnum.Offline);
      } else {
        const jsonBody = JSON.parse(body);

        const printerInfo = this._formatReflectorPrinterInfo(jsonBody);

        this._logger.info(`Reconnecting Sketch printer, ${printer.getName()}, via ${printerInfo.connType}`);

        printer.setState(PrinterStateEnum.Reconnecting);
        printer.updateFromPrinterInfo(printerInfo);
      }
    });
  } // -------------AUTH STUFF-------------------


  deauthenticate(printer) {
    const uid = printer.getId();

    const connManager = this._connectionManagers.get(uid);

    if (connManager) {
      printer.deauthenticate(this._userInfo ? this._userInfo.name : 'ANON');
      connManager.changeConnection(null, null);
    }

    const index = this._currentPrinters.indexOf(uid);

    if (index != -1) this._currentPrinters.splice(index, 1);

    this._storedPrintersManager.removePrinterForUser(uid, this._userToken);
  }

  _doAuthenticate(connectPromise, printer, printerInfo) {
    const self = this;
    const authResult = {};

    connectPromise.continuation = function (res) {
      self._logger.log(`Successfully connected to ${printerInfo.name} using connection type: ${printerInfo.connType}`);

      authResult.printer = res[0];
      authResult.authInfo = res[1]; // alert the printer's connectionManager that auth has completed

      self._connectionManagers.get(printerInfo.uid).changeConnection(authResult.printer, printerInfo);

      let addAccountPromise = q();
      if (printerInfo.connType === PrinterConnTypeEnum.USB && self._userToken) addAccountPromise = printer.invoke('AddMakerbotAccount', [self._userInfo ? self._userInfo.name : 'ANON', self._userToken]);
      return addAccountPromise.then(function () {
        self._currentPrinters.push(printer.getId());

        self.emit('add_printer', printer); // sigh... we should look into whether we really need to call this here...
        //
        // Right now it gets called so that printer.getTrackingInfo will
        // have some extruder stats-- but those aren't even guaranteed
        // to be correct, since we don't update it at all after getting
        // it the first time (and it used to be called in updateSchema too, WHY???)
        //
        // Is it necessary in the first place for ALL tracking info for a printer
        // to contain extruder stats? If so, this should be called in the
        // getTrackingInfo method of MBPrinter (which I'm wary of having
        // in the printer class in the first place), which would necessitate
        // getTrackingInfo to be a promise, which would require changes to
        // all the current tracking event-handling code...
        //
        //If not, this should only be called where necessary (and just
        // invoke, rather than storing the extruder stats as a property
        //of the printer object....)

        return printer.updateExtruderStats();
      }).then(function () {
        // Temporary(?): do not fail auth if updateMachineConfig fails.
        // Auth has succeeded at this point though, so we should present
        // that properly... Hopefully we will soon be moving away from
        // getting the schema in this function, in which case, we can
        // either keep this the way it is now, or go back to how it was before...
        printer.updateMachineConfig().catch(function (err) {
          self._logger.warn(err);
        }).finally(function () {
          const machineConfig = self._printerCache.get(printerInfo.uid).machineConfig;

          return self._storedPrintersManager.updateStoredInfo(printerInfo, machineConfig, authResult.authInfo, self._userToken);
        }).done();
        return printer;
      });
    };

    connectPromise.cancel = function () {
      this.continuation = function (res) {// do nothing?
      };
    };

    self._authPromises.set(printer.getId(), connectPromise);

    return connectPromise.then(function (res) {
      return q.all(res);
    }).timeout(PRINTER_AUTH_TIMEOUT).then(function (res) {
      return connectPromise.continuation(res);
    }).catch(function (err) {
      if (err.code === 'ETIMEDOUT') {
        const trackingInfo = util.trackingInfoForPrinter(printer);

        self._trackingService.addEvent(_.merge(trackingInfo, {
          name: 'Reauthentication Timeout',
          connection_type: printerInfo.connType
        }));
      }

      self._logger.error(`Failed to authenticate to printer ${printerInfo.name} over connection type ${printerInfo.connType}: ${err}`);

      const connectionManager = self._connectionManagers.get(printerInfo.uid); // This auth request may be happening because we're trying to move
      // from a lower priority one to a higher priority one; if it fails
      // because eg. auth code is no longer valid, we don't want MBPrinter
      // to think it's become unauthenticated when it still has its lower
      // priority connection (so we only change to unauth'd when we have
      // no fallback)


      if (!connectionManager.currentConnType) {
        printer.setState(PrinterStateEnum.Unauthenticated);
      } else {
        printer.setState(PrinterStateEnum.Pending);
      }

      throw err;
    }).finally(function () {
      self._authPromises.delete(printer.getId());
    });
  }

  authFromStored(printerInfo) {
    const printer = this._printerCache.get(printerInfo.uid);

    if (printer.isAuthenticating()) return q(printer); // check for stored auth information; only relevant for network printers

    let authInfo;

    if (printerInfo.connType === PrinterConnTypeEnum.NETWORK) {
      if (this._currentPrinters.indexOf(printerInfo.uid) !== -1) {
        if (!this._userToken) authInfo = this._storedPrintersManager.getPrinter(printerInfo.uid).authInfo;
      } else {
        throw 'No stored auth info for network printer';
      }
    }

    this._logger.debug(`Attempting reauth ${printerInfo.name} over connection type: ${printerInfo.connType}`);

    printer.setState(PrinterStateEnum.Reauthenticating);
    const self = this;
    const connectPromise = q.try(function () {
      return authInfo ? self._finder.reconnectPrinter(printerInfo, authInfo) : self._finder.reconnectPrinter(printerInfo);
    }).then(function (printer) {
      return [printer, q(authInfo)];
    });
    return this._doAuthenticate(connectPromise, printer, printerInfo).catch(err => {
      if (err instanceof croissant.UnauthorizedError) {
        this._logger.log(`Reauth to ${printerInfo.name} rejected as Unauthorized; ` + `removing local printer info for user`);

        this.deauthenticate(printer);
      }

      throw err;
    });
  }

  requestNewAuth(printerInfo) {
    const printer = this._printerCache.get(printerInfo.uid);

    if (printer.isAuthenticating() || printer.isAuthenticated()) return q(printer);

    if (printerInfo.connType === PrinterConnTypeEnum.NETWORK) {
      this._logger.debug(`Requesting new auth to ${printerInfo.name} over connection type: ${printerInfo.connType}`);

      printer.setState(PrinterStateEnum.Authenticating);
    } else {
      this._logger.debug(`Attempting reauth ${printerInfo.name} over connection type: ${printerInfo.connType}`);

      printer.setState(PrinterStateEnum.Reauthenticating);
    }

    const connectPromise = q(this._finder.connectPrinter(printerInfo));
    return this._doAuthenticate(connectPromise, printer, printerInfo);
  } // try to auth with the highest-available-priority printerInfo, without using
  // stored authInfo


  authenticate(printer) {
    const authResObj = {
      printer,
      wasNewAuth: false
    };

    const printerInfo = this._connectionManagers.get(printer.getId()).getHighestPriorityConnInfo();

    if (!printerInfo) throw 'Cannot authenticate to an offline printer';
    const isNetworkBot = printerInfo.connType === PrinterConnTypeEnum.NETWORK; // If the bot is a network bot and we don't think it belongs to the current
    // user, go straight to button-press auth

    if (isNetworkBot && this._currentPrinters.indexOf(printerInfo.uid) === -1) {
      authResObj.wasNewAuth = true;
      return this.requestNewAuth(printerInfo).then(() => {
        return authResObj;
      });
    } // otherwise, try authing from stored


    return this.authFromStored(printerInfo).catch(err => {
      // if our reauth to a network bot was denied, try button auth
      if (isNetworkBot && err instanceof croissant.UnauthorizedError) {
        authResObj.wasNewAuth = true;
        return this.requestNewAuth(printerInfo).then(() => {
          return authResObj;
        });
      }

      throw err;
    });
  }

}

module.exports = PrinterManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByaW50ZXJNYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIkltbXV0YWJsZSIsInJlcXVpcmUiLCJxIiwiRXZlbnRFbWl0dGVyIiwiXyIsInJlcXVlc3QiLCJjcm9pc3NhbnQiLCJBcmNoZXR5cGVQcmludGVyIiwiTWFrZXJCb3RQcmludGVyIiwiU2tldGNoUHJpbnRlciIsIkVycm9ycyIsIlByaW50ZXJTdGF0ZUVudW0iLCJQcmludGVyQ29ublR5cGVFbnVtIiwiQm90VHlwZUVudW0iLCJQUklOVEVSX0FVVEhfVElNRU9VVCIsIkNvbm5lY3Rpb25NYW5hZ2VyIiwidXRpbCIsInBhcnNlQ29ublR5cGUiLCJjb21wYXJlQ29ublR5cGUiLCJyZWZsZWN0b3JVcmwiLCJQcmludGVyTWFuYWdlciIsImNvbnN0cnVjdG9yIiwicGFyYW1ldGVyU2VydmljZSIsImxvZ2dpbmdTZXJ2aWNlIiwidHZBcGlDbGllbnQiLCJ0cmFja2luZ1NlcnZpY2UiLCJ1c2VySW5mbyIsInRva2VuIiwic3RvcmVkUHJpbnRlcnNNYW5hZ2VyIiwiX3BhcmFtZXRlclNlcnZpY2UiLCJfbG9nZ2VyIiwiX3R2QXBpQ2xpZW50IiwiX3RyYWNraW5nU2VydmljZSIsIl9zdG9yZWRQcmludGVyc01hbmFnZXIiLCJfcHJpbnRlckNhY2hlIiwiTWFwIiwiX2Nvbm5lY3Rpb25NYW5hZ2VycyIsIl9maW5kZXIiLCJfZmluZGluZ1Byb21pc2UiLCJfc3RhcnRGaW5kZXJUaW1lb3V0IiwiX3N0b3BGaW5kZXJUaW1lb3V0IiwiX3BvbGxpbmdSZWZsZWN0b3JJZCIsIl91c2VySW5mbyIsIl91c2VyVG9rZW4iLCJfY3VycmVudFByaW50ZXJzIiwiX2F1dGhQcm9taXNlcyIsInJlY29ubmVjdFByaW50ZXJzIiwiYmluZCIsIl9wb2xsUmVmbGVjdG9yRm9yU2tldGNoUHJpbnRlcnMiLCJfcmVjb25uZWN0TWFrZXJCb3RQcmludGVyIiwiX3JlY29ubmVjdFNrZXRjaFByaW50ZXIiLCJza2V0Y2hQcmludGVyTGlzdCIsImluaXQiLCJzZWxmIiwibG9hZFByaW50ZXJzUHJvbWlzZSIsIl91c2VyUHJpbnRlcnNGcm9tU3RvcmVkIiwiX2xvYWRBbm9ueW1vdXNQcmludGVycyIsInRoZW4iLCJfbG9hZEFyY2hldHlwZVByaW50ZXJzIiwicHJpbnRlciIsImdldFByaW50ZXJzIiwiZW1pdCIsImFyY2hldHlwZVByaW50ZXJQcm9taXNlcyIsImFyY2hldHlwZUlkcyIsImdldEFyY2hldHlwZVByaW50ZXJzIiwiaWQiLCJpbmZvIiwiZ2V0UHJpbnRlciIsInB1c2giLCJfY3JlYXRlQXJjaGV0eXBlUHJpbnRlciIsInZlbmRvciIsImdlbmRlciIsImFsbFNldHRsZWQiLCJzdG9wIiwicHJvbWlzZSIsInZhbHVlcyIsImNhbmNlbCIsInVpZCIsImdldCIsImRpc2Nvbm5lY3QiLCJjYW5jZWxGaW5kaW5nQ29udGludWF0aW9uIiwiY2xlYXJUaW1lb3V0Iiwic3RvcEZpbmRpbmdQcmludGVycyIsIl9nZXRVc2VyUHJpbnRlcnNGcm9tV2ViIiwicHJpbnRlckluZm9zUHJvbWlzZSIsImdldFVzZXJQcmludGVyc0Zyb21SZWZsZWN0b3IiLCJ1c2VyUHJpbnRlckxpc3RSZXMiLCJ1c2VyUHJpbnRlcnMiLCJwcmludGVycyIsInN1cHBvcnRlZFJlZmxlY3RvckJvdHMiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwicHJpbnRlcklkIiwiYm90VHlwZSIsInN0YXR1cyIsImJvdF90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfZ2V0UmVmbGVjdG9yUHJpbnRlckluZm9zIiwiZXJyIiwid2FybiIsInJlc3VsdHMiLCJzdG9yZWRVc2VyUHJpbnRlcnMiLCJnZXRVc2VyUHJpbnRlcnMiLCJpbmNsdWRlcyIsInJlbW92ZVByaW50ZXJGb3JVc2VyIiwiY2FjaGVkUHJpbnRlciIsIl9wcmludGVySW5mb0Zyb21TYXZlZEluZm8iLCJwcmludGVyX2luZm8iLCJfb2ZmbGluZVByaW50ZXJzRnJvbVByaW50ZXJJbmZvc0xpc3QiLCJzdGFydCIsImNsaWVudFNlY3JldCIsImZpbmFsbHkiLCJQcmludGVyRmluZGVyIiwic2V0Q2xpZW50U2VjcmV0Iiwic2V0VGhpbmdpdmVyc2VJbmZvIiwibmFtZSIsInVzZXJuYW1lIiwic2V0VXNlcm5hbWVPbmx5IiwiX2ZpbmRQcmludGVycyIsInRpbWVJbnRlcnZhbCIsIm9wdGlvbnMiLCJoZWFkZXJzIiwidXJsIiwic2V0SW50ZXJ2YWwiLCJyZXMiLCJib2R5Iiwic3RhdHVzQ29kZSIsIkpTT04iLCJwYXJzZSIsInNrZXRjaFByaW50ZXJJZHMiLCJmaWx0ZXIiLCJtYXRjaCIsInNrZXRjaFVpZHMiLCJfdWlkRnJvbUJvdFR5cGVBbmRJc2VyaWFsIiwic2tldGNoIiwiZm9yRWFjaCIsInR2UHJpbnRlckluZm8iLCJpc0VtcHR5IiwicHJpbnRlckluZm8iLCJfZm9ybWF0UmVmbGVjdG9yUHJpbnRlckluZm8iLCJfY3JlYXRlUHJpbnRlciIsImNhdGNoIiwibG9nIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsInVwZGF0ZUZyb21QcmludGVySW5mbyIsImFub25QcmludGVyVWlkcyIsImdldEFub255bW91c1ByaW50ZXJzIiwiX29mZmxpbmVQcmludGVyc0Zyb21VaWRMaXN0IiwidWlkcyIsInByaW50ZXJQcm9taXNlcyIsImhhbmRsZUVyciIsInNhdmVkSW5mbyIsIl9jcmVhdGVPZmZsaW5lUHJpbnRlciIsIm1hY2hpbmVDb25maWciLCJwcmludGVySW5mb3MiLCJwcmludGVySWRzIiwicHJpbnRlcnNMaXN0IiwiaXNlcmlhbCIsInZpZCIsInBpZCIsInNwbGl0Iiwic2xpY2UiLCJqb2luIiwiUHJpbnRlckluZm8iLCJhZGRyZXNzIiwiaXAiLCJwcmludGVyX2lkIiwiY29ublR5cGUiLCJ1cGRhdGVTdG9yZWRJbmZvIiwic2V0U3RhdGUiLCJSZWNvbm5lY3RpbmciLCJnZXRJZCIsInRvQXJyYXkiLCJpc1BlbmRpbmciLCJzZXRUaW1lb3V0IiwiZG9uZSIsImZpbmRQcmludGVycyIsInByaW50ZXJQcm9taXNlIiwiY29ubmVjdGlvbk1hbmFnZXIiLCJnZXRTdGF0dXMiLCJzdGF0ZSIsIk9mZmxpbmUiLCJpbmRleE9mIiwiVW5hdXRoZW50aWNhdGVkIiwidXBkYXRlSW5mbyIsImFmdGVyRmluZGluZyIsIl9jaGVja0Nvbm5lY3Rpb25zIiwiZXJyb3IiLCJwYWlyIiwia2V5IiwidmFsIiwiY2hlY2tDb25uZWN0aW9ucyIsInR5cGUiLCJhZGRFcnJvciIsImdldFBsdWdpbkVycm9yIiwiYWRkQXJjaGV0eXBlUHJpbnRlciIsInZlbmRvck5hbWUiLCJnZW5kZXJOYW1lIiwic3RvcmVBcmNoZXR5cGUiLCJnZXRHZW5kZXIiLCJzZXQiLCJfYXR0YWNoVHJhY2tpbmdFdmVudHMiLCJ1cGRhdGVOb3RpZmljYXRpb25zIiwib24iLCJ0cmFja2luZ0luZm8iLCJ0cmFja2luZ0luZm9Gb3JQcmludGVyIiwibmV3Q29ublR5cGUiLCJnZXRDb25uZWN0aW9uVHlwZSIsIlVTQiIsImFkZEV2ZW50IiwibWVyZ2UiLCJnZXROYW1lIiwiZ2V0SXBBZGRyZXNzIiwiYWRkQnlJcCIsIk5FVFdPUksiLCJjdXJyUHJpbnRlckluZm8iLCJfcHJpbnRlckluZm9zIiwidGVzdCIsIlJFRkxFQ1RPUiIsImF1dGhGcm9tU3RvcmVkIiwiX2dldEdlbmRlciIsImRvbmVDYWxsYmFjayIsIm5vZGVpZnkiLCJib3RUeXBlVG9HZW5kZXIiLCJmaW5kQnlJcCIsInVuZGVmaW5lZCIsImlzQXV0aGVudGljYXRlZCIsIkFSQ0hFVFlQRSIsImlzU2tldGNoUHJpbnRlciIsImN1cnJDb25uTWFuYWdlciIsIl9jdXJyZW50Q29ublR5cGUiLCJnZXRJc2VyaWFsIiwianNvbkJvZHkiLCJkZWF1dGhlbnRpY2F0ZSIsImNvbm5NYW5hZ2VyIiwiY2hhbmdlQ29ubmVjdGlvbiIsImluZGV4Iiwic3BsaWNlIiwiX2RvQXV0aGVudGljYXRlIiwiY29ubmVjdFByb21pc2UiLCJhdXRoUmVzdWx0IiwiY29udGludWF0aW9uIiwiYXV0aEluZm8iLCJhZGRBY2NvdW50UHJvbWlzZSIsImludm9rZSIsInVwZGF0ZUV4dHJ1ZGVyU3RhdHMiLCJ1cGRhdGVNYWNoaW5lQ29uZmlnIiwiYWxsIiwidGltZW91dCIsImNvZGUiLCJjb25uZWN0aW9uX3R5cGUiLCJjdXJyZW50Q29ublR5cGUiLCJQZW5kaW5nIiwiZGVsZXRlIiwiaXNBdXRoZW50aWNhdGluZyIsImRlYnVnIiwiUmVhdXRoZW50aWNhdGluZyIsInRyeSIsInJlY29ubmVjdFByaW50ZXIiLCJVbmF1dGhvcml6ZWRFcnJvciIsInJlcXVlc3ROZXdBdXRoIiwiQXV0aGVudGljYXRpbmciLCJjb25uZWN0UHJpbnRlciIsImF1dGhlbnRpY2F0ZSIsImF1dGhSZXNPYmoiLCJ3YXNOZXdBdXRoIiwiZ2V0SGlnaGVzdFByaW9yaXR5Q29ubkluZm8iLCJpc05ldHdvcmtCb3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxNQUFNQSxTQUFTLEdBQUdDLE9BQU8sQ0FBQyxXQUFELENBQXpCOztBQUNBLE1BQU1DLENBQUMsR0FBR0QsT0FBTyxDQUFDLEdBQUQsQ0FBakI7O0FBQ0EsTUFBTUUsWUFBWSxHQUFHRixPQUFPLENBQUMsZUFBRCxDQUE1Qjs7QUFDQSxNQUFNRyxDQUFDLEdBQUdILE9BQU8sQ0FBQyxRQUFELENBQWpCOztBQUNBLE1BQU1JLE9BQU8sR0FBR0osT0FBTyxDQUFDLFNBQUQsQ0FBdkI7O0FBRUEsTUFBTUssU0FBUyxHQUFHTCxPQUFPLENBQUMsYUFBRCxDQUF6Qjs7QUFDQSxNQUFNTSxnQkFBZ0IsR0FBR04sT0FBTyxDQUFDLHFCQUFELENBQWhDOztBQUNBLE1BQU1PLGVBQWUsR0FBR1AsT0FBTyxDQUFDLG9CQUFELENBQS9COztBQUNBLE1BQU1RLGFBQWEsR0FBR1IsT0FBTyxDQUFDLGlCQUFELENBQTdCOztBQUNBLE1BQU1TLE1BQU0sR0FBR1QsT0FBTyxDQUFDLFVBQUQsQ0FBdEI7O0FBQ0EsTUFBTVUsZ0JBQWdCLEdBQUdWLE9BQU8sQ0FBQyxhQUFELENBQVAsQ0FBdUJVLGdCQUFoRDs7QUFDQSxNQUFNQyxtQkFBbUIsR0FBR1gsT0FBTyxDQUFDLGFBQUQsQ0FBUCxDQUF1QlcsbUJBQW5EOztBQUNBLE1BQU1DLFdBQVcsR0FBR1osT0FBTyxDQUFDLGFBQUQsQ0FBUCxDQUF1QlksV0FBM0M7O0FBQ0EsTUFBTUMsb0JBQW9CLEdBQUdiLE9BQU8sQ0FBQyxhQUFELENBQVAsQ0FBdUJhLG9CQUFwRDs7QUFDQSxNQUFNQyxpQkFBaUIsR0FBR2QsT0FBTyxDQUFDLDRCQUFELENBQWpDOztBQUNBLE1BQU1lLElBQUksR0FBR2YsT0FBTyxDQUFDLFFBQUQsQ0FBcEI7O0FBQ0EsTUFBTTtBQUFFZ0IsRUFBQUEsYUFBRjtBQUFpQkMsRUFBQUE7QUFBakIsSUFBcUNqQixPQUFPLENBQUMsK0JBQUQsQ0FBbEQsQyxDQUVBOzs7QUFDQSxNQUFNa0IsWUFBWSxHQUFHLGdDQUFyQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNQyxjQUFOLFNBQTZCakIsWUFBN0IsQ0FBMEM7QUFDdENrQixFQUFBQSxXQUFXLENBQ1BDLGdCQURPLEVBRVBDLGNBRk8sRUFHUEMsV0FITyxFQUlQQyxlQUpPLEVBS1BDLFFBTE8sRUFNUEMsS0FOTyxFQU9QQyxxQkFQTyxFQVFUO0FBQ0U7QUFFQSxTQUFLQyxpQkFBTCxHQUF5QlAsZ0JBQXpCO0FBQ0EsU0FBS1EsT0FBTCxHQUFlUCxjQUFmO0FBQ0EsU0FBS1EsWUFBTCxHQUFvQlAsV0FBcEI7QUFDQSxTQUFLUSxnQkFBTCxHQUF3QlAsZUFBeEI7QUFDQSxTQUFLUSxzQkFBTCxHQUE4QkwscUJBQTlCO0FBRUEsU0FBS00sYUFBTCxHQUFxQixJQUFJbEMsU0FBUyxDQUFDbUMsR0FBZCxFQUFyQjtBQUNBLFNBQUtDLG1CQUFMLEdBQTJCLElBQUlELEdBQUosRUFBM0I7QUFFQSxTQUFLRSxPQUFMLEdBQWUsSUFBZjtBQUNBLFNBQUtDLGVBQUwsR0FBdUIsSUFBdkI7QUFDQSxTQUFLQyxtQkFBTCxHQUEyQixJQUEzQjtBQUNBLFNBQUtDLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EsU0FBS0MsbUJBQUwsR0FBMkIsSUFBM0I7QUFFQSxTQUFLQyxTQUFMLEdBQWlCaEIsUUFBakI7QUFDQSxTQUFLaUIsVUFBTCxHQUFrQmhCLEtBQWxCO0FBQ0EsU0FBS2lCLGdCQUFMLEdBQXdCLEVBQXhCO0FBRUEsU0FBS0MsYUFBTCxHQUFxQixJQUFJVixHQUFKLEVBQXJCO0FBRUEsU0FBS1csaUJBQUwsR0FBeUIsS0FBS0EsaUJBQUwsQ0FBdUJDLElBQXZCLENBQTRCLElBQTVCLENBQXpCO0FBQ0EsU0FBS0MsK0JBQUwsR0FBdUMsS0FBS0EsK0JBQUwsQ0FBcUNELElBQXJDLENBQTBDLElBQTFDLENBQXZDO0FBQ0EsU0FBS0UseUJBQUwsR0FBaUMsS0FBS0EseUJBQUwsQ0FBK0JGLElBQS9CLENBQW9DLElBQXBDLENBQWpDO0FBQ0EsU0FBS0csdUJBQUwsR0FBK0IsS0FBS0EsdUJBQUwsQ0FBNkJILElBQTdCLENBQWtDLElBQWxDLENBQS9CO0FBRUEsU0FBS0ksaUJBQUwsR0FBeUIsRUFBekI7QUFDSDs7QUFFREMsRUFBQUEsSUFBSSxHQUFHO0FBQ0gsVUFBTUMsSUFBSSxHQUFHLElBQWIsQ0FERyxDQUVIOztBQUNBLFFBQUlDLG1CQUFKOztBQUNBLFFBQUksS0FBS1gsVUFBVCxFQUFxQjtBQUNqQlcsTUFBQUEsbUJBQW1CLEdBQUcsS0FBS0MsdUJBQUwsQ0FBNkIsS0FBS1osVUFBbEMsQ0FBdEI7QUFDSCxLQUZELE1BRU87QUFDSFcsTUFBQUEsbUJBQW1CLEdBQUcsS0FBS0Usc0JBQUwsRUFBdEI7QUFDSDs7QUFFRCxXQUFPRixtQkFBbUIsQ0FDckJHLElBREUsQ0FDRyxZQUFXO0FBQ2IsYUFBT0osSUFBSSxDQUFDSyxzQkFBTCxDQUE0QkwsSUFBSSxDQUFDVixVQUFqQyxDQUFQO0FBQ0gsS0FIRSxFQUlGYyxJQUpFLENBSUcsWUFBVztBQUNiLFdBQUssTUFBTUUsT0FBWCxJQUFzQk4sSUFBSSxDQUFDTyxXQUFMLEVBQXRCLEVBQTBDUCxJQUFJLENBQUNRLElBQUwsQ0FBVSxhQUFWLEVBQXlCRixPQUF6QixFQUQ3QixDQUViOzs7QUFDQU4sTUFBQUEsSUFBSSxDQUFDUSxJQUFMLENBQVUscUJBQVY7QUFDSCxLQVJFLENBQVA7QUFTSDs7QUFFREgsRUFBQUEsc0JBQXNCLENBQUMvQixLQUFELEVBQVE7QUFDMUIsVUFBTW1DLHdCQUF3QixHQUFHLEVBQWpDOztBQUVBLFVBQU1DLFlBQVksR0FBRyxLQUFLOUIsc0JBQUwsQ0FBNEIrQixvQkFBNUIsQ0FBaUQsS0FBS3JCLFVBQXRELENBQXJCOztBQUVBLFNBQUssTUFBTXNCLEVBQVgsSUFBaUJGLFlBQWpCLEVBQStCO0FBQzNCLFlBQU1HLElBQUksR0FBRyxLQUFLakMsc0JBQUwsQ0FBNEJrQyxVQUE1QixDQUF1Q0YsRUFBdkMsQ0FBYjs7QUFDQUgsTUFBQUEsd0JBQXdCLENBQUNNLElBQXpCLENBQThCLEtBQUtDLHVCQUFMLENBQTZCSCxJQUFJLENBQUNJLE1BQWxDLEVBQTBDSixJQUFJLENBQUNLLE1BQS9DLENBQTlCO0FBQ0g7O0FBQ0QsV0FBT3JFLENBQUMsQ0FBQ3NFLFVBQUYsQ0FBYVYsd0JBQWIsQ0FBUDtBQUNIOztBQUVEVyxFQUFBQSxJQUFJLEdBQUc7QUFDSCxTQUFLLE1BQU1DLE9BQVgsSUFBc0IsS0FBSzdCLGFBQUwsQ0FBbUI4QixNQUFuQixFQUF0QixFQUFtRDtBQUMvQ0QsTUFBQUEsT0FBTyxDQUFDRSxNQUFSO0FBQ0g7O0FBRUQsU0FBSyxNQUFNQyxHQUFYLElBQWtCLEtBQUtqQyxnQkFBdkIsRUFBeUM7QUFDckMsWUFBTWUsT0FBTyxHQUFHLEtBQUt6QixhQUFMLENBQW1CNEMsR0FBbkIsQ0FBdUJELEdBQXZCLENBQWhCOztBQUNBLFVBQUlsQixPQUFKLEVBQWFBLE9BQU8sQ0FBQ29CLFVBQVI7QUFDaEIsS0FSRSxDQVVIOzs7QUFDQSxRQUFJLEtBQUt6QyxlQUFULEVBQTBCLEtBQUtBLGVBQUwsQ0FBcUIwQyx5QkFBckI7O0FBRTFCLFFBQUksS0FBS3pDLG1CQUFULEVBQThCO0FBQzFCO0FBQ0E7QUFDQTBDLE1BQUFBLFlBQVksQ0FBQyxLQUFLMUMsbUJBQU4sQ0FBWjtBQUNBLGFBQU9yQyxDQUFDLEVBQVI7QUFDSCxLQUxELE1BS08sSUFBSSxLQUFLc0Msa0JBQVQsRUFBNkI7QUFDaEM7QUFDQTtBQUNBLFlBQU1hLElBQUksR0FBRyxJQUFiO0FBQ0E0QixNQUFBQSxZQUFZLENBQUMsS0FBS3pDLGtCQUFOLENBQVo7QUFDQSxhQUFPLEtBQUtILE9BQUwsQ0FBYTZDLG1CQUFiLEdBQW1DekIsSUFBbkMsQ0FBd0MsWUFBVztBQUN0RCxlQUFPSixJQUFJLENBQUNmLGVBQVo7QUFDSCxPQUZNLENBQVA7QUFHSCxLQVJNLE1BUUE7QUFDSDtBQUNBO0FBQ0EsYUFBTyxLQUFLQSxlQUFaO0FBQ0g7QUFDSjs7QUFFRDZDLEVBQUFBLHVCQUF1QixHQUFHO0FBQ3RCO0FBQ0EsVUFBTUMsbUJBQW1CLEdBQUdsRixDQUFDLENBQ3pCLEtBQUs2QixZQUFMLENBQWtCc0QsNEJBQWxCLENBQStDLEtBQUsxQyxVQUFwRCxFQUFnRWMsSUFBaEUsQ0FDSTZCLGtCQUFrQixJQUFJO0FBQ2xCLFlBQU1DLFlBQVksR0FBR0Qsa0JBQWtCLENBQUNFLFFBQXhDO0FBQ0EsWUFBTUMsc0JBQXNCLEdBQUcsRUFBL0I7QUFFQUMsTUFBQUEsTUFBTSxDQUFDQyxJQUFQLENBQVlKLFlBQVosRUFBMEJLLEdBQTFCLENBQThCQyxTQUFTLElBQUk7QUFDdkM7QUFDQSxjQUFNQyxPQUFPLEdBQUdQLFlBQVksQ0FBQ00sU0FBRCxDQUFaLENBQXdCRSxNQUF4QixDQUErQkMsUUFBL0M7O0FBQ0EsWUFBSW5GLFdBQVcsQ0FBQ29GLGNBQVosQ0FBMkJILE9BQTNCLENBQUosRUFBeUM7QUFDckNMLFVBQUFBLHNCQUFzQixDQUFDSSxTQUFELENBQXRCLEdBQW9DTixZQUFZLENBQUNNLFNBQUQsQ0FBaEQ7QUFDSDtBQUNKLE9BTkQ7QUFPQSxhQUFPLEtBQUtLLHlCQUFMLENBQStCVCxzQkFBL0IsQ0FBUDtBQUNILEtBYkwsRUFjSVUsR0FBRyxJQUFJO0FBQ0g7QUFDQSxXQUFLckUsT0FBTCxDQUFhc0UsSUFBYixDQUFrQix3REFBbEIsRUFBNEVELEdBQTVFOztBQUNBLFlBQU1BLEdBQU47QUFDSCxLQWxCTCxDQUR5QixDQUE3QixDQUZzQixDQXlCdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBT2YsbUJBQW1CLENBQUMzQixJQUFwQixDQUF5QjRDLE9BQU8sSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxVQUFJLENBQUNBLE9BQUwsRUFBYyxPQUp5QixDQU12Qzs7QUFDQSxZQUFNQyxrQkFBa0IsR0FBRyxLQUFLckUsc0JBQUwsQ0FBNEJzRSxlQUE1QixDQUE0QyxLQUFLNUQsVUFBakQsQ0FBM0I7O0FBRUEsV0FBSyxNQUFNa0MsR0FBWCxJQUFrQnlCLGtCQUFsQixFQUFzQztBQUNsQztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dCLFlBQUksQ0FBQ1osTUFBTSxDQUFDQyxJQUFQLENBQVlVLE9BQVosRUFBcUJHLFFBQXJCLENBQThCM0IsR0FBOUIsQ0FBTCxFQUF5QztBQUNyQyxlQUFLNUMsc0JBQUwsQ0FBNEJ3RSxvQkFBNUIsQ0FBaUQ1QixHQUFqRCxFQUFzRCxLQUFLbEMsVUFBM0Q7O0FBQ0EsZUFBS2tCLElBQUwsQ0FBVSxnQkFBVixFQUE0QixLQUFLM0IsYUFBTCxDQUFtQjRDLEdBQW5CLENBQXVCRCxHQUF2QixDQUE1QjtBQUNILFNBSEQsTUFHTztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdCQUFNNkIsYUFBYSxHQUFHLEtBQUt6RSxzQkFBTCxDQUE0QmtDLFVBQTVCLENBQXVDVSxHQUF2QyxDQUF0Qjs7QUFDQXdCLFVBQUFBLE9BQU8sQ0FBQ3hCLEdBQUQsQ0FBUCxHQUFlLEtBQUs4Qix5QkFBTCxDQUErQjtBQUFFQyxZQUFBQSxZQUFZLEVBQUVGLGFBQWEsQ0FBQ0U7QUFBOUIsV0FBL0IsQ0FBZjtBQUNIO0FBQ0o7O0FBRUQsYUFBTyxLQUFLQyxvQ0FBTCxDQUEwQ1IsT0FBMUMsQ0FBUDtBQUNILEtBdENNLENBQVA7QUF1Q0g7O0FBRURTLEVBQUFBLEtBQUssQ0FBQ0MsWUFBRCxFQUFlO0FBQ2hCO0FBQ0EsUUFBSXpELG1CQUFtQixHQUFHcEQsQ0FBQyxFQUEzQjtBQUNBLFFBQUksS0FBS3lDLFVBQVQsRUFBcUJXLG1CQUFtQixHQUFHLEtBQUs2Qix1QkFBTCxFQUF0QjtBQUVyQixXQUFPN0IsbUJBQW1CLENBQ3JCRyxJQURFLENBQ0csTUFBTTtBQUNSLGFBQU8sS0FBS0Msc0JBQUwsRUFBUDtBQUNILEtBSEUsRUFJRkQsSUFKRSxDQUlHLE1BQU07QUFDUjtBQUNBLFdBQUssTUFBTW9CLEdBQVgsSUFBa0IsS0FBS2pDLGdCQUF2QixFQUF5QztBQUNyQyxhQUFLaUIsSUFBTCxDQUFVLGFBQVYsRUFBeUIsS0FBSzNCLGFBQUwsQ0FBbUI0QyxHQUFuQixDQUF1QkQsR0FBdkIsQ0FBekI7QUFDSDtBQUNKLEtBVEUsRUFVRm1DLE9BVkUsQ0FVTSxNQUFNO0FBQ1g7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQUszRSxPQUFMLEdBQWUsSUFBSS9CLFNBQVMsQ0FBQzJHLGFBQWQsRUFBZjs7QUFDQSxXQUFLNUUsT0FBTCxDQUFhNkUsZUFBYixDQUE2QkgsWUFBN0I7O0FBQ0EsVUFBSSxLQUFLckUsU0FBTCxJQUFrQixLQUFLQyxVQUEzQixFQUF1QztBQUNuQyxhQUFLTixPQUFMLENBQWE4RSxrQkFBYixDQUFnQyxLQUFLekUsU0FBTCxDQUFlMEUsSUFBL0MsRUFBcUQsS0FBS3pFLFVBQTFEO0FBQ0gsT0FGRCxNQUVPO0FBQ0g7QUFDQTtBQUNBLGNBQU0wRSxRQUFRLEdBQUcsS0FBSzNFLFNBQUwsR0FBaUIsS0FBS0EsU0FBTCxDQUFlMEUsSUFBaEMsR0FBdUMsTUFBeEQ7O0FBQ0EsYUFBSy9FLE9BQUwsQ0FBYWlGLGVBQWIsQ0FBNkJELFFBQTdCO0FBQ0g7O0FBQ0QsV0FBS0UsYUFBTCxHQWpCVyxDQW1CWDs7O0FBQ0EsV0FBS3ZFLCtCQUFMLENBQXFDLENBQXJDO0FBQ0gsS0EvQkUsQ0FBUDtBQWdDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBOzs7QUFDSUEsRUFBQUEsK0JBQStCLENBQUN3RSxZQUFELEVBQWU7QUFDMUMsUUFBSSxDQUFDLEtBQUsvRSxtQkFBVixFQUErQjtBQUMzQixZQUFNZ0YsT0FBTyxHQUFHO0FBQ1pDLFFBQUFBLE9BQU8sRUFBRTtBQUNMLDJCQUFrQixVQUFTLEtBQUsvRSxVQUFXLEVBRHRDO0FBRUwsMEJBQWdCO0FBRlgsU0FERztBQUtaZ0YsUUFBQUEsR0FBRyxFQUFHLEdBQUV4RyxZQUFhO0FBTFQsT0FBaEI7O0FBUUEsV0FBS1csT0FBTCxDQUFhb0MsSUFBYixDQUFtQiwyQ0FBbkI7O0FBQ0EsV0FBS3pCLG1CQUFMLEdBQTJCbUYsV0FBVyxDQUFDLE1BQU07QUFDekN2SCxRQUFBQSxPQUFPLENBQUNvSCxPQUFELEVBQVUsQ0FBQ3RCLEdBQUQsRUFBTTBCLEdBQU4sRUFBV0MsSUFBWCxLQUFvQjtBQUNqQyxjQUFJM0IsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXSyxRQUFYLENBQW9CcUIsR0FBRyxDQUFDRSxVQUF4QixDQUFaLEVBQWlEO0FBQzdDLGlCQUFLakcsT0FBTCxDQUFhc0UsSUFBYixDQUFtQixnREFBK0NELEdBQUksRUFBdEU7QUFDSCxXQUZELE1BRU87QUFDSCxrQkFBTTtBQUFFWCxjQUFBQTtBQUFGLGdCQUFld0MsSUFBSSxDQUFDQyxLQUFMLENBQVdILElBQVgsQ0FBckI7QUFDQSxrQkFBTUksZ0JBQWdCLEdBQUd4QyxNQUFNLENBQUNDLElBQVAsQ0FBWUgsUUFBWixFQUFzQjJDLE1BQXRCLENBQTZCbEUsRUFBRSxJQUFJQSxFQUFFLENBQUNtRSxLQUFILENBQVMsY0FBVCxDQUFuQyxDQUF6QjtBQUNBLGtCQUFNQyxVQUFVLEdBQUdILGdCQUFnQixDQUFDdEMsR0FBakIsQ0FBcUIzQixFQUFFLElBQ3RDLEtBQUtxRSx5QkFBTCxDQUErQnpILFdBQVcsQ0FBQzBILE1BQTNDLEVBQW1EdEUsRUFBbkQsQ0FEZSxDQUFuQjtBQUdBLGlCQUFLZCxpQkFBTCxHQUF5QmtGLFVBQXpCO0FBRUFILFlBQUFBLGdCQUFnQixDQUFDTSxPQUFqQixDQUF5QjNDLFNBQVMsSUFBSTtBQUNsQyxvQkFBTTRDLGFBQWEsR0FBR2pELFFBQVEsQ0FBQ0ssU0FBRCxDQUE5QjtBQUNBO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUM0QixrQkFBSXpGLENBQUMsQ0FBQ3NJLE9BQUYsQ0FBVUQsYUFBYSxDQUFDMUMsTUFBeEIsQ0FBSixFQUFxQyxPQUFPN0YsQ0FBQyxDQUFDLElBQUQsQ0FBUjs7QUFFckMsb0JBQU15SSxXQUFXLEdBQUcsS0FBS0MsMkJBQUwsQ0FBaUNILGFBQWpDLENBQXBCOztBQUVBLGtCQUFJLENBQUMsS0FBS3ZHLGFBQUwsQ0FBbUI0QyxHQUFuQixDQUF3QixhQUFZZSxTQUFVLEVBQTlDLENBQUwsRUFBdUQ7QUFDbkQscUJBQUsvRCxPQUFMLENBQWFvQyxJQUFiLENBQW1CLGdDQUErQjJCLFNBQVUsb0JBQTVEOztBQUNBLHFCQUFLZ0QsY0FBTCxDQUFvQkYsV0FBcEIsRUFDS2xGLElBREwsQ0FDVUUsT0FBTyxJQUFJO0FBQ2I7QUFDQSx1QkFBS0UsSUFBTCxDQUFVLGFBQVYsRUFBeUJGLE9BQXpCO0FBQ0EsdUJBQUtFLElBQUwsQ0FBVSxxQkFBVjtBQUNILGlCQUxMLEVBTUtpRixLQU5MLENBTVczQyxHQUFHLElBQUksS0FBS3JFLE9BQUwsQ0FBYWlILEdBQWIsQ0FBaUI1QyxHQUFqQixDQU5sQjtBQU9ILGVBVEQsTUFTTztBQUNILG9CQUFJNkMsT0FBTyxDQUFDQyxHQUFSLENBQVlDLFFBQVosSUFBd0JGLE9BQU8sQ0FBQ0MsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXJELEVBQW1FO0FBQy9EQyxrQkFBQUEsT0FBTyxDQUFDSixHQUFSLENBQWEsbUNBQWIsRUFBaURsRCxTQUFqRDtBQUNILGlCQUhFLENBSUg7OztBQUNBM0YsZ0JBQUFBLENBQUMsQ0FBQyxLQUFLZ0MsYUFBTCxDQUFtQjRDLEdBQW5CLENBQXdCLGFBQVllLFNBQVUsRUFBOUMsQ0FBRCxDQUFELENBQW9EcEMsSUFBcEQsQ0FBeURFLE9BQU8sSUFBSTtBQUNoRUEsa0JBQUFBLE9BQU8sQ0FBQ3lGLHFCQUFSLENBQThCVCxXQUE5QjtBQUNILGlCQUZEO0FBR0g7QUFDSixhQTdCRDtBQThCSDtBQUNKLFNBMUNNLENBQVA7QUEyQ0gsT0E1Q3FDLEVBNENuQ25CLFlBQVksR0FBRyxJQTVDb0IsQ0FBdEM7QUE2Q0g7QUFDSjs7QUFFRGhFLEVBQUFBLHNCQUFzQixHQUFHO0FBQ3JCLFVBQU02RixlQUFlLEdBQUcsS0FBS3BILHNCQUFMLENBQTRCcUgsb0JBQTVCLEVBQXhCOztBQUNBLFdBQU8sS0FBS0MsMkJBQUwsQ0FBaUNGLGVBQWpDLENBQVA7QUFDSDs7QUFFREUsRUFBQUEsMkJBQTJCLENBQUNDLElBQUQsRUFBTztBQUM5QixVQUFNQyxlQUFlLEdBQUcsRUFBeEI7O0FBRUEsVUFBTUMsU0FBUyxHQUFHdkQsR0FBRyxJQUFJO0FBQ3JCLFdBQUtyRSxPQUFMLENBQWFzRSxJQUFiLENBQWtCRCxHQUFsQjtBQUNILEtBRkQ7O0FBSUEsU0FBSyxNQUFNdEIsR0FBWCxJQUFrQjJFLElBQWxCLEVBQXdCO0FBQ3BCLFlBQU1HLFNBQVMsR0FBRyxLQUFLMUgsc0JBQUwsQ0FBNEJrQyxVQUE1QixDQUF1Q1UsR0FBdkMsQ0FBbEI7O0FBQ0EsWUFBTThELFdBQVcsR0FBRyxLQUFLaEMseUJBQUwsQ0FBK0JnRCxTQUEvQixDQUFwQjs7QUFDQUYsTUFBQUEsZUFBZSxDQUFDckYsSUFBaEIsQ0FBcUIsS0FBS3dGLHFCQUFMLENBQTJCakIsV0FBM0IsRUFBd0NnQixTQUFTLENBQUNFLGFBQWxELEVBQWlFZixLQUFqRSxDQUF1RVksU0FBdkUsQ0FBckI7QUFDSDs7QUFFRCxXQUFPeEosQ0FBQyxDQUFDc0UsVUFBRixDQUFhaUYsZUFBYixDQUFQO0FBQ0g7O0FBRUQ1QyxFQUFBQSxvQ0FBb0MsQ0FBQ2lELFlBQUQsRUFBZTtBQUMvQyxVQUFNTCxlQUFlLEdBQUcsRUFBeEI7O0FBRUEsVUFBTUMsU0FBUyxHQUFHdkQsR0FBRyxJQUFJO0FBQ3JCLFdBQUtyRSxPQUFMLENBQWFzRSxJQUFiLENBQWtCRCxHQUFsQjtBQUNILEtBRkQ7O0FBSUFULElBQUFBLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZbUUsWUFBWixFQUEwQmxFLEdBQTFCLENBQThCQyxTQUFTLElBQUk7QUFDdkMsWUFBTThELFNBQVMsR0FBRyxLQUFLMUgsc0JBQUwsQ0FBNEJrQyxVQUE1QixDQUF1QzBCLFNBQXZDLEtBQXFELEVBQXZFO0FBQ0E0RCxNQUFBQSxlQUFlLENBQUNyRixJQUFoQixDQUNJLEtBQUt3RixxQkFBTCxDQUEyQkUsWUFBWSxDQUFDakUsU0FBRCxDQUF2QyxFQUFvRDhELFNBQVMsQ0FBQ0UsYUFBOUQsRUFBNkVmLEtBQTdFLENBQW1GWSxTQUFuRixDQURKO0FBR0gsS0FMRDtBQU9BLFdBQU94SixDQUFDLENBQUNzRSxVQUFGLENBQWFpRixlQUFiLENBQVA7QUFDSDs7QUFFRHZELEVBQUFBLHlCQUF5QixDQUFDWCxZQUFELEVBQWU7QUFDcEMsVUFBTXVFLFlBQVksR0FBRyxFQUFyQjtBQUVBLFVBQU1DLFVBQVUsR0FBR3JFLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZSixZQUFaLENBQW5CO0FBQ0F3RSxJQUFBQSxVQUFVLENBQUNuRSxHQUFYLENBQWUzQixFQUFFLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBSTtBQUNBLGNBQU0wRSxXQUFXLEdBQUcsS0FBS0MsMkJBQUwsQ0FBaUNyRCxZQUFZLENBQUN0QixFQUFELENBQTdDLENBQXBCOztBQUNBNkYsUUFBQUEsWUFBWSxDQUFDbkIsV0FBVyxDQUFDOUQsR0FBYixDQUFaLEdBQWdDOEQsV0FBaEM7QUFDSCxPQUhELENBR0UsT0FBT3hDLEdBQVAsRUFBWTtBQUNWLGFBQUtyRSxPQUFMLENBQWFzRSxJQUFiLENBQW1CLDhCQUE2QjRELFlBQVksQ0FBQy9GLEVBQUQsQ0FBWixDQUFpQm1ELElBQUssS0FBSWpCLEdBQUksRUFBOUU7QUFDSDtBQUNKLEtBVkQ7QUFZQSxXQUFPMkQsWUFBUDtBQUNIOztBQUVEdkcsRUFBQUEsdUJBQXVCLENBQUM1QixLQUFELEVBQVE7QUFDM0IsVUFBTTJFLGtCQUFrQixHQUFHLEtBQUtyRSxzQkFBTCxDQUE0QnNFLGVBQTVCLENBQTRDNUUsS0FBNUMsQ0FBM0I7O0FBQ0EsV0FBTyxLQUFLNEgsMkJBQUwsQ0FBaUNqRCxrQkFBakMsQ0FBUDtBQUNIOztBQUVEZ0MsRUFBQUEseUJBQXlCLENBQUN0QyxRQUFELEVBQVdpRSxPQUFYLEVBQW9CO0FBQ3pDLFFBQUlDLEdBQUo7QUFDQSxRQUFJQyxHQUFKOztBQUVBLFFBQUluRSxRQUFRLEtBQUtuRixXQUFXLENBQUMwSCxNQUE3QixFQUFxQztBQUNqQzJCLE1BQUFBLEdBQUcsR0FBRyxNQUFOO0FBQ0FDLE1BQUFBLEdBQUcsR0FBRyxNQUFOO0FBQ0gsS0FIRCxNQUdPO0FBQ0hELE1BQUFBLEdBQUcsR0FBRyxNQUFOO0FBQ0FDLE1BQUFBLEdBQUcsR0FBSSxPQUFNbkUsUUFBUSxDQUFDb0UsS0FBVCxDQUFlLEdBQWYsRUFBb0IsQ0FBcEIsQ0FBdUIsRUFBOUIsQ0FBZ0NDLEtBQWhDLENBQXNDLENBQUMsQ0FBdkMsQ0FBTjtBQUNIOztBQUVELFdBQU8sQ0FBQ0gsR0FBRCxFQUFNQyxHQUFOLEVBQVdGLE9BQVgsRUFBb0JLLElBQXBCLENBQXlCLEdBQXpCLENBQVA7QUFDSDs7QUFFRDFCLEVBQUFBLDJCQUEyQixDQUFDSCxhQUFELEVBQWdCO0FBQ3ZDLFVBQU1FLFdBQVcsR0FBRyxJQUFJckksU0FBUyxDQUFDaUssV0FBZCxFQUFwQjtBQUNBNUIsSUFBQUEsV0FBVyxDQUFDdkIsSUFBWixHQUFtQnFCLGFBQWEsQ0FBQ3JCLElBQWpDO0FBQ0F1QixJQUFBQSxXQUFXLENBQUM2QixPQUFaLEdBQXNCL0IsYUFBYSxDQUFDMUMsTUFBZCxDQUFxQjBFLEVBQTNDO0FBQ0E5QixJQUFBQSxXQUFXLENBQUM5RCxHQUFaLEdBQWtCLEtBQUt5RCx5QkFBTCxDQUErQkcsYUFBYSxDQUFDMUMsTUFBZCxDQUFxQkMsUUFBcEQsRUFBOER5QyxhQUFhLENBQUNpQyxVQUE1RSxDQUFsQjtBQUNBL0IsSUFBQUEsV0FBVyxDQUFDekUsSUFBWixHQUFtQnVFLGFBQWEsQ0FBQzFDLE1BQWpDO0FBQ0E0QyxJQUFBQSxXQUFXLENBQUNnQyxRQUFaLEdBQXVCMUosYUFBYSxDQUFDd0gsYUFBRCxDQUFwQztBQUVBLFdBQU9FLFdBQVA7QUFDSDs7QUFFRGhDLEVBQUFBLHlCQUF5QixDQUFDZ0QsU0FBRCxFQUFZO0FBQ2pDLFVBQU1oQixXQUFXLEdBQUcsSUFBSXJJLFNBQVMsQ0FBQ2lLLFdBQWQsRUFBcEI7QUFDQTVCLElBQUFBLFdBQVcsQ0FBQ3ZCLElBQVosR0FBbUJ1QyxTQUFTLENBQUMvQyxZQUFWLENBQXVCUSxJQUExQztBQUNBdUIsSUFBQUEsV0FBVyxDQUFDNkIsT0FBWixHQUFzQmIsU0FBUyxDQUFDL0MsWUFBVixDQUF1QjRELE9BQTdDO0FBQ0E3QixJQUFBQSxXQUFXLENBQUM5RCxHQUFaLEdBQWtCOEUsU0FBUyxDQUFDL0MsWUFBVixDQUF1Qi9CLEdBQXpDO0FBQ0E4RCxJQUFBQSxXQUFXLENBQUN6RSxJQUFaLEdBQW1CeUYsU0FBUyxDQUFDL0MsWUFBVixDQUF1QjFDLElBQTFDO0FBQ0F5RSxJQUFBQSxXQUFXLENBQUNnQyxRQUFaLEdBQXVCMUosYUFBYSxDQUFDMEksU0FBUyxDQUFDL0MsWUFBWCxDQUFwQztBQUVBLFdBQU8rQixXQUFQO0FBQ0g7O0FBRURpQixFQUFBQSxxQkFBcUIsQ0FBQ2pCLFdBQUQsRUFBY2tCLGFBQWQsRUFBNkI7QUFDOUMsVUFBTWxHLE9BQU8sR0FBRyxLQUFLekIsYUFBTCxDQUFtQjRDLEdBQW5CLENBQXVCNkQsV0FBVyxDQUFDOUQsR0FBbkMsQ0FBaEI7O0FBRUEsUUFBSWxCLE9BQUosRUFBYTtBQUNUO0FBQ0E7QUFDQTtBQUNBQSxNQUFBQSxPQUFPLENBQUN5RixxQkFBUixDQUE4QlQsV0FBOUI7QUFDQSxhQUFPLEtBQUsxRyxzQkFBTCxDQUE0QjJJLGdCQUE1QixDQUE2Q2pDLFdBQTdDLEVBQTBEbEYsSUFBMUQsQ0FBK0QsTUFBTTtBQUN4RSxlQUFPRSxPQUFQO0FBQ0gsT0FGTSxDQUFQO0FBR0g7O0FBRUQsV0FBTyxLQUFLa0YsY0FBTCxDQUFvQkYsV0FBcEIsRUFBaUNrQixhQUFqQyxFQUFnRHBHLElBQWhELENBQXFERSxPQUFPLElBQUk7QUFDbkVBLE1BQUFBLE9BQU8sQ0FBQ2tILFFBQVIsQ0FBaUJsSyxnQkFBZ0IsQ0FBQ21LLFlBQWxDOztBQUNBLFdBQUtsSSxnQkFBTCxDQUFzQndCLElBQXRCLENBQTJCVCxPQUFPLENBQUNvSCxLQUFSLEVBQTNCOztBQUNBLGFBQU9wSCxPQUFQO0FBQ0gsS0FKTSxDQUFQO0FBS0g7O0FBRURRLEVBQUFBLFVBQVUsQ0FBQ1UsR0FBRCxFQUFNO0FBQ1osV0FBTyxLQUFLM0MsYUFBTCxDQUFtQjRDLEdBQW5CLENBQXVCRCxHQUF2QixDQUFQO0FBQ0g7O0FBRURqQixFQUFBQSxXQUFXLEdBQUc7QUFDVixXQUFPLEtBQUsxQixhQUFMLENBQW1COEksT0FBbkIsRUFBUDtBQUNIOztBQUVEekQsRUFBQUEsYUFBYSxHQUFHO0FBQ1o7QUFDQTtBQUVBLFVBQU1sRSxJQUFJLEdBQUcsSUFBYjs7QUFDQSxRQUFJLENBQUNBLElBQUksQ0FBQ2YsZUFBTixJQUF5QixDQUFDZSxJQUFJLENBQUNmLGVBQUwsQ0FBcUIySSxTQUFyQixFQUE5QixFQUFnRTtBQUM1RDVILE1BQUFBLElBQUksQ0FBQ2Isa0JBQUwsR0FBMEIwSSxVQUFVLENBQUMsWUFBVztBQUM1QzdILFFBQUFBLElBQUksQ0FBQ2Isa0JBQUwsR0FBMEIsSUFBMUI7QUFDQXRDLFFBQUFBLENBQUMsQ0FBQ21ELElBQUksQ0FBQ2hCLE9BQUwsQ0FBYTZDLG1CQUFiLEVBQUQsQ0FBRCxDQUFzQ2lHLElBQXRDO0FBQ0gsT0FIbUMsRUFHakMsSUFIaUMsQ0FBcEM7QUFLQTlILE1BQUFBLElBQUksQ0FBQ2YsZUFBTCxHQUF1QnBDLENBQUMsQ0FDcEJtRCxJQUFJLENBQUNoQixPQUFMLENBQWErSSxZQUFiLENBQTBCLFVBQVN6QyxXQUFULEVBQXNCO0FBQzVDLFlBQUkwQyxjQUFKLENBRDRDLENBRTVDOztBQUNBLFlBQUksQ0FBQ2hJLElBQUksQ0FBQ25CLGFBQUwsQ0FBbUI0QyxHQUFuQixDQUF1QjZELFdBQVcsQ0FBQzlELEdBQW5DLENBQUwsRUFBOEM7QUFDMUN3RyxVQUFBQSxjQUFjLEdBQUdoSSxJQUFJLENBQUN3RixjQUFMLENBQW9CRixXQUFwQixFQUFpQ0csS0FBakMsQ0FBdUMsVUFBUzNDLEdBQVQsRUFBYztBQUNsRTlDLFlBQUFBLElBQUksQ0FBQ3ZCLE9BQUwsQ0FBYWlILEdBQWIsQ0FBaUI1QyxHQUFqQjtBQUNILFdBRmdCLENBQWpCO0FBR0gsU0FKRCxNQUlPO0FBQ0hrRixVQUFBQSxjQUFjLEdBQUduTCxDQUFDLENBQUNtRCxJQUFJLENBQUNuQixhQUFMLENBQW1CNEMsR0FBbkIsQ0FBdUI2RCxXQUFXLENBQUM5RCxHQUFuQyxDQUFELENBQWxCO0FBQ0g7O0FBRUR3RyxRQUFBQSxjQUFjLENBQUM1SCxJQUFmLENBQW9CLFVBQVNFLE9BQVQsRUFBa0I7QUFDbEMsZ0JBQU0ySCxpQkFBaUIsR0FBR2pJLElBQUksQ0FBQ2pCLG1CQUFMLENBQXlCMEMsR0FBekIsQ0FBNkI2RCxXQUFXLENBQUM5RCxHQUF6QyxDQUExQixDQURrQyxDQUVsQzs7O0FBQ0EsY0FBSWxCLE9BQU8sQ0FBQzRILFNBQVIsR0FBb0JDLEtBQXBCLEtBQThCN0ssZ0JBQWdCLENBQUM4SyxPQUFuRCxFQUE0RDtBQUN4RCxnQkFBSXBJLElBQUksQ0FBQ1QsZ0JBQUwsQ0FBc0I4SSxPQUF0QixDQUE4Qi9DLFdBQVcsQ0FBQzlELEdBQTFDLE1BQW1ELENBQUMsQ0FBeEQsRUFBMkQ7QUFDdkRsQixjQUFBQSxPQUFPLENBQUNrSCxRQUFSLENBQWlCbEssZ0JBQWdCLENBQUNtSyxZQUFsQztBQUNILGFBRkQsTUFFTztBQUNIbkgsY0FBQUEsT0FBTyxDQUFDa0gsUUFBUixDQUFpQmxLLGdCQUFnQixDQUFDZ0wsZUFBbEM7QUFDSDtBQUNKOztBQUNETCxVQUFBQSxpQkFBaUIsQ0FBQ00sVUFBbEIsQ0FBNkJqRCxXQUE3QjtBQUNILFNBWEQ7QUFZSCxPQXZCRCxDQURvQixDQUF4QixDQU40RCxDQWlDNUQ7O0FBQ0F0RixNQUFBQSxJQUFJLENBQUNmLGVBQUwsQ0FBcUJ1SixZQUFyQixHQUFvQyxZQUFXO0FBQzNDeEksUUFBQUEsSUFBSSxDQUFDeUksaUJBQUw7O0FBRUF6SSxRQUFBQSxJQUFJLENBQUNkLG1CQUFMLEdBQTJCMkksVUFBVSxDQUFDLFlBQVc7QUFDN0M3SCxVQUFBQSxJQUFJLENBQUNkLG1CQUFMLEdBQTJCLElBQTNCOztBQUNBYyxVQUFBQSxJQUFJLENBQUNrRSxhQUFMO0FBQ0gsU0FIb0MsRUFHbEMsSUFIa0MsQ0FBckM7QUFJSCxPQVBEOztBQVFBbEUsTUFBQUEsSUFBSSxDQUFDZixlQUFMLENBQXFCMEMseUJBQXJCLEdBQWlELFlBQVc7QUFDeEQzQixRQUFBQSxJQUFJLENBQUNmLGVBQUwsQ0FBcUJ1SixZQUFyQixHQUFvQyxJQUFwQztBQUNILE9BRkQ7O0FBSUF4SSxNQUFBQSxJQUFJLENBQUNmLGVBQUwsQ0FDS21CLElBREwsQ0FDVSxZQUFXO0FBQ2IsWUFBSUosSUFBSSxDQUFDZixlQUFMLENBQXFCdUosWUFBekIsRUFBdUM7QUFDbkN4SSxVQUFBQSxJQUFJLENBQUNmLGVBQUwsQ0FBcUJ1SixZQUFyQjtBQUNIO0FBQ0osT0FMTCxFQU1LL0MsS0FOTCxDQU1XLFVBQVMzQyxHQUFULEVBQWM7QUFDakI5QyxRQUFBQSxJQUFJLENBQUN2QixPQUFMLENBQWFpSyxLQUFiLENBQW1CNUYsR0FBbkI7QUFDSCxPQVJMLEVBU0tnRixJQVRMO0FBVUg7QUFDSjs7QUFFRFcsRUFBQUEsaUJBQWlCLEdBQUc7QUFDaEIsVUFBTXpJLElBQUksR0FBRyxJQUFiOztBQUVBLFNBQUssTUFBTTJJLElBQVgsSUFBbUIzSSxJQUFJLENBQUNqQixtQkFBeEIsRUFBNkM7QUFDekMsWUFBTTZKLEdBQUcsR0FBR0QsSUFBSSxDQUFDLENBQUQsQ0FBaEI7QUFDQSxZQUFNRSxHQUFHLEdBQUdGLElBQUksQ0FBQyxDQUFELENBQWhCO0FBQ0FFLE1BQUFBLEdBQUcsQ0FBQ0MsZ0JBQUosR0FDS3JELEtBREwsQ0FDVyxVQUFTM0MsR0FBVCxFQUFjO0FBQ2pCLFlBQUlBLEdBQUcsQ0FBQ2lHLElBQVIsRUFBYztBQUNWLGdCQUFNekksT0FBTyxHQUFHTixJQUFJLENBQUNuQixhQUFMLENBQW1CNEMsR0FBbkIsQ0FBdUJtSCxHQUF2QixDQUFoQixDQURVLENBRVY7OztBQUNBdEksVUFBQUEsT0FBTyxDQUFDMEksUUFBUixDQUFpQjNMLE1BQU0sQ0FBQzRMLGNBQVAsQ0FBc0JuRyxHQUFHLENBQUNpRyxJQUExQixDQUFqQjs7QUFDQS9JLFVBQUFBLElBQUksQ0FBQ3ZCLE9BQUwsQ0FBYWlLLEtBQWIsQ0FBbUI1RixHQUFuQjtBQUNIO0FBQ0osT0FSTCxFQVNLZ0YsSUFUTDtBQVVIO0FBQ0o7O0FBRURvQixFQUFBQSxtQkFBbUIsQ0FBQ0MsVUFBRCxFQUFhQyxVQUFiLEVBQXlCO0FBQ3hDLFVBQU1wSixJQUFJLEdBQUcsSUFBYjtBQUVBLFdBQU9uRCxDQUFDLENBQUMsS0FBS21FLHVCQUFMLENBQTZCbUksVUFBN0IsRUFBeUNDLFVBQXpDLENBQUQsQ0FBRCxDQUF3RGhKLElBQXhELENBQTZELFVBQVNFLE9BQVQsRUFBa0I7QUFDbEZOLE1BQUFBLElBQUksQ0FBQ3BCLHNCQUFMLENBQTRCeUssY0FBNUIsQ0FBMkMvSSxPQUFPLENBQUNvSCxLQUFSLEVBQTNDLEVBQTREeUIsVUFBNUQsRUFBd0VDLFVBQXhFLEVBQW9GcEosSUFBSSxDQUFDVixVQUF6Rjs7QUFDQSxhQUFPZ0IsT0FBUDtBQUNILEtBSE0sQ0FBUDtBQUlIOztBQUVEVSxFQUFBQSx1QkFBdUIsQ0FBQ21JLFVBQUQsRUFBYUMsVUFBYixFQUF5QjtBQUM1QyxXQUFPLEtBQUs1SyxpQkFBTCxDQUF1QjhLLFNBQXZCLENBQWlDLFVBQWpDLEVBQTZDRixVQUE3QyxFQUF5RGhKLElBQXpELENBQThEYyxNQUFNLElBQUk7QUFDM0UsWUFBTVosT0FBTyxHQUFHLElBQUlwRCxnQkFBSixDQUFxQmlNLFVBQXJCLEVBQWlDakksTUFBakMsQ0FBaEI7O0FBQ0EsV0FBSzNCLGdCQUFMLENBQXNCd0IsSUFBdEIsQ0FBMkJULE9BQU8sQ0FBQ29ILEtBQVIsRUFBM0I7O0FBQ0EsV0FBSzdJLGFBQUwsR0FBcUIsS0FBS0EsYUFBTCxDQUFtQjBLLEdBQW5CLENBQXVCakosT0FBTyxDQUFDb0gsS0FBUixFQUF2QixFQUF3Q3BILE9BQXhDLENBQXJCO0FBQ0EsYUFBT0EsT0FBUDtBQUNILEtBTE0sQ0FBUDtBQU1IOztBQUVEa0osRUFBQUEscUJBQXFCLENBQUNsSixPQUFELEVBQVU7QUFDM0JBLElBQUFBLE9BQU8sQ0FBQ21KLG1CQUFSLENBQTRCQyxFQUE1QixDQUErQixrQkFBL0IsRUFBbUQsTUFBTTtBQUNyRCxZQUFNQyxZQUFZLEdBQUdoTSxJQUFJLENBQUNpTSxzQkFBTCxDQUE0QnRKLE9BQTVCLENBQXJCO0FBQ0EsWUFBTXVKLFdBQVcsR0FBR3ZKLE9BQU8sQ0FBQ3dKLGlCQUFSLEVBQXBCOztBQUVBLFVBQUlELFdBQVcsS0FBS3RNLG1CQUFtQixDQUFDd00sR0FBeEMsRUFBNkM7QUFDekMsYUFBS3BMLGdCQUFMLENBQXNCcUwsUUFBdEIsQ0FBK0JqTixDQUFDLENBQUNrTixLQUFGLENBQVE7QUFBRWxHLFVBQUFBLElBQUksRUFBRTtBQUFSLFNBQVIsRUFBdUM0RixZQUF2QyxDQUEvQjtBQUNIO0FBQ0osS0FQRDtBQVNBckosSUFBQUEsT0FBTyxDQUFDbUosbUJBQVIsQ0FBNEJDLEVBQTVCLENBQStCLGNBQS9CLEVBQStDNUcsR0FBRyxJQUFJO0FBQ2xEZ0QsTUFBQUEsT0FBTyxDQUFDSixHQUFSLENBQWEsR0FBRXBGLE9BQU8sQ0FBQzRKLE9BQVIsRUFBa0IsTUFBS3BILEdBQUksa0JBQWlCeEMsT0FBTyxDQUFDd0osaUJBQVIsRUFBNEIsRUFBdkY7QUFFQTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ1ksVUFBSXhKLE9BQU8sQ0FBQ3dKLGlCQUFSLE9BQWdDdk0sbUJBQW1CLENBQUN3TSxHQUF4RCxFQUE2RDtBQUN6RCxZQUFJekosT0FBTyxDQUFDNkosWUFBUixFQUFKLEVBQTRCO0FBQ3hCLGVBQUtDLE9BQUwsQ0FBYTlKLE9BQU8sQ0FBQzZKLFlBQVIsRUFBYjtBQUNBN0osVUFBQUEsT0FBTyxDQUFDa0gsUUFBUixDQUFpQmxLLGdCQUFnQixDQUFDbUssWUFBbEM7O0FBQ0EsZUFBS2hKLE9BQUwsQ0FBYWlILEdBQWIsQ0FDSyxHQUFFbkksbUJBQW1CLENBQUN3TSxHQUFJLHNDQUFxQ3pKLE9BQU8sQ0FBQzRKLE9BQVIsRUFBa0IsT0FDOUUzTSxtQkFBbUIsQ0FBQzhNLE9BQ3ZCLE9BQU0vSixPQUFPLENBQUM2SixZQUFSLEVBQXVCLEtBSGxDOztBQUtBLGlCQUFPN0osT0FBTyxDQUFDbUosbUJBQVIsQ0FBNEJqSixJQUE1QixDQUFpQyxjQUFqQyxFQUFpRCxLQUFqRCxDQUFQO0FBQ0g7O0FBQ0QsZUFBT0YsT0FBTyxDQUFDbUosbUJBQVIsQ0FBNEJqSixJQUE1QixDQUFpQyxjQUFqQyxFQUFpRCxJQUFqRCxDQUFQO0FBQ0g7O0FBQ0QsVUFBSUYsT0FBTyxDQUFDd0osaUJBQVIsT0FBZ0N2TSxtQkFBbUIsQ0FBQzhNLE9BQXhELEVBQWlFO0FBQzdELGNBQU1WLFlBQVksR0FBR2hNLElBQUksQ0FBQ2lNLHNCQUFMLENBQTRCdEosT0FBNUIsQ0FBckI7O0FBQ0EsYUFBSzNCLGdCQUFMLENBQXNCcUwsUUFBdEIsQ0FBK0JqTixDQUFDLENBQUNrTixLQUFGLENBQVE7QUFBRWxHLFVBQUFBLElBQUksRUFBRTtBQUFSLFNBQVIsRUFBdUQ0RixZQUF2RCxDQUEvQjs7QUFFQSxZQUFJLEtBQUtySyxVQUFULEVBQXFCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBTWdMLGVBQWUsR0FBRyxLQUFLdkwsbUJBQUwsQ0FDbkIwQyxHQURtQixDQUNmbkIsT0FBTyxDQUFDb0gsS0FBUixFQURlLEVBRW5CNkMsYUFGbUIsQ0FFTDlJLEdBRkssQ0FFRGxFLG1CQUFtQixDQUFDOE0sT0FGbkIsQ0FBeEI7O0FBR0EsZ0JBQU07QUFBRWxELFlBQUFBLE9BQUY7QUFBV3RHLFlBQUFBO0FBQVgsY0FBb0J5SixlQUExQjtBQUVBaEssVUFBQUEsT0FBTyxDQUFDa0gsUUFBUixDQUFpQmxLLGdCQUFnQixDQUFDbUssWUFBbEM7QUFDQTZDLFVBQUFBLGVBQWUsQ0FBQ25ELE9BQWhCLEdBQTBCLGtDQUFrQ3FELElBQWxDLENBQXVDckQsT0FBdkMsSUFDcEJBLE9BRG9CLEdBRXBCQSxPQUFPLENBQUNKLEtBQVIsQ0FBYyxHQUFkLEVBQW1CLENBQW5CLENBRk47QUFHQXVELFVBQUFBLGVBQWUsQ0FBQ3pKLElBQWhCLEdBQXVCO0FBQUU4QixZQUFBQSxRQUFRLEVBQUU5QixJQUFJLENBQUM4QjtBQUFqQixXQUF2QjtBQUNBMkgsVUFBQUEsZUFBZSxDQUFDaEQsUUFBaEIsR0FBMkIvSixtQkFBbUIsQ0FBQ2tOLFNBQS9DOztBQUVBLGVBQUtoTSxPQUFMLENBQWFpSCxHQUFiLENBQ0ssR0FDR25JLG1CQUFtQixDQUFDOE0sT0FDdkIsc0NBQXFDL0osT0FBTyxDQUFDNEosT0FBUixFQUFrQix1QkFINUQ7O0FBTUEsZUFBSzFFLGNBQUwsQ0FBb0I4RSxlQUFwQixFQUFxQ2xLLElBQXJDLENBQTBDRSxPQUFPLElBQUk7QUFDakQsaUJBQUt2QixtQkFBTCxDQUF5QjBDLEdBQXpCLENBQTZCNkksZUFBZSxDQUFDOUksR0FBN0MsRUFBa0QrRyxVQUFsRCxDQUE2RCtCLGVBQTdEOztBQUNBLGdCQUFJO0FBQ0EsbUJBQUtJLGNBQUwsQ0FBb0JKLGVBQXBCO0FBQ0EscUJBQU9oSyxPQUFPLENBQUNtSixtQkFBUixDQUE0QmpKLElBQTVCLENBQWlDLGNBQWpDLEVBQWlELEtBQWpELENBQVA7QUFDSCxhQUhELENBR0UsT0FBT3NDLEdBQVAsRUFBWTtBQUNWZ0QsY0FBQUEsT0FBTyxDQUFDSixHQUFSLENBQVk1QyxHQUFaO0FBQ0g7QUFDSixXQVJEO0FBU0g7O0FBRUQsZUFBT3hDLE9BQU8sQ0FBQ21KLG1CQUFSLENBQTRCakosSUFBNUIsQ0FBaUMsY0FBakMsRUFBaUQsSUFBakQsQ0FBUDtBQUNIO0FBQ0osS0FyRUQsRUFWMkIsQ0FpRjNCO0FBQ0E7QUFDQTs7QUFDQTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLSzs7QUFFRGdGLEVBQUFBLGNBQWMsQ0FBQ0YsV0FBRCxFQUFja0IsYUFBZCxFQUE2QjtBQUN2QyxVQUFNeEcsSUFBSSxHQUFHLElBQWI7O0FBQ0EsUUFBSXNGLFdBQVcsQ0FBQ3pFLElBQVosQ0FBaUI4QixRQUFqQixLQUE4Qm5GLFdBQVcsQ0FBQzBILE1BQTlDLEVBQXNEO0FBQ2xELGFBQU9sRixJQUFJLENBQUMySyxVQUFMLENBQWdCckYsV0FBVyxDQUFDekUsSUFBWixDQUFpQjhCLFFBQWpDLEVBQTJDdkMsSUFBM0MsQ0FBZ0QsVUFBU2MsTUFBVCxFQUFpQjtBQUNwRSxjQUFNWixPQUFPLEdBQUcsSUFBSWxELGFBQUosQ0FBa0JrSSxXQUFsQixFQUErQnBFLE1BQS9CLEVBQXVDbEIsSUFBSSxDQUFDVixVQUE1QyxFQUF3RFUsSUFBeEQsQ0FBaEI7QUFDQUEsUUFBQUEsSUFBSSxDQUFDbkIsYUFBTCxHQUFxQm1CLElBQUksQ0FBQ25CLGFBQUwsQ0FBbUIwSyxHQUFuQixDQUF1QmpFLFdBQVcsQ0FBQzlELEdBQW5DLEVBQXdDbEIsT0FBeEMsQ0FBckI7O0FBQ0FOLFFBQUFBLElBQUksQ0FBQ3dKLHFCQUFMLENBQTJCbEosT0FBM0I7O0FBQ0EsZUFBT0EsT0FBUDtBQUNILE9BTE0sQ0FBUDtBQU1IOztBQUNELFVBQU0ySCxpQkFBaUIsR0FBRyxJQUFJdkssaUJBQUosRUFBMUI7QUFDQXVLLElBQUFBLGlCQUFpQixDQUFDTSxVQUFsQixDQUE2QmpELFdBQTdCO0FBQ0F0RixJQUFBQSxJQUFJLENBQUNqQixtQkFBTCxHQUEyQmlCLElBQUksQ0FBQ2pCLG1CQUFMLENBQXlCd0ssR0FBekIsQ0FBNkJqRSxXQUFXLENBQUM5RCxHQUF6QyxFQUE4Q3lHLGlCQUE5QyxDQUEzQixDQVp1QyxDQWN2Qzs7QUFDQUEsSUFBQUEsaUJBQWlCLENBQUN5QixFQUFsQixDQUFxQixXQUFyQixFQUFrQyxVQUFTcEUsV0FBVCxFQUFzQnNGLFlBQXRCLEVBQW9DO0FBQ2xFNUssTUFBQUEsSUFBSSxDQUFDMEssY0FBTCxDQUFvQnBGLFdBQXBCLEVBQWlDdUYsT0FBakMsQ0FBeUNELFlBQXpDO0FBQ0gsS0FGRDtBQUdBM0MsSUFBQUEsaUJBQWlCLENBQUN5QixFQUFsQixDQUNJLFFBREosRUFFSSxVQUFTcEUsV0FBVCxFQUFzQjtBQUNsQjtBQUNBLFVBQUl0RixJQUFJLENBQUNwQixzQkFBTCxDQUE0QmtDLFVBQTVCLENBQXVDd0UsV0FBVyxDQUFDOUQsR0FBbkQsQ0FBSixFQUNJeEIsSUFBSSxDQUFDcEIsc0JBQUwsQ0FBNEIySSxnQkFBNUIsQ0FBNkNqQyxXQUE3QztBQUNQLEtBTkwsRUFPSSxJQVBKO0FBVUEsV0FBT3RGLElBQUksQ0FBQzJLLFVBQUwsQ0FBZ0JyRixXQUFXLENBQUN6RSxJQUFaLENBQWlCOEIsUUFBakMsRUFBMkN2QyxJQUEzQyxDQUFnRCxVQUFTYyxNQUFULEVBQWlCO0FBQ3BFLFlBQU1aLE9BQU8sR0FBRyxJQUFJbkQsZUFBSixDQUFvQm1JLFdBQXBCLEVBQWlDcEUsTUFBakMsRUFBeUNzRixhQUF6QyxFQUF3RHlCLGlCQUF4RCxDQUFoQjtBQUNBakksTUFBQUEsSUFBSSxDQUFDbkIsYUFBTCxHQUFxQm1CLElBQUksQ0FBQ25CLGFBQUwsQ0FBbUIwSyxHQUFuQixDQUF1QmpFLFdBQVcsQ0FBQzlELEdBQW5DLEVBQXdDbEIsT0FBeEMsQ0FBckI7O0FBQ0FOLE1BQUFBLElBQUksQ0FBQ3dKLHFCQUFMLENBQTJCbEosT0FBM0I7O0FBRUEsYUFBT0EsT0FBUDtBQUNILEtBTk0sQ0FBUDtBQU9IOztBQUVEcUssRUFBQUEsVUFBVSxDQUFDaEksUUFBRCxFQUFXO0FBQ2pCLFVBQU15RyxVQUFVLEdBQUd6TCxJQUFJLENBQUNtTixlQUFMLENBQXFCbkksUUFBckIsQ0FBbkI7QUFDQSxXQUFPLEtBQUtuRSxpQkFBTCxDQUF1QjhLLFNBQXZCLENBQWlDLFVBQWpDLEVBQTZDRixVQUE3QyxFQUF5RHpHLFFBQXpELENBQVA7QUFDSDs7QUFFRHlILEVBQUFBLE9BQU8sQ0FBQ2hELEVBQUQsRUFBSztBQUNSLFVBQU1wSCxJQUFJLEdBQUcsSUFBYjtBQUVBLFdBQU9uRCxDQUFDLENBQUNtRCxJQUFJLENBQUNoQixPQUFMLENBQWErTCxRQUFiLENBQXNCM0QsRUFBdEIsQ0FBRCxDQUFELENBQTZCaEgsSUFBN0IsQ0FBa0MsVUFBU2tGLFdBQVQsRUFBc0I7QUFDM0Q7QUFDQSxVQUFJLENBQUM5SCxXQUFXLENBQUNvRixjQUFaLENBQTJCMEMsV0FBVyxDQUFDekUsSUFBWixDQUFpQjhCLFFBQTVDLENBQUwsRUFBNEQ7QUFFNUQsVUFBSXJDLE9BQU8sR0FBRzBLLFNBQWQ7O0FBQ0EsWUFBTTNILGFBQWEsR0FBR3JELElBQUksQ0FBQ25CLGFBQUwsQ0FBbUI0QyxHQUFuQixDQUF1QjZELFdBQVcsQ0FBQzlELEdBQW5DLENBQXRCOztBQUVBbEIsTUFBQUEsT0FBTyxHQUFHekMsZUFBZSxDQUFDd0YsYUFBRCxFQUFnQmlDLFdBQWhCLENBQWYsSUFBK0MsQ0FBL0MsR0FBbURqQyxhQUFuRCxHQUFtRS9DLE9BQTdFO0FBRUEsWUFBTTBILGNBQWMsR0FBRzFILE9BQU8sR0FBR3pELENBQUMsQ0FBQ3lELE9BQUQsQ0FBSixHQUFnQk4sSUFBSSxDQUFDd0YsY0FBTCxDQUFvQkYsV0FBcEIsQ0FBOUM7QUFFQSxhQUFPMEMsY0FBYyxDQUFDNUgsSUFBZixDQUFvQixVQUFTRSxPQUFULEVBQWtCO0FBQ3pDLFlBQUlBLE9BQU8sQ0FBQzJLLGVBQVIsRUFBSixFQUErQixPQUFPM0ssT0FBUDs7QUFFL0JOLFFBQUFBLElBQUksQ0FBQ2pCLG1CQUFMLENBQXlCMEMsR0FBekIsQ0FBNkI2RCxXQUFXLENBQUM5RCxHQUF6QyxFQUE4QytHLFVBQTlDLENBQXlEakQsV0FBekQsRUFIeUMsQ0FJekM7QUFDQTs7O0FBQ0EsWUFBSTtBQUNBLGlCQUFPdEYsSUFBSSxDQUFDMEssY0FBTCxDQUFvQnBGLFdBQXBCLENBQVA7QUFDSCxTQUZELENBRUUsT0FBT3hDLEdBQVAsRUFBWTtBQUNWLGlCQUFPeEMsT0FBUDtBQUNIO0FBQ0osT0FYTSxDQUFQO0FBWUgsS0F2Qk0sQ0FBUDtBQXdCSDs7QUFFRGIsRUFBQUEsaUJBQWlCLEdBQUc7QUFDaEIsU0FBS2hCLE9BQUwsQ0FBYW9DLElBQWIsQ0FBbUIsMEJBQW5CLEVBRGdCLENBRWhCO0FBQ0E7OztBQUNBLFNBQUt0QixnQkFBTCxDQUFzQjRGLE9BQXRCLENBQThCM0QsR0FBRyxJQUFJO0FBQ2pDLFlBQU1sQixPQUFPLEdBQUcsS0FBS3pCLGFBQUwsQ0FBbUI0QyxHQUFuQixDQUF1QkQsR0FBdkIsQ0FBaEI7O0FBQ0EsVUFBSWxCLE9BQU8sQ0FBQ3dKLGlCQUFSLE9BQWdDdk0sbUJBQW1CLENBQUMyTixTQUF4RCxFQUFtRTs7QUFFbkUsVUFBSSxDQUFDNUssT0FBTyxDQUFDNkssZUFBUixFQUFMLEVBQWdDO0FBQzVCLGFBQUt2TCx5QkFBTCxDQUErQjRCLEdBQS9CLEVBQW9DbEIsT0FBcEM7QUFDSCxPQUZELE1BRU87QUFDSCxhQUFLVCx1QkFBTCxDQUE2QlMsT0FBN0I7QUFDSDtBQUNKLEtBVEQ7QUFVSDs7QUFFRFYsRUFBQUEseUJBQXlCLENBQUM0QixHQUFELEVBQU1sQixPQUFOLEVBQWU7QUFDcEMsVUFBTThLLGVBQWUsR0FBRyxLQUFLck0sbUJBQUwsQ0FBeUIwQyxHQUF6QixDQUE2QkQsR0FBN0IsQ0FBeEI7O0FBQ0EsVUFBTTtBQUFFNkosTUFBQUE7QUFBRixRQUF1QkQsZUFBN0I7O0FBQ0EsVUFBTTlGLFdBQVcsR0FBRzhGLGVBQWUsQ0FBQ2IsYUFBaEIsQ0FBOEI5SSxHQUE5QixDQUFrQzRKLGdCQUFsQyxDQUFwQjs7QUFFQSxRQUFJL0YsV0FBSixFQUFpQjtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQUs3RyxPQUFMLENBQWFvQyxJQUFiLENBQW1CLGdCQUFlUCxPQUFPLENBQUM0SixPQUFSLEVBQWtCLGdCQUFlNUUsV0FBVyxDQUFDZ0MsUUFBUyxFQUF4Rjs7QUFDQSxXQUFLb0QsY0FBTCxDQUFvQnBGLFdBQXBCO0FBQ0g7QUFDSjs7QUFFRHpGLEVBQUFBLHVCQUF1QixDQUFDUyxPQUFELEVBQVU7QUFDN0IsVUFBTThELE9BQU8sR0FBRztBQUNaQyxNQUFBQSxPQUFPLEVBQUU7QUFDTCx5QkFBa0IsVUFBUyxLQUFLL0UsVUFBVyxFQUR0QztBQUVMLHdCQUFnQjtBQUZYLE9BREc7QUFLWmdGLE1BQUFBLEdBQUcsRUFBRyxHQUFFeEcsWUFBYSxhQUFZd0MsT0FBTyxDQUFDZ0wsVUFBUixFQUFxQjtBQUwxQyxLQUFoQjtBQVFBdE8sSUFBQUEsT0FBTyxDQUFDb0gsT0FBRCxFQUFVLENBQUN0QixHQUFELEVBQU0wQixHQUFOLEVBQVdDLElBQVgsS0FBb0I7QUFDakMsVUFBSTNCLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBV0ssUUFBWCxDQUFvQnFCLEdBQUcsQ0FBQ0UsVUFBeEIsQ0FBWixFQUFpRDtBQUM3QyxhQUFLakcsT0FBTCxDQUFhb0MsSUFBYixDQUFtQiwrREFBOERQLE9BQU8sQ0FBQzRKLE9BQVIsRUFBa0IsRUFBbkc7O0FBQ0E1SixRQUFBQSxPQUFPLENBQUNrSCxRQUFSLENBQWlCbEssZ0JBQWdCLENBQUM4SyxPQUFsQztBQUNILE9BSEQsTUFHTztBQUNILGNBQU1tRCxRQUFRLEdBQUc1RyxJQUFJLENBQUNDLEtBQUwsQ0FBV0gsSUFBWCxDQUFqQjs7QUFDQSxjQUFNYSxXQUFXLEdBQUcsS0FBS0MsMkJBQUwsQ0FBaUNnRyxRQUFqQyxDQUFwQjs7QUFDQSxhQUFLOU0sT0FBTCxDQUFhb0MsSUFBYixDQUFtQixnQ0FBK0JQLE9BQU8sQ0FBQzRKLE9BQVIsRUFBa0IsU0FBUTVFLFdBQVcsQ0FBQ2dDLFFBQVMsRUFBakc7O0FBQ0FoSCxRQUFBQSxPQUFPLENBQUNrSCxRQUFSLENBQWlCbEssZ0JBQWdCLENBQUNtSyxZQUFsQztBQUNBbkgsUUFBQUEsT0FBTyxDQUFDeUYscUJBQVIsQ0FBOEJULFdBQTlCO0FBQ0g7QUFDSixLQVhNLENBQVA7QUFZSCxHQTN1QnFDLENBNnVCdEM7OztBQUNBa0csRUFBQUEsY0FBYyxDQUFDbEwsT0FBRCxFQUFVO0FBQ3BCLFVBQU1rQixHQUFHLEdBQUdsQixPQUFPLENBQUNvSCxLQUFSLEVBQVo7O0FBRUEsVUFBTStELFdBQVcsR0FBRyxLQUFLMU0sbUJBQUwsQ0FBeUIwQyxHQUF6QixDQUE2QkQsR0FBN0IsQ0FBcEI7O0FBQ0EsUUFBSWlLLFdBQUosRUFBaUI7QUFDYm5MLE1BQUFBLE9BQU8sQ0FBQ2tMLGNBQVIsQ0FBdUIsS0FBS25NLFNBQUwsR0FBaUIsS0FBS0EsU0FBTCxDQUFlMEUsSUFBaEMsR0FBdUMsTUFBOUQ7QUFDQTBILE1BQUFBLFdBQVcsQ0FBQ0MsZ0JBQVosQ0FBNkIsSUFBN0IsRUFBbUMsSUFBbkM7QUFDSDs7QUFFRCxVQUFNQyxLQUFLLEdBQUcsS0FBS3BNLGdCQUFMLENBQXNCOEksT0FBdEIsQ0FBOEI3RyxHQUE5QixDQUFkOztBQUNBLFFBQUltSyxLQUFLLElBQUksQ0FBQyxDQUFkLEVBQWlCLEtBQUtwTSxnQkFBTCxDQUFzQnFNLE1BQXRCLENBQTZCRCxLQUE3QixFQUFvQyxDQUFwQzs7QUFDakIsU0FBSy9NLHNCQUFMLENBQTRCd0Usb0JBQTVCLENBQWlENUIsR0FBakQsRUFBc0QsS0FBS2xDLFVBQTNEO0FBQ0g7O0FBRUR1TSxFQUFBQSxlQUFlLENBQUNDLGNBQUQsRUFBaUJ4TCxPQUFqQixFQUEwQmdGLFdBQTFCLEVBQXVDO0FBQ2xELFVBQU10RixJQUFJLEdBQUcsSUFBYjtBQUVBLFVBQU0rTCxVQUFVLEdBQUcsRUFBbkI7O0FBRUFELElBQUFBLGNBQWMsQ0FBQ0UsWUFBZixHQUE4QixVQUFTeEgsR0FBVCxFQUFjO0FBQ3hDeEUsTUFBQUEsSUFBSSxDQUFDdkIsT0FBTCxDQUFhaUgsR0FBYixDQUNLLDZCQUE0QkosV0FBVyxDQUFDdkIsSUFBSywyQkFBMEJ1QixXQUFXLENBQUNnQyxRQUFTLEVBRGpHOztBQUdBeUUsTUFBQUEsVUFBVSxDQUFDekwsT0FBWCxHQUFxQmtFLEdBQUcsQ0FBQyxDQUFELENBQXhCO0FBQ0F1SCxNQUFBQSxVQUFVLENBQUNFLFFBQVgsR0FBc0J6SCxHQUFHLENBQUMsQ0FBRCxDQUF6QixDQUx3QyxDQU94Qzs7QUFDQXhFLE1BQUFBLElBQUksQ0FBQ2pCLG1CQUFMLENBQXlCMEMsR0FBekIsQ0FBNkI2RCxXQUFXLENBQUM5RCxHQUF6QyxFQUE4Q2tLLGdCQUE5QyxDQUErREssVUFBVSxDQUFDekwsT0FBMUUsRUFBbUZnRixXQUFuRjs7QUFFQSxVQUFJNEcsaUJBQWlCLEdBQUdyUCxDQUFDLEVBQXpCO0FBQ0EsVUFBSXlJLFdBQVcsQ0FBQ2dDLFFBQVosS0FBeUIvSixtQkFBbUIsQ0FBQ3dNLEdBQTdDLElBQW9EL0osSUFBSSxDQUFDVixVQUE3RCxFQUNJNE0saUJBQWlCLEdBQUc1TCxPQUFPLENBQUM2TCxNQUFSLENBQWUsb0JBQWYsRUFBcUMsQ0FDckRuTSxJQUFJLENBQUNYLFNBQUwsR0FBaUJXLElBQUksQ0FBQ1gsU0FBTCxDQUFlMEUsSUFBaEMsR0FBdUMsTUFEYyxFQUVyRC9ELElBQUksQ0FBQ1YsVUFGZ0QsQ0FBckMsQ0FBcEI7QUFJSixhQUFPNE0saUJBQWlCLENBQ25COUwsSUFERSxDQUNHLFlBQVc7QUFDYkosUUFBQUEsSUFBSSxDQUFDVCxnQkFBTCxDQUFzQndCLElBQXRCLENBQTJCVCxPQUFPLENBQUNvSCxLQUFSLEVBQTNCOztBQUNBMUgsUUFBQUEsSUFBSSxDQUFDUSxJQUFMLENBQVUsYUFBVixFQUF5QkYsT0FBekIsRUFGYSxDQUliO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsZUFBT0EsT0FBTyxDQUFDOEwsbUJBQVIsRUFBUDtBQUNILE9BdkJFLEVBd0JGaE0sSUF4QkUsQ0F3QkcsWUFBVztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUUsUUFBQUEsT0FBTyxDQUNGK0wsbUJBREwsR0FFSzVHLEtBRkwsQ0FFVyxVQUFTM0MsR0FBVCxFQUFjO0FBQ2pCOUMsVUFBQUEsSUFBSSxDQUFDdkIsT0FBTCxDQUFhc0UsSUFBYixDQUFrQkQsR0FBbEI7QUFDSCxTQUpMLEVBS0thLE9BTEwsQ0FLYSxZQUFXO0FBQ2hCLGdCQUFNNkMsYUFBYSxHQUFHeEcsSUFBSSxDQUFDbkIsYUFBTCxDQUFtQjRDLEdBQW5CLENBQXVCNkQsV0FBVyxDQUFDOUQsR0FBbkMsRUFBd0NnRixhQUE5RDs7QUFDQSxpQkFBT3hHLElBQUksQ0FBQ3BCLHNCQUFMLENBQTRCMkksZ0JBQTVCLENBQ0hqQyxXQURHLEVBRUhrQixhQUZHLEVBR0h1RixVQUFVLENBQUNFLFFBSFIsRUFJSGpNLElBQUksQ0FBQ1YsVUFKRixDQUFQO0FBTUgsU0FiTCxFQWNLd0ksSUFkTDtBQWdCQSxlQUFPeEgsT0FBUDtBQUNILE9BL0NFLENBQVA7QUFnREgsS0FoRUQ7O0FBa0VBd0wsSUFBQUEsY0FBYyxDQUFDdkssTUFBZixHQUF3QixZQUFXO0FBQy9CLFdBQUt5SyxZQUFMLEdBQW9CLFVBQVN4SCxHQUFULEVBQWMsQ0FDOUI7QUFDSCxPQUZEO0FBR0gsS0FKRDs7QUFNQXhFLElBQUFBLElBQUksQ0FBQ1IsYUFBTCxDQUFtQitKLEdBQW5CLENBQXVCakosT0FBTyxDQUFDb0gsS0FBUixFQUF2QixFQUF3Q29FLGNBQXhDOztBQUVBLFdBQU9BLGNBQWMsQ0FDaEIxTCxJQURFLENBQ0csVUFBU29FLEdBQVQsRUFBYztBQUNoQixhQUFPM0gsQ0FBQyxDQUFDeVAsR0FBRixDQUFNOUgsR0FBTixDQUFQO0FBQ0gsS0FIRSxFQUlGK0gsT0FKRSxDQUlNOU8sb0JBSk4sRUFLRjJDLElBTEUsQ0FLRyxVQUFTb0UsR0FBVCxFQUFjO0FBQ2hCLGFBQU9zSCxjQUFjLENBQUNFLFlBQWYsQ0FBNEJ4SCxHQUE1QixDQUFQO0FBQ0gsS0FQRSxFQVFGaUIsS0FSRSxDQVFJLFVBQVMzQyxHQUFULEVBQWM7QUFDakIsVUFBSUEsR0FBRyxDQUFDMEosSUFBSixLQUFhLFdBQWpCLEVBQThCO0FBQzFCLGNBQU03QyxZQUFZLEdBQUdoTSxJQUFJLENBQUNpTSxzQkFBTCxDQUE0QnRKLE9BQTVCLENBQXJCOztBQUNBTixRQUFBQSxJQUFJLENBQUNyQixnQkFBTCxDQUFzQnFMLFFBQXRCLENBQ0lqTixDQUFDLENBQUNrTixLQUFGLENBQVFOLFlBQVIsRUFBc0I7QUFDbEI1RixVQUFBQSxJQUFJLEVBQUUsMEJBRFk7QUFFbEIwSSxVQUFBQSxlQUFlLEVBQUVuSCxXQUFXLENBQUNnQztBQUZYLFNBQXRCLENBREo7QUFNSDs7QUFFRHRILE1BQUFBLElBQUksQ0FBQ3ZCLE9BQUwsQ0FBYWlLLEtBQWIsQ0FDSyxxQ0FBb0NwRCxXQUFXLENBQUN2QixJQUFLLHlCQUF3QnVCLFdBQVcsQ0FBQ2dDLFFBQVMsS0FBSXhFLEdBQUksRUFEL0c7O0FBR0EsWUFBTW1GLGlCQUFpQixHQUFHakksSUFBSSxDQUFDakIsbUJBQUwsQ0FBeUIwQyxHQUF6QixDQUE2QjZELFdBQVcsQ0FBQzlELEdBQXpDLENBQTFCLENBZGlCLENBZWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsVUFBSSxDQUFDeUcsaUJBQWlCLENBQUN5RSxlQUF2QixFQUF3QztBQUNwQ3BNLFFBQUFBLE9BQU8sQ0FBQ2tILFFBQVIsQ0FBaUJsSyxnQkFBZ0IsQ0FBQ2dMLGVBQWxDO0FBQ0gsT0FGRCxNQUVPO0FBQ0hoSSxRQUFBQSxPQUFPLENBQUNrSCxRQUFSLENBQWlCbEssZ0JBQWdCLENBQUNxUCxPQUFsQztBQUNIOztBQUNELFlBQU03SixHQUFOO0FBQ0gsS0FuQ0UsRUFvQ0ZhLE9BcENFLENBb0NNLFlBQVc7QUFDaEIzRCxNQUFBQSxJQUFJLENBQUNSLGFBQUwsQ0FBbUJvTixNQUFuQixDQUEwQnRNLE9BQU8sQ0FBQ29ILEtBQVIsRUFBMUI7QUFDSCxLQXRDRSxDQUFQO0FBdUNIOztBQUVEZ0QsRUFBQUEsY0FBYyxDQUFDcEYsV0FBRCxFQUFjO0FBQ3hCLFVBQU1oRixPQUFPLEdBQUcsS0FBS3pCLGFBQUwsQ0FBbUI0QyxHQUFuQixDQUF1QjZELFdBQVcsQ0FBQzlELEdBQW5DLENBQWhCOztBQUNBLFFBQUlsQixPQUFPLENBQUN1TSxnQkFBUixFQUFKLEVBQWdDLE9BQU9oUSxDQUFDLENBQUN5RCxPQUFELENBQVIsQ0FGUixDQUl4Qjs7QUFDQSxRQUFJMkwsUUFBSjs7QUFDQSxRQUFJM0csV0FBVyxDQUFDZ0MsUUFBWixLQUF5Qi9KLG1CQUFtQixDQUFDOE0sT0FBakQsRUFBMEQ7QUFDdEQsVUFBSSxLQUFLOUssZ0JBQUwsQ0FBc0I4SSxPQUF0QixDQUE4Qi9DLFdBQVcsQ0FBQzlELEdBQTFDLE1BQW1ELENBQUMsQ0FBeEQsRUFBMkQ7QUFDdkQsWUFBSSxDQUFDLEtBQUtsQyxVQUFWLEVBQXNCMk0sUUFBUSxHQUFHLEtBQUtyTixzQkFBTCxDQUE0QmtDLFVBQTVCLENBQXVDd0UsV0FBVyxDQUFDOUQsR0FBbkQsRUFBd0R5SyxRQUFuRTtBQUN6QixPQUZELE1BRU87QUFDSCxjQUFNLHlDQUFOO0FBQ0g7QUFDSjs7QUFFRCxTQUFLeE4sT0FBTCxDQUFhcU8sS0FBYixDQUFvQixxQkFBb0J4SCxXQUFXLENBQUN2QixJQUFLLDBCQUF5QnVCLFdBQVcsQ0FBQ2dDLFFBQVMsRUFBdkc7O0FBQ0FoSCxJQUFBQSxPQUFPLENBQUNrSCxRQUFSLENBQWlCbEssZ0JBQWdCLENBQUN5UCxnQkFBbEM7QUFFQSxVQUFNL00sSUFBSSxHQUFHLElBQWI7QUFDQSxVQUFNOEwsY0FBYyxHQUFHalAsQ0FBQyxDQUNuQm1RLEdBRGtCLENBQ2QsWUFBVztBQUNaLGFBQU9mLFFBQVEsR0FDVGpNLElBQUksQ0FBQ2hCLE9BQUwsQ0FBYWlPLGdCQUFiLENBQThCM0gsV0FBOUIsRUFBMkMyRyxRQUEzQyxDQURTLEdBRVRqTSxJQUFJLENBQUNoQixPQUFMLENBQWFpTyxnQkFBYixDQUE4QjNILFdBQTlCLENBRk47QUFHSCxLQUxrQixFQU1sQmxGLElBTmtCLENBTWIsVUFBU0UsT0FBVCxFQUFrQjtBQUNwQixhQUFPLENBQUNBLE9BQUQsRUFBVXpELENBQUMsQ0FBQ29QLFFBQUQsQ0FBWCxDQUFQO0FBQ0gsS0FSa0IsQ0FBdkI7QUFTQSxXQUFPLEtBQUtKLGVBQUwsQ0FBcUJDLGNBQXJCLEVBQXFDeEwsT0FBckMsRUFBOENnRixXQUE5QyxFQUEyREcsS0FBM0QsQ0FBaUUzQyxHQUFHLElBQUk7QUFDM0UsVUFBSUEsR0FBRyxZQUFZN0YsU0FBUyxDQUFDaVEsaUJBQTdCLEVBQWdEO0FBQzVDLGFBQUt6TyxPQUFMLENBQWFpSCxHQUFiLENBQ0ssYUFBWUosV0FBVyxDQUFDdkIsSUFBSyw2QkFBOUIsR0FBOEQsc0NBRGxFOztBQUdBLGFBQUt5SCxjQUFMLENBQW9CbEwsT0FBcEI7QUFDSDs7QUFDRCxZQUFNd0MsR0FBTjtBQUNILEtBUk0sQ0FBUDtBQVNIOztBQUVEcUssRUFBQUEsY0FBYyxDQUFDN0gsV0FBRCxFQUFjO0FBQ3hCLFVBQU1oRixPQUFPLEdBQUcsS0FBS3pCLGFBQUwsQ0FBbUI0QyxHQUFuQixDQUF1QjZELFdBQVcsQ0FBQzlELEdBQW5DLENBQWhCOztBQUNBLFFBQUlsQixPQUFPLENBQUN1TSxnQkFBUixNQUE4QnZNLE9BQU8sQ0FBQzJLLGVBQVIsRUFBbEMsRUFBNkQsT0FBT3BPLENBQUMsQ0FBQ3lELE9BQUQsQ0FBUjs7QUFFN0QsUUFBSWdGLFdBQVcsQ0FBQ2dDLFFBQVosS0FBeUIvSixtQkFBbUIsQ0FBQzhNLE9BQWpELEVBQTBEO0FBQ3RELFdBQUs1TCxPQUFMLENBQWFxTyxLQUFiLENBQ0ssMEJBQXlCeEgsV0FBVyxDQUFDdkIsSUFBSywwQkFBeUJ1QixXQUFXLENBQUNnQyxRQUFTLEVBRDdGOztBQUdBaEgsTUFBQUEsT0FBTyxDQUFDa0gsUUFBUixDQUFpQmxLLGdCQUFnQixDQUFDOFAsY0FBbEM7QUFDSCxLQUxELE1BS087QUFDSCxXQUFLM08sT0FBTCxDQUFhcU8sS0FBYixDQUFvQixxQkFBb0J4SCxXQUFXLENBQUN2QixJQUFLLDBCQUF5QnVCLFdBQVcsQ0FBQ2dDLFFBQVMsRUFBdkc7O0FBQ0FoSCxNQUFBQSxPQUFPLENBQUNrSCxRQUFSLENBQWlCbEssZ0JBQWdCLENBQUN5UCxnQkFBbEM7QUFDSDs7QUFFRCxVQUFNakIsY0FBYyxHQUFHalAsQ0FBQyxDQUFDLEtBQUttQyxPQUFMLENBQWFxTyxjQUFiLENBQTRCL0gsV0FBNUIsQ0FBRCxDQUF4QjtBQUNBLFdBQU8sS0FBS3VHLGVBQUwsQ0FBcUJDLGNBQXJCLEVBQXFDeEwsT0FBckMsRUFBOENnRixXQUE5QyxDQUFQO0FBQ0gsR0ExNkJxQyxDQTQ2QnRDO0FBQ0E7OztBQUNBZ0ksRUFBQUEsWUFBWSxDQUFDaE4sT0FBRCxFQUFVO0FBQ2xCLFVBQU1pTixVQUFVLEdBQUc7QUFDZmpOLE1BQUFBLE9BRGU7QUFFZmtOLE1BQUFBLFVBQVUsRUFBRTtBQUZHLEtBQW5COztBQUtBLFVBQU1sSSxXQUFXLEdBQUcsS0FBS3ZHLG1CQUFMLENBQXlCMEMsR0FBekIsQ0FBNkJuQixPQUFPLENBQUNvSCxLQUFSLEVBQTdCLEVBQThDK0YsMEJBQTlDLEVBQXBCOztBQUNBLFFBQUksQ0FBQ25JLFdBQUwsRUFBa0IsTUFBTSwyQ0FBTjtBQUVsQixVQUFNb0ksWUFBWSxHQUFHcEksV0FBVyxDQUFDZ0MsUUFBWixLQUF5Qi9KLG1CQUFtQixDQUFDOE0sT0FBbEUsQ0FUa0IsQ0FXbEI7QUFDQTs7QUFDQSxRQUFJcUQsWUFBWSxJQUFJLEtBQUtuTyxnQkFBTCxDQUFzQjhJLE9BQXRCLENBQThCL0MsV0FBVyxDQUFDOUQsR0FBMUMsTUFBbUQsQ0FBQyxDQUF4RSxFQUEyRTtBQUN2RStMLE1BQUFBLFVBQVUsQ0FBQ0MsVUFBWCxHQUF3QixJQUF4QjtBQUNBLGFBQU8sS0FBS0wsY0FBTCxDQUFvQjdILFdBQXBCLEVBQWlDbEYsSUFBakMsQ0FBc0MsTUFBTTtBQUMvQyxlQUFPbU4sVUFBUDtBQUNILE9BRk0sQ0FBUDtBQUdILEtBbEJpQixDQW9CbEI7OztBQUNBLFdBQU8sS0FBSzdDLGNBQUwsQ0FBb0JwRixXQUFwQixFQUFpQ0csS0FBakMsQ0FBdUMzQyxHQUFHLElBQUk7QUFDakQ7QUFDQSxVQUFJNEssWUFBWSxJQUFJNUssR0FBRyxZQUFZN0YsU0FBUyxDQUFDaVEsaUJBQTdDLEVBQWdFO0FBQzVESyxRQUFBQSxVQUFVLENBQUNDLFVBQVgsR0FBd0IsSUFBeEI7QUFDQSxlQUFPLEtBQUtMLGNBQUwsQ0FBb0I3SCxXQUFwQixFQUFpQ2xGLElBQWpDLENBQXNDLE1BQU07QUFDL0MsaUJBQU9tTixVQUFQO0FBQ0gsU0FGTSxDQUFQO0FBR0g7O0FBQ0QsWUFBTXpLLEdBQU47QUFDSCxLQVRNLENBQVA7QUFVSDs7QUE3OEJxQzs7QUFnOUIxQzZLLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQjdQLGNBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgSW1tdXRhYmxlID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XHJcbmNvbnN0IHEgPSByZXF1aXJlKCdxJyk7XHJcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcclxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG5jb25zdCByZXF1ZXN0ID0gcmVxdWlyZSgncmVxdWVzdCcpO1xyXG5cclxuY29uc3QgY3JvaXNzYW50ID0gcmVxdWlyZSgnLi9jcm9pc3NhbnQnKTtcclxuY29uc3QgQXJjaGV0eXBlUHJpbnRlciA9IHJlcXVpcmUoJy4vYXJjaGV0eXBlX3ByaW50ZXInKTtcclxuY29uc3QgTWFrZXJCb3RQcmludGVyID0gcmVxdWlyZSgnLi9tYWtlcmJvdC1wcmludGVyJyk7XHJcbmNvbnN0IFNrZXRjaFByaW50ZXIgPSByZXF1aXJlKCcuL3NrZXRjaFByaW50ZXInKTtcclxuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcclxuY29uc3QgUHJpbnRlclN0YXRlRW51bSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJykuUHJpbnRlclN0YXRlRW51bTtcclxuY29uc3QgUHJpbnRlckNvbm5UeXBlRW51bSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJykuUHJpbnRlckNvbm5UeXBlRW51bTtcclxuY29uc3QgQm90VHlwZUVudW0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLkJvdFR5cGVFbnVtO1xyXG5jb25zdCBQUklOVEVSX0FVVEhfVElNRU9VVCA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJykuUFJJTlRFUl9BVVRIX1RJTUVPVVQ7XHJcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9wcmludGVyQ29ubmVjdGlvbk1hbmFnZXInKTtcclxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xyXG5jb25zdCB7IHBhcnNlQ29ublR5cGUsIGNvbXBhcmVDb25uVHlwZSB9ID0gcmVxdWlyZSgnLi91dGlscy9wcmludGVyQ29ubmVjdGlvblV0aWwnKTtcclxuXHJcbi8vIFRPRE86IE1vdmUgdGhpcyBvdXQgdG8gZGVmYXVsdC1jb25maWcgdG8gc3VwcG9ydCBzdGFnaW5nIFVSTCBpbiB0aGUgZnV0dXJlXHJcbmNvbnN0IHJlZmxlY3RvclVybCA9ICdodHRwczovL3JlZmxlY3Rvci5tYWtlcmJvdC5jb20nO1xyXG5cclxuLypcclxuRXZlbnRzOlxyXG4gICAgYWRkX3ByaW50ZXI6IHJlcXVlc3QgdGhhdCBhIHByaW50ZXIgYmUgYWRkZWQgdG8gTXkgUHJpbnRlcnNcclxuICAgIHJlbW92ZV9wcmludGVyOiByZXF1ZXN0IHRoYXQgYSBwcmludGVyIGJlIHJlbW92ZWQgZnJvbSBNeSBQcmludGVyc1xyXG4gICAgdXBkYXRlX3ByaW50ZXJfbGlzdDogcmVxdWVzdCB0aGF0IHRoZSBwcmludGVyIGxpc3QgaW4gcHJpbnRlciBzdG9yZSBiZSB1cGRhdGVkXHJcbiovXHJcblxyXG5jbGFzcyBQcmludGVyTWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwYXJhbWV0ZXJTZXJ2aWNlLFxyXG4gICAgICAgIGxvZ2dpbmdTZXJ2aWNlLFxyXG4gICAgICAgIHR2QXBpQ2xpZW50LFxyXG4gICAgICAgIHRyYWNraW5nU2VydmljZSxcclxuICAgICAgICB1c2VySW5mbyxcclxuICAgICAgICB0b2tlbixcclxuICAgICAgICBzdG9yZWRQcmludGVyc01hbmFnZXJcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclNlcnZpY2UgPSBwYXJhbWV0ZXJTZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dpbmdTZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMuX3R2QXBpQ2xpZW50ID0gdHZBcGlDbGllbnQ7XHJcbiAgICAgICAgdGhpcy5fdHJhY2tpbmdTZXJ2aWNlID0gdHJhY2tpbmdTZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3JlZFByaW50ZXJzTWFuYWdlciA9IHN0b3JlZFByaW50ZXJzTWFuYWdlcjtcclxuXHJcbiAgICAgICAgdGhpcy5fcHJpbnRlckNhY2hlID0gbmV3IEltbXV0YWJsZS5NYXAoKTtcclxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uTWFuYWdlcnMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2ZpbmRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZmluZGluZ1Byb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0RmluZGVyVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc3RvcEZpbmRlclRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3BvbGxpbmdSZWZsZWN0b3JJZCA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuX3VzZXJJbmZvID0gdXNlckluZm87XHJcbiAgICAgICAgdGhpcy5fdXNlclRva2VuID0gdG9rZW47XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFByaW50ZXJzID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuX2F1dGhQcm9taXNlcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RQcmludGVycyA9IHRoaXMucmVjb25uZWN0UHJpbnRlcnMuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9wb2xsUmVmbGVjdG9yRm9yU2tldGNoUHJpbnRlcnMgPSB0aGlzLl9wb2xsUmVmbGVjdG9yRm9yU2tldGNoUHJpbnRlcnMuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9yZWNvbm5lY3RNYWtlckJvdFByaW50ZXIgPSB0aGlzLl9yZWNvbm5lY3RNYWtlckJvdFByaW50ZXIuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9yZWNvbm5lY3RTa2V0Y2hQcmludGVyID0gdGhpcy5fcmVjb25uZWN0U2tldGNoUHJpbnRlci5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLnNrZXRjaFByaW50ZXJMaXN0ID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgICAvLyBsb2FkIHVwIHByaW50ZXJzIGZyb20gc3RvcmVkXHJcbiAgICAgICAgbGV0IGxvYWRQcmludGVyc1Byb21pc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuX3VzZXJUb2tlbikge1xyXG4gICAgICAgICAgICBsb2FkUHJpbnRlcnNQcm9taXNlID0gdGhpcy5fdXNlclByaW50ZXJzRnJvbVN0b3JlZCh0aGlzLl91c2VyVG9rZW4pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxvYWRQcmludGVyc1Byb21pc2UgPSB0aGlzLl9sb2FkQW5vbnltb3VzUHJpbnRlcnMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsb2FkUHJpbnRlcnNQcm9taXNlXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2xvYWRBcmNoZXR5cGVQcmludGVycyhzZWxmLl91c2VyVG9rZW4pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJpbnRlciBvZiBzZWxmLmdldFByaW50ZXJzKCkpIHNlbGYuZW1pdCgnYWRkX3ByaW50ZXInLCBwcmludGVyKTtcclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHVwZGF0ZSBvZiBwcmludGVyIHN0b3JlXHJcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ3VwZGF0ZV9wcmludGVyX2xpc3QnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2xvYWRBcmNoZXR5cGVQcmludGVycyh0b2tlbikge1xyXG4gICAgICAgIGNvbnN0IGFyY2hldHlwZVByaW50ZXJQcm9taXNlcyA9IFtdO1xyXG5cclxuICAgICAgICBjb25zdCBhcmNoZXR5cGVJZHMgPSB0aGlzLl9zdG9yZWRQcmludGVyc01hbmFnZXIuZ2V0QXJjaGV0eXBlUHJpbnRlcnModGhpcy5fdXNlclRva2VuKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBhcmNoZXR5cGVJZHMpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuX3N0b3JlZFByaW50ZXJzTWFuYWdlci5nZXRQcmludGVyKGlkKTtcclxuICAgICAgICAgICAgYXJjaGV0eXBlUHJpbnRlclByb21pc2VzLnB1c2godGhpcy5fY3JlYXRlQXJjaGV0eXBlUHJpbnRlcihpbmZvLnZlbmRvciwgaW5mby5nZW5kZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHEuYWxsU2V0dGxlZChhcmNoZXR5cGVQcmludGVyUHJvbWlzZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9taXNlIG9mIHRoaXMuX2F1dGhQcm9taXNlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBwcm9taXNlLmNhbmNlbCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCB1aWQgb2YgdGhpcy5fY3VycmVudFByaW50ZXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByaW50ZXIgPSB0aGlzLl9wcmludGVyQ2FjaGUuZ2V0KHVpZCk7XHJcbiAgICAgICAgICAgIGlmIChwcmludGVyKSBwcmludGVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGNvbnRpbnVhdGlvbiB0aGF0IHNjaGVkdWxlcyBmaW5kIHRvIHN0YXJ0IHVwIGFnYWluLi4uXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpbmRpbmdQcm9taXNlKSB0aGlzLl9maW5kaW5nUHJvbWlzZS5jYW5jZWxGaW5kaW5nQ29udGludWF0aW9uKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9zdGFydEZpbmRlclRpbWVvdXQpIHtcclxuICAgICAgICAgICAgLy8gaWYgc3RhcnRGbmRlclRpbWVvdXQgaXMgc2V0LCBmaW5kZXIgaGFzIGFscmVhZHkgc3RvcHBlZCwgYW5kIHRoZVxyXG4gICAgICAgICAgICAvLyBzdG9wIHByb21pc2UgcmVzb2x2ZWRcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N0YXJ0RmluZGVyVGltZW91dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBxKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdG9wRmluZGVyVGltZW91dCkge1xyXG4gICAgICAgICAgICAvLyBpZiBzdG9wRmluZGVyVGltZW91dCBpcyBzZXQsIHdlIGFyZSB3YWl0aW5nIHRvIHN0b3AgdGhlIGRldGVjdG9yXHJcbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSB0aW1lb3V0IGFuZCBzdG9wIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RvcEZpbmRlclRpbWVvdXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZGVyLnN0b3BGaW5kaW5nUHJpbnRlcnMoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2ZpbmRpbmdQcm9taXNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpZiBuZWl0aGVyIGFyZSBzZXQsIHN0b3AgaGFzIGJlZW4gY2FsbGVkOyByZXR1cm4gdGhlIHByb21pc2Ugd2FpdGluZ1xyXG4gICAgICAgICAgICAvLyBmb3Igc3RvcCB0byBmaW5pc2hcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRpbmdQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZ2V0VXNlclByaW50ZXJzRnJvbVdlYigpIHtcclxuICAgICAgICAvLyB0aGVzZSBwcm9taXNlcyByZXR1cm4gbWFwcyBvZiB1aWQgLT4gcHJpbnRlckluZm9cclxuICAgICAgICBjb25zdCBwcmludGVySW5mb3NQcm9taXNlID0gcShcclxuICAgICAgICAgICAgdGhpcy5fdHZBcGlDbGllbnQuZ2V0VXNlclByaW50ZXJzRnJvbVJlZmxlY3Rvcih0aGlzLl91c2VyVG9rZW4pLnRoZW4oXHJcbiAgICAgICAgICAgICAgICB1c2VyUHJpbnRlckxpc3RSZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJQcmludGVycyA9IHVzZXJQcmludGVyTGlzdFJlcy5wcmludGVycztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdXBwb3J0ZWRSZWZsZWN0b3JCb3RzID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHVzZXJQcmludGVycykubWFwKHByaW50ZXJJZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgbm8tbG9uZ2VyLXN1cHBvcnRlZCBib3RzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdFR5cGUgPSB1c2VyUHJpbnRlcnNbcHJpbnRlcklkXS5zdGF0dXMuYm90X3R5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCb3RUeXBlRW51bS5oYXNPd25Qcm9wZXJ0eShib3RUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkUmVmbGVjdG9yQm90c1twcmludGVySWRdID0gdXNlclByaW50ZXJzW3ByaW50ZXJJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UmVmbGVjdG9yUHJpbnRlckluZm9zKHN1cHBvcnRlZFJlZmxlY3RvckJvdHMpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIHRvIGZldGNoIGZyb20gcmVmbGVjdG9yLCBidXQgdGhhdCdzIG9rYXkuLi5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybignRmFpbGVkIHRvIGZldGNoIHByaW50ZXIgbGlzdCBmcm9tIHJlZmxlY3RvciBmb3IgdXNlcjogJywgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyB0cmVhdCB0aGUgbGlzdCBnb3R0ZW4gZnJvbSB0dkFwaUNsaWVudCBhcyB0aGUgYWJzb2x1dGUgdHJ1dGhcclxuICAgICAgICAvLyBvZiBwcmludGVycyBhc3NvY2lhdGVkIHdpdGggdGhlIGFjY291bnQ7IGlmIHByaW50ZXJzIGFyZSBpblxyXG4gICAgICAgIC8vIHRoaXMgbGlzdCBidXQgbm90IGluIHRoZSBzdG9yZWQsIGFkZCB0aGVtOyBpZiBwcmludGVycyBhcmUgbm90XHJcbiAgICAgICAgLy8gaW4gdGhpcyBsaXN0IGJ1dCBhcmUgaW4gc3RvcmVkLCBjbGVhbiB0aGVtIG91dFxyXG5cclxuICAgICAgICByZXR1cm4gcHJpbnRlckluZm9zUHJvbWlzZS50aGVuKHJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBmYWlsZWQgdG8gZmV0Y2ggcHJpbnRlcnMgZnJvbSByZWZsZWN0b3IsXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGJvdGhlciBjbGVhbmluZzsgd2UgZG9uJ3Qgd2FudCB0byBtaXN0YWtlbmx5IGRlYXV0aGVudGljYXRlXHJcbiAgICAgICAgICAgIC8vIGFsbCB0aGUgdXNlcidzIHByaW50ZXJzLi4uLlxyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdHMpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIGNsZWFuXHJcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFVzZXJQcmludGVycyA9IHRoaXMuX3N0b3JlZFByaW50ZXJzTWFuYWdlci5nZXRVc2VyUHJpbnRlcnModGhpcy5fdXNlclRva2VuKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdWlkIG9mIHN0b3JlZFVzZXJQcmludGVycykge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJZiBzdG9yZWRVc2VyUHJpbnRlcnMgY29udGFpbiBhIHByaW50ZXIgKHVpZCkgbm90IHByZXNlbnQgaW5cclxuICAgICAgICAgICAgICAgICAqIHR2QXBpQ2xpZW50J3MgbGlzdCwgcmVtb3ZlIGl0LlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIElmIHR2QXBpQ2xpZW50IGhhcyBhIHByaW50ZXIgKHVpZCkgbm90IHByZXNlbnQgaW5cclxuICAgICAgICAgICAgICAgICAqIHN0b3JlZFVzZXJQcmludGVycyBsaXN0LCB0aGVuIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHN0b3JlZFxyXG4gICAgICAgICAgICAgICAgICogbGlzdCB2aWEgY3JlYXRlUHJpbnRlciBmbG93LlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIEhvd2V2ZXIsIGlmIGEgcHJpbnRlciAodWlkKSBpcyBmb3VuZCBpbiBib3RoIHR2QXBpQ2xpZW50IGFuZFxyXG4gICAgICAgICAgICAgICAgICogaW4gc3RvcmVkVXNlclByaW50ZXJzIGxpc3RzLCB1c2Ugc3RvcmVkVXNlclByaW50ZXJzIGluZm8uXHJcbiAgICAgICAgICAgICAgICAgKiBUaGlzIHdpbGwgYXZvaWQgYXV0b21hdGljYWxseSBzZXR0aW5nIHRoZSBwcmludGVyIHRvXHJcbiAgICAgICAgICAgICAgICAgKiByZWZsZWN0b3IuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogLS0gUmF5XHJcbiAgICAgICAgICAgICAgICAgKiovXHJcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHJlc3VsdHMpLmluY2x1ZGVzKHVpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9yZWRQcmludGVyc01hbmFnZXIucmVtb3ZlUHJpbnRlckZvclVzZXIodWlkLCB0aGlzLl91c2VyVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlX3ByaW50ZXInLCB0aGlzLl9wcmludGVyQ2FjaGUuZ2V0KHVpZCkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0gVHJ5IExBTiBiZWZvcmUgYXR0ZW1wdGluZyByZWZsZWN0b3Igb24gYXBwLWxvYWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgb25seSB3aGVuIHdlJ3JlIGNhcGFibGUgb2YgZmFsbGluZyBiYWNrIHRvIHJlZmxlY3RvclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggTEFOIGNvbm5lY3Rpb25zLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkUHJpbnRlciA9IHRoaXMuX3N0b3JlZFByaW50ZXJzTWFuYWdlci5nZXRQcmludGVyKHVpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1t1aWRdID0gdGhpcy5fcHJpbnRlckluZm9Gcm9tU2F2ZWRJbmZvKHsgcHJpbnRlcl9pbmZvOiBjYWNoZWRQcmludGVyLnByaW50ZXJfaW5mbyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZmxpbmVQcmludGVyc0Zyb21QcmludGVySW5mb3NMaXN0KHJlc3VsdHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0KGNsaWVudFNlY3JldCkge1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgbG9nZ2VkLWluIHVzZXIsIHRyeSBsb2FkaW5nIHRoZWlyIHByaW50ZXIgbGlzdCBmcm9tIHdlYlxyXG4gICAgICAgIGxldCBsb2FkUHJpbnRlcnNQcm9taXNlID0gcSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl91c2VyVG9rZW4pIGxvYWRQcmludGVyc1Byb21pc2UgPSB0aGlzLl9nZXRVc2VyUHJpbnRlcnNGcm9tV2ViKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBsb2FkUHJpbnRlcnNQcm9taXNlXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkQXJjaGV0eXBlUHJpbnRlcnMoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgYWxsIG91ciBwcmludGVycyBtYWtlIGl0IG9udG8gdGhlIE15IFByaW50ZXJzIGxpc3QuLi5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdWlkIG9mIHRoaXMuX2N1cnJlbnRQcmludGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYWRkX3ByaW50ZXInLCB0aGlzLl9wcmludGVyQ2FjaGUuZ2V0KHVpZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBGaW5kIENyb2lzc2FudCBwcmludGVyc1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgZGV0ZWN0aW9uIHJlZ2FyZGxlc3Mgb2Ygc3VjY2Vzcy9mYWlsdXJlIG9mIHByaW50ZXIgbG9hZGluZ1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3Mgc29tZSB3ZWlyZG5lc3Mgd2l0aCBtYWtpbmcgYSBuZXcgZmluZGVyIGJlZm9yZSB0aGUgbGFzdCBvbmVcclxuICAgICAgICAgICAgICAgIC8vIGhhcyBiZWVuIHN0b3BwZWQsIHNvIG1ha2UgaXQgaGVyZSwgd2hlcmUgdGhlIHByZXZpb3VzIHNob3VsZFxyXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5pdGVseSBoYXZlIGJlZW4gc3RvcHBlZC4uLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmluZGVyID0gbmV3IGNyb2lzc2FudC5QcmludGVyRmluZGVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5kZXIuc2V0Q2xpZW50U2VjcmV0KGNsaWVudFNlY3JldCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXNlckluZm8gJiYgdGhpcy5fdXNlclRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmluZGVyLnNldFRoaW5naXZlcnNlSW5mbyh0aGlzLl91c2VySW5mby5uYW1lLCB0aGlzLl91c2VyVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV3IGF1dGggZmxvdyBfYWx3YXlzXyByZXF1aXJlcyBhIHVzZXJuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogR2V0IHRoZSBsb2NhbCB1c2VybmFtZSB3aGVuIG5vdCBsb2dnZWQgaW5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VybmFtZSA9IHRoaXMuX3VzZXJJbmZvID8gdGhpcy5fdXNlckluZm8ubmFtZSA6ICdBTk9OJztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maW5kZXIuc2V0VXNlcm5hbWVPbmx5KHVzZXJuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRQcmludGVycygpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFBvbGwgUmVmbGVjdG9yIGZvciBTa2V0Y2ggUHJpbnRlcnMgZXZlcnkgNSBzZWNvbmRzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2xsUmVmbGVjdG9yRm9yU2tldGNoUHJpbnRlcnMoNSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9sbHMgUmVmbGVjdG9yIHZpYSBHRVQtUkVRVUVTVCBmb3IgU2tldGNoIFByaW50ZXJzXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gdGltZUludGVydmFsIC0gRGVsYXkgaW4gc2Vjb25kcyBiZXR3ZWVuIGVhY2ggR0VULXJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgX3BvbGxSZWZsZWN0b3JGb3JTa2V0Y2hQcmludGVycyh0aW1lSW50ZXJ2YWwpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3BvbGxpbmdSZWZsZWN0b3JJZCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuX3VzZXJUb2tlbn1gLFxyXG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdXJsOiBgJHtyZWZsZWN0b3JVcmx9L3ByaW50ZXJzYCxcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBQb2xsaW5nIFJlZmxlY3Rvci1HRVQgZm9yIFNrZXRjaCBQcmludGVyc2ApO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2xsaW5nUmVmbGVjdG9ySWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0KG9wdGlvbnMsIChlcnIsIHJlcywgYm9keSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgIVsyMDAsIDIwMV0uaW5jbHVkZXMocmVzLnN0YXR1c0NvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBSRVFVRVNUIEVycm9yLiBVbmFibGUgdG8gZmV0Y2ggcHJpbnRlciBsaXN0LiAke2Vycn1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHByaW50ZXJzIH0gPSBKU09OLnBhcnNlKGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBza2V0Y2hQcmludGVySWRzID0gT2JqZWN0LmtleXMocHJpbnRlcnMpLmZpbHRlcihpZCA9PiBpZC5tYXRjaCgvXigyODU3MTYyNykvZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBza2V0Y2hVaWRzID0gc2tldGNoUHJpbnRlcklkcy5tYXAoaWQgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VpZEZyb21Cb3RUeXBlQW5kSXNlcmlhbChCb3RUeXBlRW51bS5za2V0Y2gsIGlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNrZXRjaFByaW50ZXJMaXN0ID0gc2tldGNoVWlkcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNrZXRjaFByaW50ZXJJZHMuZm9yRWFjaChwcmludGVySWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHZQcmludGVySW5mbyA9IHByaW50ZXJzW3ByaW50ZXJJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogcmVmbGVjdG9yIG1heSBzZW5kIGJhY2sgYSByZXNwb25zZSB3aXRoIGFuIElEIGJ1dCBubyBzdGF0dXMgdW50aWwgZnVsbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRlY2xhcmluZyB0aGUgYm90IG9mZmxpbmUgKGZvciB+NSBtaW5zKS4gaWYgdGhhdCBoYXBwZW5zIHdlIGRvbid0IHdhbnQgdG8gYWRkIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGVudHJ5IHRvIHRoZSBwcmludGVyIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNFbXB0eSh0dlByaW50ZXJJbmZvLnN0YXR1cykpIHJldHVybiBxKG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaW50ZXJJbmZvID0gdGhpcy5fZm9ybWF0UmVmbGVjdG9yUHJpbnRlckluZm8odHZQcmludGVySW5mbyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wcmludGVyQ2FjaGUuZ2V0KGAyODU3OjE2Mjc6JHtwcmludGVySWR9YCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgTmV3IFNrZXRjaCBQcmludGVyIGRldGVjdGVkIFske3ByaW50ZXJJZH1dLiBBZGRpbmcgcHJpbnRlci5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVQcmludGVyKHByaW50ZXJJbmZvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihwcmludGVyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVtaXQgY2hhbmdlIHRvIHVwZGF0ZSBwcmludGVycyBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FkZF9wcmludGVyJywgcHJpbnRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZV9wcmludGVyX2xpc3QnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLl9sb2dnZXIubG9nKGVycikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXhpc3RpbmcgU2tldGNoIFByaW50ZXIgZGV0ZWN0ZWQ6YCwgcHJpbnRlcklkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNoZWNrIHRoZSBjYWNoZSAmIGJyaW5nIGl0IGJhY2sgb25saW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcSh0aGlzLl9wcmludGVyQ2FjaGUuZ2V0KGAyODU3OjE2Mjc6JHtwcmludGVySWR9YCkpLnRoZW4ocHJpbnRlciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ZXIudXBkYXRlRnJvbVByaW50ZXJJbmZvKHByaW50ZXJJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHRpbWVJbnRlcnZhbCAqIDEwMDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfbG9hZEFub255bW91c1ByaW50ZXJzKCkge1xyXG4gICAgICAgIGNvbnN0IGFub25QcmludGVyVWlkcyA9IHRoaXMuX3N0b3JlZFByaW50ZXJzTWFuYWdlci5nZXRBbm9ueW1vdXNQcmludGVycygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZsaW5lUHJpbnRlcnNGcm9tVWlkTGlzdChhbm9uUHJpbnRlclVpZHMpO1xyXG4gICAgfVxyXG5cclxuICAgIF9vZmZsaW5lUHJpbnRlcnNGcm9tVWlkTGlzdCh1aWRzKSB7XHJcbiAgICAgICAgY29uc3QgcHJpbnRlclByb21pc2VzID0gW107XHJcblxyXG4gICAgICAgIGNvbnN0IGhhbmRsZUVyciA9IGVyciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGVycik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCB1aWQgb2YgdWlkcykge1xyXG4gICAgICAgICAgICBjb25zdCBzYXZlZEluZm8gPSB0aGlzLl9zdG9yZWRQcmludGVyc01hbmFnZXIuZ2V0UHJpbnRlcih1aWQpO1xyXG4gICAgICAgICAgICBjb25zdCBwcmludGVySW5mbyA9IHRoaXMuX3ByaW50ZXJJbmZvRnJvbVNhdmVkSW5mbyhzYXZlZEluZm8pO1xyXG4gICAgICAgICAgICBwcmludGVyUHJvbWlzZXMucHVzaCh0aGlzLl9jcmVhdGVPZmZsaW5lUHJpbnRlcihwcmludGVySW5mbywgc2F2ZWRJbmZvLm1hY2hpbmVDb25maWcpLmNhdGNoKGhhbmRsZUVycikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHEuYWxsU2V0dGxlZChwcmludGVyUHJvbWlzZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIF9vZmZsaW5lUHJpbnRlcnNGcm9tUHJpbnRlckluZm9zTGlzdChwcmludGVySW5mb3MpIHtcclxuICAgICAgICBjb25zdCBwcmludGVyUHJvbWlzZXMgPSBbXTtcclxuXHJcbiAgICAgICAgY29uc3QgaGFuZGxlRXJyID0gZXJyID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oZXJyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBPYmplY3Qua2V5cyhwcmludGVySW5mb3MpLm1hcChwcmludGVySWQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzYXZlZEluZm8gPSB0aGlzLl9zdG9yZWRQcmludGVyc01hbmFnZXIuZ2V0UHJpbnRlcihwcmludGVySWQpIHx8IHt9O1xyXG4gICAgICAgICAgICBwcmludGVyUHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU9mZmxpbmVQcmludGVyKHByaW50ZXJJbmZvc1twcmludGVySWRdLCBzYXZlZEluZm8ubWFjaGluZUNvbmZpZykuY2F0Y2goaGFuZGxlRXJyKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcS5hbGxTZXR0bGVkKHByaW50ZXJQcm9taXNlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgX2dldFJlZmxlY3RvclByaW50ZXJJbmZvcyh1c2VyUHJpbnRlcnMpIHtcclxuICAgICAgICBjb25zdCBwcmludGVySW5mb3MgPSB7fTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJpbnRlcklkcyA9IE9iamVjdC5rZXlzKHVzZXJQcmludGVycyk7XHJcbiAgICAgICAgcHJpbnRlcklkcy5tYXAoaWQgPT4ge1xyXG4gICAgICAgICAgICAvLyBfZm9ybWF0UmVmbGVjdG9yUHJpbnRlckluZm8gYXNzdW1lcyB0aGF0IHRoZSBwcmludGVyIHdpbGwgYmUgb2YgbmV3IGVub3VnaFxyXG4gICAgICAgICAgICAvLyBmaXJtd2FyZSB0byBoYXZlIGEgc3RhdHVzLmJvdF90eXBlOyB3ZSB3aWxsIGlnbm9yZSBwcmludGVycyB0aGF0XHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCBoYXZlIGl0XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmludGVySW5mbyA9IHRoaXMuX2Zvcm1hdFJlZmxlY3RvclByaW50ZXJJbmZvKHVzZXJQcmludGVyc1tpZF0pO1xyXG4gICAgICAgICAgICAgICAgcHJpbnRlckluZm9zW3ByaW50ZXJJbmZvLnVpZF0gPSBwcmludGVySW5mbztcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgRmFpbGVkIHRvIGFkZCB1c2VyIHByaW50ZXIgJHtwcmludGVyc0xpc3RbaWRdLm5hbWV9OiAke2Vycn1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJpbnRlckluZm9zO1xyXG4gICAgfVxyXG5cclxuICAgIF91c2VyUHJpbnRlcnNGcm9tU3RvcmVkKHRva2VuKSB7XHJcbiAgICAgICAgY29uc3Qgc3RvcmVkVXNlclByaW50ZXJzID0gdGhpcy5fc3RvcmVkUHJpbnRlcnNNYW5hZ2VyLmdldFVzZXJQcmludGVycyh0b2tlbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZmxpbmVQcmludGVyc0Zyb21VaWRMaXN0KHN0b3JlZFVzZXJQcmludGVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgX3VpZEZyb21Cb3RUeXBlQW5kSXNlcmlhbChib3RfdHlwZSwgaXNlcmlhbCkge1xyXG4gICAgICAgIGxldCB2aWQ7XHJcbiAgICAgICAgbGV0IHBpZDtcclxuXHJcbiAgICAgICAgaWYgKGJvdF90eXBlID09PSBCb3RUeXBlRW51bS5za2V0Y2gpIHtcclxuICAgICAgICAgICAgdmlkID0gJzI4NTcnO1xyXG4gICAgICAgICAgICBwaWQgPSAnMTYyNyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmlkID0gJzIzYzEnO1xyXG4gICAgICAgICAgICBwaWQgPSBgMDAwMCR7Ym90X3R5cGUuc3BsaXQoJ18nKVsxXX1gLnNsaWNlKC00KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBbdmlkLCBwaWQsIGlzZXJpYWxdLmpvaW4oJzonKTtcclxuICAgIH1cclxuXHJcbiAgICBfZm9ybWF0UmVmbGVjdG9yUHJpbnRlckluZm8odHZQcmludGVySW5mbykge1xyXG4gICAgICAgIGNvbnN0IHByaW50ZXJJbmZvID0gbmV3IGNyb2lzc2FudC5QcmludGVySW5mbygpO1xyXG4gICAgICAgIHByaW50ZXJJbmZvLm5hbWUgPSB0dlByaW50ZXJJbmZvLm5hbWU7XHJcbiAgICAgICAgcHJpbnRlckluZm8uYWRkcmVzcyA9IHR2UHJpbnRlckluZm8uc3RhdHVzLmlwO1xyXG4gICAgICAgIHByaW50ZXJJbmZvLnVpZCA9IHRoaXMuX3VpZEZyb21Cb3RUeXBlQW5kSXNlcmlhbCh0dlByaW50ZXJJbmZvLnN0YXR1cy5ib3RfdHlwZSwgdHZQcmludGVySW5mby5wcmludGVyX2lkKTtcclxuICAgICAgICBwcmludGVySW5mby5pbmZvID0gdHZQcmludGVySW5mby5zdGF0dXM7XHJcbiAgICAgICAgcHJpbnRlckluZm8uY29ublR5cGUgPSBwYXJzZUNvbm5UeXBlKHR2UHJpbnRlckluZm8pO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJpbnRlckluZm87XHJcbiAgICB9XHJcblxyXG4gICAgX3ByaW50ZXJJbmZvRnJvbVNhdmVkSW5mbyhzYXZlZEluZm8pIHtcclxuICAgICAgICBjb25zdCBwcmludGVySW5mbyA9IG5ldyBjcm9pc3NhbnQuUHJpbnRlckluZm8oKTtcclxuICAgICAgICBwcmludGVySW5mby5uYW1lID0gc2F2ZWRJbmZvLnByaW50ZXJfaW5mby5uYW1lO1xyXG4gICAgICAgIHByaW50ZXJJbmZvLmFkZHJlc3MgPSBzYXZlZEluZm8ucHJpbnRlcl9pbmZvLmFkZHJlc3M7XHJcbiAgICAgICAgcHJpbnRlckluZm8udWlkID0gc2F2ZWRJbmZvLnByaW50ZXJfaW5mby51aWQ7XHJcbiAgICAgICAgcHJpbnRlckluZm8uaW5mbyA9IHNhdmVkSW5mby5wcmludGVyX2luZm8uaW5mbztcclxuICAgICAgICBwcmludGVySW5mby5jb25uVHlwZSA9IHBhcnNlQ29ublR5cGUoc2F2ZWRJbmZvLnByaW50ZXJfaW5mbyk7XHJcblxyXG4gICAgICAgIHJldHVybiBwcmludGVySW5mbztcclxuICAgIH1cclxuXHJcbiAgICBfY3JlYXRlT2ZmbGluZVByaW50ZXIocHJpbnRlckluZm8sIG1hY2hpbmVDb25maWcpIHtcclxuICAgICAgICBjb25zdCBwcmludGVyID0gdGhpcy5fcHJpbnRlckNhY2hlLmdldChwcmludGVySW5mby51aWQpO1xyXG5cclxuICAgICAgICBpZiAocHJpbnRlcikge1xyXG4gICAgICAgICAgICAvLyBhc3N1bWUgdGhlIGluZm8gd2UncmUgcmVjZWl2aW5nIGhlcmUgaXMgdGhlIGxhdGVzdCBmb3IgdGhpcyBwcmludGVyO1xyXG4gICAgICAgICAgICAvLyBpZiB0aGlzIHByaW50ZXIgb2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gbWFkZSwgdXBkYXRlIGl0cyBpbmZvIGluXHJcbiAgICAgICAgICAgIC8vIE1CUHJpbnRlciBhbmQgc3RvcmVkIGluZm9cclxuICAgICAgICAgICAgcHJpbnRlci51cGRhdGVGcm9tUHJpbnRlckluZm8ocHJpbnRlckluZm8pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmVkUHJpbnRlcnNNYW5hZ2VyLnVwZGF0ZVN0b3JlZEluZm8ocHJpbnRlckluZm8pLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW50ZXI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVByaW50ZXIocHJpbnRlckluZm8sIG1hY2hpbmVDb25maWcpLnRoZW4ocHJpbnRlciA9PiB7XHJcbiAgICAgICAgICAgIHByaW50ZXIuc2V0U3RhdGUoUHJpbnRlclN0YXRlRW51bS5SZWNvbm5lY3RpbmcpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UHJpbnRlcnMucHVzaChwcmludGVyLmdldElkKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJpbnRlcjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRQcmludGVyKHVpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcmludGVyQ2FjaGUuZ2V0KHVpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UHJpbnRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW50ZXJDYWNoZS50b0FycmF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2ZpbmRQcmludGVycygpIHtcclxuICAgICAgICAvLyBzdGFydCBmaW5kaW5nIHByaW50ZXJzOyB0aGlzIHdpbGwgc3RvcCB0aGUgZmluZGVyIGFmdGVyIDMgc2VjcywgYW5kXHJcbiAgICAgICAgLy8gdGhlbiBzdGFydCBpdCAzIHNlY3MgYWZ0ZXIgX2ZpbmRpbmdQcm9taXNlIHJlc29sdmVzXHJcblxyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGlmICghc2VsZi5fZmluZGluZ1Byb21pc2UgfHwgIXNlbGYuX2ZpbmRpbmdQcm9taXNlLmlzUGVuZGluZygpKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3N0b3BGaW5kZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3N0b3BGaW5kZXJUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHEoc2VsZi5fZmluZGVyLnN0b3BGaW5kaW5nUHJpbnRlcnMoKSkuZG9uZSgpO1xyXG4gICAgICAgICAgICB9LCAzMDAwKTtcclxuXHJcbiAgICAgICAgICAgIHNlbGYuX2ZpbmRpbmdQcm9taXNlID0gcShcclxuICAgICAgICAgICAgICAgIHNlbGYuX2ZpbmRlci5maW5kUHJpbnRlcnMoZnVuY3Rpb24ocHJpbnRlckluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcHJpbnRlclByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgZGV0ZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLl9wcmludGVyQ2FjaGUuZ2V0KHByaW50ZXJJbmZvLnVpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRlclByb21pc2UgPSBzZWxmLl9jcmVhdGVQcmludGVyKHByaW50ZXJJbmZvKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2xvZ2dlci5sb2coZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRlclByb21pc2UgPSBxKHNlbGYuX3ByaW50ZXJDYWNoZS5nZXQocHJpbnRlckluZm8udWlkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwcmludGVyUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHByaW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbk1hbmFnZXIgPSBzZWxmLl9jb25uZWN0aW9uTWFuYWdlcnMuZ2V0KHByaW50ZXJJbmZvLnVpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgcHJpbnRlciBpcyBjb21pbmcgYmFjayBvbmxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW50ZXIuZ2V0U3RhdHVzKCkuc3RhdGUgPT09IFByaW50ZXJTdGF0ZUVudW0uT2ZmbGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX2N1cnJlbnRQcmludGVycy5pbmRleE9mKHByaW50ZXJJbmZvLnVpZCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRlci5zZXRTdGF0ZShQcmludGVyU3RhdGVFbnVtLlJlY29ubmVjdGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ZXIuc2V0U3RhdGUoUHJpbnRlclN0YXRlRW51bS5VbmF1dGhlbnRpY2F0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnVwZGF0ZUluZm8ocHJpbnRlckluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGhhY2sgdG8gbWFrZSB0aGlzIGNvbnRpbnVhdGlvbiBjYW5jZWxsYWJsZS4uLi5cclxuICAgICAgICAgICAgc2VsZi5fZmluZGluZ1Byb21pc2UuYWZ0ZXJGaW5kaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9jaGVja0Nvbm5lY3Rpb25zKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5fc3RhcnRGaW5kZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zdGFydEZpbmRlclRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpbmRQcmludGVycygpO1xyXG4gICAgICAgICAgICAgICAgfSwgMzAwMCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNlbGYuX2ZpbmRpbmdQcm9taXNlLmNhbmNlbEZpbmRpbmdDb250aW51YXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2ZpbmRpbmdQcm9taXNlLmFmdGVyRmluZGluZyA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBzZWxmLl9maW5kaW5nUHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX2ZpbmRpbmdQcm9taXNlLmFmdGVyRmluZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9maW5kaW5nUHJvbWlzZS5hZnRlckZpbmRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2xvZ2dlci5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5kb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9jaGVja0Nvbm5lY3Rpb25zKCkge1xyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2Ygc2VsZi5fY29ubmVjdGlvbk1hbmFnZXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhaXJbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHBhaXJbMV07XHJcbiAgICAgICAgICAgIHZhbC5jaGVja0Nvbm5lY3Rpb25zKClcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJpbnRlciA9IHNlbGYuX3ByaW50ZXJDYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZG91YmxlY2hlY2sgdGhpcy4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmludGVyLmFkZEVycm9yKEVycm9ycy5nZXRQbHVnaW5FcnJvcihlcnIudHlwZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9sb2dnZXIuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmRvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkQXJjaGV0eXBlUHJpbnRlcih2ZW5kb3JOYW1lLCBnZW5kZXJOYW1lKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBxKHRoaXMuX2NyZWF0ZUFyY2hldHlwZVByaW50ZXIodmVuZG9yTmFtZSwgZ2VuZGVyTmFtZSkpLnRoZW4oZnVuY3Rpb24ocHJpbnRlcikge1xyXG4gICAgICAgICAgICBzZWxmLl9zdG9yZWRQcmludGVyc01hbmFnZXIuc3RvcmVBcmNoZXR5cGUocHJpbnRlci5nZXRJZCgpLCB2ZW5kb3JOYW1lLCBnZW5kZXJOYW1lLCBzZWxmLl91c2VyVG9rZW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJpbnRlcjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfY3JlYXRlQXJjaGV0eXBlUHJpbnRlcih2ZW5kb3JOYW1lLCBnZW5kZXJOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclNlcnZpY2UuZ2V0R2VuZGVyKCdNYWtlckJvdCcsIGdlbmRlck5hbWUpLnRoZW4oZ2VuZGVyID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJpbnRlciA9IG5ldyBBcmNoZXR5cGVQcmludGVyKHZlbmRvck5hbWUsIGdlbmRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcmludGVycy5wdXNoKHByaW50ZXIuZ2V0SWQoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByaW50ZXJDYWNoZSA9IHRoaXMuX3ByaW50ZXJDYWNoZS5zZXQocHJpbnRlci5nZXRJZCgpLCBwcmludGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByaW50ZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2F0dGFjaFRyYWNraW5nRXZlbnRzKHByaW50ZXIpIHtcclxuICAgICAgICBwcmludGVyLnVwZGF0ZU5vdGlmaWNhdGlvbnMub24oJ2Nvbm5fdHlwZV9jaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWNraW5nSW5mbyA9IHV0aWwudHJhY2tpbmdJbmZvRm9yUHJpbnRlcihwcmludGVyKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q29ublR5cGUgPSBwcmludGVyLmdldENvbm5lY3Rpb25UeXBlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmV3Q29ublR5cGUgPT09IFByaW50ZXJDb25uVHlwZUVudW0uVVNCKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFja2luZ1NlcnZpY2UuYWRkRXZlbnQoXy5tZXJnZSh7IG5hbWU6ICdQcmludGVyIEFkZGVkIFVTQicgfSwgdHJhY2tpbmdJbmZvKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcHJpbnRlci51cGRhdGVOb3RpZmljYXRpb25zLm9uKCdkeWluZ19zY3JlYW0nLCBlcnIgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtwcmludGVyLmdldE5hbWUoKX0gfCAke2Vycn0gfCBDb25uZWN0aW9uOiAke3ByaW50ZXIuZ2V0Q29ubmVjdGlvblR5cGUoKX1gKTtcclxuXHJcbiAgICAgICAgICAgIC8qKiAqKiBNb25rZXkgUGF0Y2hpbmcgKipcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogV2hlbiBhIFVTQiBjb25uZWN0aW9uIGRpZXMsIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgdGhlIGNyb2lzc2FudFxyXG4gICAgICAgICAgICAgKiBuZXR3b3JrIGRpc2NvdmVyeSB3aWxsIHBpY2sgdXAgdGhlIHByaW50ZXIuIEJVVCB0aGVyZSBpcyBhXHJcbiAgICAgICAgICAgICAqIGhpZ2hlciBjaGFuY2UgdGhhdCBpdCB3b24ndCBiZSBwaWNrZWQgdXAgYnkgdGhlIG5ldHdvcmtcclxuICAgICAgICAgICAgICogZGlzY292ZXJ5LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBMZXQncyBhdHRlbXB0IHRvIGNvbm5lY3QgdmlhIElQIGFkZHJlc3MgYmVmb3JlIGRlY2lkaW5nIHRvIGxhYmVsXHJcbiAgICAgICAgICAgICAqIHRoZSBwcmludGVyIGFzIFwiT0ZGTElORVwiLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAtLSBSYXlcclxuICAgICAgICAgICAgICoqL1xyXG4gICAgICAgICAgICBpZiAocHJpbnRlci5nZXRDb25uZWN0aW9uVHlwZSgpID09PSBQcmludGVyQ29ublR5cGVFbnVtLlVTQikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByaW50ZXIuZ2V0SXBBZGRyZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEJ5SXAocHJpbnRlci5nZXRJcEFkZHJlc3MoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRlci5zZXRTdGF0ZShQcmludGVyU3RhdGVFbnVtLlJlY29ubmVjdGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmxvZyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7UHJpbnRlckNvbm5UeXBlRW51bS5VU0J9IENvbm5lY3Rpb24gZHJvcHBlZCBvdXQuIFN3aXRjaGluZyAke3ByaW50ZXIuZ2V0TmFtZSgpfSB0byAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJpbnRlckNvbm5UeXBlRW51bS5ORVRXT1JLXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXQgJHtwcmludGVyLmdldElwQWRkcmVzcygpfS4uLmBcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmludGVyLnVwZGF0ZU5vdGlmaWNhdGlvbnMuZW1pdCgnZG9EaXNjb25uZWN0JywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW50ZXIudXBkYXRlTm90aWZpY2F0aW9ucy5lbWl0KCdkb0Rpc2Nvbm5lY3QnLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJpbnRlci5nZXRDb25uZWN0aW9uVHlwZSgpID09PSBQcmludGVyQ29ublR5cGVFbnVtLk5FVFdPUkspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNraW5nSW5mbyA9IHV0aWwudHJhY2tpbmdJbmZvRm9yUHJpbnRlcihwcmludGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNraW5nU2VydmljZS5hZGRFdmVudChfLm1lcmdlKHsgbmFtZTogJ1ByaW50ZXIgRGlzY29ubmVjdGVkIGZyb20gTmV0d29yaycgfSwgdHJhY2tpbmdJbmZvKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VzZXJUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29uc3RydWN0IHByaW50ZXJJbmZvIHcvIHJlZmxlY3RvciBjb25uZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JvaXNzYW50IG9ubHkgY2FyZXMgYWJvdXQgdGhlIHVzZXJUb2tlbiAmIHVpZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJVVCBmb3IgdGhlIGFwcCB0byBwcm9wZXJseSBhc3NpZ24gcmVmbGVjdG9yIGNvbm5lY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIElQIGFkZHJlc3MgbmVlZHMgdG8gYmUgcGFyc2VkIG91dCBmcm9tICd0Y3A6PGlwYWRkcj5cclxuICAgICAgICAgICAgICAgICAgICAvLyA6cG9ydCMnIHRvICc8aXBhZGRyPidcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyUHJpbnRlckluZm8gPSB0aGlzLl9jb25uZWN0aW9uTWFuYWdlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldChwcmludGVyLmdldElkKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fcHJpbnRlckluZm9zLmdldChQcmludGVyQ29ublR5cGVFbnVtLk5FVFdPUkspO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYWRkcmVzcywgaW5mbyB9ID0gY3VyclByaW50ZXJJbmZvO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwcmludGVyLnNldFN0YXRlKFByaW50ZXJTdGF0ZUVudW0uUmVjb25uZWN0aW5nKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyUHJpbnRlckluZm8uYWRkcmVzcyA9IC9eKD86WzAtOV17MSwzfVxcLil7M31bMC05XXsxLDN9JC8udGVzdChhZGRyZXNzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGFkZHJlc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhZGRyZXNzLnNwbGl0KCc6JylbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyclByaW50ZXJJbmZvLmluZm8gPSB7IGJvdF90eXBlOiBpbmZvLmJvdF90eXBlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyclByaW50ZXJJbmZvLmNvbm5UeXBlID0gUHJpbnRlckNvbm5UeXBlRW51bS5SRUZMRUNUT1I7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5sb2coXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJpbnRlckNvbm5UeXBlRW51bS5ORVRXT1JLXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gQ29ubmVjdGlvbiBkcm9wcGVkIG91dC4gU3dpdGNoaW5nICR7cHJpbnRlci5nZXROYW1lKCl9IG92ZXIgdG8gUmVmbGVjdG9yLi4uYFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVByaW50ZXIoY3VyclByaW50ZXJJbmZvKS50aGVuKHByaW50ZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uTWFuYWdlcnMuZ2V0KGN1cnJQcmludGVySW5mby51aWQpLnVwZGF0ZUluZm8oY3VyclByaW50ZXJJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aEZyb21TdG9yZWQoY3VyclByaW50ZXJJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmludGVyLnVwZGF0ZU5vdGlmaWNhdGlvbnMuZW1pdCgnZG9EaXNjb25uZWN0JywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJpbnRlci51cGRhdGVOb3RpZmljYXRpb25zLmVtaXQoJ2RvRGlzY29ubmVjdCcsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGh0dHA6Ly9qaXJhLm1ha2VyYm90Lm5ldC9icm93c2UvUEVOLTEyNTVcclxuICAgICAgICAvLyBDb21tZW50aW5nIG91dCB1bnRpbCB3ZSBmaWd1cmUgb3V0IHdoZW4gZXhhY3RseSB3ZSB3YW50IHRoZXNlIGV2ZW50c1xyXG4gICAgICAgIC8vIHRvIGJlIHNlbnQgZnJvbSBvdXIgc2lkZS4uLlxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgbGV0IHBwID0gJ1ByaW50UHJvY2Vzcyc7XHJcblxyXG4gICAgICAgIGxldCBzZW5kUHJpbnRUcmFja2luZ0V2ZW50ID0gKG5hbWUpID0+IHtcclxuICAgICAgICAgICAgbGV0IHRyYWNraW5nSW5mbyA9IHV0aWwudHJhY2tpbmdJbmZvRm9yUHJpbnRlcihwcmludGVyKTtcclxuICAgICAgICAgICAgdHJhY2tpbmdJbmZvLmV4dHJ1ZGVyX3R5cGUgPSBwcmludGVyLmdldEN1cnJlbnRFeHRydWRlclR5cGUoKTtcclxuICAgICAgICAgICAgdGhpcy5fdHJhY2tpbmdTZXJ2aWNlLmFkZEV2ZW50KFxyXG4gICAgICAgICAgICAgICAgXy5tZXJnZSh7IG5hbWU6IG5hbWUgfSwgdHJhY2tpbmdJbmZvKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcHJpbnRlci51cGRhdGVOb3RpZmljYXRpb25zLm9uKFxyXG4gICAgICAgICAgICAncHJvY2Vzc19jb21wbGV0ZWQnLFxyXG4gICAgICAgICAgICAoaW5mbykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZm8uY3VycmVudF9wcm9jZXNzLm5hbWUgPT09IHBwKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbmRQcmludFRyYWNraW5nRXZlbnQoXCJQcmludCBDb21wbGV0ZWRcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBwcmludGVyLnVwZGF0ZU5vdGlmaWNhdGlvbnMub24oXHJcbiAgICAgICAgICAgICdwcm9jZXNzX2NhbmNlbGxlZCcsXHJcbiAgICAgICAgICAgIChpbmZvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5jdXJyZW50X3Byb2Nlc3MubmFtZSA9PT0gcHApXHJcbiAgICAgICAgICAgICAgICAgICAgc2VuZFByaW50VHJhY2tpbmdFdmVudChcIlByaW50IENhbmNlbGxlZFwiKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHByaW50ZXIudXBkYXRlTm90aWZpY2F0aW9ucy5vbihcclxuICAgICAgICAgICAgJ3Byb2Nlc3NfZmFpbGVkJyxcclxuICAgICAgICAgICAgKGluZm8pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmZvLmN1cnJlbnRfcHJvY2Vzcy5uYW1lID09PSBwcClcclxuICAgICAgICAgICAgICAgICAgICBzZW5kUHJpbnRUcmFja2luZ0V2ZW50KFwiUHJpbnQgRmFpbGVkXCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAqL1xyXG4gICAgfVxyXG5cclxuICAgIF9jcmVhdGVQcmludGVyKHByaW50ZXJJbmZvLCBtYWNoaW5lQ29uZmlnKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHByaW50ZXJJbmZvLmluZm8uYm90X3R5cGUgPT09IEJvdFR5cGVFbnVtLnNrZXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0R2VuZGVyKHByaW50ZXJJbmZvLmluZm8uYm90X3R5cGUpLnRoZW4oZnVuY3Rpb24oZ2VuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmludGVyID0gbmV3IFNrZXRjaFByaW50ZXIocHJpbnRlckluZm8sIGdlbmRlciwgc2VsZi5fdXNlclRva2VuLCBzZWxmKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3ByaW50ZXJDYWNoZSA9IHNlbGYuX3ByaW50ZXJDYWNoZS5zZXQocHJpbnRlckluZm8udWlkLCBwcmludGVyKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2F0dGFjaFRyYWNraW5nRXZlbnRzKHByaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW50ZXI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcigpO1xyXG4gICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnVwZGF0ZUluZm8ocHJpbnRlckluZm8pO1xyXG4gICAgICAgIHNlbGYuX2Nvbm5lY3Rpb25NYW5hZ2VycyA9IHNlbGYuX2Nvbm5lY3Rpb25NYW5hZ2Vycy5zZXQocHJpbnRlckluZm8udWlkLCBjb25uZWN0aW9uTWFuYWdlcik7XHJcblxyXG4gICAgICAgIC8vIGhvb2sgdXAgZXZlbnRzXHJcbiAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIub24oJ25lZWRfYXV0aCcsIGZ1bmN0aW9uKHByaW50ZXJJbmZvLCBkb25lQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgc2VsZi5hdXRoRnJvbVN0b3JlZChwcmludGVySW5mbykubm9kZWlmeShkb25lQ2FsbGJhY2spO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLm9uKFxyXG4gICAgICAgICAgICAndXBkYXRlJyxcclxuICAgICAgICAgICAgZnVuY3Rpb24ocHJpbnRlckluZm8pIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIHN0b3JlZCBpbmZvIGZvciBib3QgaWYgd2UncmUgc3RvcmluZyBpbmZvIGZvciBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3N0b3JlZFByaW50ZXJzTWFuYWdlci5nZXRQcmludGVyKHByaW50ZXJJbmZvLnVpZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3RvcmVkUHJpbnRlcnNNYW5hZ2VyLnVwZGF0ZVN0b3JlZEluZm8ocHJpbnRlckluZm8pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGYuX2dldEdlbmRlcihwcmludGVySW5mby5pbmZvLmJvdF90eXBlKS50aGVuKGZ1bmN0aW9uKGdlbmRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBwcmludGVyID0gbmV3IE1ha2VyQm90UHJpbnRlcihwcmludGVySW5mbywgZ2VuZGVyLCBtYWNoaW5lQ29uZmlnLCBjb25uZWN0aW9uTWFuYWdlcik7XHJcbiAgICAgICAgICAgIHNlbGYuX3ByaW50ZXJDYWNoZSA9IHNlbGYuX3ByaW50ZXJDYWNoZS5zZXQocHJpbnRlckluZm8udWlkLCBwcmludGVyKTtcclxuICAgICAgICAgICAgc2VsZi5fYXR0YWNoVHJhY2tpbmdFdmVudHMocHJpbnRlcik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcHJpbnRlcjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0R2VuZGVyKGJvdF90eXBlKSB7XHJcbiAgICAgICAgY29uc3QgZ2VuZGVyTmFtZSA9IHV0aWwuYm90VHlwZVRvR2VuZGVyKGJvdF90eXBlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU2VydmljZS5nZXRHZW5kZXIoJ01ha2VyQm90JywgZ2VuZGVyTmFtZSwgYm90X3R5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEJ5SXAoaXApIHtcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHEoc2VsZi5fZmluZGVyLmZpbmRCeUlwKGlwKSkudGhlbihmdW5jdGlvbihwcmludGVySW5mbykge1xyXG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IG5vbi1zdXBwb3J0ZWQgYm90cyBmcm9tIGJlaW5nIGNvbm5lY3RlZFxyXG4gICAgICAgICAgICBpZiAoIUJvdFR5cGVFbnVtLmhhc093blByb3BlcnR5KHByaW50ZXJJbmZvLmluZm8uYm90X3R5cGUpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBsZXQgcHJpbnRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkUHJpbnRlciA9IHNlbGYuX3ByaW50ZXJDYWNoZS5nZXQocHJpbnRlckluZm8udWlkKTtcclxuXHJcbiAgICAgICAgICAgIHByaW50ZXIgPSBjb21wYXJlQ29ublR5cGUoY2FjaGVkUHJpbnRlciwgcHJpbnRlckluZm8pID49IDAgPyBjYWNoZWRQcmludGVyIDogcHJpbnRlcjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHByaW50ZXJQcm9taXNlID0gcHJpbnRlciA/IHEocHJpbnRlcikgOiBzZWxmLl9jcmVhdGVQcmludGVyKHByaW50ZXJJbmZvKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwcmludGVyUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHByaW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmludGVyLmlzQXV0aGVudGljYXRlZCgpKSByZXR1cm4gcHJpbnRlcjtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLl9jb25uZWN0aW9uTWFuYWdlcnMuZ2V0KHByaW50ZXJJbmZvLnVpZCkudXBkYXRlSW5mbyhwcmludGVySW5mbyk7XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IHRvIGF1dGggZnJvbSBzdG9yZWQgaW5mbzsgaWYgaXQgZmFpbHMsIGp1c3RcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcHJpbnRlciBhbmQgYXV0aCB3aWxsIGJlIHJlcXVlc3RlZCBmb3IgaXRcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuYXV0aEZyb21TdG9yZWQocHJpbnRlckluZm8pO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByaW50ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlY29ubmVjdFByaW50ZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBSZWNvbm5lY3RpbmcgUHJpbnRlcnMuLi5gKTtcclxuICAgICAgICAvLyBMaXN0IHRocm91Z2ggYWxsIHRoZSBjdXJyZW50IHByaW50ZXJzIGFuZCB0cnkgdG8gcmVhdXRoIHVzaW5nXHJcbiAgICAgICAgLy8gdGhlIGxhdGVzdCBwcmludGVySW5mbyBmcm9tIHRoZSBfY29ubmVjdGlvbk1hbmFnZXIuXHJcbiAgICAgICAgdGhpcy5fY3VycmVudFByaW50ZXJzLmZvckVhY2godWlkID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJpbnRlciA9IHRoaXMuX3ByaW50ZXJDYWNoZS5nZXQodWlkKTtcclxuICAgICAgICAgICAgaWYgKHByaW50ZXIuZ2V0Q29ubmVjdGlvblR5cGUoKSA9PT0gUHJpbnRlckNvbm5UeXBlRW51bS5BUkNIRVRZUEUpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmICghcHJpbnRlci5pc1NrZXRjaFByaW50ZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0TWFrZXJCb3RQcmludGVyKHVpZCwgcHJpbnRlcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3RTa2V0Y2hQcmludGVyKHByaW50ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgX3JlY29ubmVjdE1ha2VyQm90UHJpbnRlcih1aWQsIHByaW50ZXIpIHtcclxuICAgICAgICBjb25zdCBjdXJyQ29ubk1hbmFnZXIgPSB0aGlzLl9jb25uZWN0aW9uTWFuYWdlcnMuZ2V0KHVpZCk7XHJcbiAgICAgICAgY29uc3QgeyBfY3VycmVudENvbm5UeXBlIH0gPSBjdXJyQ29ubk1hbmFnZXI7XHJcbiAgICAgICAgY29uc3QgcHJpbnRlckluZm8gPSBjdXJyQ29ubk1hbmFnZXIuX3ByaW50ZXJJbmZvcy5nZXQoX2N1cnJlbnRDb25uVHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChwcmludGVySW5mbykge1xyXG4gICAgICAgICAgICAvLyBPTkxZIHJlY29ubmVjdCB0byBwcmludGVycyB3aXRoIFByaW50ZXJJbmZvXHJcbiAgICAgICAgICAgIC8vIE9GRkxJTkUgUHJpbnRlcnMgd2lsbCBub3QgaGF2ZSBhIGNyb2lzc2FudC5wcmludGVySW5mb1xyXG4gICAgICAgICAgICAvLyBzdG9yZWQgaW4gY29ubmVjdGlvbk1hbmFnZXJcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYFJlY29ubmVjdGluZyAke3ByaW50ZXIuZ2V0TmFtZSgpfSBwcmludGVyIHZpYSAke3ByaW50ZXJJbmZvLmNvbm5UeXBlfWApO1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhGcm9tU3RvcmVkKHByaW50ZXJJbmZvKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX3JlY29ubmVjdFNrZXRjaFByaW50ZXIocHJpbnRlcikge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuX3VzZXJUb2tlbn1gLFxyXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXJsOiBgJHtyZWZsZWN0b3JVcmx9L3ByaW50ZXJzLyR7cHJpbnRlci5nZXRJc2VyaWFsKCl9YCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXF1ZXN0KG9wdGlvbnMsIChlcnIsIHJlcywgYm9keSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyIHx8ICFbMjAwLCAyMDFdLmluY2x1ZGVzKHJlcy5zdGF0dXNDb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYEVycm9yISBVbmFibGUgdG8gcmVjb25uZWN0IHZpYSBSZWZsZWN0b3IgZm9yIFNrZXRjaCBQcmludGVyICR7cHJpbnRlci5nZXROYW1lKCl9YCk7XHJcbiAgICAgICAgICAgICAgICBwcmludGVyLnNldFN0YXRlKFByaW50ZXJTdGF0ZUVudW0uT2ZmbGluZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uQm9keSA9IEpTT04ucGFyc2UoYm9keSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmludGVySW5mbyA9IHRoaXMuX2Zvcm1hdFJlZmxlY3RvclByaW50ZXJJbmZvKGpzb25Cb2R5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBSZWNvbm5lY3RpbmcgU2tldGNoIHByaW50ZXIsICR7cHJpbnRlci5nZXROYW1lKCl9LCB2aWEgJHtwcmludGVySW5mby5jb25uVHlwZX1gKTtcclxuICAgICAgICAgICAgICAgIHByaW50ZXIuc2V0U3RhdGUoUHJpbnRlclN0YXRlRW51bS5SZWNvbm5lY3RpbmcpO1xyXG4gICAgICAgICAgICAgICAgcHJpbnRlci51cGRhdGVGcm9tUHJpbnRlckluZm8ocHJpbnRlckluZm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLUFVVEggU1RVRkYtLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBkZWF1dGhlbnRpY2F0ZShwcmludGVyKSB7XHJcbiAgICAgICAgY29uc3QgdWlkID0gcHJpbnRlci5nZXRJZCgpO1xyXG5cclxuICAgICAgICBjb25zdCBjb25uTWFuYWdlciA9IHRoaXMuX2Nvbm5lY3Rpb25NYW5hZ2Vycy5nZXQodWlkKTtcclxuICAgICAgICBpZiAoY29ubk1hbmFnZXIpIHtcclxuICAgICAgICAgICAgcHJpbnRlci5kZWF1dGhlbnRpY2F0ZSh0aGlzLl91c2VySW5mbyA/IHRoaXMuX3VzZXJJbmZvLm5hbWUgOiAnQU5PTicpO1xyXG4gICAgICAgICAgICBjb25uTWFuYWdlci5jaGFuZ2VDb25uZWN0aW9uKG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9jdXJyZW50UHJpbnRlcnMuaW5kZXhPZih1aWQpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkgdGhpcy5fY3VycmVudFByaW50ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgdGhpcy5fc3RvcmVkUHJpbnRlcnNNYW5hZ2VyLnJlbW92ZVByaW50ZXJGb3JVc2VyKHVpZCwgdGhpcy5fdXNlclRva2VuKTtcclxuICAgIH1cclxuXHJcbiAgICBfZG9BdXRoZW50aWNhdGUoY29ubmVjdFByb21pc2UsIHByaW50ZXIsIHByaW50ZXJJbmZvKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGNvbnN0IGF1dGhSZXN1bHQgPSB7fTtcclxuXHJcbiAgICAgICAgY29ubmVjdFByb21pc2UuY29udGludWF0aW9uID0gZnVuY3Rpb24ocmVzKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX2xvZ2dlci5sb2coXHJcbiAgICAgICAgICAgICAgICBgU3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCB0byAke3ByaW50ZXJJbmZvLm5hbWV9IHVzaW5nIGNvbm5lY3Rpb24gdHlwZTogJHtwcmludGVySW5mby5jb25uVHlwZX1gXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGF1dGhSZXN1bHQucHJpbnRlciA9IHJlc1swXTtcclxuICAgICAgICAgICAgYXV0aFJlc3VsdC5hdXRoSW5mbyA9IHJlc1sxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFsZXJ0IHRoZSBwcmludGVyJ3MgY29ubmVjdGlvbk1hbmFnZXIgdGhhdCBhdXRoIGhhcyBjb21wbGV0ZWRcclxuICAgICAgICAgICAgc2VsZi5fY29ubmVjdGlvbk1hbmFnZXJzLmdldChwcmludGVySW5mby51aWQpLmNoYW5nZUNvbm5lY3Rpb24oYXV0aFJlc3VsdC5wcmludGVyLCBwcmludGVySW5mbyk7XHJcblxyXG4gICAgICAgICAgICBsZXQgYWRkQWNjb3VudFByb21pc2UgPSBxKCk7XHJcbiAgICAgICAgICAgIGlmIChwcmludGVySW5mby5jb25uVHlwZSA9PT0gUHJpbnRlckNvbm5UeXBlRW51bS5VU0IgJiYgc2VsZi5fdXNlclRva2VuKVxyXG4gICAgICAgICAgICAgICAgYWRkQWNjb3VudFByb21pc2UgPSBwcmludGVyLmludm9rZSgnQWRkTWFrZXJib3RBY2NvdW50JywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3VzZXJJbmZvID8gc2VsZi5fdXNlckluZm8ubmFtZSA6ICdBTk9OJyxcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl91c2VyVG9rZW4sXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFkZEFjY291bnRQcm9taXNlXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jdXJyZW50UHJpbnRlcnMucHVzaChwcmludGVyLmdldElkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgnYWRkX3ByaW50ZXInLCBwcmludGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2lnaC4uLiB3ZSBzaG91bGQgbG9vayBpbnRvIHdoZXRoZXIgd2UgcmVhbGx5IG5lZWQgdG8gY2FsbCB0aGlzIGhlcmUuLi5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJpZ2h0IG5vdyBpdCBnZXRzIGNhbGxlZCBzbyB0aGF0IHByaW50ZXIuZ2V0VHJhY2tpbmdJbmZvIHdpbGxcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIHNvbWUgZXh0cnVkZXIgc3RhdHMtLSBidXQgdGhvc2UgYXJlbid0IGV2ZW4gZ3VhcmFudGVlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGNvcnJlY3QsIHNpbmNlIHdlIGRvbid0IHVwZGF0ZSBpdCBhdCBhbGwgYWZ0ZXIgZ2V0dGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHRoZSBmaXJzdCB0aW1lIChhbmQgaXQgdXNlZCB0byBiZSBjYWxsZWQgaW4gdXBkYXRlU2NoZW1hIHRvbywgV0hZPz8/KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgaXQgbmVjZXNzYXJ5IGluIHRoZSBmaXJzdCBwbGFjZSBmb3IgQUxMIHRyYWNraW5nIGluZm8gZm9yIGEgcHJpbnRlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbnRhaW4gZXh0cnVkZXIgc3RhdHM/IElmIHNvLCB0aGlzIHNob3VsZCBiZSBjYWxsZWQgaW4gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0VHJhY2tpbmdJbmZvIG1ldGhvZCBvZiBNQlByaW50ZXIgKHdoaWNoIEknbSB3YXJ5IG9mIGhhdmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBwcmludGVyIGNsYXNzIGluIHRoZSBmaXJzdCBwbGFjZSksIHdoaWNoIHdvdWxkIG5lY2Vzc2l0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0VHJhY2tpbmdJbmZvIHRvIGJlIGEgcHJvbWlzZSwgd2hpY2ggd291bGQgcmVxdWlyZSBjaGFuZ2VzIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsIHRoZSBjdXJyZW50IHRyYWNraW5nIGV2ZW50LWhhbmRsaW5nIGNvZGUuLi5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vSWYgbm90LCB0aGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVyZSBuZWNlc3NhcnkgKGFuZCBqdXN0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW52b2tlLCByYXRoZXIgdGhhbiBzdG9yaW5nIHRoZSBleHRydWRlciBzdGF0cyBhcyBhIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgICAgLy9vZiB0aGUgcHJpbnRlciBvYmplY3QuLi4uKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmludGVyLnVwZGF0ZUV4dHJ1ZGVyU3RhdHMoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUZW1wb3JhcnkoPyk6IGRvIG5vdCBmYWlsIGF1dGggaWYgdXBkYXRlTWFjaGluZUNvbmZpZyBmYWlscy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBdXRoIGhhcyBzdWNjZWVkZWQgYXQgdGhpcyBwb2ludCB0aG91Z2gsIHNvIHdlIHNob3VsZCBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBwcm9wZXJseS4uLiBIb3BlZnVsbHkgd2Ugd2lsbCBzb29uIGJlIG1vdmluZyBhd2F5IGZyb21cclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXR0aW5nIHRoZSBzY2hlbWEgaW4gdGhpcyBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSwgd2UgY2FuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWl0aGVyIGtlZXAgdGhpcyB0aGUgd2F5IGl0IGlzIG5vdywgb3IgZ28gYmFjayB0byBob3cgaXQgd2FzIGJlZm9yZS4uLlxyXG4gICAgICAgICAgICAgICAgICAgIHByaW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZU1hY2hpbmVDb25maWcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9sb2dnZXIud2FybihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hY2hpbmVDb25maWcgPSBzZWxmLl9wcmludGVyQ2FjaGUuZ2V0KHByaW50ZXJJbmZvLnVpZCkubWFjaGluZUNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9zdG9yZWRQcmludGVyc01hbmFnZXIudXBkYXRlU3RvcmVkSW5mbyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludGVySW5mbyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWNoaW5lQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhSZXN1bHQuYXV0aEluZm8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fdXNlclRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJpbnRlcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbm5lY3RQcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRpbnVhdGlvbiA9IGZ1bmN0aW9uKHJlcykge1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZz9cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzZWxmLl9hdXRoUHJvbWlzZXMuc2V0KHByaW50ZXIuZ2V0SWQoKSwgY29ubmVjdFByb21pc2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gY29ubmVjdFByb21pc2VcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcS5hbGwocmVzKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRpbWVvdXQoUFJJTlRFUl9BVVRIX1RJTUVPVVQpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RQcm9taXNlLmNvbnRpbnVhdGlvbihyZXMpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFVElNRURPVVQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2tpbmdJbmZvID0gdXRpbC50cmFja2luZ0luZm9Gb3JQcmludGVyKHByaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyYWNraW5nU2VydmljZS5hZGRFdmVudChcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy5tZXJnZSh0cmFja2luZ0luZm8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdSZWF1dGhlbnRpY2F0aW9uIFRpbWVvdXQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbl90eXBlOiBwcmludGVySW5mby5jb25uVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuX2xvZ2dlci5lcnJvcihcclxuICAgICAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZSB0byBwcmludGVyICR7cHJpbnRlckluZm8ubmFtZX0gb3ZlciBjb25uZWN0aW9uIHR5cGUgJHtwcmludGVySW5mby5jb25uVHlwZX06ICR7ZXJyfWBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uTWFuYWdlciA9IHNlbGYuX2Nvbm5lY3Rpb25NYW5hZ2Vycy5nZXQocHJpbnRlckluZm8udWlkKTtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXV0aCByZXF1ZXN0IG1heSBiZSBoYXBwZW5pbmcgYmVjYXVzZSB3ZSdyZSB0cnlpbmcgdG8gbW92ZVxyXG4gICAgICAgICAgICAgICAgLy8gZnJvbSBhIGxvd2VyIHByaW9yaXR5IG9uZSB0byBhIGhpZ2hlciBwcmlvcml0eSBvbmU7IGlmIGl0IGZhaWxzXHJcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGVnLiBhdXRoIGNvZGUgaXMgbm8gbG9uZ2VyIHZhbGlkLCB3ZSBkb24ndCB3YW50IE1CUHJpbnRlclxyXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhpbmsgaXQncyBiZWNvbWUgdW5hdXRoZW50aWNhdGVkIHdoZW4gaXQgc3RpbGwgaGFzIGl0cyBsb3dlclxyXG4gICAgICAgICAgICAgICAgLy8gcHJpb3JpdHkgY29ubmVjdGlvbiAoc28gd2Ugb25seSBjaGFuZ2UgdG8gdW5hdXRoJ2Qgd2hlbiB3ZSBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyBubyBmYWxsYmFjaylcclxuICAgICAgICAgICAgICAgIGlmICghY29ubmVjdGlvbk1hbmFnZXIuY3VycmVudENvbm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRlci5zZXRTdGF0ZShQcmludGVyU3RhdGVFbnVtLlVuYXV0aGVudGljYXRlZCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW50ZXIuc2V0U3RhdGUoUHJpbnRlclN0YXRlRW51bS5QZW5kaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9hdXRoUHJvbWlzZXMuZGVsZXRlKHByaW50ZXIuZ2V0SWQoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGF1dGhGcm9tU3RvcmVkKHByaW50ZXJJbmZvKSB7XHJcbiAgICAgICAgY29uc3QgcHJpbnRlciA9IHRoaXMuX3ByaW50ZXJDYWNoZS5nZXQocHJpbnRlckluZm8udWlkKTtcclxuICAgICAgICBpZiAocHJpbnRlci5pc0F1dGhlbnRpY2F0aW5nKCkpIHJldHVybiBxKHByaW50ZXIpO1xyXG5cclxuICAgICAgICAvLyBjaGVjayBmb3Igc3RvcmVkIGF1dGggaW5mb3JtYXRpb247IG9ubHkgcmVsZXZhbnQgZm9yIG5ldHdvcmsgcHJpbnRlcnNcclxuICAgICAgICBsZXQgYXV0aEluZm87XHJcbiAgICAgICAgaWYgKHByaW50ZXJJbmZvLmNvbm5UeXBlID09PSBQcmludGVyQ29ublR5cGVFbnVtLk5FVFdPUkspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRQcmludGVycy5pbmRleE9mKHByaW50ZXJJbmZvLnVpZCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3VzZXJUb2tlbikgYXV0aEluZm8gPSB0aGlzLl9zdG9yZWRQcmludGVyc01hbmFnZXIuZ2V0UHJpbnRlcihwcmludGVySW5mby51aWQpLmF1dGhJbmZvO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ05vIHN0b3JlZCBhdXRoIGluZm8gZm9yIG5ldHdvcmsgcHJpbnRlcic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgQXR0ZW1wdGluZyByZWF1dGggJHtwcmludGVySW5mby5uYW1lfSBvdmVyIGNvbm5lY3Rpb24gdHlwZTogJHtwcmludGVySW5mby5jb25uVHlwZX1gKTtcclxuICAgICAgICBwcmludGVyLnNldFN0YXRlKFByaW50ZXJTdGF0ZUVudW0uUmVhdXRoZW50aWNhdGluZyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3RQcm9taXNlID0gcVxyXG4gICAgICAgICAgICAudHJ5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhJbmZvXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLl9maW5kZXIucmVjb25uZWN0UHJpbnRlcihwcmludGVySW5mbywgYXV0aEluZm8pXHJcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLl9maW5kZXIucmVjb25uZWN0UHJpbnRlcihwcmludGVySW5mbyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHByaW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbcHJpbnRlciwgcShhdXRoSW5mbyldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZG9BdXRoZW50aWNhdGUoY29ubmVjdFByb21pc2UsIHByaW50ZXIsIHByaW50ZXJJbmZvKS5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgY3JvaXNzYW50LlVuYXV0aG9yaXplZEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIubG9nKFxyXG4gICAgICAgICAgICAgICAgICAgIGBSZWF1dGggdG8gJHtwcmludGVySW5mby5uYW1lfSByZWplY3RlZCBhcyBVbmF1dGhvcml6ZWQ7IGAgKyBgcmVtb3ZpbmcgbG9jYWwgcHJpbnRlciBpbmZvIGZvciB1c2VyYFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVhdXRoZW50aWNhdGUocHJpbnRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlcXVlc3ROZXdBdXRoKHByaW50ZXJJbmZvKSB7XHJcbiAgICAgICAgY29uc3QgcHJpbnRlciA9IHRoaXMuX3ByaW50ZXJDYWNoZS5nZXQocHJpbnRlckluZm8udWlkKTtcclxuICAgICAgICBpZiAocHJpbnRlci5pc0F1dGhlbnRpY2F0aW5nKCkgfHwgcHJpbnRlci5pc0F1dGhlbnRpY2F0ZWQoKSkgcmV0dXJuIHEocHJpbnRlcik7XHJcblxyXG4gICAgICAgIGlmIChwcmludGVySW5mby5jb25uVHlwZSA9PT0gUHJpbnRlckNvbm5UeXBlRW51bS5ORVRXT1JLKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcclxuICAgICAgICAgICAgICAgIGBSZXF1ZXN0aW5nIG5ldyBhdXRoIHRvICR7cHJpbnRlckluZm8ubmFtZX0gb3ZlciBjb25uZWN0aW9uIHR5cGU6ICR7cHJpbnRlckluZm8uY29ublR5cGV9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwcmludGVyLnNldFN0YXRlKFByaW50ZXJTdGF0ZUVudW0uQXV0aGVudGljYXRpbmcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgQXR0ZW1wdGluZyByZWF1dGggJHtwcmludGVySW5mby5uYW1lfSBvdmVyIGNvbm5lY3Rpb24gdHlwZTogJHtwcmludGVySW5mby5jb25uVHlwZX1gKTtcclxuICAgICAgICAgICAgcHJpbnRlci5zZXRTdGF0ZShQcmludGVyU3RhdGVFbnVtLlJlYXV0aGVudGljYXRpbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY29ubmVjdFByb21pc2UgPSBxKHRoaXMuX2ZpbmRlci5jb25uZWN0UHJpbnRlcihwcmludGVySW5mbykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kb0F1dGhlbnRpY2F0ZShjb25uZWN0UHJvbWlzZSwgcHJpbnRlciwgcHJpbnRlckluZm8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRyeSB0byBhdXRoIHdpdGggdGhlIGhpZ2hlc3QtYXZhaWxhYmxlLXByaW9yaXR5IHByaW50ZXJJbmZvLCB3aXRob3V0IHVzaW5nXHJcbiAgICAvLyBzdG9yZWQgYXV0aEluZm9cclxuICAgIGF1dGhlbnRpY2F0ZShwcmludGVyKSB7XHJcbiAgICAgICAgY29uc3QgYXV0aFJlc09iaiA9IHtcclxuICAgICAgICAgICAgcHJpbnRlcixcclxuICAgICAgICAgICAgd2FzTmV3QXV0aDogZmFsc2UsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJpbnRlckluZm8gPSB0aGlzLl9jb25uZWN0aW9uTWFuYWdlcnMuZ2V0KHByaW50ZXIuZ2V0SWQoKSkuZ2V0SGlnaGVzdFByaW9yaXR5Q29ubkluZm8oKTtcclxuICAgICAgICBpZiAoIXByaW50ZXJJbmZvKSB0aHJvdyAnQ2Fubm90IGF1dGhlbnRpY2F0ZSB0byBhbiBvZmZsaW5lIHByaW50ZXInO1xyXG5cclxuICAgICAgICBjb25zdCBpc05ldHdvcmtCb3QgPSBwcmludGVySW5mby5jb25uVHlwZSA9PT0gUHJpbnRlckNvbm5UeXBlRW51bS5ORVRXT1JLO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgYm90IGlzIGEgbmV0d29yayBib3QgYW5kIHdlIGRvbid0IHRoaW5rIGl0IGJlbG9uZ3MgdG8gdGhlIGN1cnJlbnRcclxuICAgICAgICAvLyB1c2VyLCBnbyBzdHJhaWdodCB0byBidXR0b24tcHJlc3MgYXV0aFxyXG4gICAgICAgIGlmIChpc05ldHdvcmtCb3QgJiYgdGhpcy5fY3VycmVudFByaW50ZXJzLmluZGV4T2YocHJpbnRlckluZm8udWlkKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgYXV0aFJlc09iai53YXNOZXdBdXRoID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdE5ld0F1dGgocHJpbnRlckluZm8pLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhSZXNPYmo7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCB0cnkgYXV0aGluZyBmcm9tIHN0b3JlZFxyXG4gICAgICAgIHJldHVybiB0aGlzLmF1dGhGcm9tU3RvcmVkKHByaW50ZXJJbmZvKS5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAvLyBpZiBvdXIgcmVhdXRoIHRvIGEgbmV0d29yayBib3Qgd2FzIGRlbmllZCwgdHJ5IGJ1dHRvbiBhdXRoXHJcbiAgICAgICAgICAgIGlmIChpc05ldHdvcmtCb3QgJiYgZXJyIGluc3RhbmNlb2YgY3JvaXNzYW50LlVuYXV0aG9yaXplZEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBhdXRoUmVzT2JqLndhc05ld0F1dGggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdE5ld0F1dGgocHJpbnRlckluZm8pLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRoUmVzT2JqO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByaW50ZXJNYW5hZ2VyO1xyXG4iXX0=
