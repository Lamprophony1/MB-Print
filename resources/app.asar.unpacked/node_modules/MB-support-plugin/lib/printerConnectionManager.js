'use strict';

const EventEmitter = require('eventemitter3');

const q = require('q');

const PRINTER_CONNECTION_TIMEOUT = require('./constants').PRINTER_CONNECTION_TIMEOUT;

const PrinterConnTypeEnum = require('./constants').PrinterConnTypeEnum;

const PRIORITY = [PrinterConnTypeEnum.USB, PrinterConnTypeEnum.NETWORK, PrinterConnTypeEnum.REFLECTOR];
/*
Events:
    update: emitted when we think printer info should be updated
    connection_change: emitted when the connection type should change (eg.
        switching from network to usb connection)
    need_auth: emitted to request that authentication be done for the given
        printerInfo
    check_life: emitted to ask MBPrinter to check that its current connection
        is still alive
*/

class ConnectionManager extends EventEmitter {
  constructor() {
    super();
    this.setInitState();
  } // there's probably a better way to handle this (architecturally) such that
  // this isn't needed, but I guess it's okay for now...?


  setInitState() {
    this._printerInfos = new Map();
    this._currentConnType = null; // TODO: keep previous printer around for some time?

    this._lastReaped = null;
    this._prevInfos = new Map();
  }

  _infosAreEqual(printerInfo1, printerInfo2) {
    // ignore timestamps in our equality-checking (make copies of the
    // printerInfos so we don't end up changing them)
    const pInfo1 = Object.assign({}, printerInfo1);
    delete pInfo1.timestamp;
    const pInfo2 = Object.assign({}, printerInfo2);
    delete pInfo2.timestamp;
    return JSON.stringify(pInfo1) === JSON.stringify(pInfo2);
  }

  hasConnType(connType) {
    return !!this._printerInfos.get(connType);
  } // returns the printerInfo for the highest priority connection available


  getHighestPriorityConnInfo() {
    for (const connType of PRIORITY) {
      const conn = this._printerInfos.get(connType);

      if (conn) return conn;
    }

    return null;
  } // return true if connType1 is of higher priority than connType2 (invalid being
  // lowest priority);
  // return false if connType1 is invalid (regardless of whether connType2 is valid)


  static isHigherPriority(connType1, connType2) {
    const c1index = PRIORITY.indexOf(connType1);
    const c2index = PRIORITY.indexOf(connType2);
    if (c1index < 0) return false;else if (c2index < 0) return true;else return c1index < c2index;
  }

  updateInfo(printerInfo) {
    const connType = printerInfo.connType;
    const highestPriorityConnInfo = this.getHighestPriorityConnInfo(); // should request infos be updated if:
    // * this is the first printerInfo we're receiving for this bot or
    // * if printer is connected, and the info is for the current connection or
    // * the printer is not connected, and the info is for the highest priority
    // * of connType currently available
    // AND
    // * info has changed
    // * (otherwise, info that is connType specific, like address, will get
    // * changed every time a bot gets detected on a different interface)

    if ((!highestPriorityConnInfo || this._currentConnType && connType === this._currentConnType || !this._currentConnType && highestPriorityConnInfo.connType === connType) && !this._infosAreEqual(this._printerInfos.get(connType), printerInfo)) this.emit('update', printerInfo);
    printerInfo.timestamp = new Date();

    this._printerInfos.set(connType, printerInfo);
  }

  changeConnection(croissantPrinter, printerInfo) {
    if (printerInfo) {
      this._currentConnType = printerInfo.connType;
    } else {
      this._currentConnType = null;
    }

    this.emit('connection_change', croissantPrinter);
  }

  checkConnections() {
    const self = this; // check if connections have disappeared or if current conn should change

    return this._reap().finally(function () {
      if (!self._printerInfos.size) {
        // printer has gone completely offline
        self.changeConnection(null, null);
      } else {
        // try to auth to highest priorty conn possible
        self._tryConnectionChange(self._prevInfos);
      } // copy current state of _printerInfos map


      self._prevInfos = new Map();

      for (const pair of self._printerInfos) {
        const key = pair[0];
        const val = pair[1];

        self._prevInfos.set(key, val);
      }
    });
  }

  _tryConnectionChange(prevPrinterInfos) {
    const self = this;

    const shouldRequestAuth = function (printerInfo) {
      if (!printerInfo) return false; // if the printerInfo is for a higher priority than the currently
      // used, check that it wasn't around previously (otherwise, we
      // would have already attempted auth to it, and failed)

      const higherThanCurrent = ConnectionManager.isHigherPriority(printerInfo.connType, self._currentConnType);
      const isNewlyDiscovered = !prevPrinterInfos.get(printerInfo.connType);
      const justLostConnection = prevPrinterInfos.size > self._printerInfos.size && !self._currentConnType;
      return higherThanCurrent && isNewlyDiscovered || justLostConnection;
    };

    const _requestAuth = function (printerInfo) {
      if (shouldRequestAuth(printerInfo)) {
        self.emit('need_auth', printerInfo, function (err) {
          if (err) {
            // if we fail, try again with a lower priority connection until
            // it works, or we give up
            let i = PRIORITY.indexOf(printerInfo.connType) + 1;

            while (!self._printerInfos.get(PRIORITY[i]) && i < PRIORITY.length) i++;

            const pInfo = self._printerInfos.get(PRIORITY[i]);

            _requestAuth(pInfo);
          }
        });
      }
    };

    const highestPriorityConnInfo = this.getHighestPriorityConnInfo();

    _requestAuth(highestPriorityConnInfo);
  }

  _reap() {
    // get rid of old printerInfos
    const now = new Date();
    let reapDonePromise;

    for (const pair of this._printerInfos) {
      const connectionType = pair[0];
      const printerInfo = pair[1]; // if the printerInfo was not updated during this last round of detection
      // (ie. was timestamped before the last reap), AND it has exceeded the
      // timeout limit, this printer has likely disappeared from this interface
      // check if the printer is detected and it is passed its timeout or was recently connected

      if (printerInfo.timestamp < this._lastReaped && now - printerInfo.timestamp > PRINTER_CONNECTION_TIMEOUT || this._currentConnType != null) {
        if (connectionType === this._currentConnType) {
          // If connection type is being used, ask the printer if it's
          // is still alive
          const checkDoneDeferred = new q.defer();
          reapDonePromise = checkDoneDeferred.promise;
          this.emit('check_life', this._checkAliveDoneCallback(this, checkDoneDeferred));
        } else {
          // else delete mercilessly
          this._printerInfos.delete(connectionType);
        }
      }
    }

    this._lastReaped = now;
    if (!reapDonePromise) reapDonePromise = q();
    return reapDonePromise;
  }

  _checkAliveDoneCallback(self, checkDoneDeferred) {
    return function (isAlive, err) {
      if (isAlive) {
        self._printerInfos.get(self._currentConnType).timestamp = new Date();
      } else {
        self._printerInfos.delete(self._currentConnType);

        self.changeConnection(null, null);
      }

      if (err) {
        checkDoneDeferred.reject(err);
      } else {
        checkDoneDeferred.resolve();
      }
    };
  }

  get currentConnType() {
    return this._currentConnType;
  }

}

module.exports = ConnectionManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByaW50ZXJDb25uZWN0aW9uTWFuYWdlci5qcyJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwicSIsIlBSSU5URVJfQ09OTkVDVElPTl9USU1FT1VUIiwiUHJpbnRlckNvbm5UeXBlRW51bSIsIlBSSU9SSVRZIiwiVVNCIiwiTkVUV09SSyIsIlJFRkxFQ1RPUiIsIkNvbm5lY3Rpb25NYW5hZ2VyIiwiY29uc3RydWN0b3IiLCJzZXRJbml0U3RhdGUiLCJfcHJpbnRlckluZm9zIiwiTWFwIiwiX2N1cnJlbnRDb25uVHlwZSIsIl9sYXN0UmVhcGVkIiwiX3ByZXZJbmZvcyIsIl9pbmZvc0FyZUVxdWFsIiwicHJpbnRlckluZm8xIiwicHJpbnRlckluZm8yIiwicEluZm8xIiwiT2JqZWN0IiwiYXNzaWduIiwidGltZXN0YW1wIiwicEluZm8yIiwiSlNPTiIsInN0cmluZ2lmeSIsImhhc0Nvbm5UeXBlIiwiY29ublR5cGUiLCJnZXQiLCJnZXRIaWdoZXN0UHJpb3JpdHlDb25uSW5mbyIsImNvbm4iLCJpc0hpZ2hlclByaW9yaXR5IiwiY29ublR5cGUxIiwiY29ublR5cGUyIiwiYzFpbmRleCIsImluZGV4T2YiLCJjMmluZGV4IiwidXBkYXRlSW5mbyIsInByaW50ZXJJbmZvIiwiaGlnaGVzdFByaW9yaXR5Q29ubkluZm8iLCJlbWl0IiwiRGF0ZSIsInNldCIsImNoYW5nZUNvbm5lY3Rpb24iLCJjcm9pc3NhbnRQcmludGVyIiwiY2hlY2tDb25uZWN0aW9ucyIsInNlbGYiLCJfcmVhcCIsImZpbmFsbHkiLCJzaXplIiwiX3RyeUNvbm5lY3Rpb25DaGFuZ2UiLCJwYWlyIiwia2V5IiwidmFsIiwicHJldlByaW50ZXJJbmZvcyIsInNob3VsZFJlcXVlc3RBdXRoIiwiaGlnaGVyVGhhbkN1cnJlbnQiLCJpc05ld2x5RGlzY292ZXJlZCIsImp1c3RMb3N0Q29ubmVjdGlvbiIsIl9yZXF1ZXN0QXV0aCIsImVyciIsImkiLCJsZW5ndGgiLCJwSW5mbyIsIm5vdyIsInJlYXBEb25lUHJvbWlzZSIsImNvbm5lY3Rpb25UeXBlIiwiY2hlY2tEb25lRGVmZXJyZWQiLCJkZWZlciIsInByb21pc2UiLCJfY2hlY2tBbGl2ZURvbmVDYWxsYmFjayIsImRlbGV0ZSIsImlzQWxpdmUiLCJyZWplY3QiLCJyZXNvbHZlIiwiY3VycmVudENvbm5UeXBlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsTUFBTUEsWUFBWSxHQUFHQyxPQUFPLENBQUMsZUFBRCxDQUE1Qjs7QUFDQSxNQUFNQyxDQUFDLEdBQUdELE9BQU8sQ0FBQyxHQUFELENBQWpCOztBQUVBLE1BQU1FLDBCQUEwQixHQUFHRixPQUFPLENBQUMsYUFBRCxDQUFQLENBQXVCRSwwQkFBMUQ7O0FBQ0EsTUFBTUMsbUJBQW1CLEdBQUdILE9BQU8sQ0FBQyxhQUFELENBQVAsQ0FBdUJHLG1CQUFuRDs7QUFFQSxNQUFNQyxRQUFRLEdBQUcsQ0FBQ0QsbUJBQW1CLENBQUNFLEdBQXJCLEVBQTBCRixtQkFBbUIsQ0FBQ0csT0FBOUMsRUFBdURILG1CQUFtQixDQUFDSSxTQUEzRSxDQUFqQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU1DLGlCQUFOLFNBQWdDVCxZQUFoQyxDQUE2QztBQUN6Q1UsRUFBQUEsV0FBVyxHQUFHO0FBQ1Y7QUFDQSxTQUFLQyxZQUFMO0FBQ0gsR0FKd0MsQ0FNekM7QUFDQTs7O0FBQ0FBLEVBQUFBLFlBQVksR0FBRztBQUNYLFNBQUtDLGFBQUwsR0FBcUIsSUFBSUMsR0FBSixFQUFyQjtBQUNBLFNBQUtDLGdCQUFMLEdBQXdCLElBQXhCLENBRlcsQ0FJWDs7QUFDQSxTQUFLQyxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixJQUFJSCxHQUFKLEVBQWxCO0FBQ0g7O0FBRURJLEVBQUFBLGNBQWMsQ0FBQ0MsWUFBRCxFQUFlQyxZQUFmLEVBQTZCO0FBQ3ZDO0FBQ0E7QUFDQSxV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bkIsQ0FBMEJ6QixJQUFJLENBQUNqQyxnQkFBL0I7O0FBQ0FpQyxRQUFBQSxJQUFJLENBQUNILGdCQUFMLENBQXNCLElBQXRCLEVBQTRCLElBQTVCO0FBQ0g7O0FBQ0QsVUFBSWlCLEdBQUosRUFBUztBQUNMTyxRQUFBQSxpQkFBaUIsQ0FBQ00sTUFBbEIsQ0FBeUJiLEdBQXpCO0FBQ0gsT0FGRCxNQUVPO0FBQ0hPLFFBQUFBLGlCQUFpQixDQUFDTyxPQUFsQjtBQUNIO0FBQ0osS0FaRDtBQWFIOztBQUVELE1BQUlDLGVBQUosR0FBc0I7QUFDbEIsV0FBTyxLQUFLOUQsZ0JBQVo7QUFDSDs7QUF2TXdDOztBQTBNN0MrRCxNQUFNLENBQUNDLE9BQVAsR0FBaUJyRSxpQkFBakIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XHJcbmNvbnN0IHEgPSByZXF1aXJlKCdxJyk7XHJcblxyXG5jb25zdCBQUklOVEVSX0NPTk5FQ1RJT05fVElNRU9VVCA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJykuUFJJTlRFUl9DT05ORUNUSU9OX1RJTUVPVVQ7XHJcbmNvbnN0IFByaW50ZXJDb25uVHlwZUVudW0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLlByaW50ZXJDb25uVHlwZUVudW07XHJcblxyXG5jb25zdCBQUklPUklUWSA9IFtQcmludGVyQ29ublR5cGVFbnVtLlVTQiwgUHJpbnRlckNvbm5UeXBlRW51bS5ORVRXT1JLLCBQcmludGVyQ29ublR5cGVFbnVtLlJFRkxFQ1RPUl07XHJcblxyXG4vKlxyXG5FdmVudHM6XHJcbiAgICB1cGRhdGU6IGVtaXR0ZWQgd2hlbiB3ZSB0aGluayBwcmludGVyIGluZm8gc2hvdWxkIGJlIHVwZGF0ZWRcclxuICAgIGNvbm5lY3Rpb25fY2hhbmdlOiBlbWl0dGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gdHlwZSBzaG91bGQgY2hhbmdlIChlZy5cclxuICAgICAgICBzd2l0Y2hpbmcgZnJvbSBuZXR3b3JrIHRvIHVzYiBjb25uZWN0aW9uKVxyXG4gICAgbmVlZF9hdXRoOiBlbWl0dGVkIHRvIHJlcXVlc3QgdGhhdCBhdXRoZW50aWNhdGlvbiBiZSBkb25lIGZvciB0aGUgZ2l2ZW5cclxuICAgICAgICBwcmludGVySW5mb1xyXG4gICAgY2hlY2tfbGlmZTogZW1pdHRlZCB0byBhc2sgTUJQcmludGVyIHRvIGNoZWNrIHRoYXQgaXRzIGN1cnJlbnQgY29ubmVjdGlvblxyXG4gICAgICAgIGlzIHN0aWxsIGFsaXZlXHJcbiovXHJcblxyXG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuc2V0SW5pdFN0YXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhlcmUncyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMgKGFyY2hpdGVjdHVyYWxseSkgc3VjaCB0aGF0XHJcbiAgICAvLyB0aGlzIGlzbid0IG5lZWRlZCwgYnV0IEkgZ3Vlc3MgaXQncyBva2F5IGZvciBub3cuLi4/XHJcbiAgICBzZXRJbml0U3RhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJpbnRlckluZm9zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRDb25uVHlwZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IGtlZXAgcHJldmlvdXMgcHJpbnRlciBhcm91bmQgZm9yIHNvbWUgdGltZT9cclxuICAgICAgICB0aGlzLl9sYXN0UmVhcGVkID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9wcmV2SW5mb3MgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2luZm9zQXJlRXF1YWwocHJpbnRlckluZm8xLCBwcmludGVySW5mbzIpIHtcclxuICAgICAgICAvLyBpZ25vcmUgdGltZXN0YW1wcyBpbiBvdXIgZXF1YWxpdHktY2hlY2tpbmcgKG1ha2UgY29waWVzIG9mIHRoZVxyXG4gICAgICAgIC8vIHByaW50ZXJJbmZvcyBzbyB3ZSBkb24ndCBlbmQgdXAgY2hhbmdpbmcgdGhlbSlcclxuICAgICAgICBjb25zdCBwSW5mbzEgPSBPYmplY3QuYXNzaWduKHt9LCBwcmludGVySW5mbzEpO1xyXG4gICAgICAgIGRlbGV0ZSBwSW5mbzEudGltZXN0YW1wO1xyXG4gICAgICAgIGNvbnN0IHBJbmZvMiA9IE9iamVjdC5hc3NpZ24oe30sIHByaW50ZXJJbmZvMik7XHJcbiAgICAgICAgZGVsZXRlIHBJbmZvMi50aW1lc3RhbXA7XHJcblxyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwSW5mbzEpID09PSBKU09OLnN0cmluZ2lmeShwSW5mbzIpO1xyXG4gICAgfVxyXG5cclxuICAgIGhhc0Nvbm5UeXBlKGNvbm5UeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fcHJpbnRlckluZm9zLmdldChjb25uVHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV0dXJucyB0aGUgcHJpbnRlckluZm8gZm9yIHRoZSBoaWdoZXN0IHByaW9yaXR5IGNvbm5lY3Rpb24gYXZhaWxhYmxlXHJcbiAgICBnZXRIaWdoZXN0UHJpb3JpdHlDb25uSW5mbygpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbm5UeXBlIG9mIFBSSU9SSVRZKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLl9wcmludGVySW5mb3MuZ2V0KGNvbm5UeXBlKTtcclxuICAgICAgICAgICAgaWYgKGNvbm4pIHJldHVybiBjb25uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm4gdHJ1ZSBpZiBjb25uVHlwZTEgaXMgb2YgaGlnaGVyIHByaW9yaXR5IHRoYW4gY29ublR5cGUyIChpbnZhbGlkIGJlaW5nXHJcbiAgICAvLyBsb3dlc3QgcHJpb3JpdHkpO1xyXG4gICAgLy8gcmV0dXJuIGZhbHNlIGlmIGNvbm5UeXBlMSBpcyBpbnZhbGlkIChyZWdhcmRsZXNzIG9mIHdoZXRoZXIgY29ublR5cGUyIGlzIHZhbGlkKVxyXG4gICAgc3RhdGljIGlzSGlnaGVyUHJpb3JpdHkoY29ublR5cGUxLCBjb25uVHlwZTIpIHtcclxuICAgICAgICBjb25zdCBjMWluZGV4ID0gUFJJT1JJVFkuaW5kZXhPZihjb25uVHlwZTEpO1xyXG4gICAgICAgIGNvbnN0IGMyaW5kZXggPSBQUklPUklUWS5pbmRleE9mKGNvbm5UeXBlMik7XHJcblxyXG4gICAgICAgIGlmIChjMWluZGV4IDwgMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGVsc2UgaWYgKGMyaW5kZXggPCAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBlbHNlIHJldHVybiBjMWluZGV4IDwgYzJpbmRleDtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVJbmZvKHByaW50ZXJJbmZvKSB7XHJcbiAgICAgICAgY29uc3QgY29ublR5cGUgPSBwcmludGVySW5mby5jb25uVHlwZTtcclxuICAgICAgICBjb25zdCBoaWdoZXN0UHJpb3JpdHlDb25uSW5mbyA9IHRoaXMuZ2V0SGlnaGVzdFByaW9yaXR5Q29ubkluZm8oKTtcclxuICAgICAgICAvLyBzaG91bGQgcmVxdWVzdCBpbmZvcyBiZSB1cGRhdGVkIGlmOlxyXG4gICAgICAgIC8vICogdGhpcyBpcyB0aGUgZmlyc3QgcHJpbnRlckluZm8gd2UncmUgcmVjZWl2aW5nIGZvciB0aGlzIGJvdCBvclxyXG4gICAgICAgIC8vICogaWYgcHJpbnRlciBpcyBjb25uZWN0ZWQsIGFuZCB0aGUgaW5mbyBpcyBmb3IgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBvclxyXG4gICAgICAgIC8vICogdGhlIHByaW50ZXIgaXMgbm90IGNvbm5lY3RlZCwgYW5kIHRoZSBpbmZvIGlzIGZvciB0aGUgaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIC8vICogb2YgY29ublR5cGUgY3VycmVudGx5IGF2YWlsYWJsZVxyXG4gICAgICAgIC8vIEFORFxyXG4gICAgICAgIC8vICogaW5mbyBoYXMgY2hhbmdlZFxyXG4gICAgICAgIC8vICogKG90aGVyd2lzZSwgaW5mbyB0aGF0IGlzIGNvbm5UeXBlIHNwZWNpZmljLCBsaWtlIGFkZHJlc3MsIHdpbGwgZ2V0XHJcbiAgICAgICAgLy8gKiBjaGFuZ2VkIGV2ZXJ5IHRpbWUgYSBib3QgZ2V0cyBkZXRlY3RlZCBvbiBhIGRpZmZlcmVudCBpbnRlcmZhY2UpXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAoIWhpZ2hlc3RQcmlvcml0eUNvbm5JbmZvIHx8XHJcbiAgICAgICAgICAgICAgICAodGhpcy5fY3VycmVudENvbm5UeXBlICYmIGNvbm5UeXBlID09PSB0aGlzLl9jdXJyZW50Q29ublR5cGUpIHx8XHJcbiAgICAgICAgICAgICAgICAoIXRoaXMuX2N1cnJlbnRDb25uVHlwZSAmJiBoaWdoZXN0UHJpb3JpdHlDb25uSW5mby5jb25uVHlwZSA9PT0gY29ublR5cGUpKSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5faW5mb3NBcmVFcXVhbCh0aGlzLl9wcmludGVySW5mb3MuZ2V0KGNvbm5UeXBlKSwgcHJpbnRlckluZm8pXHJcbiAgICAgICAgKVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHByaW50ZXJJbmZvKTtcclxuXHJcbiAgICAgICAgcHJpbnRlckluZm8udGltZXN0YW1wID0gbmV3IERhdGUoKTtcclxuICAgICAgICB0aGlzLl9wcmludGVySW5mb3Muc2V0KGNvbm5UeXBlLCBwcmludGVySW5mbyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhbmdlQ29ubmVjdGlvbihjcm9pc3NhbnRQcmludGVyLCBwcmludGVySW5mbykge1xyXG4gICAgICAgIGlmIChwcmludGVySW5mbykge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29ublR5cGUgPSBwcmludGVySW5mby5jb25uVHlwZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29ublR5cGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uX2NoYW5nZScsIGNyb2lzc2FudFByaW50ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrQ29ubmVjdGlvbnMoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgY29ubmVjdGlvbnMgaGF2ZSBkaXNhcHBlYXJlZCBvciBpZiBjdXJyZW50IGNvbm4gc2hvdWxkIGNoYW5nZVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFwKCkuZmluYWxseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCFzZWxmLl9wcmludGVySW5mb3Muc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJpbnRlciBoYXMgZ29uZSBjb21wbGV0ZWx5IG9mZmxpbmVcclxuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlQ29ubmVjdGlvbihudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBhdXRoIHRvIGhpZ2hlc3QgcHJpb3J0eSBjb25uIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICBzZWxmLl90cnlDb25uZWN0aW9uQ2hhbmdlKHNlbGYuX3ByZXZJbmZvcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGNvcHkgY3VycmVudCBzdGF0ZSBvZiBfcHJpbnRlckluZm9zIG1hcFxyXG4gICAgICAgICAgICBzZWxmLl9wcmV2SW5mb3MgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBzZWxmLl9wcmludGVySW5mb3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhaXJbMF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBwYWlyWzFdO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fcHJldkluZm9zLnNldChrZXksIHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfdHJ5Q29ubmVjdGlvbkNoYW5nZShwcmV2UHJpbnRlckluZm9zKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGNvbnN0IHNob3VsZFJlcXVlc3RBdXRoID0gZnVuY3Rpb24ocHJpbnRlckluZm8pIHtcclxuICAgICAgICAgICAgaWYgKCFwcmludGVySW5mbykgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGhlIHByaW50ZXJJbmZvIGlzIGZvciBhIGhpZ2hlciBwcmlvcml0eSB0aGFuIHRoZSBjdXJyZW50bHlcclxuICAgICAgICAgICAgLy8gdXNlZCwgY2hlY2sgdGhhdCBpdCB3YXNuJ3QgYXJvdW5kIHByZXZpb3VzbHkgKG90aGVyd2lzZSwgd2VcclxuICAgICAgICAgICAgLy8gd291bGQgaGF2ZSBhbHJlYWR5IGF0dGVtcHRlZCBhdXRoIHRvIGl0LCBhbmQgZmFpbGVkKVxyXG4gICAgICAgICAgICBjb25zdCBoaWdoZXJUaGFuQ3VycmVudCA9IENvbm5lY3Rpb25NYW5hZ2VyLmlzSGlnaGVyUHJpb3JpdHkocHJpbnRlckluZm8uY29ublR5cGUsIHNlbGYuX2N1cnJlbnRDb25uVHlwZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzTmV3bHlEaXNjb3ZlcmVkID0gIXByZXZQcmludGVySW5mb3MuZ2V0KHByaW50ZXJJbmZvLmNvbm5UeXBlKTtcclxuICAgICAgICAgICAgY29uc3QganVzdExvc3RDb25uZWN0aW9uID0gcHJldlByaW50ZXJJbmZvcy5zaXplID4gc2VsZi5fcHJpbnRlckluZm9zLnNpemUgJiYgIXNlbGYuX2N1cnJlbnRDb25uVHlwZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoaGlnaGVyVGhhbkN1cnJlbnQgJiYgaXNOZXdseURpc2NvdmVyZWQpIHx8IGp1c3RMb3N0Q29ubmVjdGlvbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBfcmVxdWVzdEF1dGggPSBmdW5jdGlvbihwcmludGVySW5mbykge1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVxdWVzdEF1dGgocHJpbnRlckluZm8pKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ25lZWRfYXV0aCcsIHByaW50ZXJJbmZvLCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGZhaWwsIHRyeSBhZ2FpbiB3aXRoIGEgbG93ZXIgcHJpb3JpdHkgY29ubmVjdGlvbiB1bnRpbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCB3b3Jrcywgb3Igd2UgZ2l2ZSB1cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IFBSSU9SSVRZLmluZGV4T2YocHJpbnRlckluZm8uY29ublR5cGUpICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghc2VsZi5fcHJpbnRlckluZm9zLmdldChQUklPUklUWVtpXSkgJiYgaSA8IFBSSU9SSVRZLmxlbmd0aCkgaSsrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcEluZm8gPSBzZWxmLl9wcmludGVySW5mb3MuZ2V0KFBSSU9SSVRZW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlcXVlc3RBdXRoKHBJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGhpZ2hlc3RQcmlvcml0eUNvbm5JbmZvID0gdGhpcy5nZXRIaWdoZXN0UHJpb3JpdHlDb25uSW5mbygpO1xyXG4gICAgICAgIF9yZXF1ZXN0QXV0aChoaWdoZXN0UHJpb3JpdHlDb25uSW5mbyk7XHJcbiAgICB9XHJcblxyXG4gICAgX3JlYXAoKSB7XHJcbiAgICAgICAgLy8gZ2V0IHJpZCBvZiBvbGQgcHJpbnRlckluZm9zXHJcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgICBsZXQgcmVhcERvbmVQcm9taXNlO1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLl9wcmludGVySW5mb3MpIHtcclxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvblR5cGUgPSBwYWlyWzBdO1xyXG4gICAgICAgICAgICBjb25zdCBwcmludGVySW5mbyA9IHBhaXJbMV07XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcmludGVySW5mbyB3YXMgbm90IHVwZGF0ZWQgZHVyaW5nIHRoaXMgbGFzdCByb3VuZCBvZiBkZXRlY3Rpb25cclxuICAgICAgICAgICAgLy8gKGllLiB3YXMgdGltZXN0YW1wZWQgYmVmb3JlIHRoZSBsYXN0IHJlYXApLCBBTkQgaXQgaGFzIGV4Y2VlZGVkIHRoZVxyXG4gICAgICAgICAgICAvLyB0aW1lb3V0IGxpbWl0LCB0aGlzIHByaW50ZXIgaGFzIGxpa2VseSBkaXNhcHBlYXJlZCBmcm9tIHRoaXMgaW50ZXJmYWNlXHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgcHJpbnRlciBpcyBkZXRlY3RlZCBhbmQgaXQgaXMgcGFzc2VkIGl0cyB0aW1lb3V0IG9yIHdhcyByZWNlbnRseSBjb25uZWN0ZWRcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgKHByaW50ZXJJbmZvLnRpbWVzdGFtcCA8IHRoaXMuX2xhc3RSZWFwZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICBub3cgLSBwcmludGVySW5mby50aW1lc3RhbXAgPiBQUklOVEVSX0NPTk5FQ1RJT05fVElNRU9VVCkgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb25uVHlwZSAhPSBudWxsXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25UeXBlID09PSB0aGlzLl9jdXJyZW50Q29ublR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb25uZWN0aW9uIHR5cGUgaXMgYmVpbmcgdXNlZCwgYXNrIHRoZSBwcmludGVyIGlmIGl0J3NcclxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBzdGlsbCBhbGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrRG9uZURlZmVycmVkID0gbmV3IHEuZGVmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICByZWFwRG9uZVByb21pc2UgPSBjaGVja0RvbmVEZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hlY2tfbGlmZScsIHRoaXMuX2NoZWNrQWxpdmVEb25lQ2FsbGJhY2sodGhpcywgY2hlY2tEb25lRGVmZXJyZWQpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBkZWxldGUgbWVyY2lsZXNzbHlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmludGVySW5mb3MuZGVsZXRlKGNvbm5lY3Rpb25UeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fbGFzdFJlYXBlZCA9IG5vdztcclxuICAgICAgICBpZiAoIXJlYXBEb25lUHJvbWlzZSkgcmVhcERvbmVQcm9taXNlID0gcSgpO1xyXG4gICAgICAgIHJldHVybiByZWFwRG9uZVByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgX2NoZWNrQWxpdmVEb25lQ2FsbGJhY2soc2VsZiwgY2hlY2tEb25lRGVmZXJyZWQpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaXNBbGl2ZSwgZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FsaXZlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9wcmludGVySW5mb3MuZ2V0KHNlbGYuX2N1cnJlbnRDb25uVHlwZSkudGltZXN0YW1wID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3ByaW50ZXJJbmZvcy5kZWxldGUoc2VsZi5fY3VycmVudENvbm5UeXBlKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlQ29ubmVjdGlvbihudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0RvbmVEZWZlcnJlZC5yZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRG9uZURlZmVycmVkLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGN1cnJlbnRDb25uVHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudENvbm5UeXBlO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xyXG4iXX0=
