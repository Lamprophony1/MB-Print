// Copyright 2014 MakerBot

#ifndef MESHUTILS_MESHINTERSECTOR_DECL_H
#define MESHUTILS_MESHINTERSECTOR_DECL_H

#include <unordered_map>
#include <unordered_set>
#include <vector>

//#define USE_MG_RTREE

// boost stuff
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/point.hpp>
#include <boost/geometry/geometries/box.hpp>
#include <boost/geometry/index/rtree.hpp>

#include "thing/mesh.h"
#include "geomutils/basic_local_rtree.h"
#include "geomutils/spacial_data.h"
#include "geomutils/Triangle3.h"

namespace bg = boost::geometry;
namespace bgm = boost::geometry::model;
namespace bgi = boost::geometry::index;

typedef bgm::point<double, 3, bg::cs::cartesian> BoostVec3;
typedef bgm::box<BoostVec3>                      Box3;

namespace LibThing {

typedef struct TriId {
  uint meshId;
  uint faceId;
  uint stride;
} TriId;

} // namespace LibThing

namespace std {
template<>
struct hash<LibThing::TriId> {
  size_t operator()(const LibThing::TriId &key) const {
    return key.stride * key.meshId + key.faceId;
  }
};

template<>
struct equal_to<LibThing::TriId> {
  bool operator()(const LibThing::TriId &a,
                  const LibThing::TriId &b) const {
    return (a.meshId == b.meshId &&
            a.faceId == b.faceId);
  }
};
} // namespace std

namespace LibThing {

#ifdef USE_MG_RTREE
struct MyTriangle {
  mgl::Triangle3 triangle;
  TriId id;
};
#endif  // USE_MG_RTREE

template<typename MESH>
class MeshIntersector {
 public:

  typedef             MESH mesh_type;

#ifdef USE_MG_RTREE
  typedef             mgl::basic_local_rtree<struct MyTriangle, 3>    RTree;
#else
  typedef std::pair<Box3, std::pair<uint, mgl::Triangle3> >           RTValue;
  typedef bgi::rtree<RTValue, bgi::dynamic_rstar>                     RTree;
#endif  // USE_MG_RTREE

  // constructors
  MeshIntersector(const std::vector<mesh_type> &meshes=
                    std::vector<mesh_type>());

  // mutators
  int computeIntersections();

  // accessors
  const RTree& rtree() const {
    return m_rtree;
  }
  const std::unordered_map<struct TriId,
                           std::unordered_set<struct TriId> >&
  intersections() const {
    return m_intersections;
  }

 protected:
  const std::vector<mesh_type>                              &m_meshes;
  uint m_maxFaces;
  RTree m_rtree;
  std::unordered_map<struct TriId,
                     std::unordered_set<struct TriId> >      m_intersections;
  std::unordered_map<struct TriId, std::unordered_set<int> > m_faceNbrMap;
#ifndef USE_MG_RTREE
  std::unordered_map<uint, std::pair<mgl::Triangle3, Box3> > m_faceTri3;
#endif  // USE_MG_RTREE
};

}      // namespace LibThing

#ifdef USE_MG_RTREE
namespace mgl {

template<>
struct to_bbox<LibThing::MyTriangle> {
  static basic_bounding_box<Scalar, 3> bound(const LibThing::MyTriangle &t) {
    basic_bounding_box<Scalar, 3> bbox(t.triangle[0]);
    bbox.expandTo(t.triangle[1]);
    bbox.expandTo(t.triangle[2]);
    return bbox;
  }
};

} // namespace mgl
#endif  // USE_MG_RTREE

#endif  // MESHUTILS_MESHINTERSECTOR_DECL_H
