// Copyright 2012 Makerbot Industries

#ifndef INCLUDE_MESHUTILS_RAY_TRIANGLE_H_
#define INCLUDE_MESHUTILS_RAY_TRIANGLE_H_

#include <Eigen/Core>

namespace LibThing {

/// Return true if ray intersects triangle, false otherwise
///
/// The ray starts at rayStart and moves in the direction of
/// rayDir. The triangle's vertices are vertex0, vertex1, and vertex2.
///
/// Note: I'm not sure if rayDir needs to be normalized, but for now
/// assume it is necessary.
///
/// If an intersection is found, t is set to the distance from
/// rayStart where the intersection occurred. The u and v outputs are
/// set to the barycentric location of the intersection within the
/// triangle.
template<typename T>
bool intersectRayTriangle(const Eigen::Matrix<T, 3, 1> &rayStart,
                          const Eigen::Matrix<T, 3, 1> &rayDir,
                          const Eigen::Matrix<T, 3, 1> &vertex0,
                          const Eigen::Matrix<T, 3, 1> &vertex1,
                          const Eigen::Matrix<T, 3, 1> &vertex2,
                          T *t,
                          T *u,
                          T *v) {
  // Adapted from the paper "Fast, Minimum Storage Ray/Triangle
  // Intersection" by Thomas Moeller and Ben Trumbore
  const Eigen::Matrix<T, 3, 1> edge1(vertex1 - vertex0);
  const Eigen::Matrix<T, 3, 1> edge2(vertex2 - vertex0);

  const Eigen::Matrix<T, 3, 1> pvec(rayDir.cross(edge2));

  const T det(edge1.dot(pvec));

  // No back-face culling

  const T epsilon(0.000001);
  if (det > -epsilon && det < epsilon)
    return false;

  const T invDet(static_cast<T>(1) / det);

  // Calculate distance from vert0 to ray origin
  const Eigen::Matrix<T, 3, 1> tvec(rayStart - vertex0);

  // Calculate U parameter and test bounds
  (*u) = tvec.dot(pvec) * invDet;
  if ((*u) < static_cast<T>(0) ||
      (*u) > static_cast<T>(1)) {
    return false;
  }

  // Prepare to test V parameter
  const Eigen::Matrix<T, 3, 1> qvec(tvec.cross(edge1));

  // Calculate V parameter and test bounds
  (*v) = rayDir.dot(qvec) * invDet;
  if ((*v) < static_cast<T>(0) ||
      ((*u) + (*v)) > static_cast<T>(1)) {
    return false;
  }

  // Calculate t, scale parameters, ray intersects triangle
  (*t) = edge2.dot(qvec) * invDet;

  return true;
}
}

#endif  // INCLUDE_MESHUTILS_RAY_TRIANGLE_H_
