#pragma once

#include <memory>
#include <vector>

#include <Eigen/Geometry>

#include "geomutils/Vector2.h"
#include "geomutils/Vector3.h"
#include "meshutils/connected_mesh.h"

namespace unitutils {

/**
 * An indexed grid of triangles in the XY plane, oriented like:
 *
 * *--*--*
 * |\s|\ |
 * |f\| \|
 * *--*--*
 * |\ |\ |
 * | \| \|
 * *--*--*
 *
 * ...where the grid cell at (x, y) is a pair of triangles.
 *
 * The LL triangle is getCellFaces((x, y)).first,
 * The UR triangle is getCellFaces((x, y)).second
 *
 * Zero-indexed, the minimum cell is (0, 0) with LL at (0, 0) and UR at (1, 1).
 *
 * The grid can be positioned arbitrarily (though always horizontally, XY),
 * and grid cells scaled to any size.
 *
 * TODO: Test-only?  Expose elsewhere for other library testing?
 */
class MESHUTILS_API PlanarMesh {
public:
    typedef geomutils::Vector3 Vector3;
    typedef geomutils::Vector2 Vector2;
    typedef LibThing::ConnectedMesh ConnectedMesh;
    typedef Eigen::Vector2i Vector2i;

    /**
     * Create a PlanarMesh with cell (0, 0) starting from position, with cells
     * of cell_size in x and y, and with cell_dims number of cells in x, y.
     */
    PlanarMesh(const Vector3& position,
               const Vector2& cell_size,
               const Vector2i& cell_dims,
               bool up_sense = true,
               std::shared_ptr<ConnectedMesh> shared_mesh =
                   std::shared_ptr<ConnectedMesh>());

    ConnectedMesh& getMesh() { return *m_mesh; }

    std::shared_ptr<ConnectedMesh> shareMesh() { return m_mesh; }

    typedef std::pair<ConnectedMesh::FaceHandle, ConnectedMesh::FaceHandle>
        FaceHandlePair;

    /**
     * Return the vertex at a particular cell position.
     */
    ConnectedMesh::VertexHandle getCellVertex(
        const Vector2i& cell_position) const;

    /**
     * Return the edge between two cell positions.
     */
    ConnectedMesh::EdgeHandle getCellEdge(
        const Vector2i& cell_position_a, const Vector2i& cell_position_b) const;

    /**
     * Return the halfedge between two cell positions.
     */
    ConnectedMesh::HalfedgeHandle getCellHalfedge(
        const Vector2i& cell_position_a, const Vector2i& cell_position_b) const;

    /**
     * Return the edges between multiple cell positions.
     */
    std::vector<ConnectedMesh::EdgeHandle> getCellEdges(
        const std::vector<Vector2i>& cell_positions) const;

    /**
     * Return the halfedges between multiple cell positions.
     */
    std::vector<ConnectedMesh::HalfedgeHandle> getCellHalfedges(
        const std::vector<Vector2i>& cell_positions) const;

    /**
     * Return the pair of triangle faces at a particular cell position.
     */
    FaceHandlePair getCellFaces(const Vector2i& cell_position) const;

    /**
     * Return all the triangle faces at the vector of cell positions.
     */
    std::vector<ConnectedMesh::FaceHandle> getCellFaces(
        const std::vector<Vector2i>& cell_positions) const;

    /**
     * Return all the vertices in the planar border, in CCW order
     */
    std::vector<ConnectedMesh::VertexHandle> getVertexBorder() const;

    typedef std::function<Scalar(const Vector2i&)> BumpFunction;

    /**
     * Bump the cell vertices in the plane a certain distance along their
     * normals.
     */
    void bumpVertices(BumpFunction bump_function);

    typedef std::function<Vector3(const Vector2i&)> TranslateFunction;

    /**
     * Translate the cell vertices in the plane by a vector.
     */
    void translateVertices(TranslateFunction translate_function);

private:
    void init(bool up_sense, std::shared_ptr<ConnectedMesh> shared_mesh);

    const Vector3 m_position;
    const Vector2 m_cell_size;
    const Vector2i m_cell_dims;

    std::shared_ptr<ConnectedMesh> m_mesh;
    std::vector<ConnectedMesh::VertexHandle> m_vertices;
    std::vector<FaceHandlePair> m_cell_faces;
};
}
