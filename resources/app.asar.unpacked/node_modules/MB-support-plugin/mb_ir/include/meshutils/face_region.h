#pragma once

#include <list>
#include <set>
#include <vector>

#include "geomutils/Vector3.h"
#include "connected_mesh.h"
#include "edge_loop.h"

#include <iostream>

namespace LibThing {

/**
 * A FaceRegion is a set of faces on a ConnectedMesh defining one or more
 * connected surface regions.
 *
 * FaceRegions have a number of EdgeLoop borders, though there is no natural
 * nesting of these borders like there is for 2D Region borders.
 *
 * Raw faces can be selected in some way from a mesh, and grouped together into
 * (optionally discrete) regions.
 */
class MESHUTILS_API FaceRegion {
public:
    typedef std::set<ConnectedMesh::FaceHandle> FaceHandleSet;

    /**
     * Creates a FaceRegion directly from any set of faces.
     * Does *not* require or ensure that the faces are contiguous.
     */
    FaceRegion(const ConnectedMesh& mesh, const FaceHandleSet& faces);

    const ConnectedMesh& getMesh() const { return *m_mesh; }

    const FaceHandleSet& getFaces() const { return m_faces; }

    bool hasFace(ConnectedMesh::FaceHandle face) const;
    
    /**
     * Returns the total surface area of the FaceRegion
     */
    Scalar getArea() const;
    
    /**
     * Returns the total surface area of the FaceRegion, projected into
     * some direction.
     */
    Scalar getProjectedArea(const geomutils::Vector3& plane_normal) const;

    size_t size() const;

    FaceHandleSet::const_iterator begin() const;

    FaceHandleSet::const_iterator end() const;
    
    /**
     * Returns the FaceRegion borders.  This is a somewhat expensive operation,
     * since the entire triangular set must be traversed.
     */
    std::vector<EdgeLoop> computeBorders() const;

    /**
     * Optionally computes and stores the FaceRegion borders internally, when
     * they may be used repeatedly in some calculation.
     */
    void initBorders(bool recompute = false);
    
    /**
     * Returns the FaceRegion borders iff initialized.  Don't call if the
     * borders are not initialized.
     */
    const std::vector<EdgeLoop>& getBorders() const;

    /**
     * Returns the minimum distance between two FaceRegions' border EdgeLoops.
     * Does so in the dumbest possible n^2 way.
     */
    static Scalar minDistance(const FaceRegion& region_a,
                              const FaceRegion& region_b);
    
    /**
     * Create a number of discrete, contiguous FaceRegions from a "soup" of
     * faces on a mesh.  Optionally initialize the borders of the collected
     * Regions.
     */
    static std::vector<FaceRegion> discreteIslands(
        const ConnectedMesh& mesh,
        const std::vector<ConnectedMesh::FaceHandle>& face_soup,
        bool init_borders = false);

    typedef std::set<const FaceRegion*> Group;
    
    /**
     * Returns groups of FaceRegions based on the distance of the Regions'
     * borders in 3D space.
     * Note that Groups hold only pointers, and the input regions must not
     * go out of scope while the returned Groups are being used.
     */
    static std::list<Group> groupNearby(
        const std::vector<FaceRegion>& face_regions, Scalar min_distance);

    /**
     * Returns groups of FaceRegions where none are actually grouped.
     */
    static std::list<Group> groupTrivial(
        const std::vector<FaceRegion>& face_regions);

private:
    ConnectedMesh const* m_mesh;
    FaceHandleSet m_faces;
    
    // Optionally initialized - can be expensive to compute
    std::vector<EdgeLoop> m_borders;
};

}  // namespace LibThing
