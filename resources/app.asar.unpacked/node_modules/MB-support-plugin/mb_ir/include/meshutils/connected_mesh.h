/* Copyright 2013 MakerBot Industries
 *
 * File:   ConnectedMesh.h
 * Author: quynhdinh
 *
 * Created on August 7, 2013, 11:43 AM
 */

#ifndef INCLUDE_MESHUTILS_CONNECTED_MESH_H_
#define INCLUDE_MESHUTILS_CONNECTED_MESH_H_

#include <array>
#include <list>
#include <vector>
#include <Eigen/Geometry>

#include "meshutils/openmesh_adaptor.h"
#include "geomutils/data_structures/basic_interval_tree.h"
#include "geomutils/Scalar.h"
#include "geomutils/OpenPath.h"
#include "geomutils/Loop.h"
#include "geomutils/Vector3.h"

namespace LibThing {

class MESHUTILS_API ConnectedMesh : public OpenMeshAdaptor {
 public:

  // Because vertex handles are stored in Vertex Traits, disallow regular
  // garbage_collection of vertices unless the client assures us we're manifold.
  void garbage_collection(bool _v = true, bool _e = true, bool _f = true,
                          bool is_manifold = false) {
      if (_v && !is_manifold) {
          std::cerr << "ConnectedMesh::garbage_collection - removing "
                    << "vertices will invalidate original and duplicate vertex "
                    << "handles. Instead, use garbage_collection with pointers "
                    << "to vertex handles to be updated"
                    << std::endl;
          assert(!_v);
      } else {
          OpenMesh::ArrayKernel::garbage_collection(_v, _e, _f);
      }
  }

  void boundingBox(Point& bbMin, Point& bbMax,
          std::array<ConnectedMesh::VertexHandle, 3> & minVerts,
          std::array<ConnectedMesh::VertexHandle, 3> & maxVerts);

  void clearVertexTags();
  void clearEdgeTags();
  void clearHalfedgeTags();
  void clearFaceTags();

  /// Utility functions for basic transformations of a mesh

  int invertMesh();

  void transform(const Eigen::Affine3f& transformation);

  void translate(const Eigen::Vector3f& translation);

  void rotate(const Eigen::Quaternionf& rotation);

  void rotate(const Eigen::Vector3f& euler_rads);

  void rotate_degrees(const Eigen::Vector3f& euler_degrees);

  void scale(const Eigen::Vector3f& scale);

  /// End mesh transformations

  bool vertexMatch(ConnectedMesh::VertexHandle target,
                              ConnectedMesh::VertexHandle candidate);

  void queueAndTagNeighbors(ConnectedMesh::FaceHandle face,
          std::vector<ConnectedMesh::FaceHandle> & taggedFaces,
          bool traverseAcrossEdges = false);

  void createSubMeshFromTaggedMesh(ConnectedMesh & dst);

  void separateIntoConnectedComponents(
    std::vector<ConnectedMesh> & singleComponentMeshes);

  ConnectedMesh::FaceHandle addInvertedFace(
    const std::vector<ConnectedMesh::VertexHandle> & OrigFaceVHandles);

  ConnectedMesh::FaceHandle addDisconnectedFace(
    const std::vector<ConnectedMesh::VertexHandle> & OrigFaceVHandles);

  ////////// Functions related to manifold analysis/repair
  bool isManifold() const;

  bool isWatertight(bool checkAlignment = false,
                    Normal alignmentDir = Normal(0.f, 0.f, 1.f)) const;

  bool verifyMeshOrientation();

  ConnectedMesh* orientMesh();  // Returns oriented mesh if orientable.

  /// Generate an intersection between the mesh and the plane z = zHeight
  ///
  /// The intersection will be a series of paths, either (hopefully) looping
  /// back to where it began or terminating. In the former case, we will add
  /// these paths to the loops param. In the later case, the paths param.
  bool generatePaths(const Scalar zHeight,
                     std::list<geomutils::Loop> &loops,
                     std::vector<geomutils::OpenPath> &paths);

  /// Force all points on a triangle whose z heights are within threshold to
  /// have the same z coordinate.
  void layerMatch(const Scalar threshold);

  /// Forget the computed mesh information needed for path generation at
  /// particular heights.
  /// TODO: More automatic handling of this when mesh modifications occur
  void clearZIndexingData();

  /**
   * Returns the center-of-mass (and optionally total area) of the mesh surface.
   */
  geomutils::Vector3 getShellCenterOfMass(Scalar* total_area = nullptr) const;

  /**
   * Returns the center-of-mass (and optionally total volume) of the mesh.
   * If the mesh is not watertight and well-oriented the center-of-mass is not
   * well-defined.
   */
  geomutils::Vector3 getCenterOfMass(Scalar* total_volume = nullptr) const;

 private:

  /// Generate an interval tree relating Z-Height interval to FaceHandle
  void generateIntervalTrees();
  bool hasIntervalTrees() const;

  void generateBumpTree();
  bool hasBumpTree() const;

  /// interval tree that relates z heights of face to face handle
  typedef geomutils::basic_interval_tree<Scalar, FaceHandle> zHeightToFaceTree;
  zHeightToFaceTree m_zHeightIntervalTree;

  typedef geomutils::basic_interval_tree<Scalar, VertexHandle> bumpTree;
  bumpTree m_bumpTree;

  /// Bump all points very close to a slice layer
  ///
  /// ensure that a slice intersects a triangle at no more than 2 edges (bumping
  /// also prevents all horizontal edges from being incident to the slice).
  /// Specifically, bumping the vertices prevents situation where two edges have
  /// a common end point that is incident to the slice.  In such a case, slice
  /// will intersect all 3 edges of the triangle.
  ///
  /// this method is called when we generate the paths at a layer height.
  void bumpVerteciesOnSliceLine(const Scalar layerHeight);
};
}
#endif  // INCLUDE_MESHUTILS_CONNECTED_MESH_H_
