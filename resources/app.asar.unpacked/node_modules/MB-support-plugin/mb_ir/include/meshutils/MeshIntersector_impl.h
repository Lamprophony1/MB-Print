// Copyright 2014 MakerBot

#include <stdio.h>
#include <stdlib.h>
#include "meshutils/MeshIntersector_decl.h"
#include "Misc.h"
#include "meshutils/TriTriIntersectionTest.h"
// #include <QtCore>
// #include <google/profiler.h>

namespace LibThing {

using namespace std;
using OpenMesh::vector_cast;

#define MI_TMPLT template <typename MESH>
#define MI_TYPE MeshIntersector<MESH>

// Box filter passed to MG RTree
class BoxFilter {
 public:
  typedef     mgl::basic_bounding_box<double, 3>              bbox_type;

  BoxFilter(const bbox_type &bbox) : m_bbox(bbox) {
  }
  bool filter(const bbox_type &bbox) const {
    return (    // m_bbox.contains(bbox) || bbox.contains(m_bbox) ||
      m_bbox.intersects(bbox));
  }
  bbox_type m_bbox;
};



// test whether two triangles intersect
inline bool
triTriIntersect(const mgl::Triangle3 &t0, const mgl::Triangle3 &t1) {
  double c0[3] = {t0[0][0], t0[0][1], t0[0][2]};
  double p1[3] = {t0[1][0] - c0[0],
                  t0[1][1] - c0[1],
                  t0[1][2] - c0[2]};
  double p2[3] = {t0[2][0] - c0[0],
                  t0[2][1] - c0[1],
                  t0[2][2] - c0[2]};
  double d0[3] = {t1[0][0], t1[0][1], t1[0][2]};
  double q1[3] = {t1[1][0] - d0[0],
                  t1[1][1] - d0[1],
                  t1[1][2] - d0[2]};
  double q2[3] = {t1[2][0] - d0[0],
                  t1[2][1] - d0[1],
                  t1[2][2] - d0[2]};
  return (tri_tri_intersect3D(c0, p1, p2, d0, q1, q2) > 0);
}



MI_TMPLT
MI_TYPE::MeshIntersector(const vector<MESH> &meshes)
  : m_meshes(meshes),
  m_maxFaces(0)
#ifndef USE_MG_RTREE
  ,m_rtree(bgi::dynamic_rstar(16))
#endif  // USE_MG_RTREE
{
  if (!meshes.size())
    return;

  // find maximum number of faces in meshes
  m_maxFaces = meshes[0].n_faces();
  for (uint i=1; i<meshes.size(); ++i)
    if (meshes[i].n_faces() > m_maxFaces)
      m_maxFaces = meshes[i].n_faces();

#ifdef USE_MG_RTREE
  // ============================================================
  // Miracle Grue rtree
  // init rtree by iterating through mesh faces and adding them to rtree
  uint count = 0;
  for (uint i=0; i<meshes.size(); ++i) {
    for (typename mesh_type::FaceIter fit=meshes[i].faces_begin();
         fit!=meshes[i].faces_end(); ++fit) {
      struct MyTriangle tri;
      int vidx = 0;
      for (typename mesh_type::ConstFaceVertexIter
           fvit=meshes[i].cfv_iter(fit);
           is_valid_handle(*fvit) && vidx<3; ++fvit, ++vidx) {
        tri.triangle[vidx] =
          vector_cast<Vec3r>(meshes[i].point(fvit));
      }
      TriId tid = {i, fit->idx(), m_maxFaces};
      tri.id = tid;       //make_pair(i, fit->idx());
      m_rtree.insert(tri);
      ++count;
    }
  }
  printf("MeshIntersector::MeshIntersector: "
         "added %u triangles to rtree\n", count);

#else

  // ============================================================
  // build boost rtree
  for (uint i=0; i<meshes.size(); ++i) {
    for (typename mesh_type::FaceIter fit=meshes[i].faces_begin();
         fit!=meshes[i].faces_end(); ++fit) {

      if (!meshes[i].cfv_iter(fit))
        continue;

      // compute face bbox
      BoostVec3 bmin, bmax;
      Vec3r tp = vector_cast<Vec3r>
                   (meshes[i].point(meshes[i].cfv_iter(fit)));
      bmin.set<0>(tp[0]);     bmin.set<1>(tp[1]);     bmin.set<2>(tp[2]);
      bmax.set<0>(tp[0]);     bmax.set<1>(tp[1]);     bmax.set<2>(tp[2]);
      mgl::Triangle3 tri;
      int vidx = 0;
      for (typename mesh_type::ConstFaceVertexIter
           fvit=meshes[i].cfv_iter(fit); is_valid_handle(*fvit) && vidx<3;
           ++fvit, ++vidx) {
        Vec3r p = vector_cast<Vec3r>(meshes[i].point(fvit));
        if (p[0] < bmin.get<0>()) bmin.set<0>(p[0]);
        if (p[1] < bmin.get<1>()) bmin.set<1>(p[1]);
        if (p[2] < bmin.get<2>()) bmin.set<2>(p[2]);
        if (p[0] > bmax.get<0>()) bmax.set<0>(p[0]);
        if (p[1] > bmax.get<1>()) bmax.set<1>(p[1]);
        if (p[2] > bmax.get<2>()) bmax.set<2>(p[2]);
        tri[vidx] = p;
      }
      uint fidx = i*m_maxFaces + fit->idx();
      m_faceTri3[fidx] = make_pair(tri, Box3(bmin, bmax));
      pair<uint, mgl::Triangle3> idx = make_pair(fidx, tri);
      m_rtree.insert(make_pair(m_faceTri3[fidx].second, idx));
    }
  }

#endif  // USE_MG_RTREE

  // build face neighbor maps
  printf("building face neighbor maps...");           fflush(stdout);
  for (uint i=0; i<meshes.size(); ++i) {
    for (typename mesh_type::FaceIter fit=meshes[i].faces_begin();
         fit!=meshes[i].faces_end(); ++fit) {
      TriId tid = {i, fit->idx(), m_maxFaces};
      std::unordered_set<int> nbrs;
      for (typename mesh_type::ConstFaceVertexIter fvit=
             meshes[i].cfv_iter(fit); is_valid_handle(*fvit); ++fvit)
        for (typename mesh_type::ConstVertexFaceIter vfit=
               meshes[i].cvf_iter(fvit); is_valid_handle(*vfit); ++vfit)
          nbrs.insert(vfit->idx());           // Warning/Note:
                                                      // face adds self as nbr..
      m_faceNbrMap[tid] = nbrs;
    }
  }
  printf("done.\n");
}



MI_TMPLT
int
MI_TYPE::computeIntersections() {
  // start Google profiler
  // ProfilerStart("intersector.prof");

  // clear intersections list
  uint count = 0;
  m_intersections.clear();

  // // create and start timer
  // QElapsedTimer timer;
  // timer.start();

#ifdef USE_MG_RTREE
  // ============================================================
  // MG RTree
  // ============================================================

  // iterate through mesh triangles in rtree and find bbox intersections
  for (RTree::const_iterator it=m_rtree.begin(); it!=m_rtree.end(); ++it) {

    const BoxFilter::bbox_type &bbox=mgl::to_bbox<MyTriangle>::bound((*it));

    // search rtree for boxes intersecting/overlapping with current box
    vector<MyTriangle>      result;
    BoxFilter filter(bbox);
    m_rtree.search(result, filter);

    // test for tri-tri intersections
    for (uint i=0; i<result.size(); ++i) {

      // set tri ids
      const TriId &id0 = it->id;
      const TriId &id1 = result[i].id;

      // check for existing intersections
      if (m_intersections[id1].find(id0) != m_intersections[id1].end())
        continue;

      // don't test neighboring faces on the same mesh
      if (id0.meshId == id1.meshId) {
        if (id0.faceId == id1.faceId)
          continue;
        if (m_faceNbrMap[id0].find(id1.faceId) !=
            m_faceNbrMap[id0].end())
          continue;
      }

      // do tri-tri intersection test
      const mgl::Triangle3 &t0 = it->triangle;
      const mgl::Triangle3 &t1 = result[i].triangle;
      if (triTriIntersect(t0, t1)) {
        // add faces to intersections list
        m_intersections[id0].insert(id1);
        m_intersections[id1].insert(id0);
        ++count;
      }
    }
  }

#else
  // ============================================================
  // Boost RTree
  // ============================================================

  // iterate through mesh triangles and find its bbox intersections
  // with other mesh faces
  for (uint i=0; i<m_meshes.size(); ++i) {
    for (typename mesh_type::FaceIter fit=m_meshes[i].faces_begin();
         fit!=m_meshes[i].faces_end(); ++fit) {

      // error checking for degenerate cases
      if (!m_meshes[i].cfv_iter(fit))
        continue;

      // get/compute current face's index, triangle3, and bbox
      uint fidx = i * m_maxFaces + fit->idx();
      const Box3 &box = m_faceTri3[fidx].second;
      const mgl::Triangle3 &tri = m_faceTri3[fidx].first;
      std::vector<RTValue> result;

      // ==================================================
      // RTree query: boost version
      // TODO: probably should also check for 'contains' and
      // 'within' cases... however, since triangles are (always)
      // planar, does intersects() cover all cases??
      m_rtree.query(bgi::intersects(box), std::back_inserter(result));

      // test for tri-tri intersections
      for (uint j=0; j<result.size(); ++j) {

        // set tri ids
        TriId id0 = {i, fit->idx(), m_maxFaces};
        TriId id1 = {result[j].second.first / m_maxFaces,
                     result[j].second.first % m_maxFaces, m_maxFaces};

        // check for existing intersections
        if (m_intersections[id1].find(id0) != m_intersections[id1].end())
          continue;

        // don't test neighboring faces on the same mesh
        if (id0.meshId == id1.meshId) {
          if (id0.faceId == id1.faceId)
            continue;
          if (m_faceNbrMap[id0].find(id1.faceId) !=
              m_faceNbrMap[id0].end())
            continue;
        }

        // do tri-tri intersection test
        const mgl::Triangle3 &t1 = result[j].second.second;
        if (triTriIntersect(tri, t1)) {
          // add faces to intersections list
          m_intersections[id0].insert(id1);
          m_intersections[id1].insert(id0);
          ++count;
        }
      }
    }
  }

#endif  // USE_MG_RTREE

  // // print info
  // printf("intersections: %u\n", count);
  // printf("total time: %lf\n", timer.elapsed()/1000.0);

  // stop Google profiler
  // ProfilerStop();
  return 1;
}

} // namespace LibThing
