// Copyright 2012 Makerbot Industries

#ifndef INCLUDE_MESHUTILS_RAY_AABB_H_
#define INCLUDE_MESHUTILS_RAY_AABB_H_

#include <Eigen/Core>

namespace LibThing {

/// Return true if ray intersects AABB, false otherwise
///
/// The ray starts at rayStart and moves in the direction of
/// rayDir. The axis-aligned bounding box is defined by its minimum
/// and maximum corners, aabbMin and aabbMax respectively.
///
/// Note: I'm not sure if rayDir needs to be normalized, but for now
/// assume it is necessary.
///
/// If an intersection is found, hit is set to the position where the
/// intersection occurred.
template<typename T>
bool intersectRayAabb(const Eigen::Matrix<T, 3, 1> &rayStart,
                      const Eigen::Matrix<T, 3, 1> &rayDir,
                      const Eigen::Matrix<T, 3, 1> &aabbMin,
                      const Eigen::Matrix<T, 3, 1> &aabbMax,
                      Eigen::Matrix<T, 3, 1> *hit) {
  // Adapted from "Fast Ray-Box Intersection" (Andrew Woo, "Graphics
  // Gems", Academic Press, 1990)

  const int kRight(0);
  const int kLeft(1);
  const int kMiddle(2);

  char inside = true;
  char quadrant[3];
  register int i;
  int whichPlane;
  double maxT[3];
  double candidatePlane[3];

  // Find candidate planes
  for (i = 0; i < 3; i++) {
    if (rayStart[i] < aabbMin[i]) {
      quadrant[i] = kLeft;
      candidatePlane[i] = aabbMin[i];
      inside = false;
    } else if (rayStart[i] > aabbMax[i]) {
      quadrant[i] = kRight;
      candidatePlane[i] = aabbMax[i];
      inside = false;
    } else {
      quadrant[i] = kMiddle;
    }
  }

  if (inside) {
    // Ray origin inside bounding box
    (*hit) = rayStart;
    return true;
  }

  // Calculate T distances to candidate planes
  for (i = 0; i < 3; i++) {
    if (quadrant[i] != kMiddle && rayDir[i] != static_cast<T>(0))
      maxT[i] = (candidatePlane[i] - rayStart[i]) / rayDir[i];
    else
      maxT[i] = static_cast<T>(-1);
  }

  // Get largest of the maxT's for final choice of intersection
  whichPlane = 0;
  for (i = 1; i < 3; i++)
    if (maxT[whichPlane] < maxT[i])
      whichPlane = i;

  // Check final candidate actually inside box
  if (maxT[whichPlane] < static_cast<T>(0))
    return false;

  for (i = 0; i < 3; i++) {
    if (whichPlane != i) {
      (*hit)[i] = rayStart[i] + maxT[whichPlane] * rayDir[i];
      if ((*hit)[i] < aabbMin[i] || (*hit)[i] > aabbMax[i])
        return false;
    } else {
      (*hit)[i] = candidatePlane[i];
    }
  }

  // Ray hits box
  return true;
}
}

#endif  // INCLUDE_MESHUTILS_RAY_AABB_H_
