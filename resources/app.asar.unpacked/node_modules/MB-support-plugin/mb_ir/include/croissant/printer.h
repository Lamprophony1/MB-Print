// Copyright 2013 MakerBot Industries

#ifndef INCLUDE_CROISSANT_PRINTER_H_
#define INCLUDE_CROISSANT_PRINTER_H_

#include <fstream>
#include <memory>
#include <mutex>
#include <utility>

#include "croissant/printer_codegen.h"
#include "croissant/printer_camera.h"
#include "croissant/manual_methods.h"
#include "mbcoreutils/vector_version.h"

#include <boost/crc.hpp>

namespace croissant {

class Printer;
typedef boost::future<std::shared_ptr<Printer> > PrinterFuture;

class PrinterPrivate;

/// Note that Printer objects cannot be directly constructed --
/// the create* methods must be used to create a printer future
/// which will become ready once the initialization sequence for
/// the given create* method is complete.
class CROISSANT_API Printer : public PrinterCodegen {
 public:

  /// Create a printer connected to the given address.  No
  /// authentication will be performed for this printer.
  static PrinterFuture createNoAuth(const std::string & addressString);

  /// Create a printer connected to the given address.  Passes
  /// a reflector style auth packet to authenticate.
  static PrinterFuture createPacketAuth(const std::string & addressString,
                                        const Json::Value & authPacket);

  /// Create a printer connected to the given address.  Directly
  /// authenticates to a local printer using the given token.
  static PrinterFuture createTokenAuth(const std::string & addressString,
                                       boost::future<std::string> && token);
  static PrinterFuture createTokenAuth(const std::string & addressString,
                                       const std::string & token);

  /// Same as createTokenAuth, but also returns a future on the
  /// results of the handshake performed as part of initialization.
  /// Really only for internal use by PrinterFinder.
  static std::pair<PrinterFuture, boost::future<Json::Value> >
  handshakeTokenAuth(const std::string & addressString,
                     boost::future<std::string> && token);

  virtual ~Printer();

  /// This will drop the connection to the printer
  void disconnect();

  /// This will become ready with no exception on invoking disconnect(),
  /// and will become ready with an exception for any other disconnection.
  boost::shared_future<void> disconnectEvent;

  /// Return true if connected, false otherwise
  bool isConnected() const;

  /// Return the address of the printer
  std::string address() const;

  /// Return the api version of the printer
  MakerBot::VectorVersion apiVersion() const;

  /// convenience method for Getting
  boost::future<void> Get(
        const std::string & remotePath,
        const std::string & localPath,
        const size_t blockSize=131072);

  void setCameraFrameNotification(
        const std::function<void(Camera::CameraFrame &&)> frameReceivedCallback);

  void unsetCameraFrameNotification();

  class CROISSANT_API PutRawMethod : methods::PutRaw {
   public:
    PutRawMethod();
    bool isSupported();
    boost::future<void> operator() (
        const std::string & fileId,
        const char * block,
        const size_t blockSize);

   private:
    std::weak_ptr<PrinterPrivate> m_printerPrivate;
    friend class Printer;
  };

  // A class for convenient putting/cancelling puts
  class CROISSANT_API PutMethod {
   public:
    PutMethod();
    bool isSupported();
    boost::future<void> operator() (
        const int id,
        const std::string & localPath,
        const std::string & remotePath,
        boost::optional<const size_t> blockSize=boost::none,
        boost::optional<std::function<void(const int &&)> > progressCallback=boost::none);
    void cancel(const int id);

   private:
    boost::future<void> doPutRaw(const int id, std::ifstream && file);
    void finish(const int id, std::ifstream && file);

    struct PutInfo {
      PutInfo(
          size_t blocksize,
          size_t filesize,
          boost::optional<std::function<void(const int &&)> > progresscallback)
        : blockSize(blocksize),
          fileSize(filesize),
          progressCallback(progresscallback) {
      }

      size_t blockSize;
      size_t fileSize;
      boost::optional<std::function<void(const int &&)> > progressCallback;
      boost::crc_32_type crc;
      size_t lenSent = 0;
      bool cancelled = false;
    };

    std::weak_ptr<PrinterPrivate> m_printerPrivate;
    std::map<int, PutInfo> m_putInfos;

   friend class Printer;
  };

  PutRawMethod PutRaw;
  PutMethod Put;

 private:
  Printer() = delete;
  Printer(std::shared_ptr<PrinterPrivate> priv);
  friend class PrinterInit;

  void setPrivate();
  void setGetCallbacks();

  std::shared_ptr<PrinterPrivate> m_private;
  int m_fileId = 0;

  struct Transfer {
    Transfer(std::ofstream &file, boost::promise<void> &promise)
      : file(file),
        transferComplete(promise) {
    }

    std::ofstream &file;
    boost::promise <void> &transferComplete;
    boost::crc_32_type crc;
  };

  class TransferMap : public std::map <std::string, Transfer> {
   public:
    std::pair <iterator, bool> emplace(std::string fileId, Transfer transfer);
    iterator find(std::string fileId);
    iterator erase(iterator);

   private:
    std::mutex m_transfersMtx;
  };

  TransferMap m_transfers;

  std::shared_ptr <Camera> m_camera;
};

}  // namespace croissant

#endif  // INCLUDE_CROISSANT_PRINTER_H_
