// Copyright 2015 MakerBot Industries

#ifndef INCLUDE_EMBEDDED_PYTHON_ASYNCIO_H_
#define INCLUDE_EMBEDDED_PYTHON_ASYNCIO_H_

#include <memory>
#include <utility>

#include "embedded_python/interpreter.h"
#include "embedded_python/future.h"
#include "embedded_python/util.h"

namespace embedded_python {

/// Singleton class for starting up the python interpreter, starting a
/// separate thread to run an asyncio loop, and interacting with the
/// python interpreter.  If you use this class at all, you must not
/// initialize the python interpreter anywhere else.
class EMBEDDED_PYTHON_API AsyncIO {
  public:
    ~AsyncIO();

    /// Get a pointer to the singleton object.  This will create and
    /// initialize the object if necessary.
    static AsyncIO *get_asyncio();

    /// This runs the given coroutine in the event loop, returning a
    /// boost future for the result of the coroutine.  This does not
    /// expose any way to cancel the coroutine.  Note that if this
    /// future is not ready and you attempt to wait for it to be
    /// ready in any code that is invoked by the asyncio event loop,
    /// you will deadlock the event loop.
    boost::future<Ref> async(const Ref &coro);

    /// This invokes a callback with the given positional arguments
    /// in the event loop and returns the result.  If the function
    /// has no arguments you must still pass in an empty tuple.
    /// This will block the current thread until the event loop gets
    /// around to invoking the callback, although if the current
    /// thread is the event loop thread then this will just directly
    /// invoke the function.
    Ref loopCall(const Ref &fn, const Ref &args);

    // Disable copy/move construction/assignment
    AsyncIO(const AsyncIO&) = delete;
    AsyncIO& operator=(const AsyncIO&) = delete;
    AsyncIO(AsyncIO&&) = delete;
    AsyncIO& operator=(AsyncIO&&) = delete;

  private:
    AsyncIO();

    void run_loop(const Ref &start_callback);
    void stop_loop();

    // Hold an interpreter reference to make sure that this object
    // gets destructed first.
    std::shared_ptr<Interpreter> m_interp;

    boost::future<void> loop_complete;
    Ref loop;

    // Callable object for the async method
    Ref async_fn;

    // Callable object for the loopCall method
    Ref loop_call_fn;
};

}  // namespace embedded_python

#endif  // INCLUDE_EMBEDDED_PYTHON_ASYNCIO_H_

