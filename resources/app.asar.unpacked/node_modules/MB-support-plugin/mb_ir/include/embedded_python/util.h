// Copyright 2015 MakerBot Industries

#ifndef INCLUDE_EMBEDDED_PYTHON_UTIL_H_
#define INCLUDE_EMBEDDED_PYTHON_UTIL_H_

#include <memory>
#include <string>
#include <utility>

#include "jsoncpp/json/value.h"
#include "embedded_python/future.h"
#include "embedded_python/ref.h"

namespace embedded_python {

/// Pretty much every python C API call requires that the calling thread
/// has first acquired the python global interpreter lock (GIL).
/// Creating a local GIL object at the beginning of a block of code
/// will ensure that the GIL is acquired for the duration of that block,
/// and that the GIL is returned to whatever state it was previously in
/// when exiting the block.  Creating multiple local GIL objects is
/// safe, and it is recommended that any function that contains a python
/// C API call directly create a GIL object or explicitly document
/// that it requires the GIL.
///
/// The GIL should not be acquired by any code that waits on a separate
/// thread, or that might block for a significant amount of time on a
/// system call (see UnlockGIL).
class EMBEDDED_PYTHON_API GIL {
  public:
    GIL();
    ~GIL();
  private:
    class Private;
    std::unique_ptr<Private> m_private;
};

/// Creating a local UnlockGIL object in a block of code will ensure
/// that we have released the GIL for the remainder of that block.
/// This will temporarily override the effect of a GIL object in a
/// parent scope, or even earlier in the current code block, and can
/// be overridden back by a GIL object created later in the code
/// block or in a child scope.
///
/// This should be used to avoid deadlock when a function that may be
/// called with the GIL needs to wait on another thread that may need
/// to invoke a python function.  More generally, it is a good idea to
/// invoke this function around any code that might block the current
/// thread when we have the GIL, and around calls to functions defined
/// in places that have nothing to do with python code.
class EMBEDDED_PYTHON_API UnlockGIL {
  public:
    UnlockGIL();
    ~UnlockGIL();
  private:
    class Private;
    std::unique_ptr<Private> m_private;
};

/// Create a python callable object that ignores all arguments
/// and a boost future that will become ready the first time
/// that the callable object has been invoked.  Requires the GIL.
std::pair<Ref, boost::future<void> > EMBEDDED_PYTHON_API Callback();

/// Create a python callable object that expects to be called with a
/// single argument that is a _ready_ asyncio.Future object, and a
/// boost future that will receive the future result.  Requires the GIL.
std::pair<Ref, boost::future<Ref> > EMBEDDED_PYTHON_API Future();

/// Create a python callable object which accepts any number of
/// positional arguments and ignores all keyword arguments, passing
/// the argument tuple to the given function.  Note that any C++
/// exceptions raised by the callback will be silently ignored.
Ref EMBEDDED_PYTHON_API Function(std::function<void(const Ref &)>);

/// Roughly equivalent to str() in python
std::string EMBEDDED_PYTHON_API toString(const Ref &);

/// Create a JSON value from a python object.  Raises a C++ exception if
/// the value cannot be converted.
Json::Value EMBEDDED_PYTHON_API toJson(const Ref &);

}  // namespace embedded_python

#endif  // INCLUDE_EMBEDDED_PYTHON_UTIL_H_

