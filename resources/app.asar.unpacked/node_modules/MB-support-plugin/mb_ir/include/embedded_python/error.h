// Copyright 2015 MakerBot Industries

#ifndef INCLUDE_EMBEDDED_PYTHON_ERROR_H_
#define INCLUDE_EMBEDDED_PYTHON_ERROR_H_

#include <stdexcept>
#include <string>

namespace embedded_python {

/// This is the C++ Exception that we raise whenever an unhandled
/// python exception is raised by python code that we execute.
///
/// TODO(chris): This doesn't give C++ code useful access to the exception
class Exception : public std::runtime_error {
  public:
    Exception(const std::string &exc) : std::runtime_error(exc) { }
};

/// Call this when a python exception has occured to convert it to
/// a C++ exception and throw this exception.  Do not invoke
/// this if no python error has actually occured.
///
/// Usually you do not need to invoke this directly.  Most python API
/// that can raise an error return a PyObject pointer, and when a Ref
/// object is constructed from that pointer we automatically invoke
/// this function if the pointer is NULL.  In the remainder of python
/// API calls you should just call ErrorCheck(), which will raise an
/// error only if one actually occured.
void EMBEDDED_PYTHON_API Error();

/// For Python C API calls which do not return a PyObject pointer, you
/// should immediately afterward invoke this function to check if an
/// error occured.  In particular you should not invoke another C API
/// function or release the GIL before invoking this.
void EMBEDDED_PYTHON_API ErrorCheck();

}  // namespace embedded_python

#endif  // INCLUDE_EMBEDDED_PYTHON_ERROR_H_

