// Copyright 2014 MakerBot

#ifndef INCLUDE_GEOMUTILS_INTERSECTION_INDEX_H_
#define INCLUDE_GEOMUTILS_INTERSECTION_INDEX_H_

#include <stdlib.h>

#include <limits>

#include "geomutils/spacial_data.h"
#include "geomutils/LineSegment2.h"

namespace geomutils {
template <>
struct to_bbox<LineSegment2> {
  static AABBox bound(const LineSegment2& ls) {
    static const Vector2 epsilon(std::numeric_limits<Scalar>::epsilon(),
                                    std::numeric_limits<Scalar>::epsilon());
    AABBox ret(ls.a);
    ret.expandTo(ls.b);
    ret.adjust(-epsilon, epsilon);
    return ret;
  }
};

class LineSegmentFilter : public BBoxFilter {
 public:
  LineSegmentFilter(const LineSegment2& data =
                      LineSegment2())
    : BBoxFilter(to_bbox<LineSegment2>::bound(data)),
    myData(data) {
  }
  bool filter(const AABBox& bb) const {
    enum leg {
      l_les = -1,
      l_equ = 0,
      l_gre = 1
    };

    if (!BBoxFilter::filter(bb))
      return false;

    leg x1, y1, x2, y2;
    x1 = myData.a[0] < bb.left() ?
         l_les : (myData.a[0] < bb.right() ?
                  l_equ : l_gre);
    x2 = myData.b[0] < bb.left() ?
         l_les : (myData.b[0] < bb.right() ?
                  l_equ : l_gre);
    y1 = myData.a[1] < bb.bottom() ?
         l_les : (myData.a[1] < bb.top() ?
                  l_equ : l_gre);
    y2 = myData.b[1] < bb.bottom() ?
         l_les : (myData.b[1] < bb.top() ?
                  l_equ : l_gre);
    int x = x1 + x2;
    int y = y1 + y2;
    return (abs(x) < 2 && abs(y) < 2);
  }

 protected:
  LineSegment2 myData;
};

}  // namespace geomutils

#endif  // INCLUDE_GEOMUTILS_INTERSECTION_INDEX_H_
