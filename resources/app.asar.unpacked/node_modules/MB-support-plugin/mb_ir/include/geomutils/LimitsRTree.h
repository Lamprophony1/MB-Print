#pragma once

// boost geometry stuff
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/box.hpp>
#include <boost/geometry/geometries/point.hpp>
#include <boost/geometry/index/rtree.hpp>

#include "limits.h"

namespace geomutils {

typedef boost::geometry::model::point<Scalar, 3, boost::geometry::cs::cartesian>
    BoostVector3;
typedef boost::geometry::model::box<BoostVector3> BoostBox3;

template <typename VALUE>
struct LimitedItem {

    LimitedItem(const Limits& limits, const VALUE& value)
        : limits(limits),
          box(BoostVector3(limits.xMin, limits.yMin, limits.zMin),
              BoostVector3(limits.xMax, limits.yMax, limits.zMax)),
          value(value) {}

    Limits limits;
    BoostBox3 box;
    VALUE value;
};

template <typename VALUE>
struct LimitedItemIndexableGetter {

    typedef const BoostBox3& result_type;

    result_type operator()(const LimitedItem<VALUE>& value) const {
        return value.box;
    }
};

template <typename VALUE>
struct LimitedItemEqualTo {
    bool operator()(const LimitedItem<VALUE>& a,
                    const LimitedItem<VALUE>& b) const {
        if (!boost::geometry::equals(a.box, b.box)) return false;
        return a.value == b.value;
    }
};

template <typename VALUE, int MAX_ELEMENTS = 16>
class LimitsRTree : public boost::geometry::index::rtree<
                        LimitedItem<VALUE>,
                        boost::geometry::index::rstar<MAX_ELEMENTS>,
                        LimitedItemIndexableGetter<VALUE>,
                        LimitedItemEqualTo<VALUE>> {

public:
    // Gotta redefine this, templates are awesome
    typedef boost::geometry::index::rtree<
        LimitedItem<VALUE>,
        boost::geometry::index::rstar<MAX_ELEMENTS>,
        LimitedItemIndexableGetter<VALUE>,
        LimitedItemEqualTo<VALUE>>
        _RTree;

    typedef typename _RTree::const_query_iterator const_query_iterator;

    typedef LimitedItem<VALUE> Item;

    const_query_iterator contains_begin(const Limits& limits) const {
        return _RTree::qbegin(boost::geometry::index::contains(toBox(limits)));
    }
    const_query_iterator contains_end() const { return _RTree::qend(); }

    const_query_iterator covered_by_begin(const Limits& limits) const {
        return _RTree::qbegin(
            boost::geometry::index::covered_by(toBox(limits)));
    }
    const_query_iterator covered_by_end() const { return _RTree::qend(); }

    const_query_iterator covers_begin(const Limits& limits) const {
        return _RTree::qbegin(boost::geometry::index::covers(toBox(limits)));
    }
    const_query_iterator covers_end() const { return _RTree::qend(); }

    const_query_iterator disjoint_begin(const Limits& limits) const {
        return _RTree::qbegin(boost::geometry::index::disjoint(toBox(limits)));
    }
    const_query_iterator disjoint_end() const { return _RTree::qend(); }

    const_query_iterator intersects_begin(const Limits& limits) const {
        return _RTree::qbegin(
            boost::geometry::index::intersects(toBox(limits)));
    }
    const_query_iterator intersects_end() const { return _RTree::qend(); }

    const_query_iterator overlaps_begin(const Limits& limits) const {
        return _RTree::qbegin(boost::geometry::index::overlaps(toBox(limits)));
    }
    const_query_iterator overlaps_end() const { return _RTree::qend(); }

    const_query_iterator within_begin(const Limits& limits) const {
        return _RTree::qbegin(boost::geometry::index::within(toBox(limits)));
    }
    const_query_iterator within_end() const { return _RTree::qend(); }

    const_query_iterator nearest_begin(const Vector3& point,
                                       size_t num_results) const {
        return _RTree::qbegin(boost::geometry::index::nearest(
            geomutils::BoostVector3(point[0], point[1], point[2]),
            num_results));
    }
    const_query_iterator nearest_end() const { return _RTree::qend(); }

    static BoostBox3 toBox(const Limits& limits) {
        return BoostBox3(BoostVector3(limits.xMin, limits.yMin, limits.zMin),
                         BoostVector3(limits.xMax, limits.yMax, limits.zMax));
    }
};
}