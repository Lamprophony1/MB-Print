/*
 * File:   ContainmentTree.cc
 * Author: FILIPP
 *
 * Created on October 29, 2012, 12:16 PM
 */

#ifndef INCLUDE_GEOMUTILS_DATA_STRUCTURES_CONTAINMENT_TREE_IMPL_H
#define INCLUDE_GEOMUTILS_DATA_STRUCTURES_CONTAINMENT_TREE_IMPL_H

#include "containment_tree_decl.h"

namespace geomutils {

#define CONTAINMENT_TEMPLATE template <typename DERIVED_T>
#define CONTAINMENT_TYPE basic_containment_tree<DERIVED_T>

class ContainmentException : public std::runtime_error {
public:
    ContainmentException(const std::string str) : std::runtime_error(str) {}
};

CONTAINMENT_TEMPLATE
CONTAINMENT_TYPE::basic_containment_tree() {}
CONTAINMENT_TEMPLATE
CONTAINMENT_TYPE::basic_containment_tree(const Loop& loop) : m_loop(loop) {
    if (m_loop.empty())
        throw ContainmentException(
            "Attempted to construct ContainmentTree from empty loop!");
}
CONTAINMENT_TEMPLATE
CONTAINMENT_TYPE::basic_containment_tree(Loop&& loop)
    : m_loop(std::move(loop)) {
    if (m_loop.empty())
        throw ContainmentException(
            "Attempted to construct ContainmentTree from empty loop!");
}
CONTAINMENT_TEMPLATE
CONTAINMENT_TYPE::basic_containment_tree(CONTAINMENT_TYPE&& other)
    : m_loop(std::move(other.m_loop)),
      m_children(std::move(other.m_children)) {}
CONTAINMENT_TEMPLATE
bool CONTAINMENT_TYPE::contains(const child_type& other) const {
    const child_type* this_cast = static_cast<const child_type*>(this);
    if (this_cast->isValid()) {
        if (other.isValid()) {
            return this_cast->contains(*other.m_loop.begin()) &&
                   !other.contains(*m_loop.begin());
        } else {
            return false;
        }
    } else {
        return other.isValid();
    }
}
CONTAINMENT_TEMPLATE
bool CONTAINMENT_TYPE::contains(const Vector2& point) const {
    const child_type* this_cast = static_cast<const child_type*>(this);
    if (!this_cast->isValid())
        return true;
    else {
        return m_loop.windingContains(point);
    }
}
CONTAINMENT_TEMPLATE
bool CONTAINMENT_TYPE::isValid() const { return !m_loop.empty(); }
CONTAINMENT_TEMPLATE
typename CONTAINMENT_TYPE::child_type& CONTAINMENT_TYPE::select(
    const Vector2& point) {
    child_type* this_cast = static_cast<child_type*>(this);
    for (typename containment_list::iterator childIter = m_children.begin();
         childIter != m_children.end();
         ++childIter) {
        if (childIter->contains(point)) return childIter->select(point);
    }
    return *this_cast;
}
CONTAINMENT_TEMPLATE
const typename CONTAINMENT_TYPE::child_type& CONTAINMENT_TYPE::select(
    const Vector2& point) const {
    const child_type* this_cast = static_cast<const child_type*>(this);
    for (typename containment_list::const_iterator childIter =
             m_children.begin();
         childIter != m_children.end();
         ++childIter) {
        if (childIter->contains(point)) return childIter->select(point);
    }
    return *this_cast;
}
CONTAINMENT_TEMPLATE
typename CONTAINMENT_TYPE::child_type& CONTAINMENT_TYPE::insert(
    child_type&& other) {
    child_type* this_cast = static_cast<child_type*>(this);
    if (other.contains(*this_cast)) {
        /*
         This node will be placed inside other node. Since only other node
         is ok to invalidate and doing other.insert(*this) will invalidate
         this, we swap first.
         */
        this_cast->swap(other);
        this_cast->insert(std::move(other));
        return *this_cast;
    } else {
        for (typename containment_list::iterator childIter = m_children.begin();
             childIter != m_children.end();
             ++childIter) {
            if (childIter->contains(other))
                return childIter->insert(std::move(other));
        }
        // my children who are inside other get transfered to it
        typename containment_list::iterator childIter = m_children.begin();
        while (childIter != m_children.end()) {
            if (other.contains(*childIter)) {
                other.insert(std::move(*childIter));
                childIter = m_children.erase(childIter);
            } else {
                ++childIter;
            }
        }
        // the hierarchy is in order.
        m_children.emplace_back(std::move(other));
        return m_children.back();
    }
}
CONTAINMENT_TEMPLATE
void CONTAINMENT_TYPE::insert(iterator from, iterator to, child_type& donor) {
    m_children.splice(m_children.end(), donor.m_children, from, to);
}
CONTAINMENT_TEMPLATE
const Loop& CONTAINMENT_TYPE::boundary() const { return m_loop; }
CONTAINMENT_TEMPLATE
void CONTAINMENT_TYPE::swap(child_type& other) {
    m_loop.swap(other.m_loop);
    m_children.swap(other.m_children);
}
CONTAINMENT_TEMPLATE
typename CONTAINMENT_TYPE::iterator CONTAINMENT_TYPE::begin() {
    return m_children.begin();
}
CONTAINMENT_TEMPLATE
typename CONTAINMENT_TYPE::const_iterator CONTAINMENT_TYPE::begin() const {
    return m_children.begin();
}
CONTAINMENT_TEMPLATE
typename CONTAINMENT_TYPE::const_iterator CONTAINMENT_TYPE::cbegin() const {
    return m_children.cbegin();
}
CONTAINMENT_TEMPLATE
typename CONTAINMENT_TYPE::iterator CONTAINMENT_TYPE::end() {
    return m_children.end();
}
CONTAINMENT_TEMPLATE
typename CONTAINMENT_TYPE::const_iterator CONTAINMENT_TYPE::end() const {
    return m_children.end();
}
CONTAINMENT_TEMPLATE
typename CONTAINMENT_TYPE::const_iterator CONTAINMENT_TYPE::cend() const {
    return m_children.cend();
}
CONTAINMENT_TEMPLATE
bool CONTAINMENT_TYPE::empty() const { return m_children.empty(); }
CONTAINMENT_TEMPLATE
size_t CONTAINMENT_TYPE::size() const { return m_children.size(); }
CONTAINMENT_TEMPLATE
typename CONTAINMENT_TYPE::iterator CONTAINMENT_TYPE::erase(iterator position) {
    return m_children.erase(position);
}
CONTAINMENT_TEMPLATE
typename CONTAINMENT_TYPE::iterator CONTAINMENT_TYPE::erase(iterator from,
                                                            iterator to) {
    return m_children.erase(from, to);
}

#define EXAMPLE_TEMPLATE template <typename T>
#define EXAMPLE_TYPE ContainmentTree<T>

EXAMPLE_TEMPLATE
EXAMPLE_TYPE::ContainmentTree() {}
EXAMPLE_TEMPLATE
EXAMPLE_TYPE::ContainmentTree(const Loop& loop) : parent_type(loop) {}
EXAMPLE_TEMPLATE
EXAMPLE_TYPE::ContainmentTree(const Loop& loop, const T& value)
    : parent_type(loop), m_value(value) {}
EXAMPLE_TEMPLATE
EXAMPLE_TYPE::ContainmentTree(ContainmentTree&& other)
    : parent_type(std::move(other)), m_value(std::move(other.m_value)) {}
EXAMPLE_TEMPLATE
typename EXAMPLE_TYPE::value_type& EXAMPLE_TYPE::value() { return m_value; }
EXAMPLE_TEMPLATE
const typename EXAMPLE_TYPE::value_type& EXAMPLE_TYPE::value() const {
    return m_value;
}
EXAMPLE_TEMPLATE
void EXAMPLE_TYPE::swap(ContainmentTree& other) {
    std::swap(m_value, other.m_value);
    parent_type::swap(other);
}
}

namespace std {

CONTAINMENT_TEMPLATE
void swap(geomutils::CONTAINMENT_TYPE& lhs, geomutils::CONTAINMENT_TYPE& rhs) {
    static_cast<typename geomutils::CONTAINMENT_TYPE::child_type&>(lhs).swap(
        static_cast<typename geomutils::CONTAINMENT_TYPE::child_type&>(rhs));
}
}

#undef EXAMPLE_TYPE
#undef EXAMPLE_TEMPLATE

#undef CONTAINMENT_TYPE
#undef CONTAINMENT_TEMPLATE

#endif /* INCLUDE_GEOMUTILS_DATA_STRUCTURES_CONTAINMENT_TREE_IMPL_H */
