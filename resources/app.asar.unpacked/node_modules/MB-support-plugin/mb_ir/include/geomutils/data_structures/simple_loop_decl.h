// Copyright 2013 MakerBot Industries

#ifndef INCLUDE_GEOMUTILS_DATA_STRUCTURES_SIMPLE_LOOP_DECL_H
#define	INCLUDE_GEOMUTILS_DATA_STRUCTURES_SIMPLE_LOOP_DECL_H

#include <vector>
#include <boost/iterator/iterator_facade.hpp>
#include <boost/iterator/iterator_adaptor.hpp>
#include <boost/type_traits.hpp>
#include <memory>

namespace geomutils {

/**
 @brief A class for providing the interface of a circularly linked list 
 to a contiguous collection of elements. Insertions and removals take 
 amortized constant time and do not invalidate existing iterators.
 */
template <typename LOOP_VALUE_TYPE,
        typename ALLOC_T = std::allocator<LOOP_VALUE_TYPE> >
class basic_simple_loop {
protected:
    ///An invalid index used by list_node
    typedef LOOP_VALUE_TYPE m_value_type;
    static const size_t npos = -1;
    class list_node {
    public:
        list_node(size_t prev, size_t next, const m_value_type& data = m_value_type()) 
                : m_prev(prev), m_next(next), m_data(data) {}
        list_node(const m_value_type& data = m_value_type()) 
                : m_prev(npos), m_next(npos), m_data(data) {}
        size_t m_prev;
        size_t m_next;
        m_value_type m_data;
    };
    ///vector backed emulation of a circularly linked list
    typedef std::vector<list_node,
            typename ALLOC_T::template rebind<list_node>::other> cll_type;
    typedef std::vector<size_t> vacant_type;
    /**
     @brief Iterator template for accessing points in the loop.
     This template 
     @param STORE_TYPE cll_type or const cll_type (determines if const_iterator)
     @param VALUE_TYPE value_type or const value_type, (determines if const_iterator)
     @param REVERSE indicates direction (false = forward, true = reverse)
     */
    template <typename STORE_TYPE, typename VALUE_TYPE, bool REVERSE = false>
    class iterator_base : public boost::iterator_facade<
            iterator_base<STORE_TYPE, VALUE_TYPE, REVERSE>, 
            VALUE_TYPE, 
            boost::bidirectional_traversal_tag> {
    public:
        template <typename O_STORE_TYPE, typename O_VALUE_TYPE, bool O_REVERSE>
        friend class iterator_base;
        friend class basic_simple_loop;
        typedef iterator_base<STORE_TYPE, VALUE_TYPE, REVERSE> my_type;
        typedef iterator_base<STORE_TYPE, VALUE_TYPE, !REVERSE> reverse_type;
        typedef iterator_base<typename boost::add_const<STORE_TYPE>::type,
                typename boost::add_const<VALUE_TYPE>::type, REVERSE>
                more_const_iterator_base;
        typedef iterator_base<typename boost::remove_const<STORE_TYPE>::type, 
                typename boost::remove_const<STORE_TYPE>::type, REVERSE>
                less_const_iterator_base;
        iterator_base();
        explicit iterator_base(STORE_TYPE* datastore);
        iterator_base(size_t index, STORE_TYPE* datastore);
        iterator_base(const iterator_base& other);
        inline operator more_const_iterator_base() const {
            return consted();
        }
        ///@return an iterator at the same position as this, but reverse direction
        inline reverse_type reversed() const {
            return reverse_type(m_index, m_datastore);
        }
        ///@brief convert an iterator into a const_iterator, noop for const_iterator
        inline more_const_iterator_base consted() const {
            return more_const_iterator_base(m_index, m_datastore);
        }
    private:
        friend class boost::iterator_core_access;
        VALUE_TYPE& dereference() const;
        void increment();
        void decrement();
        bool equal(const iterator_base& other) const;
        
        
        size_t m_index;
        STORE_TYPE* m_datastore;
    };
    /**
     @brief This iterator will loop around exactly once from 
     whatever position it was initialized with.
     @param CLOSED determines if we visit the starting point again at the end
     Most functions expect basic iterators as parameters. Simply invoke 
     .base() on one of these to convert.
     */
    template <typename STORE_TYPE, typename VALUE_TYPE, bool REVERSE = false, 
            bool CLOSED = false>
    class clamp_iterator_base : public boost::iterator_adaptor<
            clamp_iterator_base<STORE_TYPE, VALUE_TYPE, REVERSE, CLOSED>, 
            iterator_base<STORE_TYPE, VALUE_TYPE, REVERSE> > {
        typedef iterator_base<STORE_TYPE, VALUE_TYPE, REVERSE> base_type;
    public:
        typedef clamp_iterator_base<typename boost::add_const<STORE_TYPE>::type,
                typename boost::add_const<VALUE_TYPE>::type, REVERSE> 
                more_const_clamp_iterator_base;
        typedef clamp_iterator_base<typename boost::remove_const<STORE_TYPE>::type, 
                typename boost::remove_const<STORE_TYPE>::type, REVERSE>
                less_const_iterator_base;
        explicit clamp_iterator_base(STORE_TYPE* datastore) 
                : clamp_iterator_base::iterator_adaptor_(base_type(datastore)), 
                m_initial(datastore) {}
        clamp_iterator_base();
        clamp_iterator_base(size_t index, STORE_TYPE* datastore);
        clamp_iterator_base(const base_type& initial);
        clamp_iterator_base(const base_type& initial, const base_type& current);
        inline operator more_const_clamp_iterator_base() const {
            return more_const_clamp_iterator_base(m_initial, this->base_reference());
        }
    private:
        friend class boost::iterator_core_access;
        void increment();
        void decrement();
        bool equal(const clamp_iterator_base& other) const {
            return this->base_reference() == other.base_reference();
        }
        base_type m_initial;
        bool m_dirty;
    };
    /**
     * @brief Traverser class for use with c++11 for(type a : b) syntax.
     * They expose only begin and end calls that return iterators of 
     * the specified type.
     */
    template <typename ITER_BASE>
    class traverser_base {
    public:
        friend class basic_simple_loop;
        typedef ITER_BASE iterator;
        traverser_base() {}
        template <typename ITER>
        traverser_base(ITER begin, ITER end)
                : m_begin(begin), m_end(end) {}
        template <typename ITER>
        traverser_base(const traverser_base<ITER>& other)
                : m_begin(other.begin()), m_end(other.end()) {}
        template <typename ITER>
        traverser_base& operator =(const traverser_base<ITER>& other) {
            m_begin = other.begin();
            m_end = other.end();
            return *this;
        }
        iterator begin() const { return m_begin; }
        iterator end() const { return m_end; }
    private:
        iterator m_begin;
        iterator m_end;
    };
public:
    typedef m_value_type value_type;
    //circular iterators - go around infinitely
    typedef iterator_base<cll_type, value_type, false> iterator;
    typedef iterator_base<const cll_type, const value_type, false> const_iterator;
    typedef iterator_base<cll_type, value_type, true> reverse_iterator;
    typedef iterator_base<const cll_type, const value_type, true> const_reverse_iterator;
    //clamped iterators - visit every point once
    typedef clamp_iterator_base<cll_type, value_type, false, false> clamped_iterator;
    typedef clamp_iterator_base<const cll_type, const value_type, false, false> const_clamped_iterator;
    typedef clamp_iterator_base<cll_type, value_type, true, false> reverse_clamped_iterator;
    typedef clamp_iterator_base<const cll_type, const value_type, true, false> const_reverse_clamped_iterator;
    //closed iterators - visit starting point at end
    typedef clamp_iterator_base<cll_type, value_type, false, true> closed_iterator;
    typedef clamp_iterator_base<const cll_type, const value_type, false, true> const_closed_iterator;
    typedef clamp_iterator_base<cll_type, value_type, true, true> reverse_closed_iterator;
    typedef clamp_iterator_base<const cll_type, const value_type, true, true> const_reverse_closed_iterator;
    //clamped traversers, for use with c++11 for(type a : b) syntax
    typedef traverser_base<clamped_iterator> clamped_traverser;
    typedef traverser_base<const_clamped_iterator> const_clamped_traverser;
    typedef traverser_base<reverse_clamped_iterator> reverse_clamped_traverser;
    typedef traverser_base<const_reverse_clamped_iterator> const_reverse_clamped_traverser;
    //closed traversers, for use with c++11 for(type a : b) syntax
    typedef traverser_base<closed_iterator> closed_traverser;
    typedef traverser_base<const_closed_iterator> const_closed_traverser;
    typedef traverser_base<reverse_closed_iterator> reverse_closed_traverser;
    typedef traverser_base<const_reverse_closed_iterator> const_reverse_closed_traverser;
    
    
    //Loop Compatibility
    typedef iterator cw_iterator;
    typedef const_iterator const_cw_iterator;
    typedef reverse_iterator ccw_iterator;
    typedef const_reverse_iterator const_ccw_iterator;
    typedef clamped_iterator finite_cw_iterator;
    typedef const_clamped_iterator const_finite_cw_iterator;
    typedef reverse_clamped_iterator finite_ccw_iterator;
    typedef const_reverse_clamped_iterator const_finite_ccw_iterator;
    
    basic_simple_loop();
    basic_simple_loop(const basic_simple_loop& other);
    basic_simple_loop(basic_simple_loop&& other);
    basic_simple_loop& operator =(const basic_simple_loop& other);
    basic_simple_loop& operator =(basic_simple_loop&& other);
    /**
     @return iterator to the current starting position.
     */
    iterator begin();
    /**
     @return iterator to the current starting position
     */
    const_iterator begin() const;
    inline const_iterator cbegin() const { return begin(); }
    ///Loop compatibility begin functions
    inline cw_iterator clockwise() { return begin(); }
    inline const_cw_iterator clockwise() const { return begin(); }
    inline finite_cw_iterator clockwiseFinite() { return begin(); }
    inline const_finite_cw_iterator clockwiseFinite() const { return begin(); }
    /**
     @brief Get a symbolic iterator pointing to 'past the end' of the loop.
     Since loops are circularly linked list, the end() iterator is not 
     connected to the list in any way. Therefore, it is INVALID to increment
     or decrement the end iterator.
     @return iterator past the end of the loop
     */
    iterator end();
    const_iterator end() const;
    inline const_iterator cend() const { return end(); }
    ///Loop compatibility end functions
    inline cw_iterator clockwiseEnd() { return end(); }
    inline const_cw_iterator clockwiseEnd() const { return end(); }
    /**
     @return reverse iterator to the current starting position
     */
    reverse_iterator rbegin();
    /**
     @return reverse iterator to the current starting position
     */
    const_reverse_iterator rbegin() const;
    inline const_reverse_iterator crbegin() const { return rbegin(); }
    ///Loop compatibility rbegin functions
    inline ccw_iterator counterClockwise() { return rbegin(); }
    inline const_ccw_iterator counterClockwise() const { return rbegin(); }
    inline finite_ccw_iterator counterClockwiseFinite() { return rbegin(); }
    inline const_finite_ccw_iterator counterClockwiseFinite() const { return rbegin(); }
    /**
     @brief Get a symbolic reverse iterator pointing to 'past the end' of the 
     loop.
     Since loops are circularly linked list, the rend() iterator is not 
     connected to the list in any way. Therefore, it is INVALID to increment
     or decrement the rend iterator.
     @return reverse iterator past the end of the loop
     */
    reverse_iterator rend();
    const_reverse_iterator rend() const;
    inline const_reverse_iterator crend() const { return rend(); }
    ///Loop compatibility rend functions
    inline ccw_iterator counterClockwiseEnd() { return rend(); }
    inline const_ccw_iterator counterClockwiseEnd() const { return rend(); }
    //traversal objects
    clamped_traverser get_clamped_traverser();
    clamped_traverser get_clamped_traverser(const_iterator from);
    const_clamped_traverser get_clamped_traverser() const;
    const_clamped_traverser get_clamped_traverser(const_iterator from) const;
    reverse_clamped_traverser get_reverse_clamped_traverser();
    reverse_clamped_traverser get_reverse_clamped_traverser(const_reverse_iterator from);
    const_reverse_clamped_traverser get_reverse_clamped_traverser() const;
    const_reverse_clamped_traverser get_reverse_clamped_traverser(const_reverse_iterator from) const;
    closed_traverser get_closed_traverser();
    closed_traverser get_closed_traverser(const_iterator from);
    const_closed_traverser get_closed_traverser() const;
    const_closed_traverser get_closed_traverser(const_iterator from) const;
    reverse_closed_traverser get_reverse_closed_traverser();
    reverse_closed_traverser get_reverse_closed_traverser(const_reverse_iterator from);
    const_reverse_closed_traverser get_reverse_closed_traverser() const;
    const_reverse_closed_traverser get_reverse_closed_traverser(const_reverse_iterator from) const;
    /**
     @brief Place @a value at @a position. Existing iterators remain valid.
     @return iterator pointing to @a value
     Inserting at end() is equivalent to inserting at the current position.
     */
    iterator insert(const_iterator position,
            value_type&& value);
    /**
     @brief Place @a value at @a position. Existing iterators remain valid.
     @return reverse iterator pointing to @a value
     Inserting at rend() is equivalent to inserting at the current position.
     */
    reverse_iterator insert(const_reverse_iterator position,
            value_type&& value);
    ///@brief Make a copy of value and call the rvalue reference insert
    inline iterator insert(const_iterator position,
            const value_type& value) {
        return insert(position, value_type(value));
    }
    ///@brief Make a copy of value and call the rvalue reference insert
    inline reverse_iterator insert(const_reverse_iterator position,
            const value_type& value) {
        return insert(position, value_type(value));
    }
    /**
     @brief Insert a sequence of points
     @param position where new elements are inserted
     @param from, to range of elements to insert
     @return iterator to first of new elements inserted, or @a position
     */
    template <bool REVERSE, typename FORWARD_ITER>
    iterator_base<cll_type, value_type, REVERSE> insert(iterator_base<cll_type, 
            value_type, REVERSE> position, FORWARD_ITER from, FORWARD_ITER to) {
        //implementation begin
        iterator_base<cll_type, value_type, REVERSE> ret(position.m_index, &m_data);
        bool set = false;
        while(from != to) {
            if(!set) {
                ret = insert(position, *from++);
            } else {
                insert(position, *from++);
            }
        }
        return ret;
    }
    ///Loop compatibility insert
    inline cw_iterator insertPointBefore(const value_type& point, 
            const_cw_iterator position) {
        return insert(position, point);
    }
    inline ccw_iterator insertPointBefore(const value_type& point, 
            const_ccw_iterator position) {
        return insert(position, point);
    }
    inline cw_iterator insertPointAfter(const value_type& point, 
            const_cw_iterator position) {
        return insert(++position, point);
    }
    inline ccw_iterator insertPointAfter(const value_type& point, 
            const_ccw_iterator position) {
        return insert(++position, point);
    }
    template <bool REVERSE, typename FORWARD_ITER>
    inline iterator_base<cll_type, value_type, REVERSE> insertPoints(
            iterator_base<cll_type, value_type, 
            REVERSE> position, FORWARD_ITER from, FORWARD_ITER to) {
        return insert(position, from, to);
    }
    /**
     @brief remove element at @a position
     @return iterator to element just forward of position (or end)
     If erasing current position, make current point forward of the element 
     erased.
     */
    iterator erase(const_iterator position);
    /**
     @brief remove element at @a position
     @return iterator to element just reverse-ward of position (or end)
     If erasing current position, make current point reverse-ward of the 
     element erased.
     */
    reverse_iterator erase(const_reverse_iterator position);
    ///@return number of valid elements in the loop
    size_t size() const;
    ///@return true if no valid elements in the loop, false otherwise
    bool empty() const;
    ///@brief Erase all elements from the loop in a memory efficient way.
    void clear();
    ///@brief Exchange content with @a other, invalidating all iterators for both.
    void swap(basic_simple_loop& other);
private:
    /**
     @brief Allocate an index for a new node by either reusing a vacant 
     position or expanding m_data
     @return index to a node ready for writing new data
     */
    size_t allocate_index();
    cll_type m_data;
    vacant_type m_vacant;
    size_t m_current;
};

} /* namespace geomutils */

namespace std {

template <typename LOOP_VALUE_TYPE>
void swap(geomutils::basic_simple_loop<LOOP_VALUE_TYPE>& lhs, 
        geomutils::basic_simple_loop<LOOP_VALUE_TYPE>& rhs);

} /* namespace std */

namespace boost {
namespace serialization {

template <typename Archive, typename LOOP_VALUE_TYPE>
void serialize(Archive& ar, geomutils::basic_simple_loop<LOOP_VALUE_TYPE>& dest,
        const unsigned int);

} /* namespace serialization */
} /* namespace boost */

#endif	// INCLUDE_GEOMUTILS_DATA_STRUCTURES_SIMPLE_LOOP_DECL_H
