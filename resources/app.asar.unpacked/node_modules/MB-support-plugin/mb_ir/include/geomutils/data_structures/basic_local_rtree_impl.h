// Copyright 2012 MakerBot

#ifndef INCLUDE_GEOMUTILS_BASIC_LOCAL_RTREE_IMPL_H_
#define INCLUDE_GEOMUTILS_BASIC_LOCAL_RTREE_IMPL_H_

#include <algorithm>
#include <limits>
#include <utility>

#include "geomutils/data_structures/basic_local_rtree_decl.h"
#include "geomutils/intersection_index.h"

namespace geomutils {
#define BLRT_TEMPLATE template <typename T, size_t DIM, \
  typename BBOX_MAKER, size_t C>
#define BLRT_TYPE basic_local_rtree<T, DIM, BBOX_MAKER, C>

#define CURS_TEMPLATE template <typename FILTER>
#define CURS_TYPE cursor<FILTER>

BLRT_TEMPLATE
BLRT_TYPE::data_element::data_element() : m_index(DEFAULT_CHILD_PTR()) {
}
BLRT_TEMPLATE
BLRT_TYPE::data_element::data_element(const data_element& other)
  : m_value(other.m_value), m_index(other.m_index) {
}
BLRT_TEMPLATE
BLRT_TYPE::data_element::data_element(data_element&& other)
  : m_value(std::move(other.m_value)), m_index(other.m_index) {
}
BLRT_TEMPLATE
BLRT_TYPE::data_element::data_element(const value_type& value, const BBox &bb)
  : m_value(bb, value),
  m_index(DEFAULT_CHILD_PTR()) {
}
BLRT_TEMPLATE
BLRT_TYPE::data_element::data_element(const value_type& value, size_t index,
                                      const BBox &bb)
  : m_value(bb, value),
  m_index(index) {
}
BLRT_TEMPLATE
BLRT_TYPE::data_element::data_element(value_type&& value, const BBox &bb)
  : m_value(bb, std::move(value)),
  m_index(DEFAULT_CHILD_PTR()) {
}
BLRT_TEMPLATE
BLRT_TYPE::data_element::data_element(value_type&& value, size_t index,
                                      const BBox &bb)
  : m_value(bb, std::move(value)),
  m_index(index) {
}
BLRT_TEMPLATE
typename BLRT_TYPE::data_element& BLRT_TYPE::data_element::operator =(
  const data_element& other) {
  if (&other != this) {
    m_value = other.m_value;
    m_index = other.m_index;
  }
  return *this;
}
BLRT_TEMPLATE
typename BLRT_TYPE::data_element& BLRT_TYPE::data_element::operator =(
  data_element&& other) {
  m_value = std::move(other.m_value);
  m_index = other.m_index;
  return *this;
}
BLRT_TEMPLATE
CURS_TEMPLATE
BLRT_TYPE::CURS_TYPE::iterator::iterator() : m_cursor_ptr(nullptr) {}
BLRT_TEMPLATE
CURS_TEMPLATE
BLRT_TYPE::CURS_TYPE::iterator::iterator(cursor* cursor_ptr,
    data_const_iterator data_iter)
    : m_cursor_ptr(cursor_ptr), m_data_iter(data_iter) {}
BLRT_TEMPLATE
CURS_TEMPLATE
void BLRT_TYPE::CURS_TYPE::iterator::increment() {
  m_data_iter = m_cursor_ptr->get_next_data();
}
BLRT_TEMPLATE
CURS_TEMPLATE
bool BLRT_TYPE::CURS_TYPE::iterator::equal(const iterator& other) const {
  return m_cursor_ptr == other.m_cursor_ptr &&
      m_data_iter == other.m_data_iter;
}
BLRT_TEMPLATE
CURS_TEMPLATE
BLRT_TYPE::CURS_TYPE::cursor(const cursor& other)
    : m_parent(other.m_parent), m_filter(other.m_filter) {
  if (!m_parent.empty()) {
    m_work_stack.push(m_parent.m_root);
  }
}
BLRT_TEMPLATE
CURS_TEMPLATE
BLRT_TYPE::CURS_TYPE::cursor(const basic_local_rtree& parent,
    const filter_t& filt)
    : m_parent(parent), m_filter(filt) {
  if (!m_parent.empty()) {
    m_work_stack.push(m_parent.m_root);
  }
}
BLRT_TEMPLATE
CURS_TEMPLATE
typename BLRT_TYPE::data_const_iterator BLRT_TYPE::CURS_TYPE::get_next_data() {
  while (!m_work_stack.empty()) {
    const node& cur_node = m_parent.dereferenceNode(
        m_work_stack.top());
    m_work_stack.pop();
    if (!m_filter.filter(cur_node.bound())) {
      continue;
    } else {
      for (typename node::const_iterator childIter = cur_node.begin();
          childIter != cur_node.end();
          ++childIter) {
        m_work_stack.push(childIter->index());
      }
      if (cur_node.hasData()) {
        return cur_node.dataIter();
      }
    }
  }
  return m_parent.m_data.end();
}
BLRT_TEMPLATE
BLRT_TYPE::basic_local_rtree(const bbox_maker &maker)
  : m_root(DEFAULT_CHILD_PTR()),
  m_bbox_maker(maker) {
}
BLRT_TEMPLATE
BLRT_TYPE::basic_local_rtree(const basic_local_rtree& other)
  : m_root(DEFAULT_CHILD_PTR()),
  m_bbox_maker(other.m_bbox_maker) {
  for (data_const_iterator dataIter = other.m_data.begin();
       dataIter != other.m_data.end();
       ++dataIter) {
    insert(dataIter->second);
  }
}
BLRT_TEMPLATE
BLRT_TYPE::basic_local_rtree(basic_local_rtree&& other)
  : m_root(DEFAULT_CHILD_PTR()) {
  swap(other);
}
BLRT_TEMPLATE
BLRT_TYPE& BLRT_TYPE::operator=(const basic_local_rtree& other) {
  if (&other == this)
    return *this;
  m_root = DEFAULT_CHILD_PTR();
  m_bbox_maker = other.m_bbox_maker;
  m_data.clear();
  m_nodes.clear();
  m_freenodes.clear();
  for (data_const_iterator dataIter = other.m_data.begin();
       dataIter != other.m_data.end();
       ++dataIter) {
    insert(dataIter->second);
  }
  return *this;
}
BLRT_TEMPLATE
BLRT_TYPE& BLRT_TYPE::operator =(basic_local_rtree&& other) {
  swap(other);
  return *this;
}
BLRT_TEMPLATE
typename BLRT_TYPE::iterator BLRT_TYPE::insert(value_type&& value) {
  node& child = acquireNode();
  data_iterator iter = m_data.insert(m_data.end(),
                                     data_element(std::move(value),
                                                  child.index(),
                                                  m_bbox_maker(value)));
  size_t childIndex = child.index();
  if (m_root == DEFAULT_CHILD_PTR())
    m_root = acquireNode().index();
  m_nodes[childIndex].setData(iter);
  insertPrivate(m_root, childIndex, false);
  return iterator(iter);
}
BLRT_TEMPLATE
typename BLRT_TYPE::iterator BLRT_TYPE::insert(const value_type& value) {
  // delegate to rvalue reference version
  return insert(value_type(value));
}
BLRT_TEMPLATE
void BLRT_TYPE::erase(iterator iter) {
  size_t indexToErase = iter.m_base->m_index;
  m_data.erase(iter.m_base);
  erasePrivate(indexToErase);
}
BLRT_TEMPLATE
void BLRT_TYPE::clear() {
  m_data.clear();
  m_nodes.clear();
  m_freenodes.clear();
  m_root = DEFAULT_CHILD_PTR();
}
BLRT_TEMPLATE
template <typename COLLECTION, typename FILTER>
void BLRT_TYPE::search(COLLECTION& result, const FILTER& filt) const {
  if (m_root == DEFAULT_CHILD_PTR())
    return;
  searchPrivate(result, filt, m_root);
}
BLRT_TEMPLATE
void BLRT_TYPE::swap(basic_local_rtree& other) {
  m_data.swap(other.m_data);
  m_nodes.swap(other.m_nodes);
  m_freenodes.swap(other.m_freenodes);
  std::swap(m_root, other.m_root);
  std::swap(m_bbox_maker, other.m_bbox_maker);
  for (typename node_container::iterator iter = m_nodes.begin();
       iter != m_nodes.end();
       ++iter) {
    iter->setParent(this);
  }
}
BLRT_TEMPLATE
void BLRT_TYPE::validate() const {
  if (m_root == DEFAULT_CHILD_PTR())
    return;
  validate(m_root);
}
BLRT_TEMPLATE
void BLRT_TYPE::repr(std::ostream& out) const {
  if (m_root != DEFAULT_CHILD_PTR())
    repr(out, 0, m_root);
}
BLRT_TEMPLATE
void BLRT_TYPE::repr(std::ostream& out, size_t recursionLevel,
                     size_t index) const {
  for (size_t i = 0; i < recursionLevel; ++i) {
    out << '|';
  }
  out << 'N';
  if (m_nodes[index].hasData())
    out << "-L ";
  out << m_nodes[index].index() << '_' << m_nodes[index].height();
  out << '\n';
  for (typename node::const_iterator iter = m_nodes[index].begin();
       iter != m_nodes[index].end();
       ++iter) {
    repr(out, recursionLevel + 1, iter->index());
  }
}
BLRT_TEMPLATE
void BLRT_TYPE::repr_svg(std::ostream& out) const {
  out << "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?>"
      << std::endl;
  out << "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">"
      << std::endl;
  if (m_root != DEFAULT_CHILD_PTR())
    repr_svg(out, 1, m_root);
  out << "</svg>" << std::endl;
}
BLRT_TEMPLATE
void BLRT_TYPE::repr_svg(std::ostream& out, size_t recursionLevel,
                         size_t index) const {
//  static const Scalar SCALE = 10.0;
//  unsigned int rgbcolor = (255 << (recursionLevel*8)) |
//                          (255 >> ((1+recursionLevel)*8));
//  Scalar factor = (-0.5 / SCALE) * recursionLevel;
  const node& curNode = dereferenceNode(index);
  for (typename node::const_iterator iter = curNode.begin();
       iter != curNode.end();
       ++iter) {
    repr_svg(out, recursionLevel + 1, iter->index());
  }
}
BLRT_TEMPLATE
typename BLRT_TYPE::node& BLRT_TYPE::acquireNode() {
  if (!m_freenodes.empty()) {
    node& ret = m_nodes[m_freenodes.back()];
    m_freenodes.pop_back();
    ret.clear();
    return ret;
  } else {
    m_nodes.push_back(node(*this, m_nodes.size()));
    return m_nodes.back();
  }
}
BLRT_TEMPLATE
void BLRT_TYPE::insertPrivate(size_t destination_index, size_t child_index,
                              bool can_reinsert) {
  size_t candidate = m_nodes[destination_index].selectCandidate(
    m_nodes[child_index]);
  if (candidate == destination_index ||
      m_nodes[candidate].height() == m_nodes[child_index].height()) {
    // don't handle the case of splitting a child
    if (m_nodes[destination_index].hasData())
      throw LocalTreeException("Attempted to split leaf node!");
    m_nodes[destination_index].insert(m_nodes[child_index]);
  } else {
    insertPrivate(candidate, child_index, can_reinsert);
    m_nodes[destination_index].readjustBounds(candidate);
  }
  // destination might be full, so split if necessary
  if (m_nodes[destination_index].isFull()) {
    size_t above_index = m_nodes[destination_index].above();
    if (can_reinsert && above_index != DEFAULT_CHILD_PTR()) {
      m_nodes[destination_index].reinsertOutliers(CAPACITY/2);
    } else {
      node& sibling = acquireNode();
      m_nodes[destination_index].shareWith(sibling);
      size_t sibling_index = sibling.index();
      if (above_index == DEFAULT_CHILD_PTR()) {
        // if no parent, add a stage
        node& successor = acquireNode();
        size_t successorIndex = successor.index();
        m_nodes[successorIndex].insert(m_nodes[destination_index]);
        m_nodes[successorIndex].insert(m_nodes[sibling_index]);
        m_root = successorIndex;
      } else {
        m_nodes[above_index].insert(m_nodes[sibling_index]);
      }
    }
  }
}
BLRT_TEMPLATE
template <typename COLLECTION, typename FILTER>
void BLRT_TYPE::searchPrivate(COLLECTION& result, const FILTER& filt,
                              size_t base) const {
  const node& curNode = dereferenceNode(base);
  if (filt.filter(curNode.bound())) {
    if (curNode.hasData())
      result.push_back(curNode.data().second);
    for (typename node::const_iterator childIter = curNode.begin();
         childIter != curNode.end();
         ++childIter) {
      searchPrivate(result, filt, childIter->index());
    }
  }
}
BLRT_TEMPLATE
void BLRT_TYPE::erasePrivate(size_t index) {
  node& victim = m_nodes[index];
  if (victim.hasChildren()) {
    repr(std::cout);
    throw LocalTreeException("Attempted to erase non-empty node");
  }
  size_t above_index = victim.above();
  if (above_index != DEFAULT_CHILD_PTR()) {
    m_nodes[above_index].unlinkChild(index);
    if (!m_nodes[above_index].hasPurpose())
      erasePrivate(above_index);
  }
  victim.clear();
  m_freenodes.push_back(index);
  if (index == m_root)
    m_root = DEFAULT_CHILD_PTR();
}
BLRT_TEMPLATE
void BLRT_TYPE::validate(size_t index) const {
  const node& currentNode = m_nodes[index];
  if (currentNode.index() != index)
    throw LocalTreeException("Node has its index wrong");
  for (typename node::const_iterator iter = currentNode.begin();
       iter != currentNode.end();
       ++iter) {
    if (iter->above() != currentNode.index())
      throw LocalTreeException("Child has its parent wrong");
    validate(iter->index());
  }
}


BLRT_TEMPLATE
BLRT_TYPE::node::node(basic_local_rtree& parent, size_t index)
  : m_parent(&parent), m_index(index),
  m_above(parent.DEFAULT_CHILD_PTR()),
  m_height(DEFAULT_HEIGHT),
  m_data(parent.DEFAULT_DATA_PTR()) {
  clearChildren();
}

BLRT_TEMPLATE
BLRT_TYPE::node::node(basic_local_rtree& parent, size_t index,
                      data_const_iterator data)
  : m_parent(&parent), m_index(index),
  m_above(parent.DEFAULT_CHILD_PTR()),
  m_height(0),
  m_data(data), m_bounds(data->m_value.first) {
  clearChildren();
}

BLRT_TEMPLATE
bool BLRT_TYPE::node::hasData() const {
  return m_data != m_parent->DEFAULT_DATA_PTR();
}

BLRT_TEMPLATE
bool BLRT_TYPE::node::hasChildren() const {
  return m_childrenCount > 0;
}

BLRT_TEMPLATE
bool BLRT_TYPE::node::hasPurpose() const {
  return hasData() || hasChildren();
}

BLRT_TEMPLATE
bool BLRT_TYPE::node::isFull() const {
  return m_childrenCount >= CAPACITY;
}

BLRT_TEMPLATE
const typename BLRT_TYPE::bound_value& BLRT_TYPE::node::data() const {
  return m_data->m_value;
}

BLRT_TEMPLATE
typename BLRT_TYPE::data_iterator BLRT_TYPE::node::dataIter() const {
  return m_data;
}

BLRT_TEMPLATE
const typename BLRT_TYPE::BBox& BLRT_TYPE::node::bound() const {
  return m_bounds;
}

BLRT_TEMPLATE
size_t BLRT_TYPE::node::index() const {
  return m_index;
}

BLRT_TEMPLATE
size_t BLRT_TYPE::node::above() const {
  return m_above;
}

BLRT_TEMPLATE
size_t BLRT_TYPE::node::height() const {
  return m_height;
}

BLRT_TEMPLATE
void BLRT_TYPE::node::setParent(basic_local_rtree* parent) {
  m_parent = parent;
}

BLRT_TEMPLATE
void BLRT_TYPE::node::setData(data_iterator data) {
  m_data = data;
  m_bounds = m_data->m_value.first;
  if (m_height != DEFAULT_HEIGHT)
    throw LocalTreeException("Setting data for non-leaf node");
  m_height = 0;
}

BLRT_TEMPLATE
void BLRT_TYPE::node::adoptFrom(node& surrogate) {
  std::swap(m_data, surrogate.m_data);
  if (hasData()) {
    std::swap(m_bounds, surrogate.m_bounds);
    std::swap(m_height, surrogate.m_height);
  }
  while (surrogate.m_childrenCount > 0) {
    size_t childIndex = surrogate.m_children[--surrogate.m_childrenCount];
    insert(m_parent->dereferenceNode(childIndex));
  }
}

BLRT_TEMPLATE
size_t BLRT_TYPE::node::selectCandidate(node& child) {
  if (!hasChildren())
    // if I am empty, I will adopt the child
    // Shouldn't happen as we clean up empty nodes on erase
    return m_index;
  if (m_parent->dereferenceNode(m_children[0]).hasData())
    // if my child is a leaf, I assume all my children are leaves
    // and we only ever select candidates for leaves
    return m_index;
  // failing the above two, I pick minimum growth
  Scalar minGrowth = std::numeric_limits<Scalar>::max();
  size_t bestCandidate = 0;
  for (size_t i = 0; i < m_childrenCount; ++i) {
    node& current = m_parent->dereferenceNode(m_children[i]);
    Scalar oldP = current.m_bounds.perimeter();
    Scalar newP =
      current.m_bounds.expandedTo(child.m_bounds).perimeter();
    Scalar diff = newP - oldP;
    if (diff < minGrowth) {
      minGrowth = diff;
      bestCandidate = i;
    }
  }
  return m_children[bestCandidate];
}

BLRT_TEMPLATE
void BLRT_TYPE::node::insert(node& child) {
  if (m_childrenCount >= CAPACITY)
    throw LocalTreeException("Overfilled node in insertDirectly");
  m_children[m_childrenCount++] = child.m_index;
  if (child.m_above != DEFAULT_CHILD_PTR())
    throw LocalTreeException("Attempt to reparent child");
  child.m_above = m_index;
  if (m_childrenCount == 1) {
    if (child.m_height == DEFAULT_HEIGHT)
      throw LocalTreeException("Inserting child of uninitialized height");
    m_bounds = child.m_bounds;
    m_height = child.m_height + 1;
  } else {
    if (m_height != child.m_height + 1)
      throw LocalTreeException("Sibling node height mismatch");
    m_bounds.expandTo(child.m_bounds);
  }
}

BLRT_TEMPLATE
void BLRT_TYPE::node::reinsertLeaves() {
  if (hasData()) {
    m_parent->insertPrivate(m_parent->m_root, m_index, false);
  } else {
    node tmpNode = *this;
    for (size_t i = 0; i < tmpNode.m_childrenCount; ++i) {
      tmpNode.m_parent->dereferenceNode(
        tmpNode.m_children[i]).reinsertLeaves();
    }
    tmpNode.m_parent->dereferenceNode(tmpNode.m_index).clear();
    tmpNode.m_parent->m_freenodes.push_back(tmpNode.m_index);
  }
}

BLRT_TEMPLATE
void BLRT_TYPE::node::reinsertOutliers(size_t n) {
  if (n > 0) {
    auto center = m_bounds.center();
    size_t outlierIndex = 0;
    Scalar outlierDistance = std::numeric_limits<Scalar>::min();
    for (size_t i = 0; i < m_childrenCount; ++i) {
      Scalar distance = (m_parent->dereferenceNode(
                           m_children[i]).bound().center() -
                         center).squaredNorm();
      if (distance > outlierDistance) {
        outlierDistance = distance;
        outlierIndex = i;
      }
    }
    size_t outlier = m_children[outlierIndex];
    m_children[outlierIndex] = m_children[--m_childrenCount];
    m_bounds = m_parent->dereferenceNode(m_children[0]).bound();
    for (size_t i = 0; i < m_childrenCount; ++i) {
      m_bounds.expandTo(
        m_parent->dereferenceNode(m_children[i]).m_bounds);
    }
    size_t myIndex = m_index;
    basic_local_rtree* myParent = m_parent;
    myParent->m_nodes[outlier].m_above  = DEFAULT_CHILD_PTR();
    myParent->insertPrivate(m_parent->m_root, outlier, false);
    myParent->dereferenceNode(myIndex).reinsertOutliers(n - 1);
  }
}

BLRT_TEMPLATE
void BLRT_TYPE::node::readjustBounds() {
  if (hasChildren()) {
    m_bounds = m_parent->dereferenceNode(m_children[0]).m_bounds;
    for (iterator iter = begin(); iter != end(); ++iter) {
      m_bounds.expandTo(iter->m_bounds);
    }
  }
  if (m_above != m_parent->DEFAULT_CHILD_PTR()) {
    node& above = m_parent->dereferenceNode(m_above);
    above.readjustBounds();
  }
}

BLRT_TEMPLATE
void BLRT_TYPE::node::readjustBounds(size_t limit_index) {
  m_bounds.expandTo(m_parent->dereferenceNode(limit_index).m_bounds);
}

BLRT_TEMPLATE
void BLRT_TYPE::node::shareWith(node& sibling) {
  typedef std::pair<size_t, size_t> indexPair;

  static const size_t WORST_SIZE = CAPACITY/2;

  indexPair worstPairs[WORST_SIZE];
  size_t worstIndex = 0;


  if (m_childrenCount < CAPACITY)
    throw LocalTreeException("Attempted to split non-full node");
  // group children into pairs that would be worst to have in the same node
  while (m_childrenCount > 1) {
    indexPair worstPair(0, 1);
    Scalar worstPerimeter = std::numeric_limits<Scalar>::min();
    for (size_t i = 0; i < m_childrenCount; ++i) {
      node& inode = m_parent->dereferenceNode(m_children[i]);
      for (size_t j = i + 1; j < m_childrenCount; ++j) {
        node& jnode = m_parent->dereferenceNode(m_children[j]);
        Scalar perimeter =
          inode.bound().expandedTo(jnode.bound()).perimeter();
        if (perimeter > worstPerimeter) {
          worstPerimeter = perimeter;
          worstPair.first = i;
          worstPair.second = j;
        }
      }
    }
    // undo the children's parent link, they go up for adoption
    m_parent->dereferenceNode(m_children[worstPair.first]).m_above =
      DEFAULT_CHILD_PTR();
    m_parent->dereferenceNode(m_children[worstPair.second]).m_above =
      DEFAULT_CHILD_PTR();
    worstPairs[worstIndex++] = indexPair(m_children[worstPair.first],
                                         m_children[worstPair.second]);
    m_children[worstPair.second] = m_children[--m_childrenCount];
    m_children[worstPair.first] = m_children[--m_childrenCount];
  }
  // if capacity is odd, there will be one child left in this node,
  // this is fine, but readjust bounds
  if (m_childrenCount > 0)
    m_bounds = m_parent->dereferenceNode(m_children[0]).m_bounds;
  // distribute pairs such that worst combinations go in opposite nodes
  for (size_t i = 0; i < worstIndex; ++i) {
    Scalar aperim = m_bounds.perimeter();
    Scalar bperim = sibling.m_bounds.perimeter();
    // if we put first in this and second in other, how much growth
    Scalar a1g =
      m_bounds.expandedTo(m_parent->
                          dereferenceNode(worstPairs[i].first).m_bounds).
      perimeter() - aperim;
    Scalar b1g = sibling.m_bounds.expandedTo(
      m_parent->dereferenceNode(
        worstPairs[i].second).m_bounds).perimeter() - bperim;
    // and the converse
    Scalar a2g = m_bounds.expandedTo(
      m_parent->dereferenceNode(
        worstPairs[i].second).m_bounds).perimeter() - aperim;
    Scalar b2g = sibling.m_bounds.expandedTo(
      m_parent->dereferenceNode(
        worstPairs[i].first).m_bounds).perimeter() - bperim;
    Scalar g1 = a1g + b1g;
    Scalar g2 = a2g + b2g;
    // now pick the best arrangement
    if (g1 < g2) {
      insert(m_parent->dereferenceNode(worstPairs[i].first));
      sibling.insert(m_parent->dereferenceNode(worstPairs[i].second));
    } else {
      insert(m_parent->dereferenceNode(worstPairs[i].second));
      sibling.insert(m_parent->dereferenceNode(worstPairs[i].first));
    }
  }
}

BLRT_TEMPLATE
bool BLRT_TYPE::node::unlinkChild(size_t child_index) {
  for (size_t i = 0; i < m_childrenCount; ++i) {
    if (m_children[i] == child_index) {
      m_parent->m_nodes[m_children[i]].m_above = DEFAULT_CHILD_PTR();
      m_children[i] = m_children[--m_childrenCount];
      return true;
    }
  }
  return false;
}

BLRT_TEMPLATE
void BLRT_TYPE::node::clear() {
  clearChildren();
  m_above = m_parent->DEFAULT_CHILD_PTR();
  m_height = DEFAULT_HEIGHT;
  m_data = m_parent->DEFAULT_DATA_PTR();
}

BLRT_TEMPLATE
void BLRT_TYPE::node::clearChildren() {
  for (size_t i = 0; i < CAPACITY; ++i) {
    m_children[i] = m_parent->DEFAULT_CHILD_PTR();
  }
  m_childrenCount = 0;
}

#undef CURS_TYPE
#undef CURS_TEMPLATE

#undef BLRT_TYPE
#undef BLRT_TEMPLATE
}  // namespace geomutils

#endif  // INCLUDE_GEOMUTILS_BASIC_LOCAL_RTREE_IMPL_H_
