 // Copyright 2013 MakerBot Industries

#ifndef INCLUDE_GEOMUTILS_DATA_STRUCTURES_BASIC_INTERVAL_TREE_DECL_H_
#define INCLUDE_GEOMUTILS_DATA_STRUCTURES_BASIC_INTERVAL_TREE_DECL_H_

#include <functional>
#include <utility>
#include <vector>
#include <list>
#include <stack>
#include <boost/iterator/transform_iterator.hpp>
#include <boost/iterator/iterator_adaptor.hpp>
#include <iostream>

namespace geomutils {
/**
 * @brief Class for sorting storing objects by one-dimensional intervals
 * @param KEY_TYPE      a comparison-supporting value. Pairs of these make up 
 *                      intervals
 * @param MAPPED_TYPE   the type of object this tree stores
 * @param COMPARE_TYPE  how to compare keys, defaults to std::less
 * 
 * For implementation, refer to augmented tree at 
 * http://en.wikipedia.org/wiki/Interval_tree
 * Currently, tree is not balanced
 */
template <typename KEY_TYPE,
        typename MAPPED_TYPE,
        typename COMPARE_TYPE = std::less<KEY_TYPE> >
class basic_interval_tree {
public:
    //fundamental types
    typedef KEY_TYPE key_type;
    typedef MAPPED_TYPE mapped_type;
    typedef COMPARE_TYPE compare_type;
    //derived types
    /**
     * @brief Pair representing range of the interval, from low to high, 
     *        as determined by the comparator.
     */
    typedef std::pair<key_type, key_type> interval;
    /**
     * @brief value_type, where interval is key
     */
    typedef std::pair<const interval, mapped_type> value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* pointer;
    typedef ptrdiff_t difference_type;
    //c++11 goodness for easier template typedefs
    /**
     * @brief Private helper function for making iterator types 
     * easier to define. 
     * DO NOT USE OUTSIDE OF CLASS
     */
    template <typename ITER_BASE, typename RETURN_TYPE>
    class value_accessor : public std::unary_function<
            typename ITER_BASE::reference,
    RETURN_TYPE> {
    public:
        RETURN_TYPE operator ()(typename ITER_BASE::reference arg) const {
            return arg.m_data;
        }
    };
//    template <typename ITER_BASE, typename RETURN_TYPE>
//    using iterator_specializer = boost::transform_iterator<
//    value_accessor<ITER_BASE, RETURN_TYPE>, ITER_BASE>;
    template <typename ITER_BASE, typename RETURN_TYPE>
    struct iterator_specializer {
        typedef boost::transform_iterator<value_accessor<
                ITER_BASE, RETURN_TYPE>, ITER_BASE> type;
    };

    //private, not part of public interface
    struct data_item {
        data_item();
        explicit data_item(value_type&& data);
        explicit data_item(const value_type& data);
        data_item(size_t node_index, value_type&& data);
        data_item(const data_item& other);
        data_item(data_item&& other);
        size_t m_node_index;
        value_type m_data;
    private:
        data_item& operator =(const data_item&);
    };
    ///@brief PRIVATE, not for public consumption
    typedef std::list<data_item> p_data_list;
    //do not use p_data_list outside the class

    typedef typename iterator_specializer<typename p_data_list::iterator,
    reference>::type iterator;
    typedef typename iterator_specializer<typename p_data_list::const_iterator,
    const_reference>::type const_iterator;
    typedef typename iterator_specializer<typename p_data_list::reverse_iterator,
    reference>::type reverse_iterator;
    typedef typename iterator_specializer<typename p_data_list::const_reverse_iterator,
    const_reference>::type const_reverse_iterator;
    /**
     * @brief Cursor class for efficient queries into interval tree
     */
    class cursor {
    public:
        friend class basic_interval_tree;
        class cursor_iterator : public boost::iterator_adaptor<
                cursor_iterator, //derived
                const_iterator, //base
                boost::use_default, //value 
                boost::single_pass_traversal_tag> {
        public:
        private:
            friend class boost::iterator_core_access;
            friend class cursor;
            explicit cursor_iterator(cursor* parent, const_iterator iter =
                    const_iterator());
            void increment();

            cursor* m_parent;
        };

        //damn you microsoft, not letting me be explicit
//        cursor() = default;
//        cursor(const cursor&) = default;
//        cursor(cursor&&) = default;
//        cursor& operator =(const cursor& other) = default;
//        cursor& operator =(cursor&&) = default;
        cursor_iterator begin();
        cursor_iterator end();
    private:
        cursor(const basic_interval_tree* container,
                const interval& interval_);
        typedef std::stack<size_t> work_stack_type;

        const_iterator get_data(); //causes an increment, does all work
        bool fails_interval(const interval& interval_) const;

        interval m_interval;
        const basic_interval_tree* m_container;
        work_stack_type m_work_stack;
    };

    ///@brief construct internal comparator
    explicit basic_interval_tree(const compare_type& compare = compare_type());
    /**
     * @brief construct from sequence of inputs
     * @param ITER_ points to objects convertible to value_type
     * @param begin_ range of inputs
     * @param end_ range of inputs
     * @param compare optional comparison object
     */
    template <typename ITER_>
    basic_interval_tree(ITER_ begin_, ITER_ end_,
            const compare_type& compare = compare_type());
    /**
     * @brief copy constructor
     * @param other value to copy
     * This function actually does all the work, and is implicitly 
     * invoked by the other copy/assignments as needed
     */
    basic_interval_tree(const basic_interval_tree& other);
    ///@brief rvalue reference copy constructor
    basic_interval_tree(basic_interval_tree&&);
    ///@brief lvalue assignment
    basic_interval_tree& operator =(const basic_interval_tree& other);
    ///@brief rvalue assignment
    basic_interval_tree& operator =(basic_interval_tree&&);
    iterator begin();
    const_iterator cbegin() const;
    inline const_iterator begin() const { return cbegin(); }
    iterator end();
    const_iterator cend() const;
    inline const_iterator end() const { return cend(); }
    reverse_iterator rbegin();
    const_reverse_iterator crbegin() const;
    inline const_reverse_iterator rbegin() const { return crbegin(); }
    reverse_iterator rend();
    const_reverse_iterator crend() const;
    inline const_reverse_iterator rend() const { return crend(); }
    /**
     * Query the tree for all elements that overlap an input interval
     * @param key interval to search, can be one point if 
     * first and last are same
     * @return cursor object of entries that satisfy conditions
     * Access the output range by using cursor.begin() and cursor.end(), 
     * which point to const value_type&. They are input iterators, so use 
     * only once.
     * OUTPUT IS NOT ORDERED CONSISTENTLY
     */
    cursor find(const interval& key) const;
    /**
     * @brief Inserts an element into the interval tree.
     * @param key Interval occupied by the element
     * @param value Data stored at the element
     * @return iterator to newly inserted element
     */
    iterator insert(interval&& key, mapped_type&& value);
    /**
     * @brief Inserts an element into the interval tree.
     * @param key Interval occupied by the element
     * @param value Data stored at the element
     * @return iterator to newly inserted element
     */
    iterator insert(const interval& key, const mapped_type& value);
    /**
     * @brief Inserts an element into the interval tree
     * @param value interval, mapped_type pair to be inserted
     * @return iterator to newly inserted element
     */
    iterator insert(value_type&& value);
    /**
     * @brief Inserts an element into the interval tree
     * @param value interval, mapped_type pair to be inserted
     * @return iterator to newly inserted element
     */
    iterator insert(const value_type& value);
    /**
     * @brief Insert a sequence of elements
     * @param begin_ iterator to value_type
     * @param end_ iterator to value_type
     */
    template <typename ITER_>
    void insert(ITER_ begin_, ITER_ end_);
    /**
     * @brief Erase an element from the container
     * @param at element to be erased
     * @return iterator to the following element or end
     */
    iterator erase(iterator at);
    /**
     * @brief Erase a range of elements
     * @param begin_ range to erase
     * @param end_ range to erase
     * @return element following the erased range or end
     */
    iterator erase(iterator begin_, iterator end_);
    /**
     * @brief Storage and time efficient way to clear the container.
     */
    void clear();
    /**
     * @brief Get the number of data elements stored in this collection
     * @return number of data elements
     */
    size_t size() const;
    /**
     * @brief test emptiness
     * @return true if empty
     */
    bool empty() const;
    /**
     * @brief Print a nice ascii tree
     * @param out output stream
     * Assumes key_type has a valid output operator
     */
    void repr(std::ostream& out) const;
private:
    static const size_t npos = -1; //not a valid index

    void repr(std::ostream& out, size_t current_index, size_t level) const;

    struct node;
    typedef std::vector<node> p_node_vector;
    typedef std::vector<size_t> p_vacancy_vector;
    struct node {
        /**
         * @brief Default construct a node
         */
        node();
        /**
         * @brief Construct a node that knows where it is
         */
        explicit node(size_t m_index);
        /**
         * @brief construct a valid node
         * @param m_index where in the vector this node is stored
         * @param data a valid iterator to a valid data_item
         */
        node(size_t m_index, typename p_data_list::iterator data);
        /**
         * @brief construct the interval of this node's right sub-tree
         * including itself.
         * @return interval of self, and sub-tree maximum value
         */
        interval sub_tree_interval() const;
        /**
         * Makes child my left child
         * @param child
         * Assumes I have no left child
         * Does not update metadata
         */
        void attach_left(node& child);
        /**
         * Makes child my right child
         * @param child
         * Assumes I have no right child
         * Does not update metadata
         */
        void attach_right(node& child);
        /**
         * Disowns my left child
         * @param child
         * Assumes child is already my left child
         * Does not update metadata
         */
        void detach_left(node& child);
        /**
         * Disowns my right child
         * @param child
         * Assumes child is already my right child
         * Does not update metadata
         */
        void detach_right(node& child);
        size_t m_index;
        size_t m_parent; //for root, npos
        size_t m_left;
        size_t m_right;
        ///@brief size of node's children, NOT including self
        size_t m_size;
        ///@brief height above leaves, NOT including self
        size_t m_height;
        ///@brief records maximal high value of both sub-trees
        key_type m_maximal_high;
        /* stores the value_type pointed at by this node, 
         * and a back-reference to this node.
         */
        typename p_data_list::iterator m_data;
    };
    /**
     * @brief Updates sizes and bounds of nodes recursively
     * @param node_index node to update
     * Invokes this function on both children and 
     * updates self data
     */
    void update_metadata_down(size_t node_index);
    /**
     * @brief Updates sizes and bounds of nodes recursively
     * @param node_index node to update
     * updates self data from children and invokes this function 
     * on parent.
     */
    void update_metadata_up(size_t node_index);
    /**
     * @brief get the right-most node of the tree rooted at @a node_index
     * @param node_index sub-tree to search
     * @return index of right-most descendent or node_index if no right children
     */
    size_t descendent_right(size_t node_index) const;
    /**
     * @brief get the left-most node of the tree rooted at @a node_index
     * @param node_index sub-tree to search
     * @return index of left-most descendent or node_index if no left children
     */
    size_t descendent_left(size_t node_index) const;
    /**
     * @brief rebalance tree rooted at node_index
     * @param node_index root of sub-tree to rebalance
     * Causes this node's left and right sub-trees to be 
     * in balance. Possibly another node will end up in its position, 
     * but parent references will be updated accordingly.
     * Sometimes recursive down, but never recursive up, except for 
     * calls to update_metadata (maybe).
     */
    void rebalance(size_t node_index);
    /**
     * @brief helper function for rebalancing a fully populated node
     * @param node_index
     */
    void rebalance_complete(size_t node_index);
    /**
     * @brief helper function for rebalancing a node with left child
     * @param node_index
     * @param force ignore height comparison and re-arrange tree always
     */
    void rebalance_left(size_t node_index, bool force = false);
    /**
     * @brief helper function for rebalancing a node with right child
     * @param node_index
     * @param force ignore height comparison and re-arrange tree always
     */
    void rebalance_right(size_t node_index, bool force = false);
    /**
     * @brief see that target does not appear in the sub-tree rooted
     * at current
     * @param root_index sub-tree root
     * @param target_index what to search
     */
    bool subtree_contains(size_t root_index, size_t target_index);
    /**
     * @brief Disconnects node and re-balances tree
     * @param node_index which node to unlink
     * Does not erase any user data, only modifies the tree structure
     */
    void unlink_node(size_t node_index);
    /**
     * @brief Disconnects node having both children
     * @param node_index
     */
    void unlink_node_complete(size_t node_index);
    /**
     * @brief Disconnects node having left child
     * @param node_index
     */
    void unlink_node_left(size_t node_index);
    /**
     * @brief Disconnects node having right child
     * @param node_index
     */
    void unlink_node_right(size_t node_index);
    /**
     * @brief Allocates fresh node for use
     * @return index of freshly initialized node
     * Node is created with invalid data.
     */
    size_t allocate_node();
    /**
     * @brief Allocates fresh node for use
     * @param data what this node will store
     * @return index of freshly initialized node
     */
    size_t allocate_node(typename p_data_list::iterator data);
    /**
     * @brief private insertion function
     * @param orphan node to be inserted
     * This function checks root state and either creates a root or 
     * delegates to insert_node(parent, orphan)
     */
    void insert_node(node& orphan);
    /**
     * @brief private insertion function, recursive
     * @param root root of the tree at which to insert orphan
     * @param orphan newly created node to insert
     */
    void insert_node(node& root, node& orphan);
    /**
     * @brief private insertion function, recursive
     * @param root_index index to root
     * @param orphan_index index to orphan
     * Invokes the reference version
     */
    void insert_node(size_t root_index, size_t orphan_index);

    compare_type m_compare;
    size_t m_root_index;
    p_data_list m_data;
    p_node_vector m_nodes;
    p_vacancy_vector m_vacancies;
};

}

#endif // INCLUDE_GEOMUTILS_DATA_STRUCTURES_BASIC_INTERVAL_TREE_DECL_H_
