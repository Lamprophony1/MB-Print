// Copyright 2013 MakerBot Industries

#ifndef INCLUDE_GEOMUTILS_DATA_STRUCURES_BASIC_INTERVAL_TREE_IMPL_H_
#define INCLUDE_GEOMUTILS_DATA_STRUCURES_BASIC_INTERVAL_TREE_IMPL_H_

#include "geomutils/data_structures/basic_interval_tree_decl.h"
#include <algorithm>
#include <utility>
#include <string>
#include <sstream>

#define IT_TEMPLATE template <typename KEY_TYPE, \
        typename MAPPED_TYPE, typename COMPARE_TYPE>
#define IT_TYPE basic_interval_tree<KEY_TYPE, MAPPED_TYPE, COMPARE_TYPE>
#define IT_CURSOR_TYPE IT_TYPE::cursor

namespace geomutils {

/* BEGIN PRIVATE DATA STRUCTURES */
IT_TEMPLATE
IT_TYPE::data_item::data_item()  : m_node_index(npos) {}
IT_TEMPLATE
IT_TYPE::data_item::data_item(value_type&& data)  : m_node_index(npos), 
        m_data(std::move(data)){}
IT_TEMPLATE
IT_TYPE::data_item::data_item(size_t node_index, value_type&& data) 
        : m_node_index(node_index), m_data(std::move(data)) {}
IT_TEMPLATE
IT_TYPE::data_item::data_item(const data_item& other)
        : m_node_index(other.m_node_index), m_data(other.m_data) {}
IT_TEMPLATE
IT_TYPE::data_item::data_item(data_item&& other)
        : m_node_index(other.m_node_index), m_data(std::move(other.m_data)) {}
IT_TEMPLATE
IT_TYPE::node::node() : m_index(npos), m_parent(npos), 
        m_left(npos), m_right(npos), m_size(0), m_height(0){}
IT_TEMPLATE
IT_TYPE::node::node(size_t index) : m_index(index), m_parent(npos), 
        m_left(npos), m_right(npos), m_size(0), m_height(0){}
IT_TEMPLATE
IT_TYPE::node::node(size_t index, typename p_data_list::iterator data) 
        : m_index(index), m_parent(npos), m_left(npos), m_right(npos), 
        m_size(0), m_height(0), 
        m_maximal_high(data->m_data.first.second), m_data(data) {}
IT_TEMPLATE
typename IT_TYPE::interval IT_TYPE::node::sub_tree_interval() const {
    return interval(m_data->m_data.first.first, m_maximal_high);
}
IT_TEMPLATE
void IT_TYPE::node::attach_left(node& child) {
    m_left = child.m_index;
    child.m_parent = m_index;
}
IT_TEMPLATE
void IT_TYPE::node::attach_right(node& child) {
    m_right = child.m_index;
    child.m_parent = m_index;
}
IT_TEMPLATE
void IT_TYPE::node::detach_left(node& child) {
    m_left = npos;
    child.m_parent = npos;
}
IT_TEMPLATE
void IT_TYPE::node::detach_right(node& child) {
    m_right = npos;
    child.m_parent = npos;
}

/* END PRIVATE DATA STRUCTURES */

/* BEGIN PUBLIC DATA STRUCTURES */
IT_TEMPLATE
IT_CURSOR_TYPE::cursor_iterator::cursor_iterator(cursor* parent, 
        const_iterator iter) : cursor_iterator::iterator_adaptor_(iter), 
        m_parent(parent) {}
IT_TEMPLATE
void IT_CURSOR_TYPE::cursor_iterator::increment() {
    cursor_iterator::base_reference() = m_parent->get_data();
}
IT_TEMPLATE
IT_CURSOR_TYPE::cursor(const basic_interval_tree* container, 
        const interval& interval_) : m_interval(interval_), 
        m_container(container) {
    if(m_container->m_root_index != npos) {
        m_work_stack.push(m_container->m_root_index);
    }
}
IT_TEMPLATE
typename IT_CURSOR_TYPE::cursor_iterator IT_CURSOR_TYPE::begin() {
    return cursor_iterator(this, get_data());
}
IT_TEMPLATE
typename IT_CURSOR_TYPE::cursor_iterator IT_CURSOR_TYPE::end() {
    return cursor_iterator(this, m_container->cend());
}
IT_TEMPLATE
typename IT_TYPE::const_iterator IT_CURSOR_TYPE::get_data() {
    if(m_work_stack.empty()) {
        if(m_container->m_root_index != npos) {
            m_work_stack.push(m_container->m_root_index);
        }
        return m_container->cend();
    }
    const compare_type& compare = m_container->m_compare;
    const node& work_node = m_container->m_nodes[m_work_stack.top()];
    m_work_stack.pop();
    work_stack_type& gcc472bugworkaround = m_work_stack;
    auto optionally_push = [&gcc472bugworkaround](size_t arg)->void {
        if(arg != npos) {
            gcc472bugworkaround.push(arg);
        }
    };
    
    interval work_interval = work_node.sub_tree_interval();
    if(compare(work_interval.second, m_interval.first)) {
        //we are entirely to the left, can avoid adding all children
    } else if(compare(m_interval.second, work_interval.first)){
        //we are to the right, we can avoid adding the right sub-tree
        optionally_push(work_node.m_left);
    } else {
        //we must push both children
        optionally_push(work_node.m_left);
        optionally_push(work_node.m_right);
    }
    interval data_interval = work_node.m_data->m_data.first;
    if(!fails_interval(data_interval)) {
        return const_iterator(work_node.m_data);
    } else {
        return get_data();
    }
}
IT_TEMPLATE
bool IT_CURSOR_TYPE::fails_interval(const interval& interval_) const {
    const compare_type& compare = m_container->m_compare;
    return compare(m_interval.second, interval_.first) || 
            compare(interval_.second, m_interval.first);
}
/* END PUBLIC DATA STRUCTURES */

IT_TEMPLATE
IT_TYPE::basic_interval_tree(const compare_type& compare) 
        : m_compare(compare), m_root_index(npos) {}
IT_TEMPLATE
template <typename ITER_>
IT_TYPE::basic_interval_tree(ITER_ begin_, ITER_ end_, 
        const COMPARE_TYPE& compare)
        : m_compare(compare), m_root_index(npos) {
    insert(begin_, end_);
}
IT_TEMPLATE
IT_TYPE::basic_interval_tree(const basic_interval_tree& other)
        : m_compare(other.m_compare), m_root_index(npos) {
    insert(other.cbegin(), other.cend());
}
IT_TEMPLATE
IT_TYPE::basic_interval_tree(basic_interval_tree&& other)
        : m_compare(std::move(other.m_compare)), 
        m_root_index(std::move(other.m_root_index)), 
        m_data(std::move(other.m_data)), 
        m_nodes(std::move(other.m_nodes)), 
        m_vacancies(std::move(other.m_vacancies)) {}
IT_TEMPLATE
IT_TYPE& IT_TYPE::operator =(const basic_interval_tree& other) {
    if(this != &other) {
        clear();
        //forward to rvalue version
        *this = basic_interval_tree(other);
    }
    return *this;
}
IT_TEMPLATE
IT_TYPE& IT_TYPE::operator =(basic_interval_tree&& other) {
    m_compare = std::move(other.m_compare);
    m_root_index = std::move(other.m_root_index);
    m_data = std::move(other.m_data);
    m_nodes = std::move(other.m_nodes);
    m_vacancies = std::move(other.m_vacancies);
    return *this;
}
IT_TEMPLATE
typename IT_TYPE::iterator IT_TYPE::begin() {
    return static_cast<iterator>(m_data.begin());
}
IT_TEMPLATE
typename IT_TYPE::iterator IT_TYPE::end() {
    return static_cast<iterator>(m_data.end());
}
IT_TEMPLATE
typename IT_TYPE::const_iterator IT_TYPE::cbegin() const {
    return static_cast<const_iterator>(m_data.cbegin());
}
IT_TEMPLATE
typename IT_TYPE::const_iterator IT_TYPE::cend() const {
    return static_cast<const_iterator>(m_data.cend());
}
IT_TEMPLATE
typename IT_TYPE::reverse_iterator IT_TYPE::rbegin() {
    return static_cast<reverse_iterator>(m_data.rbegin());
}
IT_TEMPLATE
typename IT_TYPE::reverse_iterator IT_TYPE::rend() {
    return static_cast<reverse_iterator>(m_data.rend());
}
IT_TEMPLATE
typename IT_TYPE::const_reverse_iterator IT_TYPE::crbegin() const {
    return static_cast<const_reverse_iterator>(m_data.crbegin());
}
IT_TEMPLATE
typename IT_TYPE::const_reverse_iterator IT_TYPE::crend() const {
    return static_cast<const_reverse_iterator>(m_data.crend());
}
IT_TEMPLATE
typename IT_TYPE::cursor IT_TYPE::find(const interval& key) const {
    return cursor(this, key);
}
IT_TEMPLATE
typename IT_TYPE::iterator IT_TYPE::insert(interval&& key, 
        mapped_type&& value) {
    return insert(value_type(std::move(key), std::move(value)));
}
IT_TEMPLATE
typename IT_TYPE::iterator IT_TYPE::insert(value_type&& value) {
    iterator ret(m_data.insert(m_data.end(), 
            data_item(std::move(value))));
    size_t orphan_index = allocate_node(ret.base());
    node& orphan = m_nodes[orphan_index];
    insert_node(orphan);
    return ret;
}
IT_TEMPLATE
typename IT_TYPE::iterator IT_TYPE::insert(const interval& key, 
        const mapped_type& value) {
    //forward a temp copy to the r-value reference implementation
    return insert(value_type(key, value));
}
IT_TEMPLATE
typename IT_TYPE::iterator IT_TYPE::insert(const value_type& value) {
    //forward a temp copy to the r-value reference implementation
    return insert(value_type(value));
}
IT_TEMPLATE
template <typename ITER_>
void IT_TYPE::insert(ITER_ begin_, ITER_ end_) {
    //this version gives sensible errors
    while(begin_ != end_) {
        insert(*begin_);
        ++begin_;
    }
    //this version gives incomprehensible errors.
//    std::for_each(begin_, end_, 
//            [this](typename ITER_::reference arg){insert(arg);});
}
IT_TEMPLATE
typename IT_TYPE::iterator IT_TYPE::erase(iterator at) {
    data_item& to_erase = *at.base();
    unlink_node(to_erase.m_node_index);
    return iterator(m_data.erase(at.base()));
}
IT_TEMPLATE
typename IT_TYPE::iterator IT_TYPE::erase(iterator begin_, iterator end_) {
    while(begin_ != end_) {
        begin_ = erase(begin_);
    }
    return begin_;
}
IT_TEMPLATE
void IT_TYPE::clear() {
    m_root_index = npos;
    m_data.clear();
    m_nodes.clear();
    m_vacancies.clear();
}
IT_TEMPLATE
size_t IT_TYPE::size() const {
    return m_data.size();
}
IT_TEMPLATE
bool IT_TYPE::empty() const {
    return m_data.empty();
}
IT_TEMPLATE
void IT_TYPE::repr(std::ostream& out) const {
    if(m_root_index != npos)
        repr(out, m_root_index, 0);
}
IT_TEMPLATE
void IT_TYPE::repr(std::ostream& out, size_t current_index, 
        size_t level) const {
    if(current_index == npos) {
        out << std::string(level, '|') << std::endl;
        return;; 
    }
    const node& current_node = m_nodes[current_index];
    out << std::string(level, '|') << current_node.m_index << " "; 
    out << "s" << current_node.m_size << "h" << 
            current_node.m_height << " ";
    out << current_node.m_data->m_data.first.first << ':' << 
            current_node.m_data->m_data.first.second << '_' << 
            current_node.m_maximal_high << std::endl;
    if(current_node.m_left != npos || current_node.m_right != npos) {
        repr(out, current_node.m_left, level + 1);
        repr(out, current_node.m_right, level + 1);
    }
}
IT_TEMPLATE
void IT_TYPE::update_metadata_down(size_t node_index) {
    node& n = m_nodes[node_index];
    n.m_size = 0;
    n.m_height = 0;
    n.m_maximal_high = n.m_data->m_data.first.second;
    auto update_from_child = [this, &n](node& child)->void {
        update_metadata_down(child.m_index);
        n.m_size += 1 + child.m_size;
        n.m_height = std::max(n.m_height, 1 + child.m_height);
        if(m_compare(n.m_maximal_high, child.m_maximal_high)) {
            n.m_maximal_high = child.m_maximal_high;
        }
    };
    if(n.m_left != npos) {
        update_from_child(m_nodes[n.m_left]);
    }
    if(n.m_right != npos) {
        update_from_child(m_nodes[n.m_right]);
    }
}
IT_TEMPLATE
void IT_TYPE::update_metadata_up(size_t node_index) {
    node& n = m_nodes[node_index];
    n.m_size = 0;
    n.m_height = 0;
    n.m_maximal_high = n.m_data->m_data.first.second;
    auto update_from_child = [this, &n](node& child)->void {
        n.m_size += 1 + child.m_size;
        n.m_height = std::max(n.m_height, 1 + child.m_height);
        if(m_compare(n.m_maximal_high, child.m_maximal_high)) {
            n.m_maximal_high = child.m_maximal_high;
        }
    };
    if(n.m_left != npos) {
        update_from_child(m_nodes[n.m_left]);
    }
    if(n.m_right != npos) {
        update_from_child(m_nodes[n.m_right]);
    }
    if(n.m_parent != npos) {
        update_metadata_up(n.m_parent);
    }
}
IT_TEMPLATE
size_t IT_TYPE::descendent_right(size_t node_index) const {
    const node& current_node = m_nodes[node_index];
    if(current_node.m_right == npos) {
        return current_node.m_index;
    } else {
        return descendent_right(current_node.m_right);
    }
}
IT_TEMPLATE
size_t IT_TYPE::descendent_left(size_t node_index) const {
    const node& current_node = m_nodes[node_index];
    if(current_node.m_left == npos) {
        return current_node.m_index;
    } else {
        return descendent_right(current_node.m_left);
    }
}
IT_TEMPLATE
void IT_TYPE::rebalance(size_t node_index) {
    node& root = m_nodes[node_index];
    if(root.m_left != npos && root.m_right != npos) {
        rebalance_complete(node_index);
    } else if(root.m_left != npos && root.m_right == npos) {
        rebalance_left(node_index);
    } else if(root.m_left == npos && root.m_right != npos) {
        rebalance_right(node_index);
    }
    //if it has no children, nothing to rebalance
}
IT_TEMPLATE
void IT_TYPE::rebalance_complete(size_t node_index) {
    node& root = m_nodes[node_index];
    node& left = m_nodes[root.m_left];
    node& right = m_nodes[root.m_right];
    if(left.m_height > right.m_height + 1) {
        //rotate right
        if(left.m_right != npos)
            rebalance_right(left.m_index, true);
        rebalance_left(node_index, true);
    } else if (right.m_height > left.m_height + 1) {
        //rotate left
        if(right.m_left != npos)
            rebalance_left(right.m_index, true);
        rebalance_right(node_index, true);
    }
    //no rotation needed
}
IT_TEMPLATE
void IT_TYPE::rebalance_left(size_t node_index, bool force) {
    //I have a left child, but no right child
    node& root = m_nodes[node_index];
    node& left = m_nodes[root.m_left];
    size_t parent_index = root.m_parent;
    auto update_parent = [parent_index, &root, this](node& root_new)->void{
        if(parent_index != npos) {
            node& parent = m_nodes[parent_index];
            if(parent.m_left == root.m_index) {
                parent.attach_left(root_new);
            } else {
                parent.attach_right(root_new);
            }
        } else {
            root_new.m_parent = npos;
            m_root_index = root_new.m_index;
        }
    };
    if(left.m_height > 0 || force) {
        if(left.m_right != npos) {
            //we have a left-right case
            node& left_right = m_nodes[left.m_right];
            root.attach_left(left_right);
            left.attach_right(root);
        } else {
            root.m_left = npos;
        }
        left.attach_right(root);
        update_parent(left);
        //rebalance(left.m_index);
        update_metadata_up(root.m_index);
    }
}
IT_TEMPLATE
void IT_TYPE::rebalance_right(size_t node_index, bool force) {
    //i have a right child, but no left child
    node& root = m_nodes[node_index];
    node& right = m_nodes[root.m_right];
    size_t parent_index = root.m_parent;
    auto update_parent = [parent_index, &root, this](node& root_new)->void{
        if(parent_index != npos) {
            node& parent = m_nodes[parent_index];
            if(parent.m_left == root.m_index) {
                parent.attach_left(root_new);
            } else {
                parent.attach_right(root_new);
            }
        } else {
            root_new.m_parent = npos;
            m_root_index = root_new.m_index;
        }
    };
    if(right.m_height > 0 || force) {
        if(right.m_left != npos) {
            //we have a right-left case
            node& right_left = m_nodes[right.m_left];
            root.attach_right(right_left);
            right.attach_left(root);
        } else {
            root.m_right = npos;
        }
        right.attach_left(root);
        update_parent(right);
        //rebalance(right.m_index);
        update_metadata_up(root.m_index);
    }
}
IT_TEMPLATE
bool IT_TYPE::subtree_contains(size_t root_index, size_t target_index) {
    if(root_index == npos)
        return false;
    if(root_index == target_index)
        return true;
    node& root = m_nodes[root_index];
    return subtree_contains(root.m_left, target_index) || 
            subtree_contains(root.m_right, target_index);
}
IT_TEMPLATE
void IT_TYPE::unlink_node(size_t node_index) {
    node& orphan = m_nodes[node_index];
    if(orphan.m_left != npos && orphan.m_right != npos) {
        unlink_node_complete(orphan.m_index);
    } else if(orphan.m_left != npos && orphan.m_right == npos) {
        unlink_node_left(orphan.m_index);
    } else if(orphan.m_left == npos && orphan.m_right != npos) {
        unlink_node_right(orphan.m_index);
    } else {
        //I have no family, so I die
        if(orphan.m_parent != npos) {
            node& parent = m_nodes[orphan.m_parent];
            if(parent.m_left == orphan.m_index) {
                parent.m_left = npos;
            } else {
                parent.m_right = npos;
            }
            rebalance(parent.m_index);
        } else {
            m_root_index = npos;
        }
        m_vacancies.push_back(node_index);
    }
}
IT_TEMPLATE
void IT_TYPE::unlink_node_complete(size_t node_index) {
    //I have both both children, and I must cannibalize some grandchildren
    //instead of myself
    node& root = m_nodes[node_index];
    node& left = m_nodes[root.m_left];
    node& right = m_nodes[root.m_right];
    size_t sacrifice_index = npos;
    if(left.m_height > right.m_height) {
        sacrifice_index = descendent_right(left.m_index);
    } else {
        sacrifice_index = descendent_left(right.m_index);
    }
    node& sacrifice = m_nodes[sacrifice_index];
    //I offer this sacrifice so that I may be spared
    root.m_data = sacrifice.m_data;
    root.m_data->m_node_index = root.m_index;
    unlink_node(sacrifice.m_index);
}
IT_TEMPLATE
void IT_TYPE::unlink_node_left(size_t node_index) {
    //i have a left child, but not right
    //so i will steal his stuff and kill him instead
    node& root = m_nodes[node_index];
    node& left = m_nodes[root.m_left];
    root.m_data = left.m_data;
    root.m_data->m_node_index = root.m_index;
    unlink_node(left.m_index);
}
IT_TEMPLATE
void IT_TYPE::unlink_node_right(size_t node_index) {
    //i have a right child, but not left
    //so i will steal his stuff and kill him instead
    node& root = m_nodes[node_index];
    node& right = m_nodes[root.m_right];
    root.m_data = right.m_data;
    root.m_data->m_node_index = root.m_index;
    unlink_node(right.m_index);
}
IT_TEMPLATE
size_t IT_TYPE::allocate_node() {
    return allocate_node(m_data.end());
}
IT_TEMPLATE
size_t IT_TYPE::allocate_node(typename p_data_list::iterator data) {
    size_t ret = npos;
    if(!m_vacancies.empty()) {
        ret = m_vacancies.back();
        m_nodes[ret] = node(ret, data);
        m_vacancies.pop_back();
    } else {
        ret = m_nodes.size();
        m_nodes.push_back(node(ret, data));
    }
    data->m_node_index = ret;
    return ret;
}
IT_TEMPLATE
void IT_TYPE::insert_node(node& orphan) {
    if(m_root_index == npos) {
        m_root_index = orphan.m_index;
        rebalance(m_root_index);
    } else {
        insert_node(m_nodes[m_root_index], orphan);
    }
}
IT_TEMPLATE
void IT_TYPE::insert_node(node& root, node& orphan) {
    //compares the lower ends of the intervals
    bool compare_result = m_compare(root.m_data->m_data.first.first, 
            orphan.m_data->m_data.first.first);
    size_t& destination = compare_result ? root.m_right : root.m_left;
    if(destination == npos) {
        //we have reached the end of the branch, place here
        destination = orphan.m_index;
        orphan.m_parent = root.m_index;
        //make the list order consistent
        typename p_data_list::iterator parent_iter = root.m_data;
        if(compare_result) {
            ++parent_iter;
        }
        m_data.splice(parent_iter, m_data, orphan.m_data);
        //update the branch back toward the root
        update_metadata_up(orphan.m_index);
    } else {
        //the branch continues, recurse
        insert_node(m_nodes[destination], orphan);
    }
    
    rebalance(root.m_index);
    
}
IT_TEMPLATE
void IT_TYPE::insert_node(size_t root_index, size_t orphan_index) {
    insert_node(m_nodes[root_index], m_nodes[orphan_index]);
}

}

#undef IT_CURSOR_TYPE
#undef IT_TYPE
#undef IT_TEMPLATE

#endif  // INCLUDE_GEOMUTILS_DATA_STRUCURES_BASIC_INTERVAL_TREE_IMPL_H_
