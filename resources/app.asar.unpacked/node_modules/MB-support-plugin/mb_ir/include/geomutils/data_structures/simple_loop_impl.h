// Copyright 2013 MakerBot Industries

#ifndef INCLUDE_GEOMUTILS_DATA_STRUCURES_SIMPLE_LOOP_IMPL_H
#define	INCLUDE_GEOMUTILS_DATA_STRUCURES_SIMPLE_LOOP_IMPL_H

#include "geomutils/data_structures/simple_loop_decl.h"
#include "geomutils/Vector2.h"

namespace geomutils {

#define LOOP_TEMPLATE template <typename LOOP_VALUE_TYPE, typename ALLOC_T>
#define LOOP_TYPE basic_simple_loop<LOOP_VALUE_TYPE, ALLOC_T>

#define ITER_TEMPLATE LOOP_TEMPLATE \
        template <typename STORE_TYPE, \
        typename VALUE_TYPE, bool REVERSE>
#define ITER_TYPE LOOP_TYPE::iterator_base<STORE_TYPE, \
        VALUE_TYPE, REVERSE>

#define CLAMPED_ITER_TEMPLATE LOOP_TEMPLATE \
        template <typename STORE_TYPE, \
        typename VALUE_TYPE, bool REVERSE, bool CLOSED>
#define CLAMPED_ITER_TYPE LOOP_TYPE::clamp_iterator_base<STORE_TYPE, \
        VALUE_TYPE, REVERSE, CLOSED>

ITER_TEMPLATE
ITER_TYPE::iterator_base() : m_index(npos), m_datastore(NULL) {}
ITER_TEMPLATE
ITER_TYPE::iterator_base(STORE_TYPE* datastore) 
        : m_index(npos), m_datastore(datastore) {}
ITER_TEMPLATE
ITER_TYPE::iterator_base(size_t index, STORE_TYPE* datastore)
        : m_index(index), m_datastore(datastore) {}
ITER_TEMPLATE
ITER_TYPE::iterator_base(const iterator_base& other)
        : m_index(other.m_index), m_datastore(other.m_datastore) {}
ITER_TEMPLATE
VALUE_TYPE& ITER_TYPE::dereference() const {
    return (*m_datastore)[m_index].m_data;
}
ITER_TEMPLATE
void ITER_TYPE::increment() {
    if(REVERSE) {
        m_index = (*m_datastore)[m_index].m_prev;
    } else {
        m_index = (*m_datastore)[m_index].m_next;
    }
}
ITER_TEMPLATE
void ITER_TYPE::decrement() {
    if(REVERSE) {
        m_index = (*m_datastore)[m_index].m_next;
    } else {
        m_index = (*m_datastore)[m_index].m_prev;
    }
}
ITER_TEMPLATE
bool ITER_TYPE::equal(const iterator_base& other) const {
    return m_index == other.m_index;
}
CLAMPED_ITER_TEMPLATE
CLAMPED_ITER_TYPE::clamp_iterator_base() : m_dirty(false) {}
CLAMPED_ITER_TEMPLATE
CLAMPED_ITER_TYPE::clamp_iterator_base(size_t index, 
        STORE_TYPE* datastore)
        : clamp_iterator_base::iterator_adaptor_(base_type(index, datastore)), 
        m_initial(index, datastore), m_dirty(false) {}
CLAMPED_ITER_TEMPLATE
CLAMPED_ITER_TYPE::clamp_iterator_base(const base_type& initial) 
        : clamp_iterator_base::iterator_adaptor_(initial), 
        m_initial(initial), m_dirty(false) {}
CLAMPED_ITER_TEMPLATE
CLAMPED_ITER_TYPE::clamp_iterator_base(const base_type& initial, 
        const base_type& current)
        : clamp_iterator_base::iterator_adaptor_(current), 
        m_initial(initial), m_dirty(false) {}
CLAMPED_ITER_TEMPLATE
void CLAMPED_ITER_TYPE::increment() {
    if(CLOSED && m_dirty) { //for non closed iterator, compiler drops this out
        this->base_reference() = base_type();
    } else {
        ++this->base_reference();
        if(this->base_reference() == m_initial) {
            if(CLOSED)
                m_dirty = true;
            else
                this->base_reference() = base_type();
        }
    }
}
CLAMPED_ITER_TEMPLATE
void CLAMPED_ITER_TYPE::decrement() {
    if(CLOSED && m_dirty) { //for non closed iterator, compiler drops this out
        this->base_reference() = base_type();
    } else {
        --this->base_reference();
        if(this->base_reference() == m_initial) {
            if(CLOSED)
                m_dirty = true;
            else
                this->base_reference() = base_type();
        }
    }
}
LOOP_TEMPLATE
LOOP_TYPE::basic_simple_loop() : m_current(npos) {}
LOOP_TEMPLATE
LOOP_TYPE::basic_simple_loop(const LOOP_TYPE& other) : m_current(npos) {
    m_data.reserve(other.size());
    for(const_clamped_iterator it = other.cbegin(); 
            it != other.cend(); 
            ++it) {
        insert(end(), *it);
    }
}
LOOP_TEMPLATE
LOOP_TYPE::basic_simple_loop(LOOP_TYPE&& other) 
        : m_data(std::move(other.m_data)), m_vacant(std::move(other.m_vacant)), 
        m_current(other.m_current) {
    other.m_data.clear();
    other.m_vacant.clear();
    other.m_current = npos;
}
LOOP_TEMPLATE
LOOP_TYPE& LOOP_TYPE::operator =(const LOOP_TYPE& other) {
    if(this != &other) {
        LOOP_TYPE tmp(other);
        swap(tmp);
    }
    return *this = basic_simple_loop(other);
}
LOOP_TEMPLATE
LOOP_TYPE& LOOP_TYPE::operator =(LOOP_TYPE&& other) {
    swap(other);
    return *this;
}
LOOP_TEMPLATE
typename LOOP_TYPE::iterator LOOP_TYPE::begin() {
    return iterator(m_current, &m_data);
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_iterator LOOP_TYPE::begin() const {
    return const_iterator(m_current, &m_data);
}
LOOP_TEMPLATE
typename LOOP_TYPE::iterator LOOP_TYPE::end() {
    return iterator(&m_data);
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_iterator LOOP_TYPE::end() const {
    return const_iterator(&m_data);
}
LOOP_TEMPLATE
typename LOOP_TYPE::reverse_iterator LOOP_TYPE::rbegin() {
    return reverse_iterator(m_current, &m_data);
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_reverse_iterator LOOP_TYPE::rbegin() const {
    return const_reverse_iterator(m_current, &m_data);
}
LOOP_TEMPLATE
typename LOOP_TYPE::reverse_iterator LOOP_TYPE::rend() {
    return reverse_iterator(&m_data);
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_reverse_iterator LOOP_TYPE::rend() const {
    return const_reverse_iterator(&m_data);
}
LOOP_TEMPLATE
typename LOOP_TYPE::clamped_traverser LOOP_TYPE::get_clamped_traverser() {
    return clamped_traverser(begin(), end());
}
LOOP_TEMPLATE
typename LOOP_TYPE::clamped_traverser LOOP_TYPE::get_clamped_traverser(
        const_iterator from) {
    return clamped_traverser(iterator(from.m_index, &m_data), end());
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_clamped_traverser LOOP_TYPE::get_clamped_traverser() const {
    return const_clamped_traverser(cbegin(), cend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_clamped_traverser LOOP_TYPE::get_clamped_traverser(
        const_iterator from) const {
    return const_clamped_traverser(const_iterator(from.m_index, &m_data), cend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::reverse_clamped_traverser LOOP_TYPE::get_reverse_clamped_traverser() {
    return clamped_traverser(rbegin(), rend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::reverse_clamped_traverser LOOP_TYPE::get_reverse_clamped_traverser(
        const_reverse_iterator from) {
    return clamped_traverser(reverse_iterator(from.m_index, &m_data), rend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_reverse_clamped_traverser LOOP_TYPE::get_reverse_clamped_traverser() const {
    return clamped_traverser(crbegin(), crend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_reverse_clamped_traverser LOOP_TYPE::get_reverse_clamped_traverser(
        const_reverse_iterator from) const {
    return clamped_traverser(const_reverse_iterator(from.m_index, &m_data), 
            crend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::closed_traverser LOOP_TYPE::get_closed_traverser() {
    return closed_traverser(begin(), end());
}
LOOP_TEMPLATE
typename LOOP_TYPE::closed_traverser LOOP_TYPE::get_closed_traverser(
        const_iterator from) {
    return closed_traverser(iterator(from.m_index, &m_data), end());
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_closed_traverser LOOP_TYPE::get_closed_traverser() const {
    return closed_traverser(cbegin(), cend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_closed_traverser LOOP_TYPE::get_closed_traverser(
        const_iterator from) const {
    return closed_traverser(const_iterator(from.m_index, &m_data), cend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::reverse_closed_traverser LOOP_TYPE::get_reverse_closed_traverser() {
    return closed_traverser(rbegin(), rend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::reverse_closed_traverser LOOP_TYPE::get_reverse_closed_traverser(
        const_reverse_iterator from) {
    return closed_traverser(reverse_iterator(from.m_index, &m_data), rend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_reverse_closed_traverser LOOP_TYPE::get_reverse_closed_traverser() const {
    return closed_traverser(crbegin(), crend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::const_reverse_closed_traverser LOOP_TYPE::get_reverse_closed_traverser(
        const_reverse_iterator from) const {
    return closed_traverser(const_reverse_iterator(from.m_index, &m_data), 
            crend());
}
LOOP_TEMPLATE
typename LOOP_TYPE::iterator LOOP_TYPE::insert(const_iterator position, 
        value_type&& value) {
    size_t c, p, n;
    if(position == end()) {
        if(empty()) {
            c = allocate_index();
            m_current = c;
            m_data[c] = list_node(c, c, value);
            return iterator(c, &m_data);
        } else {
            c = allocate_index();
            p = m_data[m_current].m_prev;
            n = m_current;
        }
    } else {
        c = allocate_index();
        p = m_data[position.m_index].m_prev;
        n = position.m_index;
    }
    m_data[p].m_next = c;
    m_data[n].m_prev = c;
    m_data[c] = list_node(p, n, value);
    return iterator(c, &m_data);
}
LOOP_TEMPLATE
typename LOOP_TYPE::reverse_iterator LOOP_TYPE::insert(
        const_reverse_iterator position, value_type&& value) {
    size_t c, p, n;
    if(position == rend()) {
        if(empty()) {
            c = allocate_index();
            m_current = c;
            m_data[c] = list_node(c, c, value);
            return reverse_iterator(c, &m_data);
        } else {
            c = allocate_index();
            p = m_current;
            n = m_data[m_current].m_next;
        }
    } else {
        c = allocate_index();
        p = position.m_index;
        n = m_data[position.m_index].m_next;
    }
    m_data[p].m_next = c;
    m_data[n].m_prev = c;
    m_data[c] = list_node(p, n, value);
    return reverse_iterator(c, &m_data);
}
LOOP_TEMPLATE
typename LOOP_TYPE::iterator LOOP_TYPE::erase(const_iterator position) {
    iterator next(position.m_index, &m_data);
    iterator prev(position.m_index, &m_data);
    ++next;
    --prev;
    size_t victim = position.m_index;
    size_t successor = next.m_index;
    size_t predecessor = prev.m_index;
    m_vacant.push_back(victim);
    if(position == next) {
        //empty loop
        m_current = npos;
        return iterator(npos, &m_data);
    } else {
        m_data[predecessor].m_next = successor;
        m_data[successor].m_prev = predecessor;
        if(m_current == victim)
            m_current = successor;
        return next;
    }
}
LOOP_TEMPLATE
typename LOOP_TYPE::reverse_iterator LOOP_TYPE::erase(
        const_reverse_iterator position) {
    reverse_iterator next(position.m_index, &m_data);
    reverse_iterator prev(position.m_index, &m_data);
    ++next;
    --prev;
    size_t victim = position.m_index;
    size_t successor = next.m_index;
    size_t predecessor = prev.m_index;
    m_vacant.push_back(victim);
    if(position == next) {
        //empty loop
        m_current = npos;
        return reverse_iterator(npos, &m_data);
    } else {
        m_data[predecessor].m_prev = successor;
        m_data[successor].m_next = predecessor;
        if(m_current == victim)
            m_current = successor;
        return next;
    }
}
LOOP_TEMPLATE
size_t LOOP_TYPE::size() const {
    return m_data.size() - m_vacant.size();
}
LOOP_TEMPLATE
bool LOOP_TYPE::empty() const {
    return size() == 0;
}
LOOP_TEMPLATE
void LOOP_TYPE::clear() {
    m_data.clear();
    m_vacant.clear();
}
LOOP_TEMPLATE
void LOOP_TYPE::swap(LOOP_TYPE& other) {
    std::swap(m_current, other.m_current);
    m_data.swap(other.m_data);
    m_vacant.swap(other.m_vacant);
}
LOOP_TEMPLATE
size_t LOOP_TYPE::allocate_index() {
    size_t ret = m_data.size();
    if(m_vacant.empty()) {
        m_data.push_back(list_node());
    } else {
        ret = m_vacant.back();
        m_vacant.pop_back();
    }
    return ret;
}

} /* namespace geomutils */

namespace std {

LOOP_TEMPLATE
void swap(geomutils::LOOP_TYPE& lhs, geomutils::LOOP_TYPE& rhs) {
    lhs.swap(rhs);
}

} /* namespace std */

namespace boost {
namespace serialization {

template <typename Archive, typename LOOP_VALUE_TYPE>
void serialize(Archive& ar, geomutils::basic_simple_loop<LOOP_VALUE_TYPE>& dest,
        const unsigned int) {
    if (typename Archive::is_loading()) {
        dest.clear();
        size_t count;
        ar & count;
        for (; count > 0; --count) {
            geomutils::Vector2 pt;
            ar & pt;
            dest.insert(dest.end(), pt);
        }
    } else {
        size_t count = dest.size();
        ar & count;
        for (geomutils::Vector2& pt : dest.get_clamped_traverser()) {
            ar & pt;
        }
    }
}

} /* namespace serialization */
} /* namespace boost */

#undef CLAMPED_ITER_TYPE
#undef CLAMPED_ITER_TEMPLATE

#undef ITER_TYPE
#undef ITER_TEMPLATE

#undef LOOP_TYPE
#undef LOOP_TEMPLATE

#endif	// INCLUDE_GEOMUTILS_DATA_STRUCURES_SIMPLE_LOOP_IMPL_H
