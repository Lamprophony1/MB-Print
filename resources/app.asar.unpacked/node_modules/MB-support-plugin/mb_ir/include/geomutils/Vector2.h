// Copyright 2014 MakerBot

#ifndef INCLUDE_GEOMUTILS_VECTOR2_H_
#define INCLUDE_GEOMUTILS_VECTOR2_H_

// See MW-2333
#if defined(__unix__) || defined(__unix)
#include <unistd.h>
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-register"
#endif
#include <Eigen/Geometry>
#ifdef __clang__
#pragma clang diagnostic pop
#endif

#include <cmath>
#include <deque>
#include <functional>
#include <vector>

#include "geomutils/Scalar.h"

// Note on GEOMUTILS_API exports in this file:
// I haven't investigated this as thoughroughly as I should have,
// but the short version is that because this class inherits from an
// Eigen template, putting GEOMUTILS_API on the class attempts to export
// things that don't make sense (like the 4D constructor of Eigen::Matrix).
// As a result, we have to individually export desired functions.

namespace geomutils {

/// Standard X/Y Vector value for 2d vectors
class Vector2 : public Eigen::Matrix<Scalar, 2, 1> {
 public:
  typedef Eigen::Matrix<Scalar, 2, 1> base;

  /// Default Constructor
  GEOMUTILS_API Vector2();

  ///  copy constructor
  GEOMUTILS_API Vector2(const Vector2 &);

  ///  copy constructor
  GEOMUTILS_API Vector2(const base &v);  // NOLINT(runtime/explicit)

  ///  copy constructor
  GEOMUTILS_API Vector2(Scalar x, Scalar y);

  GEOMUTILS_API Vector2 operator+(const Vector2& v) const;
  GEOMUTILS_API Vector2 operator-(const Vector2& v) const;
  GEOMUTILS_API Vector2 operator*(const Vector2& v) const;
  GEOMUTILS_API Vector2 operator*(const Scalar &value) const;

  GEOMUTILS_API inline Scalar& x() { return (*this)[0]; }
  GEOMUTILS_API inline Scalar& y() { return (*this)[1]; }
  GEOMUTILS_API inline Scalar x() const { return (*this)[0]; }
  GEOMUTILS_API inline Scalar y() const { return (*this)[1]; }

  /// Returns tolerance equals of this vector vs pased vector p
  GEOMUTILS_API bool tequals(const Vector2 &p, const Scalar tol) const;

  /// Returns the eucledian length
  GEOMUTILS_API Scalar magnitude() const;

  /// Returns the squared length of this vector.
  GEOMUTILS_API Scalar squaredMagnitude() const;

  /// Normalizes this Vector2
  GEOMUTILS_API void normalise();

  /// Returns a new Vector2 which is the unit-vector of this vector
  GEOMUTILS_API Vector2 unit() const;

  /// Returns the dot product of this Vector2
  GEOMUTILS_API Scalar dotProduct(const Vector2 &vector) const;

  /// Returns the cross product of this Vector2
  GEOMUTILS_API Scalar crossProduct(const Vector2 &vector) const;

  /// Returns an angle from 2 passed vectors as 2 rays based at 0,0 in radians
  GEOMUTILS_API Scalar angleFromVector2s(const Vector2 &a, const Vector2 &b) const;

  /// Returns angle between Vector i-j and Vector j-k in radians
  GEOMUTILS_API Scalar angleFromPoint2s(
      const Vector2 &i, const Vector2 &j, const Vector2 &k) const;

  /// Rotates the current Vector around center by cc by angle (in radians)
  GEOMUTILS_API Vector2 rotate2d(const Vector2 &center, Scalar angle) const;

  /// Rotates the current Vector around the origin cc by angle (in radians)
  GEOMUTILS_API Vector2 rotate2d(Scalar angle) const;

  /// Rotates the current Vector aroudn the origin.
  ///
  /// cs stores the cosine of the angle in the x component and sine angle in the
  /// y component. This form avoids recalculateing sine and cosine if you
  /// already have them from a previous operation.
  GEOMUTILS_API Vector2 rotate2d(const Vector2& cs) const;

  /// Rotates teh current Vector around the origin
  ///
  /// c stores the cosine of the angle and s stores the sine of the angle.
  GEOMUTILS_API Vector2 rotate2d(Scalar c, Scalar s) const;

  /// Perform operation on both coordinates and return the resulting vector
  ///
  /// operation a function or function object that takes and returns a Scalar
  /// e.g. v2transformed :: Vector2 -> (Scalar -> Scalar) -> Vector2
  template <typename OPERATION>
  Vector2 transformed(const OPERATION& operation = OPERATION()) const {
    return Vector2(operation((*this)[0]), operation((*this)[1]));
  }

  /// Convert a Vector2 to an Eigen vector
  Eigen::Vector2d toEVector() const {
    return *this;
  }

  /// Convert an Eigen vector to a Vector2
  static Vector2 fromEVector(const Eigen::Vector2d &orig) {
    return Vector2(orig[0], orig[1]);
  }

  // Convert Eigen Vector to a vector of doubles
  static std::vector<double> toVectorDouble(const Eigen::Vector2d &orig) {
    std::vector<double> ret;
    ret.emplace_back(orig[0]);
    ret.emplace_back(orig[1]);
    return ret;
  }

  /// Distance comparator for Vector2 objects
  ///
  /// To allow you to sort points based on their distance to some anchor point.
  /// Initialize with the anchor to compare to.
  class DistanceCmp
    : public std::binary_function<const Vector2&, const Vector2&, bool> {
   public:
    DistanceCmp(const Vector2 &anchor) : m_anchor(anchor) { }  // NOLINT

    bool operator()(const Vector2 &a, const Vector2 &b) {
      return (m_anchor - a).squaredMagnitude() <
             (m_anchor - b).squaredMagnitude();
    }
   private:
    const Vector2 &m_anchor;
  };

  /// Less comparitor for Vector2 objects
  ///
  /// Less results have no meaning outside of its uesfulness for uniqueness. Use
  /// this for map and set comparators
  struct Less
      : public std::binary_function<const Vector2&, const Vector2&, bool> {
    bool operator()(const Vector2 &first, const Vector2 &second) {
      if (first[0] < second[0])
        return true;
      else if (first[0] > second[0])
        return false;
      else if (first[1] < second[1])
        return true;
      else
        return false;
    }
  };
};

/// get the magnitude of the point order indicated vector out of the plane
///
/// assumes all points are on the x-y plane
///
/// Ex: ((0,0)(0,1)(1,0))  returns -1 (normal points negative Z out of plane)
/// Ex: ((1,0)(0,0)(0,1))  returns 1 (normal points positive Z out of plane)
Scalar GEOMUTILS_API AreaSign(
    const Vector2& a,
    const Vector2& b,
    const Vector2& c);

/// Returns true if the triangle vectors has a negative index, false otherwise
///
/// uses geomutils::AreaSign()
bool GEOMUTILS_API convexVertex(
    const Vector2& i,
    const Vector2& j,
    const Vector2& k);

GEOMUTILS_API Vector2 operator -(const Vector2& rhs);
GEOMUTILS_API Vector2 operator *(Scalar s, const Vector2& rhs);
GEOMUTILS_API bool operator==(const Vector2& lhs, const Vector2& rhs);
GEOMUTILS_API inline bool operator!=(const Vector2& lhs, const Vector2& rhs) {
  return !(lhs == rhs);
}

GEOMUTILS_API std::ostream& operator <<(std::ostream& os, const Vector2& pt);

}  // namespace geomutils

namespace boost {
namespace serialization {

template <typename Archive>
void serialize(Archive& ar, geomutils::Vector2& dest, const unsigned int) {
  ar & dest.x();
  ar & dest.y();
}

}  // namespace serialization
}  // namespace boost

#endif  // INCLUDE_GEOMUTILS_VECTOR2_H_
