#include <list>
#include <vector>
#include <memory>
#include <ostream>

#include <boost/range.hpp>

#include "Loop.h"

#pragma once

// Forward-declare this so we can totally hide the clipper library
namespace ClipperLib {
struct IntPoint;
typedef std::vector<IntPoint> Path;
typedef std::vector<Path> Paths;
}

namespace geomutils {

class DiscreteRegion;

/**
 * A Region defines a 2D space with an *inside* and an *outside*.
 *
 * Region interiors are defined by a CW winding - CCW winding loops indicate
 * holes in another CW-wound outline.  All holes should be correctly nested in
 * outlines, and outlines may be nested in holes, to any degree.
 *
 * Regions can be unioned, intersected, subtracted, xor'ed, offset - basically
 * wrapping what is currently implemented by Clipper (and some extras) in a nice
 * interface.
 *
 * (Basically similar to what we have with CachedLoops, but with a standardized
 * API that reads much more nicely and that doesn't expose Clipper internals.)
 *
 * TODO: Expose the subset of this functionality applicable for raw loop lists,
 * without the need to go through a Region?
 */
class GEOMUTILS_API Region {
public:
    Region();
    Region(const Region& other);
    Region(Region&& other);

    // Either these constructor or the cast operators must be marked explicit to
    // avoid ambiguity.
    explicit Region(const Loop& loop);
    explicit Region(Loop&& loop);
    explicit Region(const std::list<Loop>& loops);
    explicit Region(std::list<Loop>&& loops);

    Region& operator=(const Region& other);
    Region& operator=(Region&& other);

    // DRAGONS - we must *explicitly* declare the destructor, otherwise it's
    // inline and we can't forward-declare the clipper state
    ~Region();

    void swap(Region& other);

    void clear();

    size_t size() const;

    bool empty() const;

    const std::list<Loop>& getLoops() const;

    Scalar area() const;

    Vector2 centroid() const;

    bool contains(const Vector2& point) const;

    void addLoop(const Loop& loop);

    void addLoop(const Loop&& loop);

    std::list<Loop>& getMutableLoops();

    // Note that union/xor are unfortunately keywords in C++
    static Region combine(const Region& region_a, const Region& region_b);

    static Region subtract(const Region& region_a, const Region& region_b);

    static Region intersect(const Region& region_a, const Region& region_b);

    static Region exclusiveOr(const Region& region_a, const Region& region_b);

    static Region offset(const Region& region,
                         Scalar distance,
                         bool square = true,
                         Scalar miter_limit = 2.0);

    static Region translate(const Region& region, const Vector2& translation);

    static std::vector<DiscreteRegion> discreteIslands(const Region& region);

    static Region convexRegion(const Region& region);

    static Region minkowskiSum(const Region& region, const Loop& pattern);

    // Operators for simpler testing and better readability - note that they
    // are exactly equivalent to the methods above.

    // combine
    Region operator+(const Region& other) const;

    // subtract
    Region operator-(const Region& other) const;

    // intersect
    Region operator*(const Region& other) const;

    // xor
    Region operator^(const Region& other) const;

    // See above
    Region& operator+=(const Region& other);

    Region& operator-=(const Region& other);

    Region& operator*=(const Region& other);

    Region& operator^=(const Region& other);

private:
    explicit Region(ClipperLib::Paths&& clipper_paths);

    const ClipperLib::Paths& getClipperPaths() const;

    void generateLoops() const;

    void generateClipperPaths() const;

    mutable std::unique_ptr<std::list<Loop>> m_loops;
    // Allow forward decl
    mutable std::unique_ptr<ClipperLib::Paths> m_clipper_paths;
};

GEOMUTILS_API std::ostream& operator<<(std::ostream& ostream,
                                       const Region& region);

/**
 * A DiscreteRegion is a Region with an outer outline that may contain
 * several holes, representing a single contiguous 2D space.
 *
 * Holes are oriented CCW, outlines CW.  Badly-oriented Regions will result in
 * badly-oriented DiscreteRegions (and probably other problems).
 *
 * TODO: Make this more lightweight, and store only pointers back to loops from
 * the original region?  We can always copy these to create new regions if
 * requested.
 */
class GEOMUTILS_API DiscreteRegion {
public:
    DiscreteRegion();
    DiscreteRegion(const Loop& outline, const std::list<Loop>& holes);
    DiscreteRegion(const Loop& outline, std::list<Loop>&& holes);
    DiscreteRegion(Loop&& outline, std::list<Loop>&& holes);

    const Loop& getOutline() const;

    typedef boost::iterator_range<std::list<Loop>::const_iterator> HoleRange;

    HoleRange getHoles() const;

    const Region& getRegion() const;

    size_t numHoles() const;

    bool contains(const Vector2& point) const;

private:
    Region m_region;
};

}  // namespace geomutils

namespace boost {
namespace serialization {

template <typename Archive>
void serialize(Archive& ar, geomutils::Region& dest, const unsigned int) {
    ar& dest.getMutableLoops();
}

}  // namespace serialization
}  // namespace boost
