#pragma once

// boost geometry stuff
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/box.hpp>
#include <boost/geometry/geometries/point.hpp>
#include <boost/geometry/index/rtree.hpp>

#include "spacial_data.h"

namespace geomutils {

template <size_t D>
using BoostVector = typename boost::geometry::model::
    point<Scalar, D, boost::geometry::cs::cartesian>;

template <size_t D>
using BoostBox = typename boost::geometry::model::box<BoostVector<D>>;

template <size_t D>
using Bounds = basic_bounding_box<Scalar, D>;

// This junk is necessary since we can't partially specialize template functions
// and because boost looves the templates.
template <size_t D, typename V, typename BOOST_V>
struct BoostVectorSetter {
    void set(const V& v, BOOST_V& bv) const {
        boost::geometry::set<D - 1>(bv, v[D - 1]);
        BoostVectorSetter<D - 1, V, BOOST_V>().set(v, bv);
    }
};

template <typename V, typename BOOST_V>
struct BoostVectorSetter<0, V, BOOST_V> {
    void set(const V& v, BOOST_V& bv) const {}
};

template <size_t D, typename V>
BoostVector<D> toBoostVector(const V& v) {
    BoostVector<D> bv;
    BoostVectorSetter<D, V, BoostVector<D>>().set(v, bv);
    return bv;
}

template <size_t D>
BoostBox<D> toBoostBox(const Bounds<D>& bounds) {
    return BoostBox<D>(toBoostVector<D>(bounds.m_min),
                       toBoostVector<D>(bounds.m_max));
}

template <size_t D, typename VALUE>
struct BoundedItem {

    BoundedItem(const Bounds<D>& bounds, const VALUE& value)
        : bounds(bounds), box(toBoostBox(bounds)), value(value) {}

    Bounds<D> bounds;
    BoostBox<D> box;
    VALUE value;
};

template <size_t D, typename VALUE>
struct BoundedItemIndexableGetter {

    typedef const BoostBox<D>& result_type;

    result_type operator()(const BoundedItem<D, VALUE>& value) const {
        return value.box;
    }
};

template <size_t D, typename VALUE>
struct BoundedItemEqualTo {
    bool operator()(const BoundedItem<D, VALUE>& a,
                    const BoundedItem<D, VALUE>& b) const {
        if (!boost::geometry::equals(a.box, b.box)) return false;
        return a.value == b.value;
    }
};

template <size_t D, typename VALUE, int MAX_ELEMENTS = 16>
class BoundsRTree : public boost::geometry::index::rtree<
                        BoundedItem<D, VALUE>,
                        boost::geometry::index::rstar<MAX_ELEMENTS>,
                        BoundedItemIndexableGetter<D, VALUE>,
                        BoundedItemEqualTo<D, VALUE>> {

public:
    // Gotta redefine this, templates are awesome
    typedef boost::geometry::index::rtree<
        BoundedItem<D, VALUE>,
        boost::geometry::index::rstar<MAX_ELEMENTS>,
        BoundedItemIndexableGetter<D, VALUE>,
        BoundedItemEqualTo<D, VALUE>>
        _RTree;

    typedef typename _RTree::const_query_iterator const_query_iterator;

    typedef BoundedItem<D, VALUE> Item;

    const_query_iterator contains_begin(const Bounds<D>& bounds) const {
        return _RTree::qbegin(
            boost::geometry::index::contains(toBoostBox(bounds)));
    }
    const_query_iterator contains_end() const { return _RTree::qend(); }

    const_query_iterator covered_by_begin(const Bounds<D>& bounds) const {
        return _RTree::qbegin(
            boost::geometry::index::covered_by(toBoostBox(bounds)));
    }
    const_query_iterator covered_by_end() const { return _RTree::qend(); }

    const_query_iterator covers_begin(const Bounds<D>& bounds) const {
        return _RTree::qbegin(
            boost::geometry::index::covers(toBoostBox(bounds)));
    }
    const_query_iterator covers_end() const { return _RTree::qend(); }

    const_query_iterator disjoint_begin(const Bounds<D>& bounds) const {
        return _RTree::qbegin(
            boost::geometry::index::disjoint(toBoostBox(bounds)));
    }
    const_query_iterator disjoint_end() const { return _RTree::qend(); }

    const_query_iterator intersects_begin(const Bounds<D>& bounds) const {
        return _RTree::qbegin(
            boost::geometry::index::intersects(toBoostBox(bounds)));
    }
    const_query_iterator intersects_end() const { return _RTree::qend(); }

    const_query_iterator overlaps_begin(const Bounds<D>& bounds) const {
        return _RTree::qbegin(
            boost::geometry::index::overlaps(toBoostBox(bounds)));
    }
    const_query_iterator overlaps_end() const { return _RTree::qend(); }

    const_query_iterator within_begin(const Bounds<D>& bounds) const {
        return _RTree::qbegin(
            boost::geometry::index::within(toBoostBox(bounds)));
    }
    const_query_iterator within_end() const { return _RTree::qend(); }

    template <typename V>
    const_query_iterator nearest_begin(const V& point,
                                       size_t num_results) const {
        return _RTree::qbegin(boost::geometry::index::nearest(
            toBoostVector<D>(point), num_results));
    }
    const_query_iterator nearest_end() const { return _RTree::qend(); }
};
}