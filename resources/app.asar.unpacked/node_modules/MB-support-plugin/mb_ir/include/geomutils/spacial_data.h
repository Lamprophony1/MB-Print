// Copyright 2014 MakerBot

#ifndef INCLUDE_GEOMUTILS_SPACIAL_DATA_H_
#define INCLUDE_GEOMUTILS_SPACIAL_DATA_H_

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-register"
#endif

#include <Eigen/Geometry>

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#include <algorithm>
#include <limits>
#include <stdexcept>
#include <iostream>
#include <string>

#include "geomutils/Scalar.h"
#include "geomutils/Vector2.h"

namespace geomutils {

/// ND AA bounding box
template<typename T, size_t D>
class basic_bounding_box {  // NOLINT(runtime/virtual)
 public:
  static const size_t DIMENSION = D;
  typedef T value_type;
  typedef Eigen::Matrix<value_type, DIMENSION, 1> VecN;

  basic_bounding_box(VecN pt = VecN()) : m_min(pt), m_max(pt) { }

  basic_bounding_box(VecN bmin, VecN bmax) : m_min(bmin), m_max(bmax) { }

  basic_bounding_box(const basic_bounding_box &bb)
    : m_min(bb.m_min), m_max(bb.m_max) { }

  template <typename BEGIN_IT, typename END_IT>
  static basic_bounding_box boundAll(BEGIN_IT begin, END_IT end) {
      basic_bounding_box bbox;
      for (size_t i = 0; i < DIMENSION; ++i) {
          bbox.m_min[i] = std::numeric_limits<T>::max();
          bbox.m_max[i] = std::numeric_limits<T>::lowest();
      }
      for (; begin != end; ++begin) {
          bbox.expandTo(*begin);
      }
      return bbox;
  }

  basic_bounding_box& operator=(const basic_bounding_box &bb) {
    if (this != &bb) {
      m_min = bb.m_min;
      m_max = bb.m_max;
    }
    return *this;
  }

  /// adjust bounding box to include point pt
  void expandTo(VecN pt) {
    for (size_t i = 0; i < DIMENSION; ++i) {
      m_min[i] = std::min(m_min[i], pt[i]);
      m_max[i] = std::max(m_max[i], pt[i]);
    }
  }

  /// adjust bounding box to include bbox bb
  void expandTo(const basic_bounding_box& bb) {
    for (size_t i = 0; i < DIMENSION; ++i) {
      m_min[i] = std::min(m_min[i], bb.m_min[i]);
      m_max[i] = std::max(m_max[i], bb.m_max[i]);
    }
  }

  /// create a copy of bb and adjust its dimensions to include point pt
  basic_bounding_box  expandedTo(VecN pt) const {
    basic_bounding_box copy = *this;
    copy.expandTo(pt);
    return copy;
  }

  /// create a copy of bb and adjust its dimensions to include bbox bb
  basic_bounding_box  expandedTo(const basic_bounding_box& bb) const {
    basic_bounding_box copy = *this;
    copy.expandTo(bb);
    return copy;
  }

  /// reset bbox
  void reset(VecN pt = VecN()) {
    m_min = m_max = pt;
  }

  /// pad bbox my delta
  void adjust(VecN minDelta, VecN maxDelta) {
    m_min += minDelta;
    m_max += maxDelta;
  }

  /// return a copy of a padded box
  basic_bounding_box adjusted(VecN minDelta, VecN maxDelta) const {
    basic_bounding_box copy = *this;
    copy.adjust(minDelta, maxDelta);
    return copy;
  }

  /// offset bounding box pos or negative
  void offset(value_type amount) {
      for (size_t i = 0; i < DIMENSION; ++i) {
          if (size(i) <= (-amount * 2)) {
              m_min[i] = m_max[i] = center()[i];
          } else {
              m_min[i] -= amount;
              m_max[i] += amount;
          }
      }
  }

  /// computer center of box
  VecN center() const {
    return (m_min + m_max) * 0.5;
  }

  value_type size(size_t i) const {
    return m_max[i] - m_min[i];
  }

  /// compute volume of ND box (1D: length, 2D: area, 3D: volume, etc)
  virtual value_type area() const {
    if (DIMENSION < 1)
      return 0;
    value_type v = 1;
    for (size_t i = 0; i < DIMENSION; ++i)
      v *= size(i);
    return v;
  }

  /// compute surface area of ND box.
  ///
  /// This is computed as the twice the sum of the volumes of all the (N-1)D
  /// sides of the box (1D: 2x length, 2D: perimeter, 3D: area, 4D: volume, etc)
  /// Technically 1D perimeter is undefined, but we define as limit of shrinking
  /// 2D bbox y-axis to zero.
  virtual value_type perimeter() const {
      value_type perimeter = 0;
      for (size_t i = 0; i < DIMENSION; ++i) {
          value_type side = 1;
          for (size_t j = 0; j < DIMENSION; ++j) {
              if (i == j && DIMENSION > 1) continue;
              side *= size(j);
          }
          perimeter += side;
      }
      return perimeter * 2;
  }

  bool contains(size_t i,
                const basic_bounding_box& other,
                bool strict = true) const {
      return strict
                 ? (m_min[i] < other.m_min[i] && other.m_max[i] < m_max[i])
                 : (m_min[i] <= other.m_min[i] && other.m_max[i] <= m_max[i]);
  }

  /// checks wheter bbox other is fully contained in bbox
  bool contains(const basic_bounding_box& other, bool strict = true) const {
      for (size_t i = 0; i < DIMENSION; ++i)
          if (!contains(i, other, strict)) return false;
      return true;
  }

  bool approxContains(size_t i,
                      const basic_bounding_box& other,
                      Scalar tol) const {

      return approxLTE(m_min[i], other.m_min[i], tol) &&
             approxLTE(other.m_max[i], m_max[i], tol);
  }

  /// Checks whether a box nearly contains another assuming some tolerance 
  bool approxContains(const basic_bounding_box& other, Scalar tol) const {
      for (size_t i = 0; i < DIMENSION; ++i) {
          if (!approxContains(i, other, tol)) return false;
      }
      return true;
  }

  /// checks whether box intersects with another in i'th dimension
  bool intersects(size_t i,
                  const basic_bounding_box& other,
                  bool include_edges = true) const {

      return include_edges
                 ? (m_min[i] <= other.m_max[i] && other.m_min[i] <= m_max[i])
                 : (m_min[i] < other.m_max[i] && other.m_min[i] < m_max[i]);
  }

  /// check if two boxes intersect
  bool intersects(const basic_bounding_box& other,
                  bool include_edges = true) const {
      for (size_t i = 0; i < DIMENSION; ++i)
          if (!intersects(i, other, include_edges)) return false;
      return true;
  }

  bool approxIntersects(size_t i,
                        const basic_bounding_box& other,
                        Scalar tol) const {

      return approxLTE(m_min[i], other.m_max[i], tol) &&
             approxLTE(other.m_min[i], m_max[i], tol);
  }

  /// Checks whether a box nearly intersects another assuming some tolerance
  bool approxIntersects(const basic_bounding_box& other, Scalar tol) const {
      for (size_t i = 0; i < DIMENSION; ++i) {
          if (!approxIntersects(i, other, tol)) return false;
      }
      return true;
  }

  /// checks whether bbox other fits inside this box
  bool fits(const basic_bounding_box& other) const {
    for (size_t i = 0; i < DIMENSION; ++i)
      if (other.size(i) >= size(i))
        return false;
    return true;
  }

  VecN m_min;
  VecN m_max;

protected:
  
  // Used in approx tests
  bool approxLTE(Scalar a, Scalar b, Scalar tol) const {
      return a < b || (std::abs(a - b) < tol);
  }
};

template <typename T, size_t D>
std::ostream& operator<<(std::ostream& os,
                         const basic_bounding_box<T, D>& bounds) {
    os << "[[";
    for (size_t i = 0; i < D; ++i) {
        os << bounds.m_min[i] << (i < (D - 1) ? "," : "");
    }
    os << "]->[";
    for (size_t i = 0; i < D; ++i) {
        os << bounds.m_max[i] << (i < (D - 1) ? "," : "");
    }
    os << "]]";
    return os;
}

class AABBox : public basic_bounding_box<Scalar, 2> {
 public:
  typedef basic_bounding_box<Scalar, 2> base;
  typedef Eigen::Matrix<Scalar, 2, 1> Vec2;

  AABBox(Vector2 pt = Vector2()) : base(Vec2(pt[0], pt[1])) { }

  AABBox(Vector2 bmin, Vector2 bmax)
    : base(Vec2(bmin[0], bmin[1]), Vec2(bmax[0], bmax[1])) { }

  AABBox(const base &bb)  // NOLINT(runtime/explicit)
    : base(bb) { }

  AABBox& operator=(const base &bb) {
    m_min = bb.m_min;
    m_max = bb.m_max;
    return *this;
  }

  Scalar left() const {
    return m_min[0];
  }

  Scalar right() const {
    return m_max[0];
  }

  Scalar bottom() const {
    return m_min[1];
  }

  Scalar top() const {
    return m_max[1];
  }

  Vector2 bottom_left() const {
    return m_min;
  }

  Vector2 bottom_right() const {
    return Vector2(m_max[0], m_min[1]);
  }

  Vector2 top_left() const {
    return Vector2(m_min[0], m_max[1]);
  }

  Vector2 top_right() const {
    return m_max;
  }

  Vector2 bottom_center() const {
    return Vector2((m_min[0] + m_max[0]) * 0.5, m_min[1]);
  }

  Vector2 top_center() const {
    return Vector2((m_min[0] + m_max[0]) * 0.5, m_max[1]);
  }

  Vector2 left_center() const {
    return Vector2(m_min[0], (m_min[1] + m_max[1]) * 0.5);
  }

  Vector2 right_center() const {
    return Vector2(m_max[0], (m_min[1] + m_max[1]) * 0.5);
  }

  Scalar size_x() const {
    return m_max[0] - m_min[0];
  }

  Scalar size_y() const {
    return m_max[1] - m_min[1];
  }

  Scalar area() const {
    return size_x() * size_y();
  }

  Scalar perimeter() const {
    return (size_x() + size_y()) * 2;
  }
};

template <typename T>
struct to_bbox {
  static AABBox bound(const T&);
};

class BBoxFilter {
 public:
  BBoxFilter(const AABBox& bb = AABBox())
    : myBound(bb) {
  }
  bool filter(const AABBox& bb) const {
    return myBound.intersects(bb);
  }
 protected:
  AABBox myBound;
};

}  // namespace geomutils

#endif  // INCLUDE_GEOMUTILS_SPACIAL_DATA_H_
