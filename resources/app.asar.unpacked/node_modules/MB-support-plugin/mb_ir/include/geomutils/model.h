// Copyright 2015 Makerbot Industries

#ifndef INCLUDE_GEOMUTILS_MODEL_H_
#define INCLUDE_GEOMUTILS_MODEL_H_

#include <list>
#include <map>
#include <string>
#include <vector>

#include "geomutils/limits.h"
#include "geomutils/Loop.h"

namespace geomutils {

/// All of the loops that exist at one Z Height
struct ZSlice {
 public:
  ZSlice() { };

  const std::vector<std::string> getMaterials() const {
    std::vector<std::string> keys;
    for (auto mapItr : m_materialLoopMap) {
      keys.push_back(mapItr.first);
    }
    return keys;
  };

  const std::list<Loop>& getExtents(const std::string &materialName) const {
    return m_materialLoopMap.at(materialName);
  };

  void addLoops(const std::string &materialName, const std::list<Loop> &loops) {
    auto& theList = m_materialLoopMap[materialName];
    theList.insert(theList.end(), loops.begin(), loops.end());
  }

 private:
  std::map<std::string, std::list<Loop> > m_materialLoopMap;
};

/// Base class for all Models that can be sliced for Miracle Grue
///
/// Any class representing a model must implement these pure virtual functions.
/// To be used by Miracle Grue, any child class should be initialized at the
/// of miracle stream.
class Model {
 public:
  explicit Model(std::string name) : m_name(name) { };

  virtual ~Model() { };

  /// Prepare the model for slicing
  virtual void prepareForSlicing() = 0;

  /// Clear slicing data
  void clearSlicingData() { };

  /// Get the bounding limits of the model
  virtual geomutils::Limits getLimits() const = 0;

  /// Is the model watertight w.r.t. the buildplate?
  virtual bool isWatertight() const = 0;

  /// For a zHeight, get a ZSlice object that maps materials to the bounds of
  /// Model.
  virtual const ZSlice getSlice(Scalar zHeight) = 0;

  // Update the scale for this model in x, y, and z. These values are multiplied
  // by the existing scale.
  virtual void updateScale(float x, float y, float z) = 0;

  /// get the name of this model. this is used to match slice settings.
  const std::string& getName() const { return m_name; }

 private:
  const std::string m_name;
};

class Layout {
 public:
  explicit Layout() { };

  virtual ~Layout() { };

  /// Load the model in from the file path
  virtual bool loadLayout(const std::string &filepath) = 0;

  /// Get a vector of Models in this Layout
  virtual const std::vector<std::shared_ptr<Model> > getModels() const = 0;
};
}

#endif  // INCLUDE_GEOMUTILS_MODEL_H_
