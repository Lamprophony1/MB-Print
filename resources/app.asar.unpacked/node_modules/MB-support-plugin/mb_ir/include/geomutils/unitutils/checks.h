#pragma once

#include <boost/test/unit_test.hpp>
#include <set>
#include <sstream>
#include <string>

#include "geomutils/Loop.h"

// A bunch of redefines from boost, to help readability.
#define CHECK(X) BOOST_CHECK(X)
#define CHECK_CLOSE(A, B, T) BOOST_CHECK_CLOSE(A, B, T)
#define CHECK_EQUAL(A, B) BOOST_CHECK_EQUAL(A, B)
#define CHECK_GT(A, B) BOOST_CHECK_GT(A, B)
#define CHECK_LT(A, B) BOOST_CHECK_LT(A, B)
#define CHECK_LE(A, B) BOOST_CHECK_LE(A, B)

#define CHECK_EQUAL_COLLECTIONS(A_B, A_E, B_B, B_E) \
    BOOST_CHECK_EQUAL_COLLECTIONS(A_B, A_E, B_B, B_E)

namespace unitutils {

// Allows simple streaming of strings into BOOST_ERROR - otherwise it's super
// awkward.
struct Message {

    template <typename T>
    Message& operator<<(const T& value) {
        stream << value;
        return *this;
    }

    operator std::string() const { return stream.str(); }

    std::stringstream stream;
};

// Required to keep the containers in scope while we iterate them from the
// boost macros
// TODO: Make this a boolean check so we can throw the boost error in the macro
// itself for better tracing of errors.
template <typename CONTAINER>
void checkEqualContainers(const CONTAINER& a, const CONTAINER& b) {
    CHECK_EQUAL_COLLECTIONS(a.begin(), a.end(), b.begin(), b.end());
}

template <typename CONTAINER>
void checkSameElements(const CONTAINER& a, const CONTAINER& b) {
    std::set<typename CONTAINER::value_type> set_a(a.begin(), a.end());
    std::set<typename CONTAINER::value_type> set_b(b.begin(), b.end());
    CHECK_EQUAL_COLLECTIONS(
        set_a.begin(), set_a.end(), set_b.begin(), set_b.end());
}

template <int DIM, typename VECTOR>
std::string vectorString(const VECTOR& vector) {
    std::stringstream builder;
    builder << "[";
    for (int i = 0; i < DIM; ++i) builder << (i == 0 ? "" : ",") << vector[i];
    builder << "]";
    return builder.str();
}

template <int DIM, typename VECTOR_A, typename VECTOR_B>
bool checkSimilarVectors(const VECTOR_A& vector_a,
                         const VECTOR_B& vector_b,
                         double tol,
                         Message& errmsg) {

    int diff_at = -1;
    for (int i = 0; i < DIM; ++i) {
        if (std::fabs(static_cast<double>(vector_a[i]) -
                      static_cast<double>(vector_b[i])) > tol) {
            diff_at = i;
            break;
        }
    }

    if (diff_at < 0) return true;

    errmsg << "Vectors " << vectorString<DIM>(vector_a) << " and "
           << vectorString<DIM>(vector_b) << " differ at index " << diff_at;

    return false;
}

bool checkLoopsClose(const geomutils::Loop& loop_a,
                     const geomutils::Loop& loop_b,
                     double tolerance,
                     Message& errmsg) {

    if (loop_a.size() != loop_b.size()) {
        errmsg << "Size of loops differ (" << loop_a.size() << " vs "
               << loop_b.size() << "), loops: " << loop_a << " vs " << loop_b;
        return false;
    }

    auto it_a = loop_a.clockwiseFinite();
    auto it_b = loop_b.clockwiseFinite();
    auto end_a = loop_a.clockwiseEnd();
    auto end_b = loop_b.clockwiseEnd();

    for (; it_a != end_a && it_b != end_b; ++it_a, ++it_b) {

        bool x_close = std::abs(it_a->x() - it_b->x()) <= tolerance;
        bool y_close = std::abs(it_a->y() - it_b->y()) <= tolerance;

        if (!x_close || !y_close) {
            errmsg << "Points in loops differ (" << *it_a << " vs " << *it_b
                   << "), loops: " << loop_a << " vs " << loop_b;
            return false;
        }
    }

    return true;
}
}

#define ERROR(M) BOOST_ERROR((std::string)(unitutils::Message() << M))

#define CHECK_EQUAL_CONTAINERS(A, B) unitutils::checkEqualContainers((A), (B))

#define CHECK_SAME_ELEMENTS(A, B) unitutils::checkSameElements((A), (B))

#define CHECK_CLOSE_LOOPS(A, B, T)                              \
    do {                                                        \
        unitutils::Message errmsg;                              \
        if (!unitutils::checkLoopsClose((A), (B), (T), errmsg)) \
            BOOST_ERROR((std::string)errmsg);                   \
    } while (0)

#define CHECK_CLOSE_NORMLOOPS(A, B, T)                            \
    do {                                                          \
        unitutils::Message errmsg;                                \
        if (!unitutils::checkLoopsClose(                          \
                (A).normalized(), (B).normalized(), (T), errmsg)) \
            BOOST_ERROR((std::string)errmsg);                     \
    } while (0)

#define CHECK_CLOSE_VECTOR2(A, B, TOL)                                   \
    do {                                                                 \
        unitutils::Message errmsg;                                       \
        if (!unitutils::checkSimilarVectors<2>((A), (B), (TOL), errmsg)) \
            BOOST_ERROR((std::string)errmsg);                            \
    } while (0)

#define CHECK_CLOSE_VECTOR3(A, B, TOL)                                   \
    do {                                                                 \
        unitutils::Message errmsg;                                       \
        if (!unitutils::checkSimilarVectors<3>((A), (B), (TOL), errmsg)) \
            BOOST_ERROR((std::string)errmsg);                            \
    } while (0)

#define CHECK_EQUAL_VECTOR2(A, B)                                    \
    do {                                                             \
        unitutils::Message errmsg;                                   \
        if (!unitutils::checkSimilarVectors<2>((A), (B), 0, errmsg)) \
            BOOST_ERROR((std::string)errmsg);                        \
    } while (0)

#define CHECK_EQUAL_VECTOR3(A, B)                                    \
    do {                                                             \
        unitutils::Message errmsg;                                   \
        if (!unitutils::checkSimilarVectors<3>((A), (B), 0, errmsg)) \
            BOOST_ERROR((std::string)errmsg);                        \
    } while (0)
