#ifndef INCLUDE_GEOMUTILS_BEZIER_CURVE_BASE_H_
#define INCLUDE_GEOMUTILS_BEZIER_CURVE_BASE_H_

#include <array>
#include <vector>

#include "geomutils/Scalar.h"

// A templated BezierCurve class to facilitate generation of 2D and 3D bezier
// curves. Since, it is mostly used with 2D and 3D points only, explicit
// template initialization will be used, allowing for keeping declaration and
// impementation of templates seperate. Using it with other types will generate
// linker errors Reference: The NURBS book by Piegl and Tiller See: Explicit
// template initialization
// https://stackoverflow.com/questions/8662517/do-template-class-member-function-implementations-always-have-to-go-in-the-heade

namespace geomutils {

template <class T>
class GEOMUTILS_API BezierCurveBase {
public:
    // Constructor(s)

    // Default contructor(s)
    BezierCurveBase();

    // Destructor(s)
    ~BezierCurveBase();

    // Sets control points for the curve
    void setControlPoints(const std::vector<T>& controlPoints);

    // Sets resolution of the curve. Higher the resolution, smoother the curve.
    // It decides number of points that will be generated on the curve. For
    // example, resolution of 10 will typically generate 10 points on the curve.
    // Resolution of 150, will ypically generate  150 points on the curve.
    // For Bezier infill pattern, reolution of 10 suffices.
    void setResolution(unsigned int resolution);

    // Returns control points.
    std::vector<T> controlPoints() const;

    // Returns degree of the curve. It is simply number of points in control
    // structure - 1 If control structure has 0 control points, 0 is returned.
    unsigned int degree() const;

    // Returns resolution of the curve
    unsigned int resolution() const;

    // Returns points on the Bezier curve
    // For standard implementation, Time complexity is O(n*u) where n is number
    // of control points and u is resolution of the curve (in other words,
    // number of desired points on the curve)
    virtual std::vector<T> generateCurve() const = 0;

protected:
    // Populates a lookup table for fast factorial calculation.
    // It is limited upto factorials of 32 since for bezier curve's calculations
    // it is sufficent in almost all cases we might encounter.
    // Time complexity O(1)
    void _populateFactorialTable();

    // Checks if is in valid range of 0-32 and returns the factorial, else
    // throws an exception. Time complexity O(1)  because of use of lookup table
    Scalar _factorial(unsigned int n) const;

    /*
    Computes binomial coefficient
     / n \
    | --- |
     \ i /
    Time complexity O(1)
    */
    Scalar _computeBinomialCoefficient(unsigned int degree,
                                       unsigned int i) const;

    // Calculates Bernstein basis (blending) functions which are classical nth
    // degree Bernstein polynomials Time complexity O(1)
    Scalar _computeBernsteinBasis(unsigned int degree,
                                  unsigned int i,
                                  double u) const;

    /*
    Calculates all Bernstein basis (blending) functions for a given degree and u

    Degree is passed as a parameter instead of computing in function from size
    of control points because sometimes it can be helpful to see bernstein
    polynomial values(for debugging) irrespective of input control points since
    they can be computed irrespective of them. Time complexity O(n) where is
    number of points in the control structure.
    */
    std::vector<Scalar> _computeAllBernsteinBasis(unsigned int degree,
                                                  double u) const;

    std::vector<T> _controlPoints;
    unsigned int _resolution;
    unsigned int _degree;
    std::array<Scalar, 33> _factorialLookup;
    static const Scalar TOLOERANCE;  // It allows for accomodating for floating
                                     // point inaccuracies. Currentlt set to
                                     // 1E-3

private:
};
}  // namespace geomutils

#endif
