// Copyright 2014 MakerBot

#ifndef INCLUDE_GEOMUTILS_VECTOR3_H_
#define INCLUDE_GEOMUTILS_VECTOR3_H_

#include "geomutils/Scalar.h"
#include "geomutils/Vector2.h"

// Note on GEOMUTILS_API exports in this file:
// I haven't investigated this as thoughroughly as I should have,
// but the short version is that because this class inherits from an
// Eigen template, putting GEOMUTILS_API on the class attempts to export
// things that don't make sense (like the 4D constructor of Eigen::Matrix).
// As a result, we have to individually export desired functions.

namespace geomutils {

/// 3d vector class... warning: may be used for points
class Vector3 : public Eigen::Matrix<Scalar, 3, 1> {
 public:
  typedef Eigen::Matrix<Scalar, 3, 1> base;

  GEOMUTILS_API Vector3();
  GEOMUTILS_API Vector3(const Vector3 &v);
  GEOMUTILS_API Vector3(const base &v);  // NOLINT(runtime/explicit)
  GEOMUTILS_API Vector3(Scalar x, Scalar y, Scalar z);
  GEOMUTILS_API Vector3(const Vector2& xy, Scalar z);

  GEOMUTILS_API Vector3& operator=(const base &);

  GEOMUTILS_API bool operator==(const Vector3& v) const;
  GEOMUTILS_API bool operator!=(const Vector3& v) const;

  /// Returns the value of the given vector added to this.
  GEOMUTILS_API Vector3 operator+(const Vector3& v) const;

  /// Returns the value of the given vector multiplied by this.
  GEOMUTILS_API Vector3 operator*(const Scalar &v) const;

  /// Returns the value of the given vector subtracted from this.
  GEOMUTILS_API Vector3 operator-(const Vector3& v) const;

  /// Access x coordinate
  GEOMUTILS_API inline Scalar& x() { return (*this)[0]; }

  /// Access y coordinate
  GEOMUTILS_API inline Scalar& y() { return (*this)[1]; }

  /// Access z coordinate
  GEOMUTILS_API inline Scalar& z() { return (*this)[2]; }

  /// Access const x coordinate
  GEOMUTILS_API inline Scalar x() const { return (*this)[0]; }

  /// Access const y coordinate
  GEOMUTILS_API inline Scalar y() const { return (*this)[1]; }

  /// Access const z coordinate
  GEOMUTILS_API inline Scalar z() const { return (*this)[2]; }

  /// Vector3 other matches this vector within tolerance tol
  GEOMUTILS_API bool tequals(const Vector3 &other, const Scalar tol) const;

  /// Returns the cross product of vector with this
  GEOMUTILS_API Vector3 crossProduct(const Vector3 &vector) const;

  /// performs a cross product, and stores the result in the object
  GEOMUTILS_API void crossProductUpdate(const Vector3 &vector);

  /// returns the dot product of vector with this
  GEOMUTILS_API Scalar dotProduct(const Vector3 &vector) const;

  /// the eucledian length
  GEOMUTILS_API Scalar magnitude() const;

  /// Gets the squared length of this vector.
  GEOMUTILS_API Scalar squaredMagnitude() const;

  /// Create a 2d vector of this object by ignoring z
  GEOMUTILS_API Vector2 toVector2() const;

  /// makes this normal
  GEOMUTILS_API void normalise();

  /// return a vector that is the normalized version of this
  GEOMUTILS_API Vector3 getNormal() const;

  // TODO(zap) - figure out the def of this
  GEOMUTILS_API Vector3 unit() const;
};

GEOMUTILS_API Vector3 operator *(Scalar s, const Vector3& rhs);

/// Output stream for a Vector3 object
GEOMUTILS_API std::ostream& operator <<(std::ostream& os, const Vector3& v);

}  // namespace geomutils

#endif  // INCLUDE_GEOMUTILS_VECTOR3_H_
