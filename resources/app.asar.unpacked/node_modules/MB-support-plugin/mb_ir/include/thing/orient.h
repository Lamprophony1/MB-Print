
#pragma once

#include <memory>
#include <vector>
#include <iostream>

#include <Eigen/Geometry>

#include "meshutils/connected_mesh.h"
#include "meshutils/face_region.h"
#include "geomutils/Region.h"
#include "geomutils/limits.h"

#include "mesh.h"
#include "instance.h"
#include "optimize.h"

/**
 * Orientation optimization of a mesh.
 *
 * This file contains an implementation of an optimization problem that uses the
 * 3D mesh geometry and basic plate slicing.
 */

namespace LibThing {

class OrientProblem;

/**
 * An OrientedMesh is a candidate solution for the OrientProblem, and represents
 * a simplified mesh with an x/y axis transformation.
 *
 * Also contains the derived geometries and stats needed to evaluate how "good"
 * an orientation it is wrt stability and surface quality.
 *
 * Must be efficiently copyable, sharable, so geometry is contained within
 * shared pointers.
 */
struct THING_API OrientedMesh {

    // Mesh information

    Eigen::Vector3f euler_angles;
    std::shared_ptr<Instance> rotated_instance;
    geomutils::Limits rotated_limits;
    float surface_area;
    bool is_watertight;

    // Stability

    std::shared_ptr<geomutils::Region> plated_region;
    std::shared_ptr<geomutils::Region> plated_hull;

    float plated_area = 0.0;
    float plated_hull_area = 0.0;
    float plate_torque = 0.0;

    // Surface Quality

    struct UnsupportedElements {
        std::set<ConnectedMesh::FaceHandle> faces;
        std::set<ConnectedMesh::EdgeHandle> edges;
        std::set<ConnectedMesh::VertexHandle> vertices;

        std::vector<FaceRegion> face_regions;
        std::list<FaceRegion::Group> face_groups;
    };

    typedef std::map<const ConnectedMesh*, UnsupportedElements>
        UnsupportedElementMap;

    std::shared_ptr<UnsupportedElementMap> unsupported_mesh_elements;

    UnsupportedElements& getUnsupportedElements(const ConnectedMesh* mesh) {
        if (!unsupported_mesh_elements)
            unsupported_mesh_elements.reset(new UnsupportedElementMap());
        return (*unsupported_mesh_elements)[mesh];
    }

    std::vector<float> unsupported_group_areas;
    float total_unsupported_group_area = 0.0;

    std::vector<float> unsupported_projected_areas;
    float total_unsupported_projected_area;

    std::vector<float> unsupported_unplated_areas;
    float total_unsupported_unplated_area = 0.0;

    std::string toDebugString() const;
};

/**
 * A search problem which attempts to find a mesh with orientation that:
 *
 * 1) Is stable enough to print
 * 2) Prints with less and more consolidated support.
 *
 * An OrientProblem search works on an (optionally) simplified version of an
 * input Mesh, given parameters related to the maximum supported angles and
 * layer height.
 */
class THING_API OrientProblem : public MetricSearchProblem<OrientedMesh> {
public:
    OrientProblem(const Mesh& mesh,
                  int max_simple_faces = 2000,
                  float min_component_surface_area = 0.0f);

    OrientProblem(ConnectedMesh& mesh,
                  int max_simple_faces = 2000,
                  float min_component_surface_area = 0.0f);

    OrientProblem(const Mesh& mesh,
                  const Eigen::Vector3f& scale,
                  int max_simple_faces = 2000,
                  float min_component_surface_area = 0.0f);

    OrientProblem(std::shared_ptr<Mesh> mesh,
                  const Eigen::Vector3f& scale,
                  int max_simple_faces = 2000,
                  float min_component_surface_area = 0.0f);

    virtual ~OrientProblem();

    const Mesh& getSimpleMesh() const;

    bool isMeshWatertight() const;

    float getMeshSurfaceArea() const;

    //
    // Search problem implementation
    //

    OrientedMesh getCandidate(const Eigen::Vector3f& euler_angles) const;

    OrientedMesh randomCandidate(SimpleRandom& random) const override;

    OrientedMesh randomNormalCandidate(SimpleRandom& random) const;

    OrientedMesh randomNeighbor(const OrientedMesh& candidate,
                                SimpleRandom& random) const override;

    Eigen::Vector3f getScoreVector(const OrientedMesh& oriented_mesh) const;

    bool isBetter(const OrientedMesh& a, const OrientedMesh& b) const override;

    float getDistance(const OrientedMesh& a,
                      const OrientedMesh& b) const override;

    /**
     * Configuration parameters which affect the OrientProblem score
     * computation.  Parameters which do not affect score should be standard
     * fields.
     */
    struct THING_API Config {

        Config();

        float layer_height;
        int num_plate_slices;
        int num_torque_shells;

        float max_supported_angle_rads;
        float min_supported_edge_grade_rads;
        float face_grouping_distance_mm;

        bool stability_scoring;
        bool surface_quality_scoring;
    };

    Config& getConfig();

    struct THING_API Stats {

        Stats();

        long simplify_time_ms;
        long build_candidate_time_ms;
        long eval_candidate_time_ms;

        long eval_stability_time_ms;
        long eval_faces_time_ms;
        long eval_edges_time_ms;
        long eval_vertices_time_ms;
        long eval_face_groups_time_ms;

        std::vector<long> debug_times;
    };

    const Stats& getStats() const;

    /**
     * Returns an oriented version of a mesh, optimized for printing.
     *
     * Helper for code that wants to drive simple orientations without dealing
     * with setting up the search Problem or choosing an Optimizer.
     */
    static OrientedMesh getAutoOrientation(
        const Mesh& mesh,
        Transform transform,
        int max_simple_faces,
        long max_time_ms,
        const Config* optional_config = nullptr,
        bool verbose = false);


    //
    // Geometry helpers
    //

    static Eigen::Matrix3f eulerToMatrix(const Eigen::Vector3f& euler_angles);

    static Eigen::Quaternionf eulerToQuaternion(
        const Eigen::Vector3f& euler_angles);

    static Eigen::Vector3f quaternionToEuler(
        const Eigen::Quaternionf& quaternion);

    static float angleToZAxis(const Eigen::Vector3f& normal);

    static std::shared_ptr<Mesh> buildSimpleMesh(const Mesh& mesh,
                                                 int desired_faces,
                                                 float min_surface_area = 0.0);

    //
    // Exposed for testing
    //

    OrientedMesh buildCandidate(const Eigen::Vector3f& euler_angles) const;

    void evaluateCandidate(OrientedMesh& candidate) const;

    /**
     * Unsupported angles are specified with respect to the positive z-axis -
     * usually all upward faces with angles < 90 degrees are naturally supported,
     * but at some angle > 90 downward faces require support.  In 2015, the
     * threshold angle was usually specified as something like 70 degrees downward,
     * or (in this system) any face with z-axis angle > (90 + 70) degrees.
     *
     *  (+Z)
     *   ^   ^ (normal)
     * \ |  /
     *  \|a/ <- a = angle from vertical < 90 degrees
     *   \/
     *   |\ <- upward face
     *   | \
     *   |  |
     *   |  |
     *   | /
     *   |/ <- downward face
     *   /\
     *  /|a\ <- a = angle from vertical > 90 < 180
     * / |  \
     *   |   V
     *   |
     * ------  (XY plate)
     */
    static bool isSupportedFace(const ConnectedMesh& mesh,
                                ConnectedMesh::FaceHandle face_handle,
                                float max_supported_angle_rads);

    /**
     * Downward/Unsupported edges are outward edges which are local minima of
     * the connected edges.
     * These edges can also be filtered by a particular minimum angle which can
     * be supported between faces - this angle is different from the unsupported
     * face angle, since overhangs of points can be greater than non-points.
     *
     *
     *         B
     *       /
     *     / <- downward angle/grade to the build plate
     *   / ------
     *  A
     */
    static bool isDownwardEdge(const ConnectedMesh& mesh,
                               ConnectedMesh::EdgeHandle edge_handle,
                               float min_supported_edge_grade_rads);

    /**
     * Returns the average normal of the faces surrounding a vertex.
     */
    static Eigen::Vector3f getVertexNormal(
        const ConnectedMesh& mesh, ConnectedMesh::VertexHandle vertex_handle);

    /**
     * Downward/Unsupported vertices are local minima of the surrounding mesh.
     */
    static bool isDownwardVertex(const ConnectedMesh& mesh,
                                 ConnectedMesh::VertexHandle vertex_handle);

    /**
     * Returns a rough estimate of the percentage of a face which is within
     * num_plate_slices of the build plate.
     */
    static float getPlateFaceFraction(const ConnectedMesh& mesh,
                                      ConnectedMesh::FaceHandle face_handle,
                                      float z_min,
                                      float layer_height,
                                      int num_plate_slices);

    /**
     * Returns a value proportional to the amount of torque applied to the
     * plated area of a model, based on the center of mass of the mesh.
     *
     * If num_torque_shells > 0, the value is computed based on the center of
     * mass of N shells of the mesh, which is more useful when the meshes are
     * not watertight.
     */
    static float getPlateTorque(const std::vector<ConnectedMesh>& meshes,
                                int num_torque_shells,
                                const geomutils::Region& plated_hull,
                                float plate_z);

private:
    void initialize(const Mesh& original_mesh);

    Eigen::Vector3f m_mesh_scale;
    std::shared_ptr<Mesh> m_mesh;
    int m_max_simple_faces;
    float m_min_component_surface_area;

    Config m_config;

    bool m_is_mesh_watertight;
    std::vector<Eigen::Vector3f> m_mesh_normals;
    float m_mesh_surface_area;

    mutable Stats m_stats;
};
}
