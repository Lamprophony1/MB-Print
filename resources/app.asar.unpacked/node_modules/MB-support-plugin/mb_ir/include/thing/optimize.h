
#include <limits>

#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/random/mersenne_twister.hpp>
#include <boost/random/uniform_int_distribution.hpp>
#include <boost/random/uniform_real_distribution.hpp>

#pragma once

namespace LibThing {

struct SimpleRandom;

/**
 * A problem with a search space and candidate solutions.  Candidate solutions
 * can only be compared to one another.
 */
template <typename CANDIDATE>
class SearchProblem {
public:
    virtual ~SearchProblem() {}

    /**
     * Returns a random candidate solution
     */
    virtual CANDIDATE randomCandidate(SimpleRandom& random) const = 0;

    /**
     * Returns a random candidate solution "close" in some way to another
     * candidate solution.
     */
    virtual CANDIDATE randomNeighbor(const CANDIDATE& candidate,
                                     SimpleRandom& random) const = 0;

    /**
     * Returns whether we prefer candidate a to candidate b.
     * Note that neutral preferences are fine, but give less information to the
     * search.
     */
    virtual bool isBetter(const CANDIDATE& a, const CANDIDATE& b) const = 0;
};

/**
 * A search problem which also defines distances between candidate solutions,
 * where the distances are roughly proportional in some way to the relative
 * candidate "score".
 *
 * Note that this candidate "score" does not need to be explicit if it is
 * awkward to compute - just the distance is necessary.
 */
template <typename CANDIDATE>
class MetricSearchProblem : public SearchProblem<CANDIDATE> {
public:
    virtual ~MetricSearchProblem() {}

    /**
     * Returns a distance between candidate a and candidate b.
     * Note that inaccurate distances are fine, but may confuse the search if
     * too inconsistent.
     */
    virtual float getDistance(const CANDIDATE& a, const CANDIDATE& b) const = 0;
};

/**
 * Basic randomization helpers
 */
struct SimpleRandom {

    SimpleRandom(int seed) : rng(seed) {}

    bool randomBool() { return randomInt(0, 1) == 0; }

    int randomInt(int min, int max) {
        return boost::random::detail::generate_uniform_int(rng, min, max);
    }

    float randomFloat(float min = 0.0, float max = 1.0) {
        return boost::random::detail::generate_uniform_real(rng, min, max);
    }

    int randomIndex(size_t size) { return randomInt(0, size - 1); }

    // TODO: Shuffle, select?
    boost::random::mt19937 rng;
};

//
// Search types
//

struct RMHCSchedule {

    RMHCSchedule(long max_neutral_iterations = std::numeric_limits<long>::max())
        : max_neutral_iterations(max_neutral_iterations) {}

    long max_neutral_iterations;
};

struct RMHCStats {
    long num_iterations = 0;
    long num_restarts = 0;
    long total_time_ms = 0;
};

/**
 * A random-mutation-hill-climber search with restart, searches comparable
 * search problems.
 */
template <typename CANDIDATE>
class RMHCSearch {
public:
    typedef RMHCSchedule Schedule;
    typedef RMHCStats Stats;

    RMHCSearch(Schedule schedule = Schedule(), int seed = 0);

    virtual ~RMHCSearch() {}

    void setInitialCandidate(const CANDIDATE& candidate);

    typedef std::function<bool(const CANDIDATE&)> BestVisitor;

    /**
     * Searches using RMHC logic, triggers an optional visitor when the next
     * best candidate is found.
     *
     * Returns the best candidate found so far.  State is maintained - can be
     * called multiple times.
     */
    inline const CANDIDATE& search(const SearchProblem<CANDIDATE>& problem,
                                   long max_time_ms,
                                   long max_iterations,
                                   BestVisitor visitor = nullptr);

    const Stats& getStats() const;

    long getCurrNeutralIterations() const;

private:
    Schedule m_schedule;

    bool m_initialized;
    std::unique_ptr<CANDIDATE> m_initial_candidate;
    CANDIDATE m_best_candidate;
    CANDIDATE m_curr_candidate;

    long m_num_neutral_iterations;

    SimpleRandom m_random;
    Stats m_stats;
};

struct SASchedule {

    SASchedule(float initial_temp, float cooling_factor)
        : initial_temp(initial_temp), cooling_factor(cooling_factor) {}

    float initial_temp;
    float cooling_factor;
};

struct SAStats {
    long num_iterations = 0;
    long num_restarts = 0;
    long num_backtracks = 0;
    long total_time_ms = 0;
};

/**
 * A simulated-annealing search with configurable initial temp and cooling, (and
 * implicit restart if an acceptable candidate is not yet found).
 *
 * The initial temperature should be something like 2x the expected score
 * differences of random candidates - this ensures something like exp(-0.5)=60%
 * of the time we'll initially choose a worse candidate.
 *
 * Cooling rate should be tuned based on the number of local minima in the
 * landscape.
 */
template <typename CANDIDATE>
class SASearch {
public:
    typedef SASchedule Schedule;
    typedef SAStats Stats;

    SASearch(Schedule schedule, int seed = 0);

    virtual ~SASearch() {}

    void setInitialCandidate(const CANDIDATE& candidate);

    typedef std::function<bool(const CANDIDATE&)> BestVisitor;

    /**
     * Searches using SA logic, triggers an optional visitor when the next
     * best candidate is found.
     *
     * Returns the best candidate found so far.  State is maintained - can be
     * called multiple times.
     */
    inline const CANDIDATE& search(
        const MetricSearchProblem<CANDIDATE>& problem,
        long max_time_ms,
        long max_iterations,
        BestVisitor visitor = nullptr);

    const Stats& getStats() const;

    float getCurrTemp() const;

private:
    const Schedule m_schedule;

    bool m_initialized;
    std::unique_ptr<CANDIDATE> m_initial_candidate;
    CANDIDATE m_best_candidate;
    CANDIDATE m_curr_candidate;

    float m_curr_temp;

    SimpleRandom m_random;
    Stats m_stats;
};

//
// RMHC Implementation
//

template <typename CANDIDATE>
RMHCSearch<CANDIDATE>::RMHCSearch(Schedule schedule, int seed)
    : m_schedule(schedule),
      m_initialized(false),
      m_num_neutral_iterations(0),
      m_random(seed) {}

template <typename CANDIDATE>
void RMHCSearch<CANDIDATE>::setInitialCandidate(const CANDIDATE& candidate) {
    m_initial_candidate.reset(new CANDIDATE(candidate));
}

template <typename CANDIDATE>
inline const CANDIDATE& RMHCSearch<CANDIDATE>::search(
    const SearchProblem<CANDIDATE>& problem,
    long max_time_ms,
    long max_iterations,
    BestVisitor visitor) {

    if (max_time_ms < 0) max_time_ms = std::numeric_limits<long>::max();
    if (max_iterations < 0) max_iterations = std::numeric_limits<long>::max();

    long start_iterations = m_stats.num_iterations;
    auto start_time = boost::posix_time::second_clock::local_time();
    auto elapsed_time = start_time - start_time;

    bool keep_going = true;

    if (!m_initialized) {

        m_best_candidate = m_curr_candidate =
            m_initial_candidate ? *m_initial_candidate
                                : problem.randomCandidate(m_random);
        ++m_stats.num_iterations;

        if (visitor) keep_going = visitor(m_best_candidate);

        m_initialized = true;
    }

    while (keep_going && elapsed_time.total_milliseconds() < max_time_ms &&
           (m_stats.num_iterations - start_iterations) < max_iterations) {

        bool restart =
            m_num_neutral_iterations > m_schedule.max_neutral_iterations;

        if (restart) ++m_stats.num_restarts;

        CANDIDATE next_candidate =
            restart ? problem.randomCandidate(m_random)
                    : problem.randomNeighbor(m_curr_candidate, m_random);
        ++m_stats.num_iterations;

        if (problem.isBetter(next_candidate, m_best_candidate)) {
            m_best_candidate = next_candidate;
            if (visitor) keep_going = visitor(m_best_candidate);
        }

        if (restart || problem.isBetter(next_candidate, m_curr_candidate))
            m_num_neutral_iterations = 0;
        else
            ++m_num_neutral_iterations;

        // NOTE: We explore neutral changes to get better coverage of the
        // fitness landscape
        if (!problem.isBetter(m_curr_candidate, next_candidate)) {
            m_curr_candidate = std::move(next_candidate);
        }

        elapsed_time =
            boost::posix_time::second_clock::local_time() - start_time;
    }

    m_stats.total_time_ms += elapsed_time.total_milliseconds();
    return m_best_candidate;
}

template <typename CANDIDATE>
const typename RMHCSearch<CANDIDATE>::Stats& RMHCSearch<CANDIDATE>::getStats()
    const {
    return m_stats;
}

template <typename CANDIDATE>
long RMHCSearch<CANDIDATE>::getCurrNeutralIterations() const {
    return m_num_neutral_iterations;
}

//
// SA Implementation
//

template <typename CANDIDATE>
SASearch<CANDIDATE>::SASearch(Schedule schedule, int seed)
    : m_schedule(schedule),
      m_initialized(false),
      m_curr_temp(-1),
      m_random(seed) {}

template <typename CANDIDATE>
void SASearch<CANDIDATE>::setInitialCandidate(const CANDIDATE& candidate) {
    m_initial_candidate.reset(new CANDIDATE(candidate));
}

template <typename CANDIDATE>
inline const CANDIDATE& SASearch<CANDIDATE>::search(
    const MetricSearchProblem<CANDIDATE>& problem,
    long max_time_ms,
    long max_iterations,
    BestVisitor visitor) {

    if (max_time_ms < 0) max_time_ms = std::numeric_limits<long>::max();
    if (max_iterations < 0) max_iterations = std::numeric_limits<long>::max();

    long start_iterations = m_stats.num_iterations;
    auto start_time = boost::posix_time::second_clock::local_time();
    auto elapsed_time = start_time - start_time;

    bool keep_going = true;

    if (!m_initialized) {

        m_best_candidate = m_curr_candidate =
            m_initial_candidate ? *m_initial_candidate
                                : problem.randomCandidate(m_random);
        ++m_stats.num_iterations;

        if (visitor) keep_going = visitor(m_best_candidate);

        m_curr_temp = m_schedule.initial_temp;

        m_initialized = true;
    }

    while (keep_going && elapsed_time.total_milliseconds() < max_time_ms &&
           (m_stats.num_iterations - start_iterations) < max_iterations) {

        bool restart = m_curr_temp <= std::numeric_limits<float>::epsilon();

        if (restart) {
            m_curr_temp = m_schedule.initial_temp;
            ++m_stats.num_restarts;
        }

        CANDIDATE next_candidate =
            restart ? problem.randomCandidate(m_random)
                    : problem.randomNeighbor(m_curr_candidate, m_random);
        ++m_stats.num_iterations;

        if (problem.isBetter(next_candidate, m_best_candidate)) {
            m_best_candidate = next_candidate;
            if (visitor) keep_going = visitor(m_best_candidate);
        }

        float distance =
            std::abs(problem.getDistance(next_candidate, m_curr_candidate));

        bool is_not_worse = !problem.isBetter(m_curr_candidate, next_candidate);

        bool should_explore =
            !is_not_worse &&
            m_random.randomFloat() < std::exp(-distance / m_curr_temp);

        // NOTE: We accept neutral changes to better explore the fitness
        // landscape
        if (is_not_worse || should_explore) {
            m_curr_candidate = std::move(next_candidate);
        }

        if (should_explore) ++m_stats.num_backtracks;

        m_curr_temp *= m_schedule.cooling_factor;

        elapsed_time =
            boost::posix_time::second_clock::local_time() - start_time;
    }

    m_stats.total_time_ms += elapsed_time.total_milliseconds();
    return m_best_candidate;
}

template <typename CANDIDATE>
const typename SASearch<CANDIDATE>::Stats& SASearch<CANDIDATE>::getStats()
    const {
    return m_stats;
}

template <typename CANDIDATE>
float SASearch<CANDIDATE>::getCurrTemp() const {
    return m_curr_temp;
}

} /* namespace */
