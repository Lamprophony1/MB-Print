// Copyright 2013 MakerBot Industries

#ifndef INCLUDE_THING_MESH_H_
#define INCLUDE_THING_MESH_H_

// See MW-2333
#if defined(__unix__) || defined(__unix)
#include <unistd.h>
#endif

#include <Eigen/Core>
#include <Eigen/Geometry>

#include <memory>
#include <set>
#include <string>
#include <vector>

#include "thing/transform.h"
#include "thing/file_id.h"
#include "meshutils/connected_mesh.h"

struct aiScene;

namespace LibThing {

typedef float ScalarF;
typedef Eigen::Vector3f Vector;
typedef Eigen::AlignedBox<ScalarF, 3> AlignedBox;
typedef Eigen::Matrix4f Matrix4x4;

/// A 3D vertex
struct THING_API Vertex {
  Vector location;
};

/// A 3D triangle
struct THING_API Triangle {
  Vertex vertices[3];
  Vector normal;
};

/// A 3D triangle that indexes into a vertex list
struct THING_API IndexedTriangle {
  unsigned int vertices[3];
};

Vector calculateNormal(const Vector &v0, const Vector &v1, const Vector &v2);

/// A collection of 3D triangles
///
/// Meshes can only be created through the static methods
/// fromFileName() and fromMemory(). Meshes are cached internally, so
/// loading a duplicate mesh may just return a duplicate Mesh pointer.
///
/// Meshes are reference counted; call the release() method to
/// decrement the reference count.
class THING_API Mesh {
 public:
  /// Create a mesh from a file
  ///
  /// Do not directly delete the result. Instead, call release(). If an error
  /// occurs while reading the mesh, throws a LibThing::IOError of type
  /// kOpenForReadFailed.
  static std::shared_ptr<Mesh> fromFileName(
    const std::string &fileName,
    const std::string &name,
    const Thingiverse::FileID fileId);

  static std::shared_ptr<Mesh> fromFileName(
    const std::string &fileName,
    const std::string &name);

  /// Create a mesh from a memory buffer
  ///
  /// Do not directly delete the result. Instead, call release(). If an error
  /// occurs while reading the mesh, throws a LibThing::IOError of type
  /// kOpenForReadFailed.
  static std::shared_ptr<Mesh> fromMemory(
    const std::vector<char> &memory,
    const std::string &filePath,
    const std::string &name,
    const std::string &hint);

  // Create a mesh directly from a ConnectedMesh
  // TODO(hqd): Fixup api so we can pass in a const mesh here?
  static std::shared_ptr<Mesh> fromConnectedMesh(ConnectedMesh& conn_mesh);

  // Create an empty mesh with just a name
  static std::shared_ptr<Mesh> emptyMesh(const std::string &name,
                                         bool moveToCache = true);

  static void printMeshCacheInfo();

  static std::shared_ptr<Mesh> moveToMeshCache(std::shared_ptr<Mesh> mesh);

  /// Read a mesh from an Asset-Importer scene, store as a connected mesh
  void meshFromTriangleList(const std::vector<Vertex> & vertexList,
                            const std::vector<IndexedTriangle> & triangleList);

  ~Mesh();

  // Adds a connected mesh to the full libthing mesh
  void addConnectedMesh(ConnectedMesh& conn_mesh,
                        bool separate_components = true);

  /// Return connected meshes
  const std::vector<ConnectedMesh> &getConnectedMeshes() const;

  /// Compare two meshes for equality
  ///
  /// Meshes are considered identical if they have the same filepath
  /// AND the same name
  bool operator==(const Mesh &other) const;

  // Exporters

  /// Write out a chunk of triangles (not a complete ASCII STL file)
  void writeStlAscii(std::ostream *out, const Transform *transform) const;

  /// Write out a chunk of triangles (not a complete Binary STL file)
  void writeStlBinary(std::ostream *out, const Transform *transform) const;

  /// Get an axis-aligned bounding box in local coordinate space
  ///
  /// Note that this does not refresh the bounding box
  const AlignedBox &aabb() const;

  /// Calculate an axis-aligned bounding box in non-local coordinates
  ///
  /// This box is not cached. The purpose is to get a bounding box for
  /// the mesh within a larger scene in which the mesh might be
  /// rotated or scaled.
  AlignedBox nonLocalAabb(const Matrix4x4 &matrix) const;

  /// Recalculate the cached axis-aligned bounding box
  void updateAabb();

  /// Set the mesh name
  ///
  /// Note that the result returned by name() may not exactly match
  /// this input, as mesh names are required to be unique.
  void setName(const std::string &name);

  /// Get the name
  std::string name() const;

  /// Get the unique name
  std::string uniqueName() const;

  /// Sets the file path for the mesh, which is used to upload to the file
  /// to thingiverse
  void setFilePath(const std::string &filePath);

  /// Gets the file path for the mesh.
  std::string filePath() const;

  /// Sets the thingiverse file id for the mesh, which we want to know
  void setFileId(const Thingiverse::FileID fileId);

  /// Gets the Thingiverse File ID for the mesh.
  Thingiverse::FileID fileId() const;

  /// Find intersection between the mesh and a ray
  ///
  /// Return true if an intersection is found, false otherwise. If an
  /// intersection is found, t will contain the distance from rayStart
  /// to the point of intersection to closest to rayStart.
  bool intersectRay(const Eigen::Vector3f &rayStart,
                    const Eigen::Vector3f &rayDir,
                    float *t) const;

  void getTransformedConnectedMeshes(const Transform& transform,
            std::vector<ConnectedMesh> & transformedMeshes) const;

  /// Add primitives from m_connectedMeshes to cmesh
  void concatenateConnectedMeshes(const Transform& transform,
    ConnectedMesh& cmesh) const;

  ////////// Functions related to manifold analysis/repair

  // Check if all connected meshes are manifold.
  bool isManifold() const;

  // Return a vector of booleans, indicating whether each connected mesh is
  // manifold or not.
  std::vector<bool> getConnectedMeshesManifoldness() const;

  bool isWatertight() const;

 private:
  /// Create an empty mesh
  Mesh();

  /// Read a mesh from a file
  ///
  /// The bounding box is updated after loading. Throws a LibThing::IOError if
  /// unsuccessful.
  void readFromFileName(const std::string &fileName,
                        const std::string &name,
                        const Thingiverse::FileID fileId);

  void readFromFileName(const std::string &fileName,
                        const std::string &name);

  /// Read a mesh from memory
  ///
  /// The bounding box is updated after loading. Throws a LibThing::IOError if
  /// unsuccessful.
  void readFromMemory(const std::vector<char> &memory,
                      const std::string &filePath,
                      const std::string &name,
                      const std::string &hint);

  /// Read a mesh from an Asset-Importer scene, store as a connected mesh
  void meshFromScene(const aiScene *scene);

  //  Attempt to load Assimp scene from memory.
  //  Returns true if scene is sucessfully loaded.
  bool loadAssimpMeshFromMemory(const std::vector<char> &memory,
                                const std::string &hint,
                                std::string &error);

  /// Attempt to read a binary STL from a file
  ///
  /// Throws LibThing::IOError if unsuccessful.
  void readBadBinarySTLFromFile(const std::string &fileName);

  /// Attempt to read a binary STL from memory
  ///
  /// Just like when readFromFileName tries readBadBinarySTL when something
  /// goes wrong. readFromMemory will try readBadBinarySTLFromMemory.
  void readBadBinarySTLFromMemory(const std::vector<char> &memory);

  /// Process connected mesh after reading from Assimp or triangle list
  void processMesh(ConnectedMesh& cmesh,
                   int invalid_face_cnt,
                   bool separate_components = true);

  /// An arbitrary name, usually related to the filename
  std::string m_name;

  /// The file path where the mesh came from
  std::string m_filePath;

  /// The Thingiverse File ID for the mesh
  Thingiverse::FileID m_fileId;

  /// Name + unique number guarantees that each cached mesh has a unique
  // name to be used in the manifest when exported into Thing file.
  unsigned m_unique;

  AlignedBox m_aabb;

  /// Customized OpenMesh mesh.  One for each component
  std::vector<ConnectedMesh> m_connectedMeshes;
};
}

#endif  // INCLUDE_THING_MESH_H_
