#ifndef ABSTRACT_TRANSCEIVER_HH
#define	ABSTRACT_TRANSCEIVER_HH

#include <cstdint>
#include <vector>
#include <memory>
#include "machine_definitions.hh" // Codegen'd in MBCoreUtils
#include "machine_errors.hh"

/** @brief Base class for communicating with movement hardware/simulators
 *
 * This is a pure virtual base class that defines the interface between our
 * acceleration algorithms and the low level hardware that actually executes
 * movement.  The API is very much optimized for the real time motion control
 * code we have developed, though it certainly may be used in other ways.
 * This should be subclassed concretely and passed to the acceleration manager
 * constructor in order to process movement commands.
 */
class ACCELERATION_API AbstractTransceiverV2 {
  public:
    virtual ~AbstractTransceiverV2() {}

    /** @brief Basic representation for motion of one axis in steps and ticks
     *
     * This structure contains every piece of information necessary to instruct
     * one axis exactly how to move for a certain period of time (specifically
     * for a fixed number of "ticks").
     */
    struct ConvertedMove {
        ConvertedMove();

        /** @brief The initial unsigned velocity of the move
         *
         * Represents how many fractional steps per tick we will move our
         * axis at the start of the move.  This is a positive value no matter
         * what direction we are moving in so that this can be as high as
         * 2^32 - 1, effectively 1 step every tick.
         */
        uint32_t velocity_fsteps_per_tick;

        /** @brief The acceleration of the move
         *
         * This value is added to the above velocity value on every tick,
         * making the units of this acceleration fractional steps per tick
         * squared.  If the value is positive we are speeding up, if it is
         * negative we are slowing down.
         */
        int32_t acceleration_fsteps_per_tick_sq;

        /** @brief The duration of the move in ticks */
        uint32_t ticks;

        /** @brief The deceleration to apply when suspending
         *
         * This is expected to be a negative value since we always want to slow
         * down when pausing, and is applied the same way as normal acceleration
         * so units are also fractional steps per tick squared.  This only kicks
         * in when pausing at the end of this move command with suspend_ok set.
         */
        int32_t suspend_decel;

        /** @brief The number of ticks to decelerate for when suspending
         *
         * When suspend_ok is set and we receive an attempt to pause, this
         * determines how many extra ticks we add to the end of the move
         * to slow down before actually pausing.  This can be set to zero
         * to indicate that we can instantly pause at the end of the move.
         */
        uint32_t suspend_ticks;

        /** @brief The index of the parser command which generated this move
         *
         * This just passes through whatever values were passed in as parser
         * indices along with input move commands.  A few legacy features do
         * actually use this value and expect it to either increment or be -1,
         * but honestly the only real reason to have this here is debugging.
         */
        int32_t parser_index;

        /** @brief The index of the machine command which generated this move
         *
         * This just passes through whatever values were passed in as command
         * indices along with input move commands.  Nothing internally uses
         * this value
         */
        uint16_t command_index;

        /** @brief The axis which should execute this move */
        machine::AxisName axis;

        /** @brief The direction of this move
         *
         * If true, the internally tracked position should only increase while
         * executing this move -- if false it should only decrease (it may do
         * neither if the velocity is zero).  Moves do not intentionally change
         * direction by decelerating down past zero, though it is certainly
         * possible to end up accidentally decelerating slightly past zero at
         * the end of a move due to rounding error, so the hardware should be
         * set up to handle this in a reasonable way.
         */
        bool direction_is_positive;

        /** @brief Whether end of move suspend is allowed
         *
         * If this is set to true, any attempt to pause while this command is
         * being executed should be deferred until the end of the move, at
         * which point an additional deceleration move should be performed
         * according to suspend_decel and suspend_ticks.  Currently if this
         * flag is not set, it is intended for any attempt to pause to be
         * deferred until the next command (which will than also check this
         * flag to determine what to do).  However we expect that additional
         * flags may be added in the future to specify alternate ways to handle
         * pause requests...
         */
        bool suspend_ok;

        /** @brief Whether this move is intended to be interruptible
         *
         * Most moves that the acceleration algorithm outputs are intended to
         * be immediately followed by another move -- the very next tick after
         * the last tick of one move should be processing the first tick of the
         * next move.  This flag is set when that is not the case -- when it
         * should not be considered a stall error that no following move is
         * ready to execute when this move is finished.  This will always be
         * set at the end of every input move that was entered during expend
         * mode.
         *
         * TODO(chris): This is being set at the end of every input move when
         * not in expend mode, which is not really accurate because these moves
         * are blended and stalling in between them is still an error.
         */
        bool halt_ok;
    };

    typedef std::vector<ConvertedMove> ConvertedMoves;

    /** @brief Used for net displacement in fractional steps across all axes */
    typedef std::vector<int64_t> Displacement;

    /** @brief Command an arbitrary number of moves across various axes
     *
     * The vector moves will contain an ordered sequence of moves for each
     * axis interleaved in an unspecified order.  In expend mode, the sequence
     * for every axis will have the same number of ticks, and the hardware is
     * expected to execute each of these sequences in sync.  Outside of expend
     * mode, the behavior is the same except that the entire sequence of calls
     * to Move until expend mode is activated again is considered to be one
     * large vector of moves containing interleaved sequences.  So if in one
     * call to Move, axis X runs out of moves 100 ticks before axis Y, the
     * the first 100 ticks of axis X from the next call will need to be synced
     * with the last 100 ticks of axis Y from this call, and then the rest of
     * the axis Y commands from the next call will continue to be 100 ticks
     * behind.  (At the time of writing every call to Move is still exactly
     * the same duration for every axis and before this changes hopefully some
     * more explicit limits will be placed on how far axes can be split between
     * moves.)
     *
     * Returns a vector indicating the net displacement for each axis across
     * the entire sequence of moves provided.  The return vector ordering is
     * always the standard axis ordering regardless of what order axes are
     * interleaced in the move vector.
     */
    virtual Displacement Move(const ConvertedMoves & moves) = 0;

    /** @brief Dictate whether additional commands will be sent
     *
     * Before any call to Move, this method will be queried until it returns
     * false, so this can be used to block commands from being sent to the
     * hardware for any reason.  But there isn't really a hard upper bound on
     * the number of commands that might be in a move command, nor is there
     * any way to not accept ownership of the entire move command once Move is
     * invoked, so this API can't really be used to directly wrap a fixed size
     * buffer without wasting a ton of buffer space for safety.  In practice
     * we always have an arbitrarily expandible overflow buffer in front of
     * our fixed size buffers accesible from the real time hardware, and just
     * use this method to keep this buffer from growing out of control.
     */
    virtual bool BufferIsFull() = 0;
};

class ExtruderInterface;

/** @brief Legacy base class for communicating with hardware
 *
 * This base class should be replaced by the above class in all actively
 * maintained subclasses as soon as possible.  It will take a major refactor
 * to remove it from birdwing however, so this will probably not go away any
 * time soon.  Below is the prexisting documentation for this base class.
 *
 * The purpose of this class is to separate the act of communicating
 * with the toolhead and pru from the calculations to convert commands
 * from mm+sec to steps+ticks. This is a pure virtual base class that defines
 * the interface. At least one implementation will communicate with
 * libstepper and toolhead manager. One implementation will log commands
 * to a file. There is no reason why future derived classes cannot do
 * more creative things.
 *
 * This interface only encompasses the parts of communication with toolhead and
 * PRU that are relevant to the acceleration manager.
 *
 * An important goal is to leave all computation to StepperConversions.
 * Accept input in steps and ticks. Try to avoid doing math in this class.
 */
class ACCELERATION_API AbstractTransceiverV1 {
  public:
    /** @brief Basic representation for motion of one axis in steps and ticks
     *
     * The interpretation of steps and ticks is assumed to be correct for
     * the axis name specified. No further computation will be done on
     * these values. They will merely be forwarded to the appropriate
     * destination.
     * It is up to StepperConversions to account for any differences in
     * step size and tick duration between different axes.
     * Certain destinations and usages are expected to ignore some
     * fields of this struct
     */
    struct ConvertedMove {
        ConvertedMove();
        machine::AxisName m_axis;
        int32_t m_velocity_steps_per_tick;
        int32_t m_acceleration_steps_per_tick_sq;
        uint32_t m_ticks;
        int32_t m_advance;
        int32_t m_parser_index;
        uint16_t m_command_index;
        int32_t m_delta_steps;
        bool m_direction_is_positive;
        bool m_pause_ok;
        int32_t m_suspend_decel;
        uint32_t m_suspend_ticks;
        bool m_last_move_of_parser_command;
        std::string to_string() const;
    };
    typedef std::vector<ConvertedMove> ConvertedMoveAxes;
    typedef std::array<ConvertedMoveAxes, 3> ConvertedMoveTrapezoid;
    typedef std::vector<int64_t> PositionCorrection;
    typedef std::array<PositionCorrection, 3> TrapezoidPositionCorrection;
    virtual ~AbstractTransceiverV1() {}
    virtual PositionCorrection Move(const ConvertedMoveAxes& move) = 0;
    virtual TrapezoidPositionCorrection
        MoveTrapezoid(const ConvertedMoveTrapezoid& trapezoid) = 0;
    virtual machine::Error SetPosition(const machine::AxisName axis,
                                       const int32_t position_steps) = 0;
    virtual void ChangeTool(std::shared_ptr<ExtruderInterface> extruder) = 0;
    virtual machine::Error SetFilamentFan(uint8_t index, bool activate) = 0;
    virtual machine::Error SetFilamentFanDuty(uint8_t index, float duty) = 0;
    virtual bool BufferIsFull(bool require_suspend_decel) const = 0;
    virtual std::vector<double> GetTickTimes() const = 0;
    virtual std::vector<uint8_t> GetRadices() const = 0;
    virtual machine::Error
        GetAxesPositions(std::vector<int32_t>* axes_position_steps) const = 0;
    virtual size_t AxisCount() const = 0;
    virtual size_t MaxAxisCount() const = 0;
    virtual bool IsValidToolhead(machine::AxisName axis) const = 0;
    virtual std::vector<machine::AxisName> GetToolheadAxes() const = 0;
    virtual std::vector<machine::AxisName> GetGantryAxes() const = 0;
    virtual std::vector<machine::AxisName> GetAssistAxes() const = 0;
};

/** @brief NullTransciever discards all inputs */
class ACCELERATION_API NullTransceiver : public AbstractTransceiverV1 {
public:
    virtual PositionCorrection Move(const ConvertedMoveAxes& move) override;
    virtual TrapezoidPositionCorrection
        MoveTrapezoid(const ConvertedMoveTrapezoid& trapezoid) override;
    virtual machine::Error SetPosition(
            const machine::AxisName axis,
            const int32_t position_steps) override;
    virtual void ChangeTool(std::shared_ptr<ExtruderInterface> extruder) override;
    virtual machine::Error SetFilamentFan(uint8_t index, bool activate) override;
    virtual machine::Error SetFilamentFanDuty(uint8_t index, float duty) override;
    virtual bool BufferIsFull(bool require_suspend_decel) const override;
    virtual machine::Error GetAxesPositions(
            std::vector<int32_t>* axes_position_steps) const override;
    virtual std::vector<double> GetTickTimes() const override;
    virtual std::vector<uint8_t> GetRadices() const override;
    virtual size_t AxisCount() const;
    virtual size_t MaxAxisCount() const;
    virtual bool IsValidToolhead(machine::AxisName axis) const override;
    virtual std::vector<machine::AxisName> GetToolheadAxes() const override;
    virtual std::vector<machine::AxisName> GetGantryAxes() const override;
    virtual std::vector<machine::AxisName> GetAssistAxes() const override;
 protected:
    size_t m_axes;
};

// Avoid needing to make any changes to code using the V1 API
typedef AbstractTransceiverV1 AbstractTransceiver;

#endif	/* ABSTRACT_TRANSCEIVER_HH */
