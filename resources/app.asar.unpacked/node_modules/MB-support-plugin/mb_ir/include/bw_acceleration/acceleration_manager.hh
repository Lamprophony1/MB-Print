#ifndef ACCEL_MANAGER_HH
#define ACCEL_MANAGER_HH
#include "machine_errors.hh" // Codegen'd in MBCoreUtils
#include "mbcoreutils/toolpath_tags.h"
#include <jsoncpp/json/json.h>
#include <memory>
#include <vector>

class AbstractTransceiverV1;
class AbstractTransceiverV2;
class StepperConversions;
class AccelerationManagerImpl;

class ACCELERATION_API AccelerationManager {
    public:
        /** @brief Constructor using the latest transceiver API */
        AccelerationManager(std::shared_ptr<AbstractTransceiverV2> transceiver);

        /** @brief Constructor using the legacy transceiver API */
        AccelerationManager(std::shared_ptr<AbstractTransceiverV1> transceiver);

        /** @brief DEPRECATED constructor from stepper conversions
         *
         * There isn't any reason at all to expose the stepper conversions
         * class in our API.
         */
        AccelerationManager(
            std::shared_ptr<StepperConversions> stepper_conversions);

        ~AccelerationManager();

        /** @brief Return the largest possible number of moves buffered here
         *
         * We can very easily report the buffer to be full with significantly
         * fewer moves buffered, but should never report that there is still
         * room in the buffer when this many moves are buffered, and thus
         * should never have more moves than this buffered.
         */
        size_t BufferSize() const;

        /** @brief "Generator" to allow "non-blocking" initialization
         *
         * We use this pattern of a separate Initialize function to allow
         * coroutine like non-blocking initialization -- the caller should
         * repeatedly call this until it does not return kNotReady and
         * should consider initialization to have errored out if the final
         * call does not return kOk.  In practice there is no initialization
         * here that can block or even error out, and this will always return
         * kOk immediately.  We should probably move all of this into the
         * constructor and deprecate this function...
         */
        machine::Error Initialize();

        /** @brief Load Acceleration settings from JSON
         *
         * This loads all settings for the acceleration manager (it does not
         * by itself change any StepperConversions settings).  Running this
         * also resets all internal buffers of pending moves (and also the
         * legacy nonmove buffer), but does not change expend buffer status
         * or whether acceleration is enabled at all.  (Calling this when
         * moves are still present in the buffers will generally result in
         * unpredictability in which moves are actually executed.)  This
         * executes all functionality in a single call and should never
         * return kNotReady.  It can error out but should generally only
         * do so when passed invalid settings.
         */
        machine::Error LoadSettings(Json::Value settings);

        /** @brief Run internal processing and produce output moves
         *
         * Internal move processing is split between this function and the
         * various input commands.  This is also the the only API call that
         * results in fully processed move commands being forwarded through
         * stepper conversions to the transceiver (or legacy nonmove commands
         * if those API calls are used).  This should generally be called
         * periodically to keep moves moving through the pipeline as space in
         * the transceiver becomes available.
         *
         * Generally, Iterate will process and output as many buffered commands
         * as it can, stopping either when more input commands are necessary
         * (returning kOk in this case) or when the transceiver indicates that
         * it has no more buffer space (returning kNotReady).  (If legacy
         * nonmove commands are used, other error codes can be returned if the
         * tranceiver's nonmove methods themselves return an error code, though
         * if this happens we still retry the command indefinitely until we get
         * kOk, so that's a thing...)  kNotReady here doesn't necessarily mean
         * that there is no more space for commands, so the caller should still
         * try to add commands and check the return value for success no matter
         * the return value.  kOk does mean that there isn't any point in
         * calling Iterate until more commands are added, but there isn't really
         * much overhead when calling Iterate in this case.  So the return value
         * here isn't especially useful.
         */
        machine::Error Iterate();

        /** @brief Equivalent to ClearBuffer() and ToggleExpendBuffer(true) */
        machine::Error Abort();

        /** @brief Queue a move to be processed and (eventually) commanded
         *
         * Incoming moves just specify a relative distance to travel for every
         * configured axis and a euclidean (root sum of squares) speed cap.
         * Optionally a set of toolpath tags, a distance to the edge of the
         * build volume, and two mostly arbitrary indices to attach to the move
         * can be provided.  The toolpath tags are used to determine whether to
         * apply beadmode settings or whether to apply retract/restart logic
         * (which is really just a special case of beadmode settings).  The
         * distance to the edge is used in the pausing logic to ensure that we
         * can't hit the edge of the build volume and lose position when we
         * pause (this logic _really_ needs to be properly documented).  The
         * command index is completely a passthrough field for use by the
         * caller and the tranceiver, whereas the parser_index is also used
         * by some legacy code (and is often logged alongside warnings and
         * errors as it is very useful for tracking down bugs).
         *
         * Should return kNotReady if there is no room in the buffer for this
         * move, in which case the caller should try again after calling
         * Iterate.  This returns kOk to indicate success, any other return
         * should be an actual error code indicating an error (probably an
         * internal acceleration error that needs to be debugged).
         */
        machine::Error AddMove(const std::vector<float>& delta_mm,
                               const float mm_per_second);
        machine::Error AddMove(const std::vector<float>& delta_mm,
                               const float mm_per_second,
                               const float distance_to_edge,
                               const int32_t parser_index,
                               const uint16_t command_index,
                               const std::vector<MakerBot::ToolpathTag>& tags);

        /** @brief Queue a delay to be processed and (eventually) commanded
         *
         * A delay command is really just a move command that moves no axes for
         * a given amount of time (when we refer to nonmove commands, we are not
         * including delay commands).  The time here is specified in seconds.
         * The same set of passthrough indices from the standard move command
         * can also be specified, but otherwise there aren't really any other
         * parameters to affect how we process this.  Return values are the same
         * as for AddMove.
         */
        machine::Error AddDelay(const float duration,
                                const int32_t parser_index,
                                const uint16_t command_index);

        /** @brief Determine whether the buffer is full
         *
         * Move commands will definitely return kNotReady if this returns true,
         * though they certainly can also return kNotReady if this is false. (If
         * legacy nonmove commands are used they will never block.)
         */
        bool BufferIsFull() const;

        /** @brief Determine whether the buffer is empty
         *
         * This can be used to determine whether there are still any moves to
         * be passed on the transceiver once we are done inputting moves.  If
         * it returns false, continuing to only call Iterate should eventually
         * send at least one more move to the transceiver, and if it returns
         * true, no move command will ever be sent to the transceiever until
         * more commands are added.  This will also always return true after
         * calling any method which clears the buffer (ClearBuffer, Abort, etc).
         */
        bool BufferIsEmpty() const;

        /** @brief Clear the acceleration buffer
         *
         * This stops all ongoing processing of moves and cancels any moves
         * that have been inputted so far but not passed on to the transceiver.
         * Additional positioning state (ie rounding error accumulators) are
         * also reset.  Any positioning tracker based on moves coming in will
         * be corrupted and need to be reset using a tracker that is based on
         * moves coming out.  (If legacy nonmove commands are used these will
         * also be cancelled by this call.)
         */
        void ClearBuffer();

        /** @brief Access to a debugging mode with no move processing
         *
         * This can be used to "turn acceleration off", which basically means
         * that all loaded settings are ignored and our output moves are
         * completely determined by our input moves.  Specifically every input
         * move produces exactly one output move with a constant velocity such
         * that the euclidean speed (root sum of squares of all axis speeds)
         * is equal to the inputted feedrate (delay commands continue to be
         * processed exactly the same way).
         *
         * This is not really tested very much so it may very well be broken.
         * Switching this on and off while the buffer is not empty will likely
         * produce undefined behavior.
         */
        void ToggleAcceleration(bool on);

        /** @brief Determine whether to perform move blending
         *
         * Our default state is to have expend_buffer on, which means that we
         * do not perform move blending and instead have every single input
         * move start by accelerating up from zero velocity and end by
         * accelerating down to zero velocity.  This mode also allows us to
         * execute "one move at a time" (ie command a move, then iterate until
         * it is passed to the transceiver and executed, then command another
         * move).  When we instead turn expend buffer off, only the start of
         * the first move is required to accelerate up from zero velocity, but
         * no commands will be passed on to the transceiver until a large
         * number of commands have been inputted.  When expend buffer is turned
         * back on, we do not clear the buffer, but instead calls to Iterate
         * will output buffered moves as fast as possible regardless of how many
         * moves are in the buffer, and new moves coming in return to being
         * constrained to start and end at zero velocity.  (We _should_ also at
         * the time this is turned back on be constraining the last move
         * remaining in the buffer to end at zero velocity and then executing
         * one last move blending pass, but for now this is up to the caller.)
         *
         * When in expend mode, there are some acceleration constraints that are
         * set to different default values (though if any beadmode tags are
         * present in a move, these constraints go back to the non expend
         * defaults even if they are not overridden in the beadmode).
         */
        machine::Error ToggleExpendBuffer(bool on);

        /** @brief Legacy nonmove command support
         *
         * This mechanism, still used by birdwing, allows the acceleration
         * manager to be in charge of preserving the ordering of all commands
         * that can appear in a toolpath.  We have one method here for every
         * nonmove toolpath command supported by birdwing, and a matching
         * tranceiver method to pass the commmand on.  The acceleration
         * manager does not actually track the order of nonmove commands
         * relative to move commands, relying instead on parser indices to keep
         * track of this (passed in here as "order").  I don't know of any
         * specific bugs in this logic but we do have a lot of reports of this
         * not working correctly...
         */
        void QueueFilamentFan(const uint8_t index, const bool activated, const unsigned int order);
        void QueueTemperatureTarget(const uint8_t index,
                                    const int16_t temperature,
                                    const unsigned int command_order);
        void QueueFilamentFanDuty(const uint8_t index, const float duty, const unsigned int order);

        /** @brief Not really sure what these actually do
         *
         * I can see that seth added these when he was adding support to all of
         * our morepork libraries for adding the source library name to every
         * log entry.  But these aren't actually used anywhere.  Channel logging
         * doesn't actually work for this repo, which may be related to non-use
         * of these functions.  But I suspect the actual reason is that doing
         * channel logging broke MSVC time estimator builds and was hastily
         * neutered.
         */
        static std::string LogChannelName();
        static std::string TelemetryChannelName();

        /** @brief Report per axis tick times in microseconds
         *
         * After LoadSettings has been passed a configuration, this will report
         * the per axis tickrates that this class has inferred from said config.
         * Really this is only useful for the userspace acceleration simulator
         * which is just blindly passing through a config without any idea what
         * hardware to be simulating -- actual hardware using this library will
         * already know its tickrate and pass in the correct settings value.
         */
        std::vector<double> GetTickTimes();
    private:
        std::unique_ptr<AccelerationManagerImpl> impl;
};

#endif
