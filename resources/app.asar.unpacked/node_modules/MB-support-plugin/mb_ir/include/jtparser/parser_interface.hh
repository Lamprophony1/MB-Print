//Copyright 2017 MakerBot Industries
#ifndef JTPARSER_PARSER_INTERFACE_HH
#define JTPARSER_PARSER_INTERFACE_HH

/* This file defines an object that JTParser uses to execute the commands
   that it parses from a JSON Toolpath. The parser must be fed one of these
   objects in its constructor.
 */

#include "machine_errors.hh"
#include "machine_definitions.hh"
#include "mbcoreutils/toolpath_tags.h"

#include <vector>

#ifdef _MSC_VER
#include <stdint.h>
#endif

namespace BirdWing {

struct PARSER_API ParserInterface {
    machine::Error (*Iterate)(void* cb_data);
    machine::Error (*Error)(void* cb_data, bool* error);

    /* Commands:
     *
     * Every command MUST take the callback data pointer as its first argument
     * and the parser_index as the last argument.  Once a given command is
     * invoked, it will be invoked repeatedly with the same arguments until it
     * does not return kNotReady, and no other commands will be invoked in
     * between these repeat calls.  The parser may invoke Reset() to escape
     * from this obligation.  Any return value from a command other than
     * kNotReady or kParseMore will be treated as a critical error that will
     * permanently block further command parsing.
     *
     * Any command function pointer can be populated with a null pointer and
     * the command will be silently ignored.  This allows new functions to be
     * added here for some users of the parser without requiring stub functions
     * to be implemented for all users.
     */

    machine::Error (*Move)(void* cb_data,
                           const std::vector<float>& point_mm,
                           float mm_per_second,
                           const std::vector<bool>& relative,
                           const std::vector<MakerBot::ToolpathTag>& tags,
                           int32_t parser_index);

    machine::Error (*SetExtruderPosition)(void* cb_data,
                                          uint8_t index,
                                          float position,
                                          int32_t parser_index);

    machine::Error (*SetTemperatureTarget)(void* cb_data,
                                           uint8_t index,
                                           int16_t temperature,
                                           int32_t parser_index);

    machine::Error (*WaitForTargetTemperature)(void* cb_data,
                                               uint8_t index,
                                               int32_t parser_index);

    machine::Error (*ToggleFan)(void* cb_data,
                                uint8_t index,
                                bool state,
                                int32_t parser_index);

    machine::Error (*SetFanDuty)(void* cb_data,
                                 uint8_t index,
                                 float duty,
                                 int32_t parser_index);

    machine::Error (*ChangeToolhead)(void* cb_data,
                                     uint8_t index,
                                     const std::vector<double>& endpoint_mm,
                                     int32_t parser_index);

    machine::Error (*Delay)(void* cb_data,
                            float seconds,
                            int32_t parser_index);

    machine::Error (*Pause)(void* cb_data,
                            int32_t parser_index);

    machine::Error (*EnablePurge)(void* cb_data,
                                  bool enable,
                                  float z_position,
                                  int32_t parser_index);

    // End of commands

    uint32_t (*GetMaxSequentialIterates)(void* cb_data);
    uint16_t (*AccelerationBufferSize)(void* cb_data);

    /* Reset any internal interface state
     *
     * Interface providers are free to cache provided arguments from one command
     * call that returns kNotReady and reuse them on the next call, but if they
     * do so they must clear this cache when reset is called.  Alternatively
     * an interface provider can ensure that every command is either executed
     * in its entirety or completely ignored with no state change on every call,
     * in which case this can just be a null pointer.
     *
     * This should only be invoked during pause/resume, so any state changes
     * handled externally by pause/resume logic do not have to be addressed
     * explicitly here (and any applications that do not allow pausing at all
     * can ignore this.
     */
    void (*Reset)(void* cb_data);

    void* cb_data;

    ParserInterface()
          : Iterate(NULL),
            Error(NULL),
            Move(NULL),
            SetExtruderPosition(NULL),
            SetTemperatureTarget(NULL),
            WaitForTargetTemperature(NULL),
            ToggleFan(NULL),
            SetFanDuty(NULL),
            ChangeToolhead(NULL),
            Delay(NULL),
            Pause(NULL),
            EnablePurge(NULL),
            GetMaxSequentialIterates(NULL),
            AccelerationBufferSize(NULL),
            Reset(NULL),
            cb_data(NULL) {
    }
};

}  // namespace BirdWing


#endif  // JTPARSER_PARSER_INTERFACE_HH
