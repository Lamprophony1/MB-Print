// Copyright 2016 MakerBot Industries

#ifndef FIRMWARE_PARSER_SRC_JT_PARSER_HH_
#define FIRMWARE_PARSER_SRC_JT_PARSER_HH_

#include <memory>
#include <string>

#include <boost/circular_buffer.hpp>

#include "jtparser/parser_interface.hh"
#include "jtparser/command.hh"
#include "jtparser/file_reader.hh"

#include "machine_errors.hh"  // Codegen'd in MBCoreUtils
#include "machine_definitions.hh"  // Codegen'd in MBCoreUtils
#include "mbcoreutils/toolpath_tags.h"


namespace BirdWing {

// We avoid keeping a stack of states for parsing and just have
// transition maps for every token we parse.  The *Key states
// are used immediately after parsing a map key, and are named
// first for the name of the map containing them and second for
// what we expect them to contain, either another map/array name,
// "Component" if it should contain a leaf node for which we have
// stored a Command::Component to uniquely identify, or "Unknown"
// if this parser version does not recognize this key.
enum ParserState {
    sStart = 0,
    sEnd,
    sRootArray,
    sPacket,
    sPacketCommandKey,
    sPacketUnknownKey,
    sCommand,
    sCommandFunctionKey,
    sCommandParametersKey,
    sCommandMetadataKey,
    sCommandTagsKey,
    sCommandUnknownKey,
    sParameters,
    sParametersComponentKey,
    sParametersUnknownKey,
    sMetadata,
    sMetadataRelativeKey,
    sMetadataUnknownKey,
    sRelative,
    sRelativeComponentKey,
    sRelativeUnknownKey,
    sTags,
    // Whenever we hit an object or array that we do not expect,
    // but we want to keep parsing, we cache away the state we
    // should transition to afterwards, set our main state to
    // sUnknownValue, and enter a "brace counting" parsing mode.
    sUnknownValue,
    // State for when we decide to just give up on parsing
    sParseError
};

/*
* A JsonToolpathParse.
* The main entry point is "ParseNext".  Takes a
* string filepath, opens the file and incrementally
* parses that json file.
*
* Generally follows the rule that an unexpected key in a json
* object is not an error, and should just be ignored.
*/

class PARSER_API JsonToolpathParser {
  public:
    JsonToolpathParser(size_t axis_count);

    JsonToolpathParser(ParserInterface* machine,
                       std::string const filepath,
                       size_t axis_count,
                       int fd = -1);

    ~JsonToolpathParser();

    /* Parses and executes 0 or more commands from the json file.  Will
     * always stop parsing after executing GetMaxSequentialIterations()
     * commands or after any command returns anything other than
     * kParseMore.  Will sometimes only stop when one of these conditions
     * is met.  If the last ParseNext call ended with a command that
     * returned kNotReady, then we resend just that command and return.
     *
     * Returns the return value from the last command, kNotReady if we
     * hit the iteration maximum, kJsonToolpathNothingParsed if we hit
     * the end of the toolpath, or kJsonToolpathParseError.
     */
    machine::Error ParseNext();

    /* Reset the parser back to a state where it will (by calling Resume)
     * resend commands starting with the command matching the provided
     * parser index.  Will fail if given an index we have not yet sent,
     * an index that is too old to not have already been executed (as
     * determined by AccelerationBufferSize()), or an index that is older
     * than one passed to a previous Suspend call.  Will also fail if we
     * can't find a move command to tell us the position of the suspend
     * command, but this will probably never happen?  Returns kOk on
     * success and kSuspendIndexNotFound for all errors.
     */
    machine::Error Suspend(int suspend_idx, double *suspend_pos_array);

    /* After successfully invoking Suspend, this function should be called
     * in place of ParseNext until this returns kResumeComplete.  Return
     * value and behavior is otherwise the same as ParseNext, although
     * Resume() cannot return parse errors.  Throws an exception when
     * invoked after Suspend failed which is not ideal...
     */
    machine::Error Resume();

    /* Get a string list of tags for the last command parsed (the current
     * command if invoked by that command's handler).  Exposed by the C
     * API but we probably don't need this function.
     */
    std::string const GetTagsAsString();

    /* Get a string that may or may not be descriptive of the last parse
     * error.  This already gets logged by the parser when the error
     * occurs so it seems particularly pointless...
     */
    std::string const GetError();

    /* Get the name of the general-use channel used by this library, if
     * you want to filter it out. This library uses boost::log, and
     * registers a global logger using a channel with this name.
     */
    static std::string LogChannel();

    /* The gantry axes positions read from the toolpath file follow absolute
     * positioning and the extruder axes have relative positions (movement)
     * currently. So when resuming after a suspend, the printer has enough
     * information in the suspended command itself to move the gantry axes
     * and complete the remainder of the move but, since the extrusion move
     * distances are relative they are scaled down and re-written into the
     * suspended command so that the printer doesn't do the whole extrusion
     * in the remaining part of the move.
     */
    void ScaleExtrusion(std::vector<double> suspend_pos);

  private:
    static bool ErrorOK(machine::Error e);
    const size_t axis_count_;
    ParserState state_, unknown_value_cached_state_;
    int unknown_map_count_, unknown_array_count_;
    Command command_;
    Command::Component component_;

    Command *suspended_cmd_, *previous_cmd_;
    int last_suspended_cmd_index_;

    ParserInterface* machine_;

    boost::circular_buffer<Command> suspend_buffer_;
    boost::circular_buffer<Command>::iterator suspend_iterator_;
    int32_t sequence_index_;
    int filesize_;
    machine::Error fill_response_;
    machine::Error iterate_response_;
    uint32_t iteration_count_;

    std::string error_packet_;  // Contains the latest error packet

    std::shared_ptr<FileReader> filereader_;
    std::string filepath_;
    bool initialized_;
    int fd_;

    machine::Error Initialize();
    void InitCommand();
    machine::Error ExecuteCommand();
    int ValidateCommand();
    callbackStatus HandleCommand();
    machine::Error ParseNextImpl();
    int ParseError();
    int UnknownCheck();
    int ProcessFloatComponent(float);

    int ProcessNull();
    int ProcessBoolean(int);
    int ProcessInteger(long long);
    int ProcessDouble(double);
    int ProcessString(unsigned char const *, size_t);
    int ProcessMapKey(unsigned char const *, size_t);
    int ProcessStartMap();
    int ProcessEndMap();
    int ProcessStartArray();
    int ProcessEndArray();

    static int g_processNull(void *);
    static int g_processBoolean(void *, int);
    static int g_processInteger(void *, long long);
    static int g_processDouble(void *, double);
    static int g_processString(void *, unsigned char const *, size_t);
    static int g_processMapKey(void *, unsigned char const *, size_t);
    static int g_processStartMap(void *);
    static int g_processEndMap(void *);
    static int g_processStartArray(void *);
    static int g_processEndArray(void *);
};

}  // namespace BirdWing

#endif  // FIRMWARE_PARSER_SRC_JT_PARSER_HH_
