// Copyright 2o2o MakerBot Industries

#ifndef INCLUDE_MGL_OBJECT_DATA_CHUNK_STACK_H_
#define INCLUDE_MGL_OBJECT_DATA_CHUNK_STACK_H_

#include <map>
#include <memory>
#include <set>
#include <string>
#include <utility>
#include <vector>

#include "gul/CachedLoops.h"
#include "mgl/object_data/chunk_types.h"

namespace Json {
class Value;
}

namespace mgl {

// Forward-declare to avoid exposing chunk_base
class chunk_base;

/**
 * A 2D region with given Z thickness, at a particular Z position.
 *
 * Chunk regions also have a type, which can be used to differentiate chunks for
 * external operations (but does not affect the chunk itself).
 *
 * A Chunk is logically const, copyable and shares geometry information between
 * all its copies.  Internally this information may be referenced from a stream
 * data window and protected by a copy of the window iterator, or new,
 * non-iterator chunks own the geometry information themselves.
 *
 * New chunks always are based on old chunks, for now, this makes it simpler to
 * track external layer attributes (MODEL, SUPPORT, layer base).  Note that this
 * does *not* mean the new chunk cannot have a different position or region,
 * just that global offsets affect it similarly to the old chunk.
 *
 * TODO: Stop tracking these external attributes, use chunk type only?
 * TODO: Chunks may also have a preferred fill orientation?  Or can we do
 * something simpler.
 */
class MGL_API Chunk {
 public:
    typedef ChunkTypes::chunk_t Type;
    typedef ChunkTypes::LayerType_e StructureType;
    typedef size_t ExtruderID;

    /**
     * A chunk's Z position includes where it is placed, as well as how it is
     * placed - a chunk may be drooped, which is logically like it is "dropped"
     * as a tetris piece from a higher location.
     */
    struct MGL_API Position {
        Position(Scalar lower_z, Scalar upper_z, Scalar nozzle_offset = 0.0);

        Scalar lower_z;
        Scalar upper_z;
        Scalar nozzle_offset;

        bool operator<(const Position& other) const {
            if (upper_z != other.upper_z) return upper_z < other.upper_z;
            if (nozzle_offset != other.nozzle_offset)
                return nozzle_offset < other.nozzle_offset;
            return lower_z < other.lower_z;
        }
    };

    Chunk(const Chunk& proto, Type type);

    Chunk(const Chunk& proto,
          const CachedLoops& region,
          const Position& position);

    Chunk(const Chunk& proto,
          Type type,
          const CachedLoops& region,
          const Position& position);

    /**
     * Adapter to ingest chunks from streams.  Do not use otherwise.
     */
    template <typename CHUNK_ITER, typename LAYER_MEASURE>
    Chunk(const CHUNK_ITER& chunk_it,
          const LAYER_MEASURE& layers,
          bool copy = false);

    /**
     * Helper to build new chunks for streams.  Do not use otherwise.
     */
    Chunk(LayerId proto_id,
          Type type,
          StructureType structure_type,
          const CachedLoops& region,
          const Position& position,
          ExtruderID extruder_id,
          Scalar layer_width);

    /**
     * Helper to build new chunks for tests.  Do not use otherwise.
     */
    Chunk(const chunk_base& base_chunk,
          StructureType structure_type,
          const Position& position);

    ~Chunk();

    //
    // Chunk factories for empty chunks of various kinds
    //

    static Chunk empty(const Chunk& proto);

    static Chunk empty(const Chunk& proto, Type type);

    /**
     * Returns a chunk guaranteed lower than any chunk at this z_position.
     */
    static Chunk lowerBound(Scalar z_position);

    /**
     * Returns a chunk guaranteed lower than any chunk at this position.
     */
    static Chunk lowerBound(const Position& position);

    /**
     * Returns a chunk guaranteed higher than any chunk at this z_position.
     */
    static Chunk upperBound(Scalar z_position);

    /**
     * Returns a chunk guaranteed higher than any chunk at this position.
     */
    static Chunk upperBound(const Position& position);

    //
    // Properties
    //

    Type getType() const;

    StructureType getStructureType() const;

    Scalar getLowerZ() const;

    Scalar getUpperZ() const;

    Scalar getMinX() const;

    Scalar getMaxX() const;

    Scalar getMinY() const;

    Scalar getMaxY() const;

    Scalar getNozzleOffset() const;

    Scalar getLayerWidth() const;

    const Position& getPosition() const;

    const ExtruderID getExtruderId() const;

    const CachedLoops& getRegion() const;

    //
    // Methods for converting back to streaming chunk_base representation.
    //

    const chunk_base& getBaseChunk() const;

    bool isInputChunk() const;

    /**
     * Allows for storing chunks in sets, provides a full, strict ordering over
     * all chunks.
     */
    bool operator<(const Chunk& other) const;

 private:
    /**
     * Helper to build new empty chunks for queries.  Do not use otherwise.
     */
    Chunk(const Position& position, bool is_low_bound);

    void calculateXYBounds();

    // The core geometry information - either owned by an iterator or ourselves
    std::shared_ptr<const chunk_base> m_chunk;
    bool m_is_input_chunk;

    StructureType m_structure_type;
    Position m_position;

    Scalar m_x_min;
    Scalar m_x_max;
    Scalar m_y_min;
    Scalar m_y_max;

    ExtruderID m_extruder_id;
    Scalar m_layer_width;
};

std::string to_string(const Chunk& chunk);

/**
 * A ChunkStack is a collection of chunks at various Z-heights, and allows for
 * querying and manipulating the chunks in common ways.
 *
 * Queries on the stack generally return ChunkRef(erences), which can then be
 * used to create new chunks based on old chunks and remove chunks.
 */
class MGL_API ChunkStack {
 public:
    // For efficient queries and other operations, the stack needs to know
    // min/max chunk thicknesses
    static const Scalar default_min_thickness;
    static const Scalar default_max_thickness;

    // The allowable z tolerance between chunks at "equal" positions
    static const Scalar default_z_tolerance;

    ChunkStack();

    ChunkStack(Scalar min_thickness, Scalar max_thickness, Scalar z_tolerance);

    ChunkStack(const ChunkStack& other);

    ChunkStack(ChunkStack&& other);

    ChunkStack& operator=(const ChunkStack& other);

    ChunkStack& operator=(ChunkStack&& other);

    ~ChunkStack();

    Json::Value getStats() const;

    Json::Value getJsonGeometry() const;

    Scalar getMinThickness() const;

    void setMinThickness(Scalar min_thickness);

    Scalar getMaxThickness() const;

    void setMaxThickness(Scalar max_thickness);

    Scalar getZTolerance() const;

    void setZTolerance(Scalar z_tolerance);

    typedef std::multiset<Chunk>::iterator ChunkRef;

    ChunkRef begin() const;

    ChunkRef end() const;

    bool empty() const;

    Scalar getLowerZ() const;

    Scalar getUpperZ() const;

    Scalar getMinX();

    Scalar getMaxX();

    Scalar getMinY();

    Scalar getMaxY();

    size_t size() const;

    /**
     * Adds a chunk to the stack, and returns a reference to the new chunk owned
     * by the stack.
     */
    ChunkRef addChunk(const Chunk& chunk);

    /**
     * Removes a chunk by reference from the stack.
     */
    void removeChunk(ChunkRef chunk);

    /**
     * Adds all the chunks from one stack to another.
     */
    void addAllChunks(const ChunkStack& other);

    /**
     * Returns all the chunk references in the set.
     * Useful for debugging.
     */
    std::vector<ChunkRef> getAllChunks() const;

    /**
     * Removes all the chunks from the stack.
     */
    void clear();

    /**
     * Queries a ChunkStack for chunks overlapping a range.
     */
    std::vector<ChunkRef> getOverlappingChunks(Scalar z_min,
                                               Scalar z_max,
                                               bool min_inclusive,
                                               bool max_inclusive) const;

    /**
     * Queries a ChunkStack for chunks contained in a range.
     */
    std::vector<ChunkRef> getContainedChunks(Scalar z_min,
                                             Scalar z_max,
                                             bool min_inclusive,
                                             bool max_inclusive) const;

    /**
     * Queries a ChunkStack for chunks touching below
     */
    std::vector<ChunkRef> getUpperZChunks(Scalar z_position) const;

    /**
     * Queries a ChunkStack for chunks touching below
     */
    std::vector<ChunkRef> getLowerZChunks(Scalar z_position) const;

    static std::pair<Scalar, Scalar> getOverlappingRange(const Chunk& chunk_a,
                                                         const Chunk& chunk_b);

    static std::pair<Scalar, Scalar> getOverlappingRange(Scalar z_min_a,
                                                         Scalar z_max_a,
                                                         Scalar z_min_b,
                                                         Scalar z_max_b);

 private:
    void calculateXYBounds();

    Scalar m_min_thickness;
    Scalar m_max_thickness;
    Scalar m_z_tolerance;

    Scalar m_x_min;
    Scalar m_x_max;
    Scalar m_y_min;
    Scalar m_y_max;
    bool m_xy_bounds_up_to_date;

    std::multiset<Chunk> m_chunks;
};

/**
 * A ChunkFilter is a way to distinguish between different types of chunks,
 * including both the regular Chunk::Type (chunk_base::chunk_t) and the
 * Chunk::StructureType (LayerMeasure::LayerType_e).
 *
 * ChunkFilters can be either default-inclusive or default-exclusive for both
 * Chunk::Types and Chunk::StructureTypes.
 *
 * A chaining syntax is also supported, to make declaring filters more
 * readable:
 *
 *  ChunkFilter::inclusive()
 *      .exclude(Chunk::Type::ct_extent)
 *      .exclude(Chunk::Type::ct_support)
 *
 *  ChunkFilter::exclusive()
 *      .include(Chunk::Type::ct_solid)
 *      .include(Chunk::Type::ct_sparse)
 */
class MGL_API ChunkFilter {
 public:
    ChunkFilter(bool default_include_type = true,
                bool default_include_structure = true,
                bool type_and_struct = true);

    static ChunkFilter inclusive();
    static ChunkFilter exclusive();

    // Builder API
    ChunkFilter& include(Chunk::Type chunk_type);
    ChunkFilter& includeAll(const std::vector<Chunk::Type>& chunk_types);
    ChunkFilter& exclude(Chunk::Type chunk_type);
    ChunkFilter& excludeAll(const std::vector<Chunk::Type>& chunk_types);

    ChunkFilter& structInclude(Chunk::StructureType structure_type);
    ChunkFilter& structIncludeAll(
        const std::vector<Chunk::StructureType>& structure_type);
    ChunkFilter& structExclude(Chunk::StructureType structure_type);
    ChunkFilter& structExcludeAll(
        const std::vector<Chunk::StructureType>& structure_type);

    bool isTypeIncluded(Chunk::Type chunk_type) const;
    bool isTypeExcluded(Chunk::Type chunk_type) const;

    bool isStructIncluded(Chunk::StructureType structure_type) const;
    bool isStructExcluded(Chunk::StructureType structure_type) const;

    bool isIncluded(const Chunk& chunk) const;
    bool isExcluded(const Chunk& chunk) const;

    ChunkFilter& invert();

    // Helpful predefined structure types
    static const std::vector<Chunk::StructureType> model_structure_types;
    static const std::vector<Chunk::StructureType> raft_structure_types;

    static ChunkFilter combineInclusive(const ChunkFilter& filter_a,
                                        const ChunkFilter& filter_b);

    static ChunkFilter combineExclusive(const ChunkFilter& filter_a,
                                        const ChunkFilter& filter_b);

    static ChunkFilter combine(const ChunkFilter& filter_a,
                               const ChunkFilter& filter_b,
                               bool inclusive);

    friend std::ostream MGL_API &operator<<(std::ostream& out,
                                            const ChunkFilter& filter);

 private:
    // True = included, False = excluded
    bool m_default_type_filter;
    std::map<Chunk::Type, bool> m_type_filter;
    bool m_default_structure_filter;
    std::map<Chunk::StructureType, bool> m_structure_filter;
    bool m_type_and_struct;
};

// DRAGONS - & goes on the RIGHT of MGL_API
std::ostream MGL_API &operator<<(std::ostream& out, const ChunkFilter& filter);

}  // namespace mgl

#endif  // INCLUDE_MGL_OBJECT_DATA_CHUNK_STACK_H_
