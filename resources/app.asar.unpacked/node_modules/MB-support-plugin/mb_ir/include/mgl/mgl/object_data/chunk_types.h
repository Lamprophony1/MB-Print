#pragma once

/**
 * Defines chunk types and layer/structure types used currently to classify
 * different regions of a print.
 */

namespace mgl {

typedef int layer_measure_index_t;  // TODO: Remove?
typedef layer_measure_index_t LayerId;

/**
 * Wrapped in a struct to allow inheritance - these enums are not class-like,
 * and so pollute the class namespace.  Inheritance is the only way to duplicate
 * this effect without rejiggering a lot of other code.
 */
struct MGL_API ChunkTypes {

    enum chunk_t {
        ct_none,            // 0: the empty chunk type, will not be printed
        ct_extent,          // 1: model limits of layer - no printable structure
        ct_shell,           // 2: model or support shells at a certain depth
        ct_interior,        // 3: model or support interior regions
        ct_interior_shell,  // 4: model or support all infill shells
        ct_fill_solid,      // 5: model solid fill
        ct_fill_sparse,     // 6: model sparse fill
        ct_fill_sparse_minfill,  // 7: model sparse minfill
        ct_fill_solid_minfill,   // 8: model solid minfill
        ct_fill_roof_surface,    // 9: model roof surface fill
        ct_fill_floor_surface,   // 10: model floor surface fill
        ct_exposed_roof,         // 11: model or support solid fill in different
                                 //     arrangements
        ct_exposed_floor,  // 12: model or support so that we may have different
                           //   treatment
        ct_exposed_floor_all_mat,  // 13: model or support exposed floors all
                                   //   materials each case
        ct_bridge,  // 14: model or support the extent and fill for a bridge
        ct_bridge_anchor,  // 15: model & support the extent of bridge anchors
        ct_bridge_no_support,  // 16: model & support bridges that are expected
                               //   to stay up
        ct_raft,   // 17: model or support different kinds of raft chunks
        ct_brim,   // 18: brims
        ct_spur,   // 19: model or support spurs
        ct_purge,  // 20: model or support purge wall chunk
        ct_supported_floor,  // 21: model or support Floor over a supported
                             //     region
        ct_rafted_floor,     // 22: model or support Floor over a rafted surface
        ct_support,          // 23: support only extents
        ct_support_base,     // 24: the support base layer only
        ct_support_fill_sparse,          // 25: support sparse fill
        ct_support_fill_sparse_minfill,  // 26: support sparse minfill
        ct_support_fill_solid,           // 27: support solid fill
        ct_support_fill_solid_minfill,   // 28: support solid minfill
        ct_support_fill_roof_surface,    // 29: support roof surface
        ct_support_fill_floor_surface,   // 30: support floor surface
        ct_invalid                       // not a valid chunk, throws exceptions
    };

    // types of layer data elements
    enum LayerType_e {
        INVALID_LAYER_ID = -1,  // -1
        VIRTUAL,                // 0
        BRIMS,                  // 1
        MODEL,                  // 2
        MODEL_BASE,             // 3
        PURGE_BASE,             // 4
        RAFT_BASE,              // 5
        RAFT_INTERFACE,         // 6
        RAFT_SURFACE,           // 7
        SUPPORT,                // 8
        SUPPORT_BASE            // 9
    };
};
}
