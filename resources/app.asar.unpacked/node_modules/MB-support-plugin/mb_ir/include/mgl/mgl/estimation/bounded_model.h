#pragma once

#include <memory>

#include <geomutils/limits.h>
#include <geomutils/model.h>

#include "toolpather.h"

#include "mgl/estimation/slice_orient.h"

namespace mgl {

/**
 * A wrapped model which is only sliced within the provided bounds.
 *
 * Two types of bounds can be specified - the overall model bounds, which define
 * the min/max region over which slicing occurs, and a number of independent
 * slice bounds.  Model regions outside the slice bounds do not produce extents.
 *
 * Ex: A "castle model" can have the bottom cut off with model bounds, and then
 * only the left tower selected in slice bounds.
 *
 *  _________________
 * | [ /\ ]    /\   | <- model bounds
 * | [/  \]___/  \  | [] are slice bounds
 * |  |          |  |
 * |__|__________|__|
 *    |__________|
 *
 * produces:
 *
 *  _________________
 * |   /\           |
 * |  /__\          |
 * |                |
 * |________________|
 *
 */
class BoundedModel : public geomutils::Model {
public:
    BoundedModel(std::shared_ptr<geomutils::Model> model,
                 bool is_prepared = false);

    virtual ~BoundedModel();

    // Watertight iff the original model is watertight
    // TODO: Is this safe to assume?
    bool isWatertight() const override;

    void prepareForSlicing() override;

    void setModelBounds(const geomutils::Limits& model_bounds);

    void addSliceBounds(const geomutils::Limits& slice_bounds);

    // Returns the *model bounds* of the model, determining min/max slice z
    geomutils::Limits getLimits() const override;

    // Returns a bounded slice at a particular height
    const geomutils::ZSlice getSlice(Scalar z_height) override;

    void updateScale(float x, float y, float z) override;

private:
    std::shared_ptr<geomutils::Model> m_model;
    bool m_is_prepared;

    geomutils::Limits m_model_bounds;
    std::vector<geomutils::Limits> m_slice_bounds;
};
}
