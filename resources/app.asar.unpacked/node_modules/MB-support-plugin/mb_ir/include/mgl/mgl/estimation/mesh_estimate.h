
#pragma once

#include <map>
#include <vector>

#include <geomutils/Region.h>
#include <geomutils/limits.h>
#include <meshutils/connected_mesh.h>
#include <meshutils/face_region.h>
#include <thing/gaggle.h>

#include "mgl/configuration.h"

namespace mgl {

/**
 * Print estimation for 3D mesh data (a Gaggle) using only mesh tools.
 * 
 * Computes a number of basic mesh properties, as well as trying to determine
 * mesh edges, faces, and vertices that are unsupported.  These mesh elements
 * are then grouped into connected regions of mesh faces that have unsupported
 * components (FaceRegions).
 *
 * Finally, nearby unsupported FaceRegions are grouped together and various 
 * metrics are calculated on them (UnsupportedAreas).
 *
 * Also basic plating information is estimated using a raw slice through the
 * bottom portion of the mesh.
 *
 * A Toolpather Configuration is needed to compute overhang angles, plating
 * info, etc.
 */
class MGL_API MeshEstimate {
public:
    MeshEstimate(const Configuration& configuration,
                 std::shared_ptr<LibThing::Gaggle> gaggle,
                 bool is_prepared = false,
                 Scalar face_grouping_distance = 0.0);

    MeshEstimate(const Configuration& configuration,
                 std::shared_ptr<LibThing::Mesh> mesh,
                 Scalar face_grouping_distance = 0.0);

    MeshEstimate(const Configuration& configuration,
                 LibThing::ConnectedMesh& mesh,
                 Scalar face_grouping_distance = 0.0);

    //
    // Accessors
    //

    const Configuration& getConfiguration() const;

    const LibThing::Gaggle& getGaggle() const;

    typedef std::vector<std::reference_wrapper<const LibThing::ConnectedMesh>>
        ConnectedMeshes;

    const ConnectedMeshes& getMeshes() const;

    //
    // Basic info
    //

    bool isManifold() const;

    bool isWatertight() const;

    Scalar getVolume() const;

    Scalar getSurfaceArea() const;

    geomutils::Vector3 getCenterOfMass() const;

    geomutils::Vector3 getShellCenterOfMass() const;

    //
    // Plating information
    //

    const geomutils::Region& getPlatedRegion() const;

    const geomutils::Region& getPlatedHull() const;

    //
    // Surface Quality
    //

    /**
     * This struct stores the different kinds of unsupported elements of a mesh.
     * Faces, edges, and vertices can all be unsupported.
     *
     * Vertices are unsupported if they are not near the plated region of the
     * mesh and are a local vertex minimum in the Z axis.
     *
     * Edges are unsupported if they are not near the plated region and have a
     * normal which points "too far" in the negative Z direction.
     *
     * Faces are unsupported if they are not near the plated region and have a
     * normal which points "too far" in the negative Z direction.
     * Also, any face which touches an unsupported edge or vertex is also
     * considered unsupported - the idea is that the unsupported edge or vertex
     * "damages" the nearby surface faces.  This makes it simpler to assign a 
     * score to surface damage since only faces can be considered.
     */
    struct MGL_API UnsupportedElements {
        std::set<LibThing::ConnectedMesh::FaceHandle> faces;
        std::set<LibThing::ConnectedMesh::EdgeHandle> edges;
        std::set<LibThing::ConnectedMesh::VertexHandle> vertices;

        std::vector<LibThing::FaceRegion> face_regions;
        std::list<LibThing::FaceRegion::Group> face_groups;
    };

    const UnsupportedElements& getUnsupportedElements(
        const LibThing::ConnectedMesh& mesh) const;

    //
    // Helpers for getting only certain kinds of unsupported elements
    //

    const std::set<LibThing::ConnectedMesh::FaceHandle>& getUnsupportedFaces(
        const LibThing::ConnectedMesh& mesh) const;

    const std::set<LibThing::ConnectedMesh::EdgeHandle>& getUnsupportedEdges(
        const LibThing::ConnectedMesh& mesh) const;

    const std::set<LibThing::ConnectedMesh::VertexHandle>&
    getUnsupportedVertices(const LibThing::ConnectedMesh& mesh) const;

    const std::vector<LibThing::FaceRegion>& getUnsupportedFaceRegions(
        const LibThing::ConnectedMesh& mesh) const;

    const std::list<LibThing::FaceRegion::Group>& getUnsupportedFaceGroups(
        const LibThing::ConnectedMesh& mesh) const;

    struct MGL_API UnsupportedArea {

        UnsupportedArea(const LibThing::FaceRegion::Group* face_group);

        const LibThing::FaceRegion::Group* face_group;

        Scalar total;
        Scalar projected;
        Scalar unplated;
        Scalar bridgeable;

        geomutils::Limits limits;
    };

    const std::vector<UnsupportedArea>& getUnsupportedAreas() const;

    //
    // Utility functions for mesh simplification
    //

    // Mostly for testing, this version copies the mesh
    static LibThing::ConnectedMesh simplifyMesh(
        const LibThing::ConnectedMesh& mesh,
        int desired_faces,
        Scalar min_surface_area);

    static std::shared_ptr<LibThing::Mesh> simplifyMesh(
        const LibThing::Mesh& mesh,
        int desired_faces,
        Scalar min_surface_area,
        bool separate_simple_components = true);

    static std::shared_ptr<LibThing::Gaggle> simplifyGaggle(
        const LibThing::Gaggle& gaggle,
        int desired_faces_per_mesh,
        Scalar min_surface_area_per_mesh);

private:
    Configuration m_configuration;
    std::shared_ptr<LibThing::Gaggle> m_gaggle;

    // Store a flat vector of the meshes to allow easier iteration of the gaggle
    // It's pretty awkward to iterate meshes otherwise.
    ConnectedMeshes m_all_meshes;

    void initBasics();

    // Init'd by the above
    bool m_is_manifold;
    bool m_is_watertight;

    Scalar m_volume;
    Scalar m_surface_area;
    geomutils::Vector3 m_center_of_mass;
    geomutils::Vector3 m_shell_center_of_mass;

    void initPlatedRegion(int num_plate_slices);

    // Init'd by the above
    geomutils::Region m_plated_region;
    geomutils::Region m_plated_hull;

    void initUnsupported(int num_plate_slices, Scalar face_grouping_distance);

    // Init'd by the above
    typedef std::map<const LibThing::ConnectedMesh*, UnsupportedElements>
        UnsupportedElementMap;
    UnsupportedElementMap m_unsupported_elements;
    std::vector<UnsupportedArea> m_unsupported_areas;

public:
    //
    // For testing only
    //

    void sortUnsupportedAreas();

    //
    // Utility functions exposed for testing - not really part of the API
    //

    static Scalar angleToZAxis(const geomutils::Vector3& normal);

    /**
     * Unsupported angles are specified with respect to the positive z-axis -
     * usually all upward faces with angles < 90 degrees are naturally
     * supported,
     * but at some angle > 90 downward faces require support.  In 2015, the
     * threshold angle was usually specified as something like 70 degrees
     * downward,
     * or (in this system) any face with z-axis angle > (90 + 70) degrees.
     *
     *  (+Z)
     *   ^   ^ (normal)
     * \ |  /
     *  \|a/ <- a = angle from vertical < 90 degrees
     *   \/
     *   |\ <- upward face
     *   | \
     *   |  |
     *   |  |
     *   | /
     *   |/ <- downward face
     *   /\
     *  /|a\ <- a = angle from vertical > 90 < 180
     * / |  \
     *   |   V
     *   |
     * ------  (XY plate)
     */
    static bool isSupportedFace(const LibThing::ConnectedMesh& mesh,
                                LibThing::ConnectedMesh::FaceHandle face_handle,
                                Scalar max_supported_angle_rads);

    /**
     * Downward/Unsupported edges are outward edges which are local minima of
     * the connected edges.
     * These edges can also be filtered by a particular minimum angle which can
     * be supported between faces - this angle is different from the unsupported
     * face angle, since overhangs of points can be greater than non-points.
     *
     *
     *         B
     *       /
     *     / <- downward angle/grade to the build plate
     *   / ------
     *  A
     */
    static bool isDownwardEdge(const LibThing::ConnectedMesh& mesh,
                               LibThing::ConnectedMesh::EdgeHandle edge_handle,
                               Scalar min_supported_edge_grade_rads);

    /**
     * Returns the average normal of the faces surrounding a vertex.
     */
    static geomutils::Vector3 getVertexNormal(
        const LibThing::ConnectedMesh& mesh,
        LibThing::ConnectedMesh::VertexHandle vertex_handle);

    /**
     * Downward/Unsupported vertices are local minima of the surrounding mesh.
     */
    static bool isDownwardVertex(
        const LibThing::ConnectedMesh& mesh,
        LibThing::ConnectedMesh::VertexHandle vertex_handle);

    /**
     * Returns a rough estimate of the percentage of a face which is within
     * num_plate_slices of the build plate.
     */
    static Scalar getPlateFaceFraction(
        const LibThing::ConnectedMesh& mesh,
        LibThing::ConnectedMesh::FaceHandle face_handle,
        Scalar z_min,
        Scalar layer_height,
        int num_plate_slices,
        Scalar* face_z_min,
        Scalar* face_z_max);
};
}
