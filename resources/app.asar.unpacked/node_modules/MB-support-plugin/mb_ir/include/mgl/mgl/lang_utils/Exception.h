
#ifndef MGL_EXCEPTION_H_
#define MGL_EXCEPTION_H_ (1)

#include <string>
#include <stdexcept>

namespace mgl {

/* http:// gcc.gnu.org/onlinedocs/cpp/Stringification.html */
#define MGL_EXCEPTION_XSTR(s) MGL_EXCEPTION_STR(s)
#define MGL_EXCEPTION_STR(s) #s

#define MGL_EXCEPTION_SUBCLASS_SUBCLASS(SUBCLASSNAME, BASECLASSNAME) \
class SUBCLASSNAME : public BASECLASSNAME { \
public: \
    template <typename T> \
    SUBCLASSNAME(T&& arg) : BASECLASSNAME(std::forward<T>(arg)) {} \
    SUBCLASSNAME() : BASECLASSNAME(MGL_EXCEPTION_XSTR(SUBCLASSNAME)) {} \
}

/**
 @brief Create a subclass of our exception base having 
 class name @a SUBCLASSNAME
 @param SUBCLASSNAME name of the subclass
 We have just one base exception, and all others derive from it. 
 All of Exception's children have exactly the same constructor and nothing 
 else, so I made a macro instead of copy pasta same code
 */
#define MGL_EXCEPTION_SUBCLASS(SUBCLASSNAME) \
        MGL_EXCEPTION_SUBCLASS_SUBCLASS(SUBCLASSNAME, mgl::Exception)

/**
 * base class for all MGL Exceptions
 *
 * DRAGONS: This gets exported across DLL boundaries, so we can't rely on
 * inherited std::runtime_error exception checks and so we slightly duplicate
 * that functionality.
 */
class MGL_API Exception {
public:
    Exception(const std::string& what) : m_what(what) {}

    Exception(const char* what) : m_what(what) {}

    virtual ~Exception() {}

    virtual const char* what() const { return m_what.c_str(); }

private:
    std::string m_what;
};

MGL_EXCEPTION_SUBCLASS(GeometryException);

} /*end namespace mgl; */

#endif // MGL_EXCEPTION_H_
