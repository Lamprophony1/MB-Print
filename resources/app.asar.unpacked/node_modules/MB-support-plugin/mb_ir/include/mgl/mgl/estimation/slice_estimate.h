
#pragma once

#include <limits.h>
#include <vector>

#include <geomutils/Region.h>
#include <geomutils/Vector3.h>
#include <geomutils/model.h>

#include "mgl/configuration.h"
#include "mgl/object_data/chunk_stack.h"

namespace mgl {

// Forward-declare, not strictly necessary to use this class
class Toolpather;

/**
 * Print estimation for a sliced model of stacked 2D Chunks.
 * 
 * Computes a number of basic properties based on the stack, like volume and
 * COM.
 *
 * Most of the functionality here is in identifying "FloorIslands" - floor
 * regions of a sliced model that are not/partially bridged, and so must be
 * supported if support is enabled.
 */
class MGL_API SliceEstimate {
public:
    explicit SliceEstimate(Toolpather& toolpather);
    explicit SliceEstimate(Toolpather&& toolpather);

    SliceEstimate(const ChunkStack& stack,
                  Scalar supported_overhang_distance = 0.0);

    SliceEstimate(ChunkStack&& stack, Scalar supported_overhang_distance = 0.0);

    const ChunkStack& getStack() const;

    //
    // Stability
    //

    static Scalar getVolume(const Chunk& chunk);

    static geomutils::Vector3 getCenterOfMass(const Chunk& chunk);

    static geomutils::Vector3 getCenterOfMass(const ChunkStack& stack,
                                              Scalar& volume);

    Scalar getVolume() const;

    Scalar getSupportVolume() const;

    geomutils::Vector3 getCenterOfMass() const;

    const geomutils::Region& getPlatedRegion() const;

    const geomutils::Region& getPlatedHull() const;

    //
    // Surface Quality
    //

    struct MGL_API FloorIsland {

        FloorIsland(const Chunk& extents,
                    const geomutils::DiscreteRegion& extent_island,
                    const geomutils::Region& floors_to_support,
                    const geomutils::Region& bridges);

        const Chunk* extents;
        geomutils::DiscreteRegion extent_island;
        geomutils::Region floors_to_support;

        // For debugging
        geomutils::Region bridges;
    };

    const std::vector<FloorIsland>& getFloorIslands() const;

    bool isPlatedIsland(const FloorIsland& floor_island, Scalar plate_z) const;

    //
    // Helpers to allow more precise construction of a SliceEstimate
    //

    static ChunkStack sliceBasic(Toolpather& toolpather);

    static Scalar getSupportedOverhang(Toolpather& toolpather);

private:
    ChunkStack m_stack;
    Scalar m_supported_overhang_distance;

    void init();

    Scalar m_volume;
    Scalar m_support_volume;

    geomutils::Vector3 m_center_of_mass;

    geomutils::Region m_plated_region;
    geomutils::Region m_plated_hull;

    std::vector<FloorIsland> m_floor_islands;

public:
    //
    // For testing
    //

    static std::vector<FloorIsland> computeFloorIslands(
        const ChunkStack& stack, Scalar supported_overhang_distance = 0.0);

    static Configuration getBasicConfiguration(Scalar layer_height = 1.0,
                                               Scalar nozzle_diameter = 1.0,
                                               bool do_raft = false,
                                               bool do_bridging = true,
                                               bool do_support = true);
};
}
