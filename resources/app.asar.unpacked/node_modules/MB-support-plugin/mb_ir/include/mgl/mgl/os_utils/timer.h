#pragma once

#include <map>
#include <string>

#include <boost/date_time/posix_time/posix_time.hpp>

namespace mgl {

/**
 * Easy-to-use timer construct.
 */
struct MGL_API Timer {

    Timer() : start_time() { reset(); }

    boost::posix_time::ptime current() {
        return boost::posix_time::microsec_clock::local_time();
    }

    boost::posix_time::time_duration elapsed() {
        return current() - start_time;
    }

    void reset() { start_time = current(); }

    boost::posix_time::ptime start_time;
};

class MGL_API NamedTimer {
public:
    NamedTimer() {}

    Timer& startTimer(const std::string& name) { return m_timers[name]; }

    bool hasTimer(const std::string& name) {
        return m_timers.find(name) != m_timers.end();
    }

    void stopTimer(const std::string& name) {
        auto found_it = m_timers.find(name);
        if (found_it == m_timers.end()) return;
        m_times[name] = elapsed(name) + found_it->second.elapsed();
        m_timers.erase(found_it);
    }

    boost::posix_time::time_duration elapsed(const std::string& name) {
        auto found_it = m_times.find(name);
        if (found_it == m_times.end())
            return boost::posix_time::time_duration();
        return found_it->second;
    }

    const std::map<std::string, boost::posix_time::time_duration>& getTimes()
        const {
        return m_times;
    }

    std::map<std::string, long> getTimesMillis() const {
        std::map<std::string, long> times_millis;
        for (const auto& item : m_times) {
            times_millis.insert(std::make_pair(
                item.first,
                static_cast<long>(item.second.total_milliseconds())));
        }
        return times_millis;
    }

private:
    std::map<std::string, Timer> m_timers;
    std::map<std::string, boost::posix_time::time_duration> m_times;
};
}

// Helper MACRO that allows easily timing a block of code with a name
#ifndef TIME
#define TIME(N, T) for (T.startTimer((N)); T.hasTimer((N)); T.stopTimer((N)))
#define TIME2(N, TA, TB)                                           \
    for (TA.startTimer((N)), TB.startTimer((N)); TA.hasTimer((N)); \
         TA.stopTimer((N)), TB.stopTimer((N)))
#endif
