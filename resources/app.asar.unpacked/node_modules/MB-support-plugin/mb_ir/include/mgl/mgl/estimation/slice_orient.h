#pragma once

#include <map>
#include <memory>
#include <string>

#include <geomutils/Vector3.h>
#include <geomutils/limits.h>

#include <thing/gaggle.h>
#include <thing/mesh.h>
#include <thing/optimize.h>

#include "mgl/configuration.h"
#include "mgl/estimation/mesh_estimate.h"
#include "mgl/estimation/slice_estimate.h"
#include "mgl/estimation/stability_estimate.h"
#include "mgl/os_utils/timer.h"

namespace mgl {

/**
 * A candidate orientation of a Gaggle with computed stats.
 * Gets copied around a lot, so needs to be lightweight.
 *
 * Includes mesh, stability, and slice estimates of an input gaggle at a
 * particular rotation.
 * 
 * Usually the slice estimation is done only in regions of the gaggle where a
 * mesh estimation shows there could be overhangs - otherwise it can be pretty
 * expensive to slice the full model, even simplified.
 */
struct MGL_API SlicedCandidate {
public:
    const geomutils::Vector3& getEulerAngles() const;

    const LibThing::Gaggle& getGaggle() const;

    const MeshEstimate& getMeshEstimate() const;

    const StabilityEstimate& getStabilityEstimate() const;

    struct MGL_API LocalSliceEstimate {

        LocalSliceEstimate() {}

        // Note that MSVC *requires* this here, sigh
        LocalSliceEstimate(LocalSliceEstimate&& other)
            : limits(std::move(other.limits)),
              local_unsupported(std::move(other.local_unsupported)),
              slice_estimate(std::move(other.slice_estimate)) {}

        geomutils::Limits limits;
        std::set<const MeshEstimate::UnsupportedArea*> local_unsupported;
        std::unique_ptr<SliceEstimate> slice_estimate;
    };

    const std::vector<LocalSliceEstimate>& getLocalSliceEstimates() const;

    const std::map<std::string, Scalar> getScores() const;

    const NamedTimer& getTimer() const;

    //
    // For testing
    //

    // Make the ordering of various parts of the estimate consistent for easier
    // testing.
    void normalize();

    const SliceEstimate& getFullSliceEstimate() const;

    const LocalSliceEstimate& getLocalSliceFor(
        const MeshEstimate::UnsupportedArea& unsupported) const;

private:
    // Gets built by the associated orienter
    friend class SliceOrientProblem;

    // Candidate geometry
    geomutils::Vector3 m_euler_angles;
    std::shared_ptr<LibThing::Gaggle> m_gaggle;

    // Candidate print estimation
    std::shared_ptr<MeshEstimate> m_mesh_estimate;
    std::shared_ptr<StabilityEstimate> m_stability_estimate;
    std::shared_ptr<std::vector<LocalSliceEstimate>> m_local_slice_estimates;

    // Candidate scores
    std::map<std::string, Scalar> m_scores;

    // Time taken to build/evaluate the candidate
    NamedTimer m_timer;

    //
    // For debugging
    //

    std::shared_ptr<SliceEstimate> m_full_slice_estimate;
};

typedef SlicedCandidate::LocalSliceEstimate LocalSliceEstimate;

/**
 * Defines a search for gaggle orientation using print estimates of a gaggle in
 * various positions.  The gaggle is usually simplified for faster searching.
 *
 * Requires a toolpather configuration to define how the gaggle would be
 * printed, as well as a number of other options (below).
 */
class MGL_API SliceOrientProblem
    : public LibThing::MetricSearchProblem<SlicedCandidate> {
public:
    struct MGL_API Options {

        Options();

        // Number of faces per mesh in the simplfied gaggle
        int desired_faces_per_mesh;
        // Min surface area of meshes in the simplified gaggle
        // (Tiny, irrelevant meshes sometimes show up as artifacts from other
        //  mesh tools)
        Scalar min_surface_area_per_mesh;

        // Whether the search should consider stability of the rotated print
        bool stability_scoring;
        // Whether the search should consider surface quality of the rotated
        // print
        bool surface_scoring;

        // Mostly for debug

        // Ignore bridging entirely
        bool ignore_bridgeable_faces;
        // Don't group faces together that are not connected
        // (Right now grouping is way inefficient)
        bool trivial_local_grouping;
        // Slice the entire gaggle, but not used in search
        bool full_slice_estimate;
    };

    SliceOrientProblem(const Configuration& configuration,
                       std::shared_ptr<LibThing::Gaggle> gaggle,
                       const Options& options = Options());

    virtual ~SliceOrientProblem() {}

    const Configuration& getConfiguration() const;

    const LibThing::Gaggle& getGaggle() const;

    const LibThing::Gaggle& getSimpleGaggle() const;

    const Options& getOptions() const;

    //
    // Search implementation below
    //

    SlicedCandidate randomCandidate(
        LibThing::SimpleRandom& random) const override;

    SlicedCandidate randomNeighbor(
        const SlicedCandidate& candidate,
        LibThing::SimpleRandom& random) const override;

    bool isBetter(const SlicedCandidate& a,
                  const SlicedCandidate& b) const override;

    float getDistance(const SlicedCandidate& a,
                      const SlicedCandidate& b) const override;

    //
    // End search implementation
    //

    SlicedCandidate buildCandidate(
        const geomutils::Vector3& euler_angles) const;

    struct MGL_API Stats {
        NamedTimer timer;
    };

    const Stats& getStats() const;

private:
    std::map<std::string, Scalar> buildScores(
        const SlicedCandidate& candidate) const;

    Configuration m_configuration;
    std::shared_ptr<LibThing::Gaggle> m_gaggle;
    std::shared_ptr<LibThing::Gaggle> m_simple_gaggle;
    Options m_options;

    mutable Stats m_stats;
};
}
