// This file was automatically generated, do not edit it!

#ifndef YONKERS_TOOL_MAPPINGS
#define YONKERS_TOOL_MAPPINGS

#include <stdint.h>
#include <string>

namespace bwcoreutils {

enum class TOOL : int {
    INVALID_ID = 0,
    MARK_11 = 1,
    MARK_11_MOD_1 = 2,
    MARK_11_MOD_2 = 3,
    MARK_11_MOD_3 = 4,
    MARK_12 = 5,
    MARK_12_5 = 6,
    MARK_12_1 = 7,
    MARK_13 = 8,
    MARK_12_2 = 9,
    MARK_12_3 = 10,
    MARK_12_4 = 11,
    MARK_12_6 = 12,
    MARK_12_7 = 13,
    MARK_13_IMPLA = 14,
    MARK_13_1 = 15,
    MARK_13_1_IMPLA = 16,
    MARK_13_2 = 17,
    MARK_13_2_IMPLA = 18,
    MARK_13_3 = 19,
    MARK_13_3_IMPLA = 20,
    MARK_13_4 = 21,
    MARK_13_4_IMPLA = 22,
    MARK_13_EXPERIMENTAL = 99,
    MK14_0 = 100,
    MK14_S_0 = 101,
    MK14_HOT_0 = 102,
    MK14_HOT_S_0 = 103,
};

enum class TYPE : int {
    UNKNOWN_TYPE = 0,
    MK12 = 1,
    MK13 = 2,
    MK13_IMPLA = 3,
    MK14 = 4,
    MK14_S = 5,
    MK14_HOT = 6,
    MK14_HOT_S = 7,
};

enum class MATERIALS : int {
    PLA = 0,
    IMPLA = 1,
    PVA = 2,
    UNKNOWN = -1,
};
// This class takes a tool_id and exposes metadata for that tool.
// Primarily intended to be used for UI clients.
// TODO(jacksonh) - use qt to make these translatable.
class YonkersTool {
public:


    YonkersTool(uint8_t id) :
        m_tool(static_cast<TOOL>(id)) {}

    YonkersTool(TOOL id) : m_tool(id) {}
    ~YonkersTool() {}

    std::string name() const {
        switch (m_tool) {
            case TOOL::INVALID_ID:
                return "Unknown";
            case TOOL::MARK_11:
                return "Smart Extruder 11.0";
            case TOOL::MARK_11_MOD_1:
                return "Smart Extruder 11.1";
            case TOOL::MARK_11_MOD_2:
                return "Smart Extruder 11.2";
            case TOOL::MARK_11_MOD_3:
                return "Smart Extruder 11.3";
            case TOOL::MARK_12:
                return "Smart Extruder 12.0";
            case TOOL::MARK_12_5:
                return "Smart Extruder 12.5";
            case TOOL::MARK_12_1:
                return "Smart Extruder 12.1";
            case TOOL::MARK_13:
                return "Smart Extruder+";
            case TOOL::MARK_12_2:
                return "Smart Extruder 12.2";
            case TOOL::MARK_12_3:
                return "Smart Extruder 12.2.1";
            case TOOL::MARK_12_4:
                return "Smart Extruder 12.3";
            case TOOL::MARK_12_6:
                return "Smart Extruder 12.4";
            case TOOL::MARK_12_7:
                return "Smart Extruder 12.6";
            case TOOL::MARK_13_IMPLA:
                return "Tough PLA Smart Extruder+";
            case TOOL::MARK_13_1:
                return "Smart Extruder+";
            case TOOL::MARK_13_1_IMPLA:
                return "Tough PLA Smart Extruder+";
            case TOOL::MARK_13_2:
                return "Smart Extruder+";
            case TOOL::MARK_13_2_IMPLA:
                return "Tough PLA Smart Extruder+";
            case TOOL::MARK_13_3:
                return "Smart Extruder+";
            case TOOL::MARK_13_3_IMPLA:
                return "Tough PLA Smart Extruder+";
            case TOOL::MARK_13_4:
                return "Smart Extruder+";
            case TOOL::MARK_13_4_IMPLA:
                return "Tough PLA Smart Extruder+";
            case TOOL::MARK_13_EXPERIMENTAL:
                return "Experimental Extruder";
            case TOOL::MK14_0:
                return "Model 1 Performance Extruder";
            case TOOL::MK14_S_0:
                return "Support 2 Performance Extruder";
            case TOOL::MK14_HOT_0:
                return "Model 1 Performance Extruder";
            case TOOL::MK14_HOT_S_0:
                return "Support 2 Performance Extruder";
            default:
                return "Unknown";
        }
    }

    std::string material() const {
        switch (m_tool) {
            case TOOL::INVALID_ID:
                return "unknown";
            case TOOL::MARK_11:
                return "PLA";
            case TOOL::MARK_11_MOD_1:
                return "PLA";
            case TOOL::MARK_11_MOD_2:
                return "PLA";
            case TOOL::MARK_11_MOD_3:
                return "PLA";
            case TOOL::MARK_12:
                return "PLA";
            case TOOL::MARK_12_5:
                return "PLA";
            case TOOL::MARK_12_1:
                return "PLA";
            case TOOL::MARK_13:
                return "PLA";
            case TOOL::MARK_12_2:
                return "PLA";
            case TOOL::MARK_12_3:
                return "PLA";
            case TOOL::MARK_12_4:
                return "PLA";
            case TOOL::MARK_12_6:
                return "PLA";
            case TOOL::MARK_12_7:
                return "PLA";
            case TOOL::MARK_13_IMPLA:
                return "Tough PLA";
            case TOOL::MARK_13_1:
                return "PLA";
            case TOOL::MARK_13_1_IMPLA:
                return "Tough PLA";
            case TOOL::MARK_13_2:
                return "PLA";
            case TOOL::MARK_13_2_IMPLA:
                return "Tough PLA";
            case TOOL::MARK_13_3:
                return "PLA";
            case TOOL::MARK_13_3_IMPLA:
                return "Tough PLA";
            case TOOL::MARK_13_4:
                return "PLA";
            case TOOL::MARK_13_4_IMPLA:
                return "Tough PLA";
            case TOOL::MARK_13_EXPERIMENTAL:
                return "PLA";
            case TOOL::MK14_0:
                return "PLA";
            case TOOL::MK14_S_0:
                return "PVA";
            case TOOL::MK14_HOT_0:
                return "ABS";
            case TOOL::MK14_HOT_S_0:
                return "SR30";
            default:
                return "Unknown";
        }
    }

    TYPE type() const {
        switch (m_tool) {
        case TOOL::INVALID_ID:
        return TYPE::UNKNOWN_TYPE;
        case TOOL::MARK_11:
        return TYPE::MK12;
        case TOOL::MARK_11_MOD_1:
        return TYPE::MK12;
        case TOOL::MARK_11_MOD_2:
        return TYPE::MK12;
        case TOOL::MARK_11_MOD_3:
        return TYPE::MK12;
        case TOOL::MARK_12:
        return TYPE::MK12;
        case TOOL::MARK_12_5:
        return TYPE::MK12;
        case TOOL::MARK_12_1:
        return TYPE::MK12;
        case TOOL::MARK_13:
        return TYPE::MK13;
        case TOOL::MARK_12_2:
        return TYPE::MK12;
        case TOOL::MARK_12_3:
        return TYPE::MK12;
        case TOOL::MARK_12_4:
        return TYPE::MK12;
        case TOOL::MARK_12_6:
        return TYPE::MK12;
        case TOOL::MARK_12_7:
        return TYPE::MK12;
        case TOOL::MARK_13_IMPLA:
        return TYPE::MK13_IMPLA;
        case TOOL::MARK_13_1:
        return TYPE::MK13;
        case TOOL::MARK_13_1_IMPLA:
        return TYPE::MK13_IMPLA;
        case TOOL::MARK_13_2:
        return TYPE::MK13;
        case TOOL::MARK_13_2_IMPLA:
        return TYPE::MK13_IMPLA;
        case TOOL::MARK_13_3:
        return TYPE::MK13;
        case TOOL::MARK_13_3_IMPLA:
        return TYPE::MK13_IMPLA;
        case TOOL::MARK_13_4:
        return TYPE::MK13;
        case TOOL::MARK_13_4_IMPLA:
        return TYPE::MK13_IMPLA;
        case TOOL::MARK_13_EXPERIMENTAL:
        return TYPE::MK13;
        case TOOL::MK14_0:
        return TYPE::MK14;
        case TOOL::MK14_S_0:
        return TYPE::MK14_S;
        case TOOL::MK14_HOT_0:
        return TYPE::MK14_HOT;
        case TOOL::MK14_HOT_S_0:
        return TYPE::MK14_HOT_S;
        default:
            return TYPE::UNKNOWN_TYPE;
        }
    }

    static TYPE type_from_type_name(const std::string& type_name) {
        // This weird formatting brought to you by switch() only
        // knowing how to handle integral types for some reason
        if(type_name == std::string("unknown")
           || type_name == std::string("Unknown")) {
            return TYPE::UNKNOWN_TYPE; }
        if(type_name == std::string("mk12")
           || type_name == std::string("Smart Extruder")) {
            return TYPE::MK12; }
        if(type_name == std::string("mk13")
           || type_name == std::string("Smart Extruder+")) {
            return TYPE::MK13; }
        if(type_name == std::string("mk13_impla")
           || type_name == std::string("Tough PLA Smart Extruder+")) {
            return TYPE::MK13_IMPLA; }
        if(type_name == std::string("mk14")
           || type_name == std::string("Model 1 Performance Extruder")) {
            return TYPE::MK14; }
        if(type_name == std::string("mk14_s")
           || type_name == std::string("Support 2 Performance Extruder")) {
            return TYPE::MK14_S; }
        if(type_name == std::string("mk14_hot")
           || type_name == std::string("Model 1 Performance Extruder")) {
            return TYPE::MK14_HOT; }
        if(type_name == std::string("mk14_hot_s")
           || type_name == std::string("Support 2 Performance Extruder")) {
            return TYPE::MK14_HOT_S; }
        return TYPE::UNKNOWN_TYPE;
    }

    static std::string type_name_from_type(const TYPE type) {
        if(type == TYPE::UNKNOWN_TYPE) { return "Unknown";}
        if(type == TYPE::MK12) { return "Smart Extruder";}
        if(type == TYPE::MK13) { return "Smart Extruder+";}
        if(type == TYPE::MK13_IMPLA) { return "Tough PLA Smart Extruder+";}
        if(type == TYPE::MK14) { return "Model 1 Performance Extruder";}
        if(type == TYPE::MK14_S) { return "Support 2 Performance Extruder";}
        if(type == TYPE::MK14_HOT) { return "Model 1 Performance Extruder";}
        if(type == TYPE::MK14_HOT_S) { return "Support 2 Performance Extruder";}
        return "Unknown";
    }

    static std::string material_from_material_type(const MATERIALS mat) {
        switch(mat) {
        case MATERIALS::PLA:
            return std::string("PLA");
        case MATERIALS::IMPLA:
            return std::string("IMPLA");
        case MATERIALS::PVA:
            return std::string("PVA");
        case MATERIALS::UNKNOWN:
            return std::string("UNKNOWN");
        default:
            return std::string("Unknown");
        }
    }

    TOOL tool() const { return m_tool; }

    bool operator==(const YonkersTool& rValue) const {
        return this->m_tool == rValue.m_tool;
    }

    bool type_match(const YonkersTool& rValue) const {
        return type() == rValue.type();
    }

    static bool toolpaths_equivalent(const TYPE a, const TYPE b) {
        switch(a) {
        case TYPE::UNKNOWN_TYPE:
            switch(b) {
            case TYPE::MK12: return true; break;
            case TYPE::MK13: return true; break;
            case TYPE::UNKNOWN_TYPE: return true; break;
            default: return false; break;
            }
        case TYPE::MK12:
            switch(b) {
            case TYPE::UNKNOWN_TYPE: return true; break;
            case TYPE::MK12: return true; break;
            default: return false; break;
            }
        case TYPE::MK13:
            switch(b) {
            case TYPE::UNKNOWN_TYPE: return true; break;
            case TYPE::MK13: return true; break;
            default: return false; break;
            }
        case TYPE::MK13_IMPLA:
            switch(b) {
            case TYPE::UNKNOWN_TYPE: return true; break;
            case TYPE::MK13_IMPLA: return true; break;
            default: return false; break;
            }
        case TYPE::MK14:
            switch(b) {
            case TYPE::UNKNOWN_TYPE: return true; break;
            case TYPE::MK14: return true; break;
            default: return false; break;
            }
        case TYPE::MK14_S:
            switch(b) {
            case TYPE::UNKNOWN_TYPE: return true; break;
            case TYPE::MK14_S: return true; break;
            default: return false; break;
            }
        case TYPE::MK14_HOT:
            switch(b) {
            case TYPE::UNKNOWN_TYPE: return true; break;
            case TYPE::MK14_HOT: return true; break;
            default: return false; break;
            }
        case TYPE::MK14_HOT_S:
            switch(b) {
            case TYPE::UNKNOWN_TYPE: return true; break;
            case TYPE::MK14_HOT_S: return true; break;
            default: return false; break;
            }
        default: return false; break;
        }
    }

private:
    TOOL m_tool;
};

} // namespace bwcoreutils

#endif // YONKERS_TOOL_MAPPINGS
