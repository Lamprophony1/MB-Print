// This file was automatically generated, do not edit it!

#ifndef MACHINE_DEFINITIONS_HH
#define MACHINE_DEFINITIONS_HH
#ifndef BRONX
#include <set>
#include <array>
#include <string>
#endif

namespace machine {

enum LevelingStates {
    kTooHigh = 1,
    kTooLow = 0,
    kWrongWay = 3,
    kJustRight = 2,
}; //enum LevelingStates

#ifndef BRONX
inline LevelingStates NextLevelingStates(const LevelingStates& c) {
    return static_cast<LevelingStates>(static_cast<size_t>(c)+1);
}
inline LevelingStates PreviousLevelingStates(const LevelingStates& c) {
    return static_cast<LevelingStates>(static_cast<size_t>(c)-1);
}

#endif

enum LevelingKnobs {
    kKnob1 = 1,
    kFixed = 0,
    kKnob2 = 2,
}; //enum LevelingKnobs

#ifndef BRONX
inline LevelingKnobs NextLevelingKnobs(const LevelingKnobs& c) {
    return static_cast<LevelingKnobs>(static_cast<size_t>(c)+1);
}
inline LevelingKnobs PreviousLevelingKnobs(const LevelingKnobs& c) {
    return static_cast<LevelingKnobs>(static_cast<size_t>(c)-1);
}

#endif

enum PowerMonitorRail {
    k5V = 0,
    k12V = 1,
    k3V3 = 2,
    k3V3Standby = 3,
    k36V = 4,
    k36Vtopbunk = 5,
    k12Vtopbunk = 6,
}; //enum PowerMonitorRail

#ifndef BRONX
inline std::string ToString(PowerMonitorRail val) {
    switch(val) {
    case k5V: return "5v";
    case k12V: return "12v";
    case k3V3: return "3v3";
    case k3V3Standby: return "3v3Standby";
    case k36V: return "36v";
    case k36Vtopbunk: return "36vTopbunk";
    case k12Vtopbunk: return "12vTopbunk";
    default: return std::string("<invalid axis ")
        + std::to_string(static_cast<int>(val)) + ">";
    }
}
inline PowerMonitorRail PowerMonitorRailFromString(const std::string& val) {
    if (false) {
    } else if (val == "5v") {
        return k5V;
    } else if (val == "12v") {
        return k12V;
    } else if (val == "3v3") {
        return k3V3;
    } else if (val == "3v3Standby") {
        return k3V3Standby;
    } else if (val == "36v") {
        return k36V;
    } else if (val == "36vTopbunk") {
        return k36Vtopbunk;
    } else if (val == "12vTopbunk") {
        return k12Vtopbunk;
    } else {
        return static_cast<PowerMonitorRail>(-1);
    }
}
inline PowerMonitorRail NextPowerMonitorRail(const PowerMonitorRail& c) {
    return static_cast<PowerMonitorRail>(static_cast<size_t>(c)+1);
}
inline PowerMonitorRail PreviousPowerMonitorRail(const PowerMonitorRail& c) {
    return static_cast<PowerMonitorRail>(static_cast<size_t>(c)-1);
}

#endif

enum PowerMonitorValue {
    kCurrent = 0,
    kVoltage = 1,
}; //enum PowerMonitorValue

#ifndef BRONX
inline std::string ToString(PowerMonitorValue val) {
    switch(val) {
    case kCurrent: return "Current";
    case kVoltage: return "Voltage";
    default: return std::string("<invalid axis ")
        + std::to_string(static_cast<int>(val)) + ">";
    }
}
inline PowerMonitorValue PowerMonitorValueFromString(const std::string& val) {
    if (false) {
    } else if (val == "Current") {
        return kCurrent;
    } else if (val == "Voltage") {
        return kVoltage;
    } else {
        return static_cast<PowerMonitorValue>(-1);
    }
}
inline PowerMonitorValue NextPowerMonitorValue(const PowerMonitorValue& c) {
    return static_cast<PowerMonitorValue>(static_cast<size_t>(c)+1);
}
inline PowerMonitorValue PreviousPowerMonitorValue(const PowerMonitorValue& c) {
    return static_cast<PowerMonitorValue>(static_cast<size_t>(c)-1);
}

#endif

enum AxisName {
    kX = 0,
    kY = 1,
    kZ = 2,
    kA = 3,
    kB = 4,
    kAA = 5,
    kBB = 6,
}; //enum AxisName

#ifndef BRONX
inline std::string ToString(AxisName val) {
    switch(val) {
    case kX: return "x";
    case kY: return "y";
    case kZ: return "z";
    case kA: return "a";
    case kB: return "b";
    case kAA: return "aa";
    case kBB: return "bb";
    default: return std::string("<invalid axis ")
        + std::to_string(static_cast<int>(val)) + ">";
    }
}
inline AxisName AxisNameFromString(const std::string& val) {
    if (false) {
    } else if (val == "x") {
        return kX;
    } else if (val == "y") {
        return kY;
    } else if (val == "z") {
        return kZ;
    } else if (val == "a") {
        return kA;
    } else if (val == "b") {
        return kB;
    } else if (val == "aa") {
        return kAA;
    } else if (val == "bb") {
        return kBB;
    } else {
        return static_cast<AxisName>(-1);
    }
}
inline AxisName NextAxisName(const AxisName& c) {
    return static_cast<AxisName>(static_cast<size_t>(c)+1);
}
inline AxisName PreviousAxisName(const AxisName& c) {
    return static_cast<AxisName>(static_cast<size_t>(c)-1);
}

#endif

enum Constants {
    kAxisCount = 4,
    kWarningThreshold = 500,
    kToolheadWarningThreshold = 128,
    kPruBufferSize = 1170,
    kMachineErrorThreshold = 2000,
    kToolheadVersionBytes = 2,
    kProcessErrorThreshold = 1000,
}; //enum Constants

#ifndef BRONX
inline Constants NextConstants(const Constants& c) {
    return static_cast<Constants>(static_cast<size_t>(c)+1);
}
inline Constants PreviousConstants(const Constants& c) {
    return static_cast<Constants>(static_cast<size_t>(c)-1);
}

#endif

enum HesMode {
    kFreeRun = 0,
    kFixedLength = 1,
}; //enum HesMode

#ifndef BRONX
inline std::string ToString(HesMode val) {
    switch(val) {
    case kFreeRun: return "free_run";
    case kFixedLength: return "fixed_length";
    default: return std::string("<invalid axis ")
        + std::to_string(static_cast<int>(val)) + ">";
    }
}
inline HesMode HesModeFromString(const std::string& val) {
    if (false) {
    } else if (val == "free_run") {
        return kFreeRun;
    } else if (val == "fixed_length") {
        return kFixedLength;
    } else {
        return static_cast<HesMode>(-1);
    }
}
inline HesMode NextHesMode(const HesMode& c) {
    return static_cast<HesMode>(static_cast<size_t>(c)+1);
}
inline HesMode PreviousHesMode(const HesMode& c) {
    return static_cast<HesMode>(static_cast<size_t>(c)-1);
}

#endif


 #ifndef BRONX
// Still need this for Birdwing-Machine for now
typedef std::set<AxisName> AxisSet;

inline std::array<machine::AxisName, 3> GantryAxes() {
    return {machine::kX, machine::kY, machine::kZ};
}

inline std::array<machine::AxisName, 2> ExtruderAxes() {
    return {machine::kA, machine::kB};
}
 #endif
} //namespace
#endif // MACHINE_DEFINITIONS_HH
