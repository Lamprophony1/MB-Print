# For use with CMakePackageConfigHelpers:
# http://www.cmake.org/cmake/help/v2.8.12/cmake.html#module:CMakePackageConfigHelpers
#
# Certain variables need to be defined in the calling script or passed to
# PATH_VARS when configure_package_config_file()ing this.
#
# CONFIG_BASENAME must always be defined in the calling scope
# Set CONFIGURE_TARGETS in the calling scope to indicate that we should include
#     a targets file and make sure that TARGETS_FILENAME is defined in the
#     calling scope and FINDPACKAGE_CONFIG_INSTALL_DIR is passed to PATH_VARS
# Set CONFIGURE_ADDITIONAL_PATHS in the calling scope to indicate that we should
#     set variable pointing to paths and make sure that ADDITIONAL_PATH_VARS,
#     ADDITIONAL_PATHS, and CONFIG_FILENAME are defined in the calling scope
# Set CONFIGURE_CMAKE_INCLUDES in the calling scope to indicate that we should
#     include a list of additional .cmake files and make sure that
#     CMAKE_INCLUDES is defined in the calling scope
# Set CONFIGURE_TRANSITIVE_DEPENDENCIES in the calling scope to indicate that
#     we should find_dependency a list of packages. Make sure that
#     TRANSITIVE_DEPENDENCIES is also defined in the calling scope.


####### Expanded from @PACKAGE_INIT@ by configure_package_config_file() #######
####### Any changes to this file will be overwritten by the next CMake run ####
####### The input file was AdvancedConfigTemplate.cmake                            ########

get_filename_component(PACKAGE_PREFIX_DIR "${CMAKE_CURRENT_LIST_DIR}/../" ABSOLUTE)

macro(set_and_check _var _file)
  set(${_var} "${_file}")
  if(NOT EXISTS "${_file}")
    message(FATAL_ERROR "File or directory ${_file} referenced by variable ${_var} does not exist !")
  endif()
endmacro()

macro(check_required_components _NAME)
  foreach(comp ${${_NAME}_FIND_COMPONENTS})
    if(NOT ${_NAME}_${comp}_FOUND)
      if(${_NAME}_FIND_REQUIRED_${comp})
        set(${_NAME}_FOUND FALSE)
      endif()
    endif()
  endforeach()
endmacro()

####################################################################################

# Makes the if()s below behave correctly
cmake_policy(SET CMP0012 NEW)

if(TRUE)
    set(TARGETFILE_LIST "JsonRpcTargets.cmake")
    foreach(target_file ${TARGETFILE_LIST})
        # make sure it exists an include it
        # see the note below about the ${PACKAGE_PREFIX_DIR} hack
        set_and_check(
            target_file
            ${PACKAGE_PREFIX_DIR}/cmake/${target_file})
        include(${target_file})
    endforeach()
endif()

if(TRUE)
    # So, supposedly we're supposed to use include(CMakeFindDependencyMacro)
    # and find_dependency(), but it doesn't support all the find_package
    # arguments we need.
    set(TRANSITIVE_DEPENDENCIES "JsonCpp REQUIRED")
    foreach(dep ${TRANSITIVE_DEPENDENCIES})
        string(REPLACE " " ";" dep_args "${dep}")
        find_package(${dep_args})
    endforeach()
endif()

if(FALSE)
    set(CMAKE_INCLUDES "")
    foreach(incl ${CMAKE_INCLUDES})
        # make sure it exists an include it
        # see the note below about the ${PACKAGE_PREFIX_DIR} hack
        set_and_check(incl ${PACKAGE_PREFIX_DIR}/${incl})
        include(${incl})
    endforeach()
endif()

if(FALSE)
    set(ADDITIONAL_PATH_VARS "")
    set(ADDITIONAL_PATHS "")

    list(LENGTH ADDITIONAL_PATHS num_paths)
    list(LENGTH ADDITIONAL_PATH_VARS num_path_vars)
    if(NOT ${num_paths} EQUAL ${num_path_vars})
        message(FATAL_ERROR "Someone (probably Ted) did something stupid.")
    endif()
    math(EXPR num_paths "${num_paths} - 1")
    foreach(idx RANGE ${num_paths})
        list(GET ADDITIONAL_PATH_VARS ${idx} path_var)
        list(GET ADDITIONAL_PATHS ${idx} path)
        if(DEFINED ${path_var})
            # I'm not sure this is the right behaviour, but the difficulty
            # level of finding bugs caused by a config file silently overwriting
            # stuff makes me inclined to be cautious.
            message(
                FATAL_ERROR
                "JsonRpcConfig.cmake won't overwrite existing var: ${path_var}")
        endif()
        # This is a bit of a hack, because we're relying on the internals
        # of CMakePackageConfigHelpers. To get around this I think we'd have
        # to have a template that produces this template, and this solution
        # with the loops and this hack seems better.
        set_and_check(${path_var} ${PACKAGE_PREFIX_DIR}/${path})
    endforeach()
endif()

# adapted from http://www.cmake.org/pipermail/cmake/2011-June/045050.html
# check that the user-requested components are
# actually targets that are part of this build
if(JsonRpc_FIND_COMPONENTS)
    foreach(component ${JsonRpc_FIND_COMPONENTS})
        if(NOT TARGET ${component})
            set(JsonRpc_${component}_FOUND FALSE)
            if(JsonRpc_FIND_REQUIRED_${component})
                message(SEND_ERROR "JsonRpc::${component} not available.")
            endif()
        else()
            set(JsonRpc_${component}_FOUND TRUE)
        endif()
    endforeach()
endif()

check_required_components(JsonRpc)
