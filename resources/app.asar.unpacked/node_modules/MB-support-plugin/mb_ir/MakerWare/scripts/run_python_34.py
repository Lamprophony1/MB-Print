#!/usr/bin/env python

import os
import subprocess
import sys
import traceback


def _infer_repo_install_path(verbose=1):

    repo_path = None

    try:
        repo_path = subprocess.check_output(['git',
                                             'rev-parse',
                                             '--show-toplevel']).strip()

        # in py3, subprocess.check_output returns a byte string. decode it and
        # cast it as a string
        if isinstance(repo_path, bytes):
            repo_path = str(repo_path.decode("utf-8"))
    except Exception as ex:
        if verbose >= 1:
            print("Could not infer repo path from git information.")
            if verbose >= 2:
                traceback.print_exc()

    install_path = None

    dot_filename = os.path.join(
        os.path.dirname(__file__), ".install_root")

    if 'MB_INSTALL_ROOT' in os.environ:
        install_path = os.environ['MB_INSTALL_ROOT']

    elif os.path.exists(dot_filename):

        relative_install_path = None
        with open(dot_filename, 'r') as dot_file:
            relative_install_path = \
                dot_file.read().replace('\n', '').strip()

        install_path = os.path.join(
            os.path.dirname(dot_filename), relative_install_path)

        if not os.path.exists(install_path):
            if verbose >= 1:
                print("Could not find install path '%s' listed in %s." %
                      (relative_install_path, dot_filename))

    elif repo_path:

        # Sigh, local Install path is ./Install, Jenkins is at ../Install, and
        # Toolchain Install is at ../../Install. Try local, Toolchain, Jenkins.
        install_path = os.path.join(repo_path, "Install")
        if not os.path.exists(install_path):
            install_path = os.path.join(repo_path, "..", "..", "Install")
        if not os.path.exists(install_path):
            install_path = os.path.join(repo_path, "..", "Install")

    else:
        raise Exception("Could not infer install path - "
                        "no MB_INSTALL_ROOT env variable, "
                        ".install_root dotfile, "
                        "or parent [../../]./Install found.")

    if not os.path.exists(install_path):
        raise Exception("Could not infer install path - "
                        "%s does not exist." % install_path)

    return (os.path.abspath(repo_path) if repo_path else None,
            os.path.abspath(install_path))


def _prepend(env, key, *new_paths):
    curr_value = [env[key]] if key in env else []
    env[key] = \
        os.pathsep.join(list(new_paths) + curr_value)


def _append(env, key, *new_paths):
    curr_value = [env[key]] if key in env else []
    env[key] = \
        os.pathsep.join(curr_value + list(new_paths))


def _bootstrap_v34_win(install_path, env):

    mb_resources = os.path.join(install_path, "MakerWare")

    # For sliceconfig, for now
    env["MB_RESOURCE_PATH"] = mb_resources

    # PYTHONHOME must be explicitly specified
    env["PYTHONHOME"] = os.path.join(mb_resources, "python34")

    _append(env, "PATH",
            # For binaries
            mb_resources,
            # For python34-req'd DLLs
            os.path.join(mb_resources, "python34", "DLLs"))

    _append(env, "PYTHONPATH",
            os.path.join(mb_resources, "python"))

    return (os.path.join(mb_resources, "python3.4.exe"), env)


def _bootstrap_v34_osx(install_path, env):

    mb_resources = os.path.join(install_path, "Library", "MakerBot")

    # For sliceconfig, for now
    env["MB_RESOURCE_PATH"] = mb_resources

    # PYTHONHOME can be inferred as parent of mb_resources, but we specify here
    env["PYTHONHOME"] = mb_resources

    _append(env, "PATH", mb_resources)

    # Generally library stuff is handled by rpaths on OSX, but in the special
    # case of builds we don't have that set up yet.
    _append(env, "DYLD_LIBRARY_PATH",
            os.path.join(mb_resources, "lib"))

    _append(env, "PYTHONPATH",
            os.path.join(mb_resources, "python"))

    return (os.path.join(mb_resources, "python3.4m"), env)


def _bootstrap_v34_linux(install_path, env):

    mb_resources = os.path.join(install_path, "usr", "share", "makerbot")

    # For sliceconfig, for now
    env["MB_RESOURCE_PATH"] = mb_resources

    _append(env, "PATH",
            os.path.join(install_path, "usr", "bin"))

    _append(env, "LD_LIBRARY_PATH",
            os.path.join(install_path, "usr", "lib"))

    _append(env, "PYTHONPATH",
            os.path.join(mb_resources, "python34"))

    # We rely on a system-installed python3.4 on linux
    return ("python3.4", env)


def bootstrap_v34(argv=None, verbose=None, pip_packages=[]):

    if 'PYTHON_BOOTSTRAPPED' in os.environ:
        return

    if argv is None:
        argv = list(sys.argv)

    if verbose is None:
        if 'BOOTSTRAP_QUIET' in os.environ:
            verbose = 0
        elif 'BOOTSTRAP_LOUD' in os.environ:
            verbose = 2
        else:
            verbose = 1

    env = os.environ.copy()

    repo_path, install_path = _infer_repo_install_path(verbose)

    if repo_path:
        # Local repo takes priority
        _append(env, "PYTHONPATH", repo_path)

    if sys.version_info < (3, 0):
        if verbose >= 1:
            print("Bootstrapping with local sources in PYTHONPATH (%s)" %
                  os.path.relpath(repo_path, os.getcwd()))

        if sys.platform.startswith("win"):
            python34, env = _bootstrap_v34_win(install_path, env)
        elif sys.platform.startswith("darwin"):
            python34, env = _bootstrap_v34_osx(install_path, env)
        elif sys.platform.startswith("linux"):
            python34, env = _bootstrap_v34_linux(install_path, env)
    else:
        # WARNING - This might not be python3.4, its just a version of python3
        python34 = 'python'

    # If this file is being executed as a script or we're getting executed by
    # the python interpreter on the command line, omit this script name or
    # python.exe
    if __name__ == "__main__" or \
       os.path.basename(sys.executable) == os.path.basename(argv[0]):
        argv = argv[1:]

    env['PYTHON_BOOTSTRAPPED'] = "1"

    if verbose >= 1:
        print("Restarting with toolchain python (%s)" %
              os.path.relpath(python34, os.getcwd()))

    # Make our messages show up now
    sys.stdout.flush()

    for package in pip_packages:
        subprocess.call([python34, '-m', 'pip', 'install', package], env=env)

    sys.exit(subprocess.call([python34] + argv, env=env))

# Start python when called from the outside world
if __name__ == "__main__":
    bootstrap_v34()
