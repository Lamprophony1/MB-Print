#!/usr/bin/python

import run_python_34
run_python_34.bootstrap_v34()

import os
import sys
import argparse
import zipfile
import tempfile
import json

import pygrue

"""Packages json toolpath from command line."""


def add_v0_firmware_metadata(meta_json, bot_type):
    # This is effectively a mini-libtinything aka .makerbot packager, which
    # should be kept minimally up-to-date for testing
    meta_json["generated_by_desktop"] = False

    # Version 0 is maximially compatible, but we add some v1 keys in to make it
    # more readable for everybody
    if "version" in meta_json:
        del meta_json["version"]

    if bot_type:
        meta_json["bot_type"] = bot_type

    # V0, V1 temperatures
    extruder_temperatures = meta_json["extruder_temperatures"]
    meta_json["extruder_temperature"] = extruder_temperatures[0]
    meta_json["toolhead_0_temperature"] = extruder_temperatures[0]
    meta_json["toolhead_1_temperature"] = \
        extruder_temperatures[1] \
        if len(extruder_temperatures) > 1 else 0

    # Distances
    extrusion_distances = meta_json["extrusion_distances_mm"]
    meta_json["extrusion_distance_mm"] = extrusion_distances[0]
    meta_json["extrusion_distance_a_mm"] = extrusion_distances[0]
    meta_json["extrusion_distance_b_mm"] = \
        extrusion_distances[1] \
        if len(extrusion_distances) > 1 else 0

    # No materials are required

    # Copy these keys over for reporting
    config_json = meta_json["miracle_config"]
    meta_json["printer_settings"] = {

        "shells": config_json.get("numberOfShells", 0),
        "support": config_json.get("doSupport", False),
        "layer_height": config_json.get("layerHeight", 0.0),
        "infill": config_json.get("infillDensity", 0.0),
        "raft": config_json.get("doRaft", False),

        "extruder_temperatures": [meta_json["toolhead_0_temperature"],
                                  meta_json["toolhead_1_temperature"]]
    }

    # What does this do? from v1.1
    meta_json["max_layer"] = meta_json["num_z_layers"]

    # Tool type is empty, to be as flexible as possible

# def add_v3_firmware_metadata(meta_json, bot_type):

#     # This is effectively a mini-libtinything aka .makerbot packager, which
#     # should be kept minimally up-to-date for testing

#     # Get singular values for all the keys
#     add_v1_firmware_metadata(meta_json, bot_type)

#     # Version 3 is required for new bots
#     meta_json["version"] = "3.0.0"

#     # TODO: Make this work once sliceconfig is working at v3.0.0


def get_thumbnails_for(thumbnail_query):

    try:
        import giphypop
        import urllib.request
        import urllib.parse
        import urllib.error
        from PIL import Image
    except ImportError as ex:

        print("For thumbnails, make sure you have the "
              "'giphypop' and 'Pillow' libraries installed.")

        raise ex

    giphy = giphypop.Giphy()
    results = [x for x in giphy.search(thumbnail_query, limit=1)]

    ext = os.path.splitext(results[0].media_url)[1]
    image_tempfile = pygrue.utils.TemporaryFile(suffix=ext)

    print(("Downloading package image from %s..." % results[0].media_url))
    urllib.request.urlretrieve(results[0].media_url,
                               image_tempfile.name)

    thumbnail_tempdir = pygrue.utils.TemporaryDir()

    thumbnails = [("thumbnail_320x200.png", (320, 200)),
                  ("thumbnail_110x80.png", (110, 80)),
                  ("thumbnail_55x40.png", (55, 40))]

    print("Generating thumbnails...")

    for thumbnail_filename, size in thumbnails:

        image = Image.open(image_tempfile.name)
        image.thumbnail(size, Image.ANTIALIAS)
        image.save(os.path.join(thumbnail_tempdir.name, thumbnail_filename),
                   "PNG")

    return thumbnail_tempdir


def package_metadata(meta_filename, meta_version, bot_type, extra_json=None):

    meta_json = None
    with open(meta_filename, 'r') as meta_file:
        meta_json = json.load(meta_file)

    if meta_version == -1:
        print("Not modifying packaged metadata.")
    elif meta_version == 0:
        add_v0_firmware_metadata(meta_json, bot_type)
    elif meta_version == 3:
        raise Exception("Not yet implemented!")
        # add_v3_firmware_metadata(meta_json, bot_type)

    if extra_json:
        meta_json.update(extra_json)

    packaged_meta_tempfile = pygrue.utils.TemporaryFile()
    with open(packaged_meta_tempfile.name, 'w') as packaged_meta_file:
        json.dump(meta_json, packaged_meta_file, sort_keys=True, indent=2)

    return packaged_meta_tempfile


def package_toolpath(toolpath_filename, meta_filename, package_filename,
                     compress=True, extra_dir=None):

    compress_method = zipfile.ZIP_STORED
    if compress:
        compress_method = zipfile.ZIP_DEFLATED

    with zipfile.ZipFile(package_filename, 'w', compress_method) as\
            package_zipfile:

        package_zipfile.write(toolpath_filename, 'print.jsontoolpath')
        package_zipfile.write(meta_filename, 'meta.json')

        if extra_dir:
            for filename in os.listdir(extra_dir):
                package_zipfile.write(os.path.join(extra_dir, filename),
                                      filename)

DESCRIPTION = \
    """Package json toolpath from command line. """

if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description=DESCRIPTION)

    parser.add_argument(
        '--bot-types', dest='bot_types',
        help='Comma-separated list of bot types', default=None)

    parser.add_argument(
        '--toolpath-file', dest='toolpath_filename',
        help='Toolpath to package', default="./print.jsontoolpath")

    parser.add_argument(
        '--meta-file', dest='meta_filename', help='Meta file to package',
        default="./meta.json")

    parser.add_argument(
        '--meta-v3', dest='meta_v3', action='store_true',
        help='Package with metadata v3 instead of v0', default=False)

    parser.add_argument(
        '--meta-raw', dest='meta_raw', action='store_true',
        help='Do not try to munge metadata to a particular version,'
        'just use incoming.',
        default=False)

    parser.add_argument(
        '--extra', dest='extra_json',
        help='Additional JSON to add to the meta.json', default=None)

    parser.add_argument(
        '--package-only', dest='package_only', action='store_true',
        help='Disable compression of the packaged makerbot file',
        default=False)

    parser.add_argument(
        '--and-unpackage', dest='and_unpackage', action='store_true',
        help='Also immediately unpackage for helpful debugging info',
        default=False)

    parser.add_argument(
        '--thumbnails-be-like', dest='thumbnail_query',
        help='Make .makerbot thumbnails great again', default=None)

    parser.add_argument(
        metavar='PACKAGE_FILE', dest='package_filename',
        help='Makerbot package file to create')

    args = parser.parse_args(sys.argv[1:])

    if not args.package_filename:
        raise Exception("No makerbot file specified.")

    if not args.bot_types and args.meta_v3:
        raise Exception("No bot types specified.")

    extra_json = args.extra_json
    if extra_json is not None:
        extra_json = json.loads(extra_json)

    if args.bot_types:
        bot_types = [bot_type.strip() for bot_type in args.bot_types.split(",")
                     if bot_type]
    else:
        bot_types = [None]

    for bot_type in bot_types:

        packaged_meta_tempfile = None
        if args.meta_v3:
            packaged_meta_tempfile = package_metadata(args.meta_filename, 3,
                                                      bot_type, extra_json)
        elif args.meta_raw:
            packaged_meta_tempfile = package_metadata(args.meta_filename, -1,
                                                      bot_type, extra_json)
        else:
            packaged_meta_tempfile = package_metadata(args.meta_filename, 0,
                                                      bot_type, extra_json)

        package_filename = args.package_filename
        if len(bot_types) > 1:
            base, ext = os.path.splitext(package_filename)
            package_filename = base + "." + bot_type + ext

        thumbnail_tempdir = None
        if args.thumbnail_query:
            thumbnail_tempdir = get_thumbnails_for(args.thumbnail_query)

        print(("Packaging %s..." % package_filename))

        # with open(packaged_meta_tempfile.name, 'r') as packaged_meta_file:
        #    print(json.dumps(
        #       json.load(packaged_meta_file), sort_keys=True, indent=2))

        package_toolpath(args.toolpath_filename,
                         packaged_meta_tempfile.name,
                         package_filename,
                         not args.package_only,
                         thumbnail_tempdir.name if thumbnail_tempdir else None)

        if args.and_unpackage:
            import unpackage_makerbot_file
            unpackage_makerbot_file.unpackage_makerbot(package_filename)
