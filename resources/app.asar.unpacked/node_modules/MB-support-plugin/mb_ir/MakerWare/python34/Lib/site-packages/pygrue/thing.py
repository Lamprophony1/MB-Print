import ctypes
import os

from . import utils


def _get_lib_thing():
    """
    Gets libtinything and specifies all the return/param types, since
    unix seems like the only platform that is good at interrpreting
    those types of things.
    """

    libthing = utils.default_thing_lib_path()
    lib = ctypes.CDLL(libthing)

    # Create a New Thing and return a pointer to it
    lib.NewThing.argtypes = []
    lib.NewThing.restype = ctypes.c_void_p

    # Add an Instance with a Gaggle Name, a Mesh File Path, a Transform and a
    # Material to a Thing. Returns nothing.
    lib.AddInstance.argtypes = [
        ctypes.c_void_p,  # thing
        ctypes.c_char_p,  # gaggle name
        ctypes.c_char_p,  # mesh file path
        ctypes.c_void_p,  # transform
        ctypes.c_char_p   # material
    ]
    lib.AddInstance.restype = None

    # Write a Thing to a Filepath. Returns a True if successful.
    lib.WriteThing.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
    lib.WriteThing.restype = ctypes.c_bool

    # Create a new default Transform with an identity matrix.
    lib.NewTransform.argtypes = []
    lib.NewTransform.restype = ctypes.c_void_p

    # Set the translation for a Transformation in x, y, and z
    lib.SetTranslation.argtypes = [
        ctypes.c_void_p,    # transform
        ctypes.c_float,     # x
        ctypes.c_float,     # y
        ctypes.c_float      # z
    ]
    lib.SetTranslation.restype = ctypes.c_void_p

    # Set the rotation for a Transform using a Quaternion
    lib.SetRotation.argtypes = [
        ctypes.c_void_p,    # transform
        ctypes.c_float,     # a
        ctypes.c_float,     # b
        ctypes.c_float,     # c
        ctypes.c_float      # d
    ]
    lib.SetRotation.restype = ctypes.c_void_p

    lib.SetScale.argtypes = [
        ctypes.c_void_p,    # transform
        ctypes.c_float,     # x
        ctypes.c_float,     # y
        ctypes.c_float      # z
    ]
    lib.SetScale.restype = ctypes.c_void_p

    lib.GetBoundingBox.argtypes = [
        ctypes.c_char_p,    # path to .thing
    ]
    lib.GetBoundingBox.restype = ctypes.py_object

    return lib

_libthing_interface = _get_lib_thing()


class Transform:

    def __init__(self):
        self.translation = [0, 0, 0]
        self.rotation = [1, 0, 0, 0]
        self.scale = [1, 1, 1]

    def to_ctype(self):
        c_transform = _libthing_interface.NewTransform()
        _libthing_interface.SetTranslation(
            c_transform,
            ctypes.c_float(self.translation[0]),
            ctypes.c_float(self.translation[1]),
            ctypes.c_float(self.translation[2]))

        _libthing_interface.SetRotation(
            c_transform,
            ctypes.c_float(self.rotation[0]),
            ctypes.c_float(self.rotation[1]),
            ctypes.c_float(self.rotation[2]),
            ctypes.c_float(self.rotation[3]))

        _libthing_interface.SetScale(
            c_transform,
            ctypes.c_float(self.scale[0]),
            ctypes.c_float(self.scale[1]),
            ctypes.c_float(self.scale[2]))

        return c_transform


class Model:

    def __init__(self, filename, model_type=None):
        self.filename = filename
        self.md5 = utils.md5_hash(self.filename)

        if model_type:
            self.model_type = model_type
        else:
            ext = os.path.splitext(filename)[1]
            if ext == '.stl':
                self.model_type = 'stl'
            else:
                self.model_type = 'thing'


class Instance:

    def __init__(
            self, model_or_filename, transform=Transform(), material='right'):
        if isinstance(model_or_filename, Model):
            self.model = model_or_filename
        else:
            self.model = Model(model_or_filename)

        if self.model.model_type == 'thing':
            raise Exception("Instances require dot stl files. File at %s is a "
                            "dot thing file." % self.model.filename)

        self.transform = transform
        self.material = material


class Gaggle:

    def __init__(self, name='default'):
        self.name = name
        self.instances = []

    def add_instance(self, instance):
        self.instances.append(instance)


class Thing:

    def __init__(self):
        self.c_thing = _libthing_interface.NewThing()
        self.gaggles = []

    def __add_instance(self, gaggle, instance):
        _libthing_interface.AddInstance(
            self.c_thing,
            ctypes.c_char_p(bytes(gaggle.name, encoding="utf-8")),
            ctypes.c_char_p(bytes(instance.model.filename, encoding="utf-8")),
            instance.transform.to_ctype(),
            ctypes.c_char_p(bytes(instance.material, encoding="utf-8")))

    def add_gaggle(self, gaggle): self.gaggles.append(gaggle)

    def gaggle(self, name):
        for g in self.gaggles:
            if g.name == name:
                return g
        new_gaggle = Gaggle(name=name)
        self.add_gaggle(new_gaggle)
        return new_gaggle

    def write_to_file(self, filename):
        for g in self.gaggles:
            for i in g.instances:
                self.__add_instance(gaggle=g, instance=i)

        return _libthing_interface.WriteThing(
            self.c_thing, ctypes.c_char_p(bytes(filename, encoding="utf-8")))


def get_bounding_box(path):
    return _libthing_interface.GetBoundingBox(
        ctypes.c_char_p(bytes(path, encoding='utf-8')))
