import os
import sys
import json
import math

import zipfile

from . import bigjson
from . import utils

# flaot regex used by the splid_by_comment function
import re
float_re = r'-?\d+\.?\d*'

"""
Miracle_Grue Toolpath API for python
"""


class Toolpath:

    def __init__(self, filename_or_data, metadata_json=None, process=None,
                 toolpath_type=None):

        data = None
        self.filename = None
        self.tempfile = None

        # check if it is a file, or raw data in
        if isinstance(filename_or_data, (list, tuple)):
            data = filename_or_data
        elif isinstance(filename_or_data, utils.TemporaryFile):
            self.tempfile = filename_or_data
            self.filename = self.tempfile.name
        elif os.path.exists(filename_or_data):
            self.filename = filename_or_data

        # if it is data, what kind of data
        if data and toolpath_type is None:
            if len(data) > 0 and isinstance(data[0], str):
                self.toolpath_type = 'gcode'
            else:
                self.toolpath_type = 'jsontoolpath'
        # if not data, must be file
        elif not toolpath_type:
            valid_exts = ['.gcode', '.makerbot', '.jsontoolpath']
            ext = os.path.splitext(self.filename)[1]
            if ext in valid_exts:
                self.toolpath_type = ext[1:]
            else:
                raise Exception(("Unknown type of toolpath '%s' "
                                 "at '%s'") % (ext, self.filename))
        else:
            self.toolpath_type = toolpath_type

        self.tempfile = None
        if not self.filename:
            self.tempfile = utils.TemporaryFile()
            with open(self.tempfile.name, 'w') as toolpath_file:
                if self.toolpath_type == 'gcode':
                    for gcode_line in data:
                        toolpath_file.write(gcode_line + '\n')
                else:
                    json.dump(data, toolpath_file, indent=2, sort_keys=True)
            self.filename = self.tempfile.name

        self.md5 = utils.md5_hash(self.filename)
        self.metadata = metadata_json
        self.process = process

        if self.toolpath_type == 'makerbot':
            with zipfile.ZipFile(self.filename, 'r') as makerbot_zip:
                toolpath_filenames = ['print.jsontoolpath', 'print.gcode']
                if all([name not in toolpath_filenames
                        for name in makerbot_zip.namelist()]):
                    raise Exception(("Unknown type of .makerbot toolpath "
                                     "at '%s'") % self.filename)

                if 'meta.json' in makerbot_zip.namelist():
                    with makerbot_zip.open('meta.json', 'r') as metadata_unzip:
                        self.metadata = \
                            json.loads(metadata_unzip.read().decode('utf-8'))

                if 'print.gcode' in makerbot_zip.namelist():
                    self.toolpath_type = "sketch"

    # Rounds X, Y, Z, A, B values in gcode file with 1 micron accuracy.
    # This function should be used to write float values to gcode file
    # instead of writing them directly without rounding.
    def round_float_for_gcode(self, value):
        return (round(value, 3))

    def get_command_lines(self):
        '''
        return commands from whatever type of input file is used
        '''
        if self.toolpath_type == "sketch":
            with zipfile.ZipFile(self.filename, 'r') as makerbot_zip:
                with makerbot_zip.open('print.gcode', 'r') as gcode_toolpath:
                    for gcode_line in gcode_toolpath:
                        yield gcode_line.decode('utf-8')

        elif self.toolpath_type == 'gcode':
            with open(self.filename, 'r') as gcode_file:
                for gcode_line in gcode_file:
                    yield gcode_line

        elif self.toolpath_type == 'jsontoolpath':
            with open(self.filename, 'r') as json_file:
                for command_json in bigjson.parse_big_toolpath(json_file):
                    yield command_json

        elif self.toolpath_type == 'makerbot':
            with zipfile.ZipFile(self.filename, 'r') as makerbot_zip:
                with makerbot_zip.open('print.jsontoolpath', 'r') as json_file:
                    for command_json in bigjson.parse_big_toolpath(json_file):
                        yield command_json

    def gcode_lines(self, index=None, window=None):
        # made this the smaller function
        tool_state = {'x': 0, 'y': 0, 'z': 0, 'a': 0, 'b': 0}

        def convert_to_gcode(command_json):

            if 'command' not in command_json:
                return None

            command = command_json['command']
            if 'function' not in command or \
                    command['function'] not in \
                    ['move', 'comment', 'toggle_fan']:
                return None

            params = command['parameters']
            values = []

            if command['function'] == 'comment':
                return '; {}'.format(params['comment'])

            # fan on / off
            if command["function"] == "toggle_fan":
                if params["value"]:
                    return 'M106; Enable Cooling Fan'
                else:
                    return 'M107; Disable Cooling Fan'

            for axis in 'xyzab':
                if axis not in params:
                    continue

                is_relative_move = command.get('metadata', {}) \
                    .get('relative', {}) \
                    .get(axis, False)

                if is_relative_move:
                    if axis in 'ab' and params[axis] == 0:
                        continue
                    tool_state[axis] += params[axis]
                else:
                    if axis in 'ab' and params[axis] == tool_state[axis]:
                        continue
                    tool_state[axis] = params[axis]

                values.append((
                    axis.upper(),
                    self.round_float_for_gcode(tool_state[axis]),))

                if axis == 'z':
                    values.append((
                        'F',
                        self.round_float_for_gcode(60*params['feedrate'])))

            if 'tags' in command:
                values.append((';', ' '.join(command['tags'])))

            return ' '.join(['G1'] + [k + str(v) for (k, v) in values])

        if self.toolpath_type == "sketch" or self.toolpath_type == 'gcode':
            for gcode_line in self.get_command_lines():
                yield gcode_line

        elif self.toolpath_type == 'jsontoolpath' or \
                self.toolpath_type == 'makerbot':
            for idx, command_json in enumerate(self.get_command_lines()):
                gcode_line = convert_to_gcode(command_json)
                if gcode_line:
                    # only output gcode lines in a window around a given
                    # jtp index
                    if index and window:
                        if abs(idx-index) < window / 2:
                            yield gcode_line + '\n'
                        if idx - index > window / 2:
                            break
                    else:
                        yield gcode_line + '\n'

    def json_commands(self):
        tool_state = {'x': 0, 'y': 0, 'z': 0, 'a': 0, 'b': 0}

        def convert_to_json(gcode_line):

            def get_parameters(move_split):
                '''
                takes in list of single line gcode and outputs dict
                ie ['G1','X0','Y0','Z0','A0','F0'] =>
                {'x':0,'y':0,'z':0,'a':0,'feedrate':0/60.0}
                will skip first member (G1)
                '''
                parameters = {}
                # eliminate blanks
                move_split[:] = [x for x in move_split if x != '']
                for move in move_split[1:]:
                    if move[0].lower() == 'f':
                        parameters['feedrate'] = float(move[1:])/60.0
                    elif move[0].lower() == 'e':
                        parameters['a'] = float(move[1:])
                    else:
                        parameters[move[0].lower()] = float(move[1:])
                return parameters

            command_function = ""
            parameters = None
            metadata = {}

            gcode_line = gcode_line.strip()
            gcode_command = None
            gcode_comment = None

            # Get comment from line
            if gcode_line.startswith(';'):
                gcode_command = ""
                gcode_comment = gcode_line
            else:
                gcode_comment_split = gcode_line.strip().split(';')
                gcode_command = gcode_comment_split[0]
                gcode_comment = ';'.join(gcode_comment_split[1:])

            # Deal with command line
            command_split = gcode_command.split(' ')
            if gcode_command.startswith('G1') and len(command_split) > 4:

                command_function = 'move'
                move_split = command_split
                parameters = get_parameters(move_split)

                if len(move_split) < 5:
                    parameters['a'] = tool_state['a']

                for key in tool_state:
                    if key not in parameters:
                        continue
                    tool_state[key] = parameters[key]

                metadata = {
                    'relative':
                        {ax: False for ax in parameters if ax != 'feedrate'}
                }

            elif gcode_command.startswith('G1') and \
                    command_split[1][0] == 'F':
                # Toolchange speed change
                tool_state['feedrate'] = float(command_split[1][1:]) / 60.0
                return []

            elif gcode_command.startswith('M135'):
                command_function = 'toolchange'
                parameters = {
                    'tool': int(command_split[1][1:]),
                    'feedrate': tool_state['feedrate']
                }

            elif any([gcode_command.startswith(cmd) for
                     cmd in ['M126', 'M106']]):
                command_function = 'toggle_fan'
                parameters = {'value': True}

            elif any([gcode_command.startswith(cmd) for
                     cmd in ['M127', 'M107']]):
                command_function = 'toggle_fan'
                parameters = {'value': False}

            # set toolhead temp `M104 S220 T0; Set Extruder Temp`
            elif gcode_command.startswith('M104'):
                params = get_parameters(command_split)
                command_function = 'set_toolhead_temperature'
                parameters = {"index": 0, "temperature": params['s']}

            else:
                return []

            json_commands = []

            json_command = {
                'command': {
                    'function': command_function,
                    'parameters': parameters,
                    'metadata': metadata,
                    'tags': [gcode_comment.strip()]
                }
            }

            json_commands.append(json_command)

            if gcode_command.startswith('M126'):
                json_command = {
                    'command': {
                        'function': 'fan_duty',
                        'parameters': {'value': 1.0},
                        'metadata': {},
                        'tags': []
                    }
                }

                json_commands.append(json_command)

            return json_commands

        if self.toolpath_type == 'jsontoolpath' or \
                self.toolpath_type == 'makerbot':
            for json_command in self.get_command_lines():
                yield json_command

        elif self.toolpath_type == 'gcode' or self.toolpath_type == "sketch":
            for gcode_line in self.gcode_lines():
                json_commands = convert_to_json(gcode_line)
                for command in json_commands:
                    yield command

    def xyzab_positions(self):
        tool_state = dict({'x': 0, 'y': 0, 'z': 0, 'a': 0, 'b': 0})

        for json_command in self.json_commands():
            if json_command.get('command', {}) \
                           .get('function', None) != 'move':
                continue

            parameters = json_command['command']['parameters']
            relative =\
                json_command['command'].get('metadata', {}).get('relative', {})

            xyzab_position = []
            for key in ['x', 'y', 'z', 'a', 'b']:
                if key not in parameters:
                    xyzab_position.append(tool_state[key])
                    continue

                key_is_relative = relative[key] if key in relative else False
                position = parameters[key]

                if key_is_relative:
                    position = position + tool_state[key]
                tool_state[key] = position

                xyzab_position.append(position)

            yield (xyzab_position, json_command)

    def xyzab_motions(self, tags=None, filters=None):
        if tags is None:
            tags = []
        elif not isinstance(tags, (list, tuple)):
            tags = [tags]
        tags = set(tags)

        if filters is None:
            filters = []
        elif not isinstance(filters, (list, tuple)):
            filters = [filters]
        filters = set(filters)

        # Python scope rules make the array necessary
        first_position = True
        last_position = None

        for xyzab_position, json_command in self.xyzab_positions():

            if first_position:
                first_position = False
                # First motion except 'a', 'b' is not reported here
                last_position = list(xyzab_position)
                last_position[3] = 0
                last_position[4] = 0

            command_tags = []
            if tags or filters:
                command_tags = json_command['command'].get('tags', [])

                if tags and tags.isdisjoint(command_tags):
                    last_position = xyzab_position
                    continue

                if filters and filters.intersection(set(command_tags)):
                    last_position = xyzab_position
                    continue

            feedrate = json_command['command']['parameters']['feedrate']

            xyzab_motion = []
            for i in range(0, len(xyzab_position)):
                if xyzab_position[i] is None or last_position[i] is None:
                    xyzab_motion.append(None)
                else:
                    xyzab_motion.append(xyzab_position[i] - last_position[i])

            last_position = xyzab_position

            yield (xyzab_motion, feedrate, json_command)

    def find_xyz_limits(self, z_range=None):

        limits = [[None, None],
                  [None, None],
                  [None, None]]

        for xyzab_position, _ in self.xyzab_positions():

            if z_range:
                z_position = xyzab_position[2]
                if z_position < z_range[0] or z_position > z_range[1]:
                    continue

            for i in range(0, len(limits)):

                limit = limits[i]
                position = xyzab_position[i]
                if limit[0] is None or limit[0] > position:
                    limit[0] = position
                if limit[1] is None or limit[1] < position:
                    limit[1] = position

        return limits

    def find_xyz_motion_distance(self, tags=None):

        distance = [0]

        for xyzab_motion, _, _ in self.xyzab_motions(tags):

            ssq = 0
            for i in range(0, 3):
                ssq = ssq + xyzab_motion[i] * xyzab_motion[i]
            distance[0] = distance[0] + math.sqrt(ssq)

        return distance[0]

    def find_ab_motion_distance(self, tags=None):
        distances_ab = [0, 0]

        for xyzab_motion, _, _ in self.xyzab_motions(tags):
            for i in range(3, 5):
                if i is 3:
                    distances_ab[0] += xyzab_motion[i]
                else:
                    distances_ab[1] += xyzab_motion[i]

        return distances_ab

    # Use on a toolpath to find all possible z-heights.
    # ex:   `toolpath =
    #           context.toolpather.generate_toolpath(config, model)`
    #       `possible_z_heights = toolpath.find_unique_z_positions()`
    def find_unique_z_positions(self):

        z_positions = set()

        for xyzab_position, _ in self.xyzab_positions():
            z_positions.add(round(xyzab_position[2], 3))

        return sorted(list(z_positions))

    def count_tagged_commands(self, tags=None):

        if tags is None:
            tags = []
        elif not isinstance(tags, (list, tuple)):
            tags = [tags]
        tags = set(tags)

        tagged_command_count = {}
        for tag in tags:
            tagged_command_count[tag] = 0

        for json_command in self.json_commands():

            if json_command.get('command', {}) \
                           .get('function', None) != 'move':
                continue

            command_tags = json_command['command']['tags']

            for command_tag in command_tags:
                if tags and command_tag not in tags:
                    continue

                tagged_command_count[command_tag] = \
                    tagged_command_count.get(command_tag, 0) + 1

        return tagged_command_count

    def count_commands_by_name(self, command_name=None):
        command_count = 0

        for json_command in self.json_commands():
            if json_command.get('command', {}) \
                           .get('function', None) == command_name:
                command_count += 1

        return command_count

    def dump_gcode(self, filelike):
        for gcode_line in self.gcode_lines():
            filelike.write(gcode_line)

    def dump_json_commands(self, filelike):
        filelike.write("[")
        for json_command in self.json_commands():
            filelike.write(json.dumps(json_command) + ",\n")
        filelike.write("]")

    def get_layer(self, z_position):
        # get a list of layers above and below the z position
        layers = self.split_layers([z_position - 0.5, z_position + 0.5])

        # helpers to find the closest layer to the z position
        lastLayer = None
        delta = 100

        # layers are in ascending order. as they increment upwards, the
        # difference between the layers height and the z position will shrink
        # until the z position is passed. store the last layer, returning it
        # when the next layer is further away.
        for layer in layers:
            new_delta = abs(layer.z_height - z_position)
            if new_delta > delta:
                return lastLayer
            lastLayer = layer

            delta = new_delta

        return layers[0] if len(layers) > 0 else None

    def split_layers(self, z_range=None):
        '''
        generate a list of layers in the toolpath between the two z heights.
        @z_range - list of z heights, 0 - lower bound, 1 - upper bound
        '''
        # try to parse by comments, if no layers are parsed out, parse by z
        # height.
        layers = self.split_layers_by_comment(z_range=z_range)
        if len(layers) > 0:
            return layers

        # DRAGONS: this will not parse out layers correctly if z hopping is on
        return self.split_layers_by_height(z_range=z_range)

    def split_layers_by_comment(self, z_range=None):
        '''
        generate a list of layers in the toolpath between the two z heights by
        looking at layer section comment commands.
        @z_range - list of z heights, 0 - lower bound, 1 - upper bound
        '''

        # parse out min and max z heights
        min_height = None
        max_height = None
        if z_range:
            min_height = z_range[0]
            max_height = z_range[1]

        # list of layers to be filled out
        layers = []

        # layer properties to be filled out
        commands = []
        upper_position = 0
        lower_position = 0
        thickness = 0
        width = 0
        extruder = None
        record = False

        # iterate through all commands
        for json_command in self.json_commands():

            # if a command is a comment command, parse it and update layer
            # properties

            command = json_command.get('command', {})
            if command.get('function', None) == 'comment':
                comment = command['parameters']['comment']

                # parser if elif tree. use the regex to parse out floats from
                # strings.
                if comment.startswith("Material"):
                    extruder = int(comment[-1])
                elif comment.startswith("Lower Position"):
                    lower_position = float(re.findall(float_re, comment)[0])
                    # if abvoe the min height, start recording
                    record = min_height is None or lower_position > min_height
                elif comment.startswith("Upper Position"):
                    new_upper_position =\
                        float(re.findall(float_re, comment)[0])

                    # all layer sections will be followed by a comment command.
                    # if the parser has recorded any commands, create a new
                    # layer and append it to the layers list.
                    if new_upper_position > upper_position:
                        if len(commands) > 0:
                            layers.append(Layer(upper_position, commands))
                            commands = []
                        upper_position = new_upper_position

                        if max_height and upper_position > max_height:
                            break
                elif comment.startswith("Thickness"):
                    thickness = float(re.findall(float_re, comment)[0])
                elif comment.startswith("Width"):
                    width = float(re.findall(float_re, comment)[0])

                continue

            # record this command
            if record:
                commands.append(json_command)

        # return all of the layers
        return layers

    def split_layers_by_height(self, z_range=None):
        '''
        legacy method for breaking layers out from a toolpath by move z height

        NOTE: if you have a toolpath that is hopping in z for travel moves,
        you're going to have a bad time.
        '''
        layers = []
        z_height = None
        current_commands = None

        for xyzab_position, json_command in self.xyzab_positions():
            next_z_height = xyzab_position[2]
            if z_height != next_z_height:

                if current_commands is None:
                    layers.append(Layer(z_height, current_commands))

                if not z_range or\
                        (next_z_height >= z_range[0] and
                         next_z_height <= z_range[1]):
                    z_height = next_z_height
                    current_commands = []
                elif z_range and next_z_height > z_range[1]:
                    break
                else:
                    z_height = None
                    current_commands = None

            if current_commands is not None:
                current_commands.append(json_command)

        # Append last layer, if we have remaining commands
        if current_commands:
            layers.append(Layer(z_height, current_commands))

        return layers


class Layer:

    """A layer is stored as a portion of a toolpath"""

    def __init__(self, z_height, json_commands):

        self.z_height = z_height
        self.toolpath = Toolpath(json_commands, toolpath_type='jsontoolpath')
