import sys
import os
import json
import inspect

import subprocess
import hashlib
from . import jsmin
import tempfile

import shutil
import atexit
import errno
import stat

def _cleanup_filename(abs_filename):

    if not os.path.exists(abs_filename):
        return

    try:
        os.remove(abs_filename)
    except Exception as ex:
        print(ex)
        print("Warning: Could not cleanup temporary file '%s'" % abs_filename)

def _cleanup_dir(abs_pathname):

    if not os.path.exists(abs_pathname):
        return

    try:

        # rmtree on Windows *really* doesn't like read-only files, hence this
        # junk here.
        def remove_read_only(func, path, exc):
            excvalue = exc[1]
            if func in (os.rmdir, os.remove) and excvalue.errno == errno.EACCES:
                os.chmod(path, stat.S_IRWXU| stat.S_IRWXG| stat.S_IRWXO) # 0777
                func(path)
            else:
                raise

        shutil.rmtree(abs_pathname,
                      ignore_errors=False, onerror=remove_read_only)

    except Exception as ex:
        print(ex)
        print("Warning: Could not cleanup temporary directory '%s'" % \
              abs_pathname)


class TemporaryFile:

    """Similar to NamedTemporaryFile, but doesn't default to being opened
       immediately, and can be opened multiple times."""

    def __init__(self, *args, **kwargs):

        fd, self.name = tempfile.mkstemp(*args, **kwargs)
        os.close(fd)

        self.file = None
        self.name = os.path.abspath(self.name)

        atexit.register(_cleanup_filename, self.name)
        self.responsible = True

    def __enter__(self):
        self.file = open(self.name)

    def __exit__(self):
        self.file.close()
        self.file = None

    def __del__(self):
        if self.responsible: _cleanup_filename(self.name)

class TemporaryDir:

    """Similar to TemporaryFile, but represents a path instead.  Deletes self
       when GC'd or program ends."""

    def __init__(self, *args, **kwargs):

        self.cleanup = True
        if 'cleanup' in kwargs:
            self.cleanup = kwargs['cleanup']
            del kwargs['cleanup']

        self.name = os.path.abspath(tempfile.mkdtemp(*args, **kwargs))
        if self.cleanup:
            atexit.register(_cleanup_dir, self.name)

    def __del__(self):
        if self.cleanup:
            _cleanup_dir(self.name)

def mkdir_dash_p(path):

    """
    Make a directory, ignore errors if the directory exists.
    Helper for the awkward makedirs behavior.
    """

    try:
        os.makedirs(path)
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise

def md5_hash(filename, block_size=2**20):

    md5 = hashlib.md5()
    with open(filename, 'rb') as open_file:
        while True:
            data = open_file.read(block_size)
            if not data:
                break
            md5.update(data)

    return md5.hexdigest()

def loads_commented_json(json_str):
    # Minify strips comments
    return json.loads(jsmin.jsmin(json_str));

def load_commented_json(json_file):

    content = ''.join(json_file.readlines())

    # Minify strips comments
    return json.loads(jsmin.jsmin(content))

def flatten_json(json, prefix=""):

    is_dict = isinstance(json, dict)
    is_list = isinstance(json, (list, tuple))

    if is_dict or is_list:
        flat_json = {}
        if prefix != "":
            prefix = prefix + "."
        for key, value in (enumerate(json) if is_list else iter(json.items())):
            flat_child = flatten_json(value, prefix + str(key))
            flat_json.update(flat_child)
        return flat_json

    return {prefix : json}

DEFAULT_GRUE_EXE_FILENAMES=['./_build/src/miracle_grue', # OSX, Linux
                            './_build/src/Release/miracle_grue.exe', # Win32
                            './_build64/src/Release/miracle_grue.exe', # Win64?
                            './obj/miracle_grue', # Legacy
                            './obj/miracle_grue.exe',
                            './Install/Library/MakerBot/miracle_grue' # OSX,
                            './Install/usr/local/bin/miracle_grue', # Linux
                            './Install/usr/bin/miracle_grue', # Linux
                            './Install/MakerWare/miracle_grue.exe'] # Win

# in versioned tar ball, /bin has executable file
# /include has headers
def default_grue_exe_filename():

    for exe_filename in DEFAULT_GRUE_EXE_FILENAMES:
        if os.path.exists(exe_filename):
            return exe_filename

    return None

DEFAULT_GRUE_LIB_PATHS=['./_build/src/mgl', # OSX, Linux
                        './_build/src/mgl/Release', # Win32
                        './_build64/src/mgl/Release', # Win64
                        './Install/Library/MakerBot/lib', # OSX
                        '../Install/Library/MakerBot/lib', # OSX
                        '../../Install/Library/MakerBot/lib', # OSX
                        './Install/usr/local/lib', # Linux
                        '../../Install/usr/local/lib', # Linux
                        './Install/usr/lib', # Linux
                        '../Install/usr/lib', # Linux
                        '../../Install/usr/lib', # Linux
                        '/usr/local/lib/OpenMesh', # Linux
                        './Install/MakerWare', # Win
                        '../Install/MakerWare', # Win
                        '../../Install/MakerWare'] # Win

def default_grue_lib_paths(grue_exe=None):
    lib_paths = []

    if grue_exe:
        rel_paths = [os.path.join(os.path.split(grue_exe)[0], 'lib')]
    else:
        rel_paths = []

    possible_lib_paths = rel_paths + DEFAULT_GRUE_LIB_PATHS

    # For MBPrint environment setup only (MacOS)
    if sys.platform == 'darwin':
        dyld_paths = os.getenv('DYLD_LIBRARY_PATH')
        if dyld_paths is not None:
            possible_lib_paths += dyld_paths.split(':')

    # For Linux based environments
    if sys.platform == 'linux':
        ld_paths = os.getenv('LD_LIBRARY_PATH')
        if ld_paths is not None:
            possible_lib_paths += ld_paths.split(':')

    # For MBPrint environment setup only (Windows)
    if sys.platform.startswith('win'):
        possible_lib_paths.append(os.path.dirname(sys.executable))

    for lib_path in possible_lib_paths:
        if os.path.exists(lib_path): lib_paths.append(lib_path)

    return lib_paths


# libmgl.dll
# libmgl.dylib
# libmgl.so
# In versioned tar balls, /usr/lib has platform specific lib
# /include has headers
def default_miracle_grue_lib_path():
    lib_name = None
    if sys.platform == 'cygwin' or sys.platform.startswith('win'):
         lib_name = 'mgl.dll'
    elif sys.platform == 'darwin':
         lib_name = 'libmgl.dylib'
    elif sys.platform == 'linux' or sys.platform == 'linux2':
        lib_name = 'libmgl.so'

    for directory in default_grue_lib_paths():
        mg_lib = os.path.join(directory, lib_name)
        if os.path.exists(mg_lib): return mg_lib

    raise Exception(
            "Could not find miracle_grue library %s in dyld library path " % lib_name)

def default_thing_lib_path():

    lib_name = None
    if sys.platform == 'cygwin' or sys.platform.startswith('win'):
         lib_name = 'thing.dll'
    elif sys.platform == 'darwin':
         lib_name = 'libthing.dylib'
    elif sys.platform == 'linux' or sys.platform == 'linux2':
        lib_name = 'libthing.so'

    for directory in default_grue_lib_paths():
        libthing = os.path.join(directory, lib_name)
        if os.path.exists(libthing): return libthing

    raise Exception(
            "Could not find libthing library %s in dyld library path " % lib_name)

def infer_grue_environ(grue_exe=None):

    lib_paths = default_grue_lib_paths(grue_exe)

    if sys.platform == 'cygwin' or sys.platform.startswith('win'):
        lib_paths = ";".join(lib_paths)
        os.environ['PATH'] = \
            os.environ.get('PATH', ".") + ";" + lib_paths

    elif sys.platform == 'darwin':
        lib_paths = ":".join(lib_paths)
        os.environ['DYLD_LIBRARY_PATH'] = \
            os.environ.get('DYLD_LIBRARY_PATH', ".") + ":" + lib_paths

    elif sys.platform == 'linux' or sys.platform == 'linux2':
        lib_paths = ":".join(lib_paths)
        os.environ['LD_LIBRARY_PATH'] = \
            os.environ.get('LD_LIBRARY_PATH', ".") + ":" + lib_paths

def get_grue_environ():

    if sys.platform == 'cygwin' or sys.platform.startswith('win'):
        if os.environ.get('PATH', None):
            return 'set PATH="%s"' % os.environ['PATH']

    elif sys.platform == 'darwin':
        if os.environ.get('DYLD_LIBRARY_PATH', None):
            return 'DYLD_LIBRARY_PATH="%s"' % os.environ['DYLD_LIBRARY_PATH']

    elif sys.platform == 'linux' or sys.platform == 'linux2':
        if os.environ.get('LD_LIBRARY_PATH', None):
            return 'LD_LIBRARY_PATH="%s"' % os.environ['LD_LIBRARY_PATH']

    return ""

def create_test_debug_dir(path=None, default_prefix="test_debug"):

    """
    Creates a directory for debug files from testing to live in.
    Tries to infer the current test being run using the local stack, otherwise
    defaults to a generic directory name.
    """

    if not path:
        path = os.getcwd()

    stack = inspect.stack()

    for frame in inspect.stack():

        file_basename = os.path.splitext(os.path.basename(frame[1]))[0]
        function_name = frame[3]

        if file_basename.startswith("test") and \
           function_name.startswith("test"):
            dirname = "%s.%s" % (file_basename, function_name)
            return TemporaryDir(cleanup=False, dir=path, prefix=dirname)

    return TemporaryDir(cleanup=False, dir=path, prefix=default_prefix)

def find_fwconfig_for_bot(print_estimator_exe_filename, bot_type):

    default_configs_dir = \
        os.path.join(os.path.split(print_estimator_exe_filename)[0],
                     'default_configs')

    fwconfig_filename = os.path.join(default_configs_dir,
                                     bot_type + ".json")

    if not os.path.exists(fwconfig_filename):
        return None

    return fwconfig_filename

def is_git_repo(repo_dir):

    try:
        subprocess.check_output('git status'.split(' '),
                                cwd=repo_dir,
                                stderr=subprocess.PIPE)
        return True
    except subprocess.CalledProcessError as ex:
        return False

class GitInfo:

    def __init__(self, branch, commit, commit_message, tags):
        self.branch = branch
        self.commit = commit
        self.commit_message = commit_message
        self.tags = tags

def get_git_info(repo_dir):

    try:
        branch = subprocess.check_output(
            'git rev-parse --abbrev-ref HEAD'.split(' '),
            cwd=repo_dir).decode(sys.stdout.encoding).strip()

        commit = subprocess.check_output(
            'git log -n1 --pretty=format:%H'.split(' '),
            cwd=repo_dir).decode(sys.stdout.encoding).strip()

        commit_message = subprocess.check_output(
            'git log -n1 --pretty=format:%B'.split(' '),
            cwd=repo_dir).decode(sys.stdout.encoding).strip()

        tags = subprocess.check_output(
            'git tag -l --points-at HEAD'.split(' '),
            cwd=repo_dir).decode(sys.stdout.encoding).strip()

    except subprocess.CalledProcessError as ex:
        print("Failed to run git commands in %s" % repo_dir)
        raise

    tags = [tag.strip() for tag in tags.split('\n') if tag]

    return GitInfo(branch, commit, commit_message, tags)

_warning_printed = False

def parse_timestamp(timestamp):

    try:
        import dateparser
        return dateparser.parse(timestamp)

    except ImportError as ex:
        pass

    if not _warning_printed:
        print("""
Warning - human-readable dateparser module not installed, falling back to UTC
timestamps only.

To install dateparser:
> [sudo] pip install --upgrade setuptools
> [sudo] pip install dateparser
""")

    import datetime
    return datetime.datetime.strptime(timestamp.translate(None, ':-'),
                                      "%Y%m%dT%H%M%S.%f")



