'use strict';

const assert = require('assert');
const nodegrue = require('../../nodegrue');

const meshes = require('./meshes');

/**
 * Allow deterministic memory management testing when tests are invoked with
 * --expose-gc.
 */
let forceGC = function() {};
if (typeof(gc) !== 'undefined') {
  forceGC = function() {
      gc();
    };
}

describe('basics', function() {

    it('should have nodegrue addon functionality', function() {

        assert(!('__invalid' in nodegrue._addon));
        assert('NodeMesh' in nodegrue._addon);
        assert('Orienter' in nodegrue._addon);

        assert.notEqual(nodegrue.getVersion(), '');
      });

    it('should load Mesh', function() {

        let mesh = new nodegrue.Mesh();
        assert.equal(mesh.numVertices(), 0);
        assert.equal(mesh.numFaces(), 0);

        mesh.loadFlatPointsAndFaces([0, 0, 0, 1, 1, 1, 2, 2, 2], [0, 1, 2]);
        assert.equal(mesh.numVertices(), 3);
        assert.equal(mesh.numFaces(), 1);
        assert.equal(mesh.isWatertight(), false);
      });

    it('should load Mesh from tri buffer', function() {

        let mesh = new nodegrue.Mesh();
        assert.equal(mesh.numVertices(), 0);
        assert.equal(mesh.numFaces(), 0);

        mesh.loadFlatTriangleBuffer([0, 0, 0, 1, 1, 1, 2, 2, 2,
            0, 0, 0, 3, 3, 3, 4, 4, 4
        ]);
        assert.equal(mesh.numVertices(), 5);
        assert.equal(mesh.numFaces(), 2);
        assert.equal(mesh.isWatertight(), false);
      });

    it('should transform Mesh', function() {

        let mesh = new nodegrue.Mesh();
        assert.equal(mesh.numVertices(), 0);
        assert.equal(mesh.numFaces(), 0);

        mesh.loadFlatTriangleBuffer(
            Float32Array.from([0, 0, 0, 1, 1, 1, 2, 2, 2]));

        // NOTE: The rows are actually *columns* in the transform
        let flatIdentity = [1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];

        mesh.flatTransform(Float32Array.from(flatIdentity));

        assert.deepEqual(mesh.dumpFlatVertices(), [0, 0, 0, 1, 1, 1, 2, 2, 2]);

        let flatZ90DegAndTrans5 = [0, -1, 0, 0,
            1, 0, 0, 0,
            0, 0, 1, 0,
            5, 5, 5, 1
        ];

        mesh.flatTransform(Float32Array.from(flatZ90DegAndTrans5));

        assert.deepEqual(mesh.dumpFlatVertices(), [5, 5, 5, 6, 4, 6, 7, 3, 7]);
      });

    it('should simplify mesh', function() {

        let plane = new meshes.Plane(1, 0, 2);
        let planeMesh = new nodegrue.Mesh();
        planeMesh.loadFlatPointsAndFaces(meshes.flatten(plane.points),
            meshes.flatten(plane.faces));

        assert.equal(planeMesh.numVertices(), 3 * 3);
        assert.equal(planeMesh.numFaces(), 2 * 2 * 2);
        assert.equal(planeMesh.isWatertight(), false);

        let orienter = new nodegrue.Orienter({
            meshes: [planeMesh],
            maxSimpleFaces: 4,
            stabilityScoring: false,
            seed: 0,
            convergenceFactor: 0.999
          });

        assert.equal(orienter.getSearchStats().numSearchFaces, 4);
        assert(orienter.getSearchStats().numSearchVertices >= 4);
      });

    it('should simplify and ignore small meshes', function() {

        let smallPlane = new meshes.Plane(1.0, 0, 1);
        let bigPlane = new meshes.Plane(10.0, 0, 1);

        let planeMesh = new nodegrue.Mesh();

        planeMesh.loadFlatPointsAndFaces(
            meshes.flatten(smallPlane.points),
            meshes.flatten(smallPlane.faces));

        planeMesh.loadFlatPointsAndFaces(
            meshes.flatten(bigPlane.points),
            meshes.flatten(bigPlane.faces));

        assert.equal(planeMesh.numVertices(), 2 * 2 * 2);

        let orienter = new nodegrue.Orienter({
            meshes: [planeMesh],
            maxSimpleFaces: 1000,
            minComponentSurfaceArea: 2.0,
            stabilityScoring: false,
            seed: 0,
            convergenceFactor: 0.999
          });

        assert.equal(orienter.getSearchStats().numSearchVertices, 2 * 2);
      });

    it('should create Orienter', function() {

        let mesh = new nodegrue.Mesh();

        let orienter = new nodegrue.Orienter([mesh], 1000, true, 0);
        assert.deepEqual([0, 0, 0], orienter.bestOrientation());
      });

    it('should orient tetrahedron', function() {

        let tetra = new meshes.Tetra(100.0);
        let tetraMesh = new nodegrue.Mesh();
        tetraMesh.loadFlatPointsAndFaces(meshes.flatten(tetra.points),
            meshes.flatten(tetra.faces));

        assert.equal(tetraMesh.numVertices(), 4);
        assert.equal(tetraMesh.numFaces(), 4);
        assert.equal(tetraMesh.isWatertight(), true);

        let orienter = new nodegrue.Orienter({
            meshes: [tetraMesh],
            maxSimpleFaces: 2000,
            stabilityScoring: true,
            seed: 0,
            convergenceFactor: 0.999
          });

        assert.deepEqual([0, 0, 0], orienter.bestOrientation());
        assert.notEqual(orienter.bestCandidate().totalUnsupportedUnplatedArea, 0);

        // Set our timeout to something that won't fail if the computer hiccups
        this.timeout(10 * 1000 /* ms */);

        // We should successfully auto-orient
        while (true) {
          // We're only really accurate to ~1s
          let best = orienter._searchOrientations(1000 /* ms */);
          assert(orienter.getSearchStats().numIterations > 0);

          if (orienter.bestCandidate().totalUnsupportedUnplatedArea == 0)
              break;
        }
      });

    it('should async orient tetrahedron', function(done) {

        // Set our timeout to something that won't fail if the computer hiccups
        this.timeout(5 * 1000 /* ms */);

        // Scope the asynchronous call so that everything can get gc'd before
        // the call is actually run.
        function scopedWork() {

          let tetra = new meshes.Tetra(100.0);
          let tetraMesh = new nodegrue.Mesh();
          tetraMesh.loadFlatPointsAndFaces(meshes.flatten(tetra.points),
              meshes.flatten(tetra.faces));

          let i = 0;
          let callback = function(orienter) {

              i = i + 1;

              try {
                // NOTE that we *must* catch these exceptions here in order to
                // trigger done()
                assert.equal(orienter.getSearchStats().numIterations, i * 2);
                assert.equal(this.isSameCallback, true);
              } catch (ex) {
                done(ex);
                return false;
              }

              // Run the orientation three times
              if (i < 3)
                  return true;

              // Schedule the test to end at a later tick
              setImmediate(function() {
                  // Force the callback orienter to be successfully disposed
                  forceGC();
                  done();
                });

              // Stop running the orientation
              return false;
            };

          callback.isSameCallback = true;

          new nodegrue.Orienter({
              meshes: [tetraMesh]
            }).searchOrientations({
                  maxTimeMs: undefined,
                  maxIterations: 2
                },
              callback);
        }

        forceGC();
        // Start the async orientation in the background
        scopedWork();
        // Cleanup any data used to initialize the orientation
        forceGC();
      });

    it('should async orient plane using promise', function() {

        // Set our timeout to something that won't fail if the computer hiccups
        this.timeout(5 * 1000 /* ms */);

        let plane = new meshes.Plane(1.0, 0, 1);
        let planeMesh = new nodegrue.Mesh();
        planeMesh.loadFlatPointsAndFaces(meshes.flatten(plane.points),
            meshes.flatten(plane.faces));

        return new nodegrue.Orienter({
                meshes: [planeMesh]
              }).searchOrientations({
                maxIterations: 20,
                notifyIterations: 10
              })
            .progress(function(orienter) {
                assert.equal(orienter.getSearchStats().numIterations, 10);
              })
            .then(function(orienter) {
                assert.equal(orienter.getSearchStats().numIterations, 20);
              });
      });

    it('should slice-orient tetrahedron', function() {

      let tetra = new meshes.Tetra(100.0);
      let tetraMesh = new nodegrue.Mesh();
      tetraMesh.loadFlatPointsAndFaces(meshes.flatten(tetra.points),
          meshes.flatten(tetra.faces));

      //tetraMesh.loadFromSTLFile('/Users/gregory.studer/Google Drive/Gauntlet Files/QTE Gauntlet/1_PV-MiniPlus-111011_C02-2016-08-12.stl');

      let configuration =
          nodegrue.SliceOrienter.getBasicConfiguration({layerHeight: 3.0,
                                                        doBridging: false,
                                                        doSupport: false});

      let orienter = new nodegrue.SliceOrienter({
          configuration: configuration,
          gaggle: [tetraMesh],
          options: {
            stabilityScoring: false
          }
        });

      assert.deepEqual([0, 0, 0], orienter.getBestCandidate().eulerAngles);

      //console.dir(orienter.getBestCandidate(), {depth: null});
      //console.log(orienter.getStats());

      // Set our timeout to something that won't fail if the computer hiccups
      this.timeout(30 * 1000 /* ms */);

      // We should successfully auto-orient
      while (true) {

        // We're only really accurate to ~1s
        let best = orienter._searchOrientations(-1, 2);
        assert(orienter.getStats().numIterations > 0);

        let unsupportedAreas =
          orienter.getBestCandidate().meshEstimate.unsupportedAreas;
        let totalUnplated = 0;

        for (let i = 0; i < unsupportedAreas.length; ++i) {
          totalUnplated += unsupportedAreas[i].unplated;
        }

        //console.dir(orienter.getBestCandidate(), {depth: null});
        //console.log(orienter.getStats());
        if (totalUnplated == 0)
            break;
      }
    });

    it('should async slice-orient plane using promise', function() {

      // Set our timeout to something that won't fail if the computer hiccups
      this.timeout(30 * 1000 /* ms */);

      let plane = new meshes.Plane(1.0, 0, 1);
      let planeMesh = new nodegrue.Mesh();
      planeMesh.loadFlatPointsAndFaces(meshes.flatten(plane.points),
          meshes.flatten(plane.faces));

      let configuration = nodegrue.SliceOrienter.getBasicConfiguration();
      configuration.doBridging = false;

      return new nodegrue.SliceOrienter({
              configuration: configuration,
              gaggle: [planeMesh]
            }).searchOrientations({
              maxIterations: 2,
              notifyIterations: 1
            })
          .progress(function(orienter) {
              assert.equal(orienter.getStats().numIterations, 1);
            })
          .then(function(orienter) {
              assert.equal(orienter.getStats().numIterations, 2);
            });
    });
  });
