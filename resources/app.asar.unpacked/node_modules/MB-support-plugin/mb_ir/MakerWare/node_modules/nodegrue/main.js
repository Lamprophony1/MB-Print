'use strict';

/**
 * Main module
 */

const addonBasename =
    ('electron' in process.versions ? 'nodegrue_addon_electron.node' :
        'nodegrue_addon.node');

const addonFilename = require.resolve(addonBasename);
const addon = require(addonBasename);

/**
 * Wrapper of core orientation functionality that allows both callback-style and
 * Q promise-style asynchronous search calls.
 *
 * (A javascript helper since the promise library isn't easily available to
 *  addons.)
 */

let orienters = [addon.Orienter, addon.SliceOrienter];

for (let i = 0; i < orienters.length; ++i) {

  orienters[i].prototype.searchOrientations = function(options, callback) {

      options = options || {};

      let maxTimeMs = options.maxTimeMs;
      let maxIterations = options.maxIterations;

      if (maxTimeMs == undefined)
          maxTimeMs = -1;

      if (maxIterations == undefined)
          maxIterations = -1;

      if (callback !== undefined) {
        this._searchOrientations(maxTimeMs, maxIterations, callback);
        return;
      }

      let notifyTimeMs = options.notifyTimeMs;
      let notifyIterations = options.notifyIterations;

      if (notifyTimeMs == undefined || notifyTimeMs < 0)
          notifyTimeMs = maxTimeMs;

      if (notifyIterations == undefined || notifyIterations < 0)
          notifyIterations = maxIterations;

      let q = require('q');
      let deferred = q.defer();

      callback = function(orienter) {

          let stats = orienter.getSearchStats ? orienter.getSearchStats() :
                                                orienter.getStats();

          let keep_going =
              (maxTimeMs < 0 || stats.totalTimeMs < maxTimeMs) &&
              (maxIterations < 0 || stats.numIterations < maxIterations);

          if (keep_going) {
            deferred.notify(orienter);
          } else {
            deferred.resolve(orienter);
          }

          return keep_going;
        };

      let orienter = this;

      // Start orienting after the caller has a chance to hook up the promise
      // callbacks.
      setImmediate(function() {
          orienter._searchOrientations(notifyTimeMs,
              notifyIterations,
              callback);
        });

      return deferred.promise;
    };

}

exports._addonFilename = addonFilename;
exports._addon = addon;

exports.getVersion = exports._addon.getVersion;
exports.Mesh = exports._addon.NodeMesh;
exports.Orienter = exports._addon.Orienter;
exports.SliceOrienter = exports._addon.SliceOrienter;
exports.Toolpather = exports._addon.NodeToolpather;
