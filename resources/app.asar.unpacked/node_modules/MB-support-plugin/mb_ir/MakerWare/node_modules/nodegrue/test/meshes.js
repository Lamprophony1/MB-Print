'use strict';

/**
 * Basic meshes for orientation tests.
 */

function Tetra(edgeDistance) {

  //          z   y
  //    2,3   ^  ^
  //   /   \  | /
  //  /  +  \  -----> x
  // 0-------1

  let zHeight = 1 / Math.sqrt(2.0);

  this.points = [[-1, 0, -zHeight], [1, 0, -zHeight],
                 [0, -1, zHeight], [0, 1, zHeight]];

  if (edgeDistance !== undefined) {

    let scale = edgeDistance / 2; // tetrahedron edge size is 2.0 currently

    for (let i = 0; i < this.points.length; i++) {
      for (let j = 0; j < 3; j++) {
        this.points[i][j] *= scale;
      }
    }
  }

  this.faces = [[0, 1, 2], [1, 3, 2], [0, 3, 1], [0, 2, 3]];
}


function Plane(edgeDistance, zHeight, cellSize) {

  //
  // Planar mesh vertices and faces
  //


  this.points = [];

  this.pIndex = function(x, y) {
      return x * (cellSize + 1) + y;
  };

  for (let x = 0; x < cellSize + 1; ++x) {
      for (let y = 0; y < cellSize + 1; ++y) {
          this.points[this.pIndex(x, y)] = [x * edgeDistance,
                                            y * edgeDistance,
                                            zHeight]
      }
  }

  this.faces = [];
  for (let x = 0; x < cellSize; ++x) {
      for (let y = 0; y < cellSize; ++y) {
          
          let a = this.pIndex(x, y);
          let b = this.pIndex(x + 1, y);
          let c = this.pIndex(x + 1, y + 1);
          let d = this.pIndex(x, y + 1);
          
          this.faces.push([a, b, d]);
          this.faces.push([b, c, d]);
      }
  }
}


function flatten(array) {

  let flattened = [];

  for (let i = 0; i < array.length; i++) {

    if (Array.isArray(array[i])) {
      array[i] = flatten(array[i]);
      for (let j = 0; j < array[i].length; j++) {
        flattened.push(array[i][j]);
      }
    } else {
      flattened.push(array[i]);
    }
  }

  return flattened;
}

exports.flatten = flatten;
exports.Tetra = Tetra;
exports.Plane = Plane;
