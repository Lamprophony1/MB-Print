#!/usr/bin/env python

import argparse
import logging
import os
import json
import sys

DESCRIPTION = """
This script updates all of the legacy profiles in this directory. Use it to add
keys to the birdwing bot hard coded profiles.
"""


# location of all the hardcoded birdwing profiles
LEGACY_DIRECTORY = os.path.dirname(os.path.abspath(__file__))


def try_as_float(value):
    """
    try to set the new value to a float (no testing for int yet)
    """
    try:
        # if the value type is a bool, return it
        if type(value) == bool:
            return value

        # if the value is a bool string, return it as a bool
        if value in ["true", "True"]:
            return True
        if value in ["false", "False"]:
            return False

        return float(value)
    except ValueError:
        logging.debug("Value \"%s\" not convertable to float. "
                      "Leaving as string" % value)
        return value


def process_args(args):
    """
    process args from command line. key, value, and debug flag.
    """
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description=DESCRIPTION)

    parser.add_argument("--key", type=str)
    parser.add_argument("--value")
    parser.add_argument("--debug", action="store_true")
    parser.add_argument("--changelog")

    parsed_args = parser.parse_args(args=args)

    # setup logging configuration based on --debug
    if parsed_args.debug:
        logging.basicConfig(level=logging.DEBUG,
                            format='%(levelname)s - %(message)s')
    else:
        logging.basicConfig(level=logging.WARNING,
                            format='%(levelname)s - %(message)s')

    if parsed_args.key is not None:
        # error handling
        if parsed_args.value is None:
            raise Exception("Key and Value Pair are required")
        if parsed_args.changelog is not None:
            raise Exception("Key and Value Pair cannot be used with changelog "
                            "file")

        changes = {parsed_args.key: try_as_float(parsed_args.value)}
        setattr(parsed_args, 'changes', changes)

    # this block is just for error handlign
    if parsed_args.value is not None:
        if parsed_args.key is None:
            raise Exception("Key and Value Pair are required")

    if parsed_args.changelog:
        with open(parsed_args.changelog) as changes_data:
            try:
                changes = json.load(changes_data)
                for key, value in changes.items():
                    changes[key] = try_as_float(value)

                setattr(parsed_args, 'changes', changes)
            except Exception as e:
                raise Exception("Error loading changelog %s:\n%s"
                                % (parsed_args.changelog, e))

                raise

    return parsed_args


def update_profiles(changes):
    """
    update all profiles with the (dot seperated) key / value pair

    NOTE: if we want to do any bot / material / support type / base type
    filtering it would happen here.
    """
    legacy_profile_filenames = [
        profile_filename
        for profile_filename
        in os.listdir(LEGACY_DIRECTORY)
        if profile_filename.endswith(".json")
    ]

    for profile_filename in legacy_profile_filenames:
        update_profile(profile_filename, changes)


def update_profile(profile_filename, changes):
    """
    update profile at profile_filename with (dot seperated) key / value pair.

    open the file at the filepath, read the dict out, follow the key path into
    nested parameters, update the dict as necessary.

    after updating the dict, write it back to the same file.
    """
    print("updating %s" % profile_filename)

    profile_path = os.path.join(LEGACY_DIRECTORY, profile_filename)
    with open(profile_path) as profile_data:
        try:
            profile = json.load(profile_data)
        except Exception as e:
            logging.critical("Error loading profile %s: %s"
                             "\nAborting."
                             "\nPlease use git to reset directory and debug")

            raise

    for key, value in changes.items():
        # member to store last node of the dict
        last_piece = profile

        # split keys by `.` to get path to walk through dict
        sub_keys = key.split(".")

        # iterate through each member of the sub kes
        for index, sub_key in enumerate(sub_keys):
            logging.debug("accessing key %s" % sub_key)

            # get the next node in the dict
            piece = None
            if isinstance(last_piece, dict):
                piece = last_piece.get(sub_key)
            elif isinstance(last_piece, list):
                piece = last_piece[int(sub_key)]

            # if the next piece doesn't exist, create it. it will either be a
            # new dict (if there are more sub keys) or will hold the passed in
            # value.
            if piece is None:
                logging.debug("Key %s does not exist" % sub_key)

                if index + 1 < len(sub_keys):
                    next_key = sub_keys[index + 1]
                    logging.debug("next key is %s" % next_key)

                    if type(next_key) == int:
                        raise Exception("Not able to update lists")
                    else:
                        last_piece.update({sub_key: {}})
                        piece = last_piece.get(sub_key)
                else:
                    logging.debug("Adding Key / Value %s: %s"
                                  % (sub_key, value))
                    last_piece.update({sub_key: value})

            # if the piece does exist, either keep on going or update if its
            # the last key.
            else:
                if index + 1 < len(sub_keys):
                    logging.debug(json.dumps(piece, sort_keys=True, indent=2))
                else:
                    logging.debug("last key, updating value")
                    last_piece.update({sub_key: value})

            last_piece = piece

    logging.debug(json.dumps(profile, sort_keys=True, indent=2))

    # write the profile to file
    with open(profile_path, 'w') as profile_file:
        json.dump(profile,
                  profile_file,
                  sort_keys=True,
                  indent=4,
                  separators=(',', ': '))


if '__main__' == __name__:
    args = process_args(sys.argv[1:])

    for key, value in args.changes.items():
        logging.warning("Setting %s to %s." % (key, value))

    update_profiles(args.changes)

    sys.exit(0)

else:
    raise Exception("Update Legacy Profiles is a script that should not be"
                    " imported.")
